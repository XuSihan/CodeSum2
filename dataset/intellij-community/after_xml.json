[{"methodBody": ["METHOD_START", "{", "myRightMarginForm    =    new   com . intellij . application . options . codeStyle . RightMarginForm ( HTML . getLanguage (  )  ,    getSettings (  )  )  ;", "myRightMarginPanel    =    myRightMarginForm . getTopPanel (  )  ;", "myJBScrollPane    =    new   JBScrollPane (  )     {", "@ Override", "public   Dimension   getPreferredSize (  )     {", "Dimension   prefSize    =    super . getPreferredSize (  )  ;", "return   new   Dimension (  (  ( prefSize . width )     +     1  5  )  ,    prefSize . height )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createUIComponents"], "fileName": "com.intellij.application.options.CodeStyleHtmlPanel"}, {"methodBody": ["METHOD_START", "{", "ListItemsDialogWrapper . installListItemsDialogForTextField ( uiField ,     (  )     -  >    new   TagListDialog ( title )  )  ;", "}", "METHOD_END"], "methodName": ["customizeField"], "fileName": "com.intellij.application.options.CodeStyleHtmlPanel"}, {"methodBody": ["METHOD_START", "{", "combo . setModel ( new   com . intellij . ui . EnumComboBoxModel ( enumClass )  )  ;", "}", "METHOD_END"], "methodName": ["fillEnumCombobox"], "fileName": "com.intellij.application.options.CodeStyleHtmlPanel"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   Integer . parseInt ( keepBlankLines . getText (  )  )  ;", "}    catch    ( NumberFormatExce   e )     {", "return    0  ;", "}", "}", "METHOD_END"], "methodName": ["getIntValue"], "fileName": "com.intellij.application.options.CodeStyleHtmlPanel"}, {"methodBody": ["METHOD_START", "{", "myJBScrollPane    =    new   JBScrollPane (  )     {", "@ Override", "public   Dimension   getPreferredSize (  )     {", "Dimension   prefSize    =    super . getPreferredSize (  )  ;", "return   new   Dimension (  (  ( prefSize . width )     +     1  5  )  ,    prefSize . height )  ;", "}", "}  ;", "myRightMarginForm    =    new   codeStyle . RightMarginForm ( XML . getLanguage (  )  ,    getSettings (  )  )  ;", "myRightMarginPanel    =    myRightMarginForm . getTopPanel (  )  ;", "}", "METHOD_END"], "methodName": ["createUIComponents"], "fileName": "com.intellij.application.options.CodeStyleXmlPanel"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   Integer . parseInt ( keepBlankLines . getText (  )  )  ;", "}    catch    ( NumberFormatExce   e )     {", "return    0  ;", "}", "}", "METHOD_END"], "methodName": ["getIntValue"], "fileName": "com.intellij.application.options.CodeStyleXmlPanel"}, {"methodBody": ["METHOD_START", "{", "XmlCodeStyleSettings   xmlSettings    =    settings . getCustomSettings ( XmlCodeStyleSettings . class )  ;", "return    ( xmlSettings . XML _ TEXT _ WRAP )     =  =     ( CommonCodeStyleSettings . WRAP _ AS _ NEEDED )  ;", "}", "METHOD_END"], "methodName": ["wrapText"], "fileName": "com.intellij.application.options.CodeStyleXmlPanel"}, {"methodBody": ["METHOD_START", "{", "HtmlCodeStylePanelExtension [  ]    extensions    =    HtmlCodeStylePanelExtension . EP _ NAME . getExtensions (  )  ;", "if    (  ( extensions . length )     =  =     0  )", "return   com . intellij . util . containers . ContainerUtil . emptyList (  )  ;", "return   Arrays . stream ( extensions )  . map (  (    el )     -  >    el . getCustomizer (  )  )  . collect ( Collectors . toList (  )  )  ;", "}", "METHOD_END"], "methodName": ["getCustomizers"], "fileName": "com.intellij.application.options.HtmlCodeStylePanelExtension"}, {"methodBody": ["METHOD_START", "{", "return   ServiceManager . getService ( XmlSettings . class )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "com.intellij.application.options.XmlSettings"}, {"methodBody": ["METHOD_START", "{", "return   ServiceManager . getService ( WebEditorOptions . class )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "return   myTagTreeHighlightingLevelCount ;", "}", "METHOD_END"], "methodName": ["getTagTreeHighlightingLevelCount"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "return   myTagTreeHighlightingOpacity ;", "}", "METHOD_END"], "methodName": ["getTagTreeHighlightingOpacity"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "return   myAutoCloseTag ;", "}", "METHOD_END"], "methodName": ["isAutoCloseTag"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "return   myAutomaticallyInsertClosingTag ;", "}", "METHOD_END"], "methodName": ["isAutomaticallyInsertClosingTag"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "return   myAutomaticallyInsertRequiredAttributes ;", "}", "METHOD_END"], "methodName": ["isAutomaticallyInsertRequiredAttributes"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "return   myAutomaticallyInsertRequiredSubTags ;", "}", "METHOD_END"], "methodName": ["isAutomaticallyInsertRequiredSubTags"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "return   myAutomaticallyStartAttribute ;", "}", "METHOD_END"], "methodName": ["isAutomaticallyStartAttribute"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "return   myInsertQuotesForAttributeValue ;", "}", "METHOD_END"], "methodName": ["isInsertQuotesForAttributeValue"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "return   mySelectWholeCssIdentifierOnDoubleClick ;", "}", "METHOD_END"], "methodName": ["isSelectWholeCssIdentifierOnDoubleClick"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "return   myShowCssColorPreviewInGutter ;", "}", "METHOD_END"], "methodName": ["isShowCssColorPreviewInGutter"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "return   myShowCssInlineColorPreview ;", "}", "METHOD_END"], "methodName": ["isShowCssInlineColorPreview"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "return   mySyncTagEditing ;", "}", "METHOD_END"], "methodName": ["isSyncTagEditing"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "return   myTagTreeHighlightingEnabled ;", "}", "METHOD_END"], "methodName": ["isTagTreeHighlightingEnabled"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "myAutoCloseTag    =    autoCloseTag ;", "}", "METHOD_END"], "methodName": ["setAutoCloseTag"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "myAutomaticallyInsertClosingTag    =    automaticallyInsertClosingTag ;", "}", "METHOD_END"], "methodName": ["setAutomaticallyInsertClosingTag"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "myAutomaticallyInsertRequiredAttributes    =    automaticallyInsertRequiredAttributes ;", "}", "METHOD_END"], "methodName": ["setAutomaticallyInsertRequiredAttributes"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "myAutomaticallyInsertRequiredSubTags    =    automaticallyInsertRequiredSubTags ;", "}", "METHOD_END"], "methodName": ["setAutomaticallyInsertRequiredSubTags"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "myAutomaticallyStartAttribute    =    automaticallyStartAttribute ;", "}", "METHOD_END"], "methodName": ["setAutomaticallyStartAttribute"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "myInsertQuotesForAttributeValue    =    insertQuotesForAttributeValue ;", "}", "METHOD_END"], "methodName": ["setInsertQuotesForAttributeValue"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "mySelectWholeCssIdentifierOnDoubleClick    =    selectWholeCssIdentifiersOnDoubleClick ;", "}", "METHOD_END"], "methodName": ["setSelectWholeCssIdentifierOnDoubleClick"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "myShowCssColorPreviewInGutter    =    showCssColorPreviewInGutter ;", "}", "METHOD_END"], "methodName": ["setShowCssColorPreviewInGutter"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "myShowCssInlineColorPreview    =    showCssInlineColorPreview ;", "}", "METHOD_END"], "methodName": ["setShowCssInlineColorPreview"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "mySyncTagEditing    =    syncTagEditing ;", "}", "METHOD_END"], "methodName": ["setSyncTagEditing"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "myTagTreeHighlightingEnabled    =    tagTreeHighlightingEnabled ;", "}", "METHOD_END"], "methodName": ["setTagTreeHighlightingEnabled"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "myTagTreeHighlightingLevelCount    =    tagTreeHighlightingLevelCount ;", "}", "METHOD_END"], "methodName": ["setTagTreeHighlightingLevelCount"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "myTagTreeHighlightingOpacity    =    tagTreeHighlightingOpacity ;", "}", "METHOD_END"], "methodName": ["setTagTreeHighlightingOpacity"], "fileName": "com.intellij.application.options.editor.WebEditorOptions"}, {"methodBody": ["METHOD_START", "{", "return   ServiceManager . getService ( XmlFoldingSettings . class )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "com.intellij.application.options.editor.XmlFoldingSettings"}, {"methodBody": ["METHOD_START", "{", "List < Configurable >    configurables    =    ContainerUtil . newSmartList ( new   XmlEmmetConfigurable (  )  )  ;", "for    ( ZenCodingGenerator   zenCodingGenerator    :    ZenCodingGenerator . getInstances (  )  )     {", "ContainerUtil . addIfNotNull ( configurables ,    zenCodingGenerator . createConfigurable (  )  )  ;", "}", "return   configurables ;", "}", "METHOD_END"], "methodName": ["getAvailableConfigurables"], "fileName": "com.intellij.application.options.emmet.EmmetConfigurableProvider"}, {"methodBody": ["METHOD_START", "{", "return   myBemElementSeparator ;", "}", "METHOD_END"], "methodName": ["getBemElementSeparator"], "fileName": "com.intellij.application.options.emmet.EmmetOptions"}, {"methodBody": ["METHOD_START", "{", "return   myBemModifierSeparator ;", "}", "METHOD_END"], "methodName": ["getBemModifierSeparator"], "fileName": "com.intellij.application.options.emmet.EmmetOptions"}, {"methodBody": ["METHOD_START", "{", "return   myBemShortElementPrefix ;", "}", "METHOD_END"], "methodName": ["getBemShortElementPrefix"], "fileName": "com.intellij.application.options.emmet.EmmetOptions"}, {"methodBody": ["METHOD_START", "{", "return   myEmmetExpandShortcut ;", "}", "METHOD_END"], "methodName": ["getEmmetExpandShortcut"], "fileName": "com.intellij.application.options.emmet.EmmetOptions"}, {"methodBody": ["METHOD_START", "{", "return   myFiltersEnabledByDefault ;", "}", "METHOD_END"], "methodName": ["getFiltersEnabledByDefault"], "fileName": "com.intellij.application.options.emmet.EmmetOptions"}, {"methodBody": ["METHOD_START", "{", "return   ServiceManager . getService ( EmmetOptions . class )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "com.intellij.application.options.emmet.EmmetOptions"}, {"methodBody": ["METHOD_START", "{", "return   myAddEditPointAtTheEndOfTemplate ;", "}", "METHOD_END"], "methodName": ["isAddEditPointAtTheEndOfTemplate"], "fileName": "com.intellij.application.options.emmet.EmmetOptions"}, {"methodBody": ["METHOD_START", "{", "return   myEmmetEnabled ;", "}", "METHOD_END"], "methodName": ["isEmmetEnabled"], "fileName": "com.intellij.application.options.emmet.EmmetOptions"}, {"methodBody": ["METHOD_START", "{", "return   myFiltersEnabledByDefault . contains ( filter . getSuffix (  )  )  ;", "}", "METHOD_END"], "methodName": ["isFilterEnabledByDefault"], "fileName": "com.intellij.application.options.emmet.EmmetOptions"}, {"methodBody": ["METHOD_START", "{", "return   myHrefAutoDetectEnabled ;", "}", "METHOD_END"], "methodName": ["isHrefAutoDetectEnabled"], "fileName": "com.intellij.application.options.emmet.EmmetOptions"}, {"methodBody": ["METHOD_START", "{", "return   myPreviewEnabled ;", "}", "METHOD_END"], "methodName": ["isPreviewEnabled"], "fileName": "com.intellij.application.options.emmet.EmmetOptions"}, {"methodBody": ["METHOD_START", "{", "myAddEditPointAtTheEndOfTemplate    =    addEditPointAtTheEndOfTemplate ;", "}", "METHOD_END"], "methodName": ["setAddEditPointAtTheEndOfTemplate"], "fileName": "com.intellij.application.options.emmet.EmmetOptions"}, {"methodBody": ["METHOD_START", "{", "myBemElementSeparator    =    StringUtil . notNullize ( bemElementSeparator )  ;", "}", "METHOD_END"], "methodName": ["setBemElementSeparator"], "fileName": "com.intellij.application.options.emmet.EmmetOptions"}, {"methodBody": ["METHOD_START", "{", "myBemModifierSeparator    =    StringUtil . notNullize ( bemModifierSeparator )  ;", "}", "METHOD_END"], "methodName": ["setBemModifierSeparator"], "fileName": "com.intellij.application.options.emmet.EmmetOptions"}, {"methodBody": ["METHOD_START", "{", "myBemShortElementPrefix    =    StringUtil . notNullize ( bemShortElementPrefix )  ;", "}", "METHOD_END"], "methodName": ["setBemShortElementPrefix"], "fileName": "com.intellij.application.options.emmet.EmmetOptions"}, {"methodBody": ["METHOD_START", "{", "myEmmetEnabled    =    emmetEnabled ;", "}", "METHOD_END"], "methodName": ["setEmmetEnabled"], "fileName": "com.intellij.application.options.emmet.EmmetOptions"}, {"methodBody": ["METHOD_START", "{", "myEmmetExpandShortcut    =    emmetExpandShortcut ;", "}", "METHOD_END"], "methodName": ["setEmmetExpandShortcut"], "fileName": "com.intellij.application.options.emmet.EmmetOptions"}, {"methodBody": ["METHOD_START", "{", "myFiltersEnabledByDefault    =    filtersEnabledByDefault ;", "}", "METHOD_END"], "methodName": ["setFiltersEnabledByDefault"], "fileName": "com.intellij.application.options.emmet.EmmetOptions"}, {"methodBody": ["METHOD_START", "{", "myHrefAutoDetectEnabled    =    hrefAutoDetectEnabled ;", "}", "METHOD_END"], "methodName": ["setHrefAutoDetectEnabled"], "fileName": "com.intellij.application.options.emmet.EmmetOptions"}, {"methodBody": ["METHOD_START", "{", "myPreviewEnabled    =    previewEnabled ;", "}", "METHOD_END"], "methodName": ["setPreviewEnabled"], "fileName": "com.intellij.application.options.emmet.EmmetOptions"}, {"methodBody": ["METHOD_START", "{", "final   List < ZenCodingFilter >    filters    =    ZenCodingFilter . getInstances (  )  ;", "final   GridBagLayout   layoutManager    =    new   GridBagLayout (  )  ;", "final   GridBagConstras   constras    =    new   GridBagConstras (  0  ,     0  ,     1  ,     1  ,     1  ,     1  ,    GridBagConstras . NORTHWEST ,    GridBagConstras . NONE ,    JBUI . emptyInsets (  )  ,     0  ,     0  )  ;", "myFiltersListPanel . setLayout ( layoutManager )  ;", "for    (    i    =     0  ;    i    <     ( filters . size (  )  )  ;    i +  +  )     {", "ZenCodingFilter   filter    =    filters . get ( i )  ;", "final   JBCheckBox   checkBox    =    new   JBCheckBox ( filter . getDisplayName (  )  )  ;", "myFilterCheckboxes . put ( filter . getSuffix (  )  ,    checkBox )  ;", "constras . gridy    =    i ;", "myFiltersListPanel . add ( checkBox ,    constras )  ;", "}", "myFiltersListPanel . revalidate (  )  ;", "}", "METHOD_END"], "methodName": ["createFiltersCheckboxes"], "fileName": "com.intellij.application.options.emmet.XmlEmmetConfigurable"}, {"methodBody": ["METHOD_START", "{", "Set < String >    result    =    ContainerUtil . newHashSet (  )  ;", "for    ( Map . Entry < String ,    JBCheckBox >    checkbox    :    myFilterCheckboxes . entrySet (  )  )     {", "if    ( checkbox . getValue (  )  . isSelected (  )  )     {", "result . add ( checkbox . getKey (  )  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["enabledFilters"], "fileName": "com.intellij.application.options.emmet.XmlEmmetConfigurable"}, {"methodBody": ["METHOD_START", "{", "XmlTag   xmlTag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  (  \"  < root >  \"     +     (  (  (  (  (  (  (  \"  < tag 1  >  < name > name 1  <  / name >  < value >  1  <  / value >  <  / tag 1  >  \"     +     \"  < tag 1  >  < name > name 2  <  / name >  < value >  2  <  / value >  <  / tag 1  >  \"  )     +     \"  < tag 1  >  < name > name 3  <  / name >  < value >  3  <  / value >  <  / tag 1  >  \"  )     +     \"  < tag 1  >  < name > name 4  <  / name >  < value >  4  <  / value >  <  / tag 1  >  \"  )     +     \"  < tag 1  >  < name > name 5  <  / name >  < value >  5  <  / value >  <  / tag 1  >  \"  )     +     \"  < tag 1  >  < name > name 6  <  / name >  < value >  6  <  / value >  <  / tag 1  >  \"  )     +     \"  < tag 1  >  < name > name 7  <  / name >  < value >  7  <  / value >  <  / tag 1  >  \"  )     +     \"  <  / root >  \"  )  )  )  ;", "XmlTag   found    =    XmlUtil . find (  \" name \"  ,     \" name 4  \"  ,     \" tag 1  \"  ,    xmlTag )  ;", "assertEquals (  \"  4  \"  ,    found . findFirstSubTag (  \" value \"  )  . getValue (  )  . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "com.intellij.codeInsight.SearchingInXmlTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  \" softWrap . html \"  )  ;", "EditorTestUtil . configures (  (  ( EditorWindow )     ( myFixture . getEditor (  )  )  )  . getDelegate (  )  ,     8  3  )  ;", "myFixture . type (  ' j '  )  ;", "myFixture . checkResultByFile (  \" softWrap _ after . html \"  )  ;", "}", "METHOD_END"], "methodName": ["testSoftWrapInInjection"], "fileName": "com.intellij.codeInsight.SoftWrapTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlBuilderTest . TestXmlBuilder   builder    =    new   XmlBuilderTest . TestXmlBuilder ( tagsAndAttributes )  ;", "new   XmlBuilderDriver ( xml )  . build ( builder )  ;", "assertEquals ( expectedEventSequence ,    builder . getResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.codeInsight.XmlBuilderTest"}, {"methodBody": ["METHOD_START", "{", "XmlBuilderTest . doTest (  \"  < root >  <  !  [ CDATA [  < asis /  >  ]  ]  >  <  / root >  \"  ,     (  \" TAG :    name =  \\  ' root \\  '    namespace =  \\  '  \\  '  \\ n \"     +     (  \" TEXT :     \\  '  <  !  [ CDATA [  < asis /  >  ]  ]  >  \\  '    DISPLAY :     \\  '  < asis /  >  \\  '  \\ n \"     +     \" ENDTAG :    name =  \\  ' root \\  '    namespace =  \\  '  \\  '  \\ n \"  )  )  ,    XmlBuilder . ProcessingOrder . TAGS _ AND _ TEXTS )  ;", "}", "METHOD_END"], "methodName": ["testCDATA"], "fileName": "com.intellij.codeInsight.XmlBuilderTest"}, {"methodBody": ["METHOD_START", "{", "XmlBuilderTest . doTest (  (  \"  < root >  \"     +     (  (  (  (  (  (  (  (  (  (  (  (  \"  < foo >  \"     +     \"  <  !  -  - aa -  -  >  \"  )     +     \"  <  / foo >  \"  )     +     \"  < foo >  \"  )     +     \"  <  !  -  -  -  -  >  \"  )     +     \"  <  / foo >  \"  )     +     \"  < foo >  \"  )     +     \" aaa <  !  -  - aa -  -  > aaa \"  )     +     \"  <  / foo >  \"  )     +     \"  < foo >  \"  )     +     \"  \\ naaa \\ n <  !  -  - aa -  -  >  \\ naaa \\ n \"  )     +     \"  <  / foo >  \"  )     +     \"  <  / root >  \"  )  )  ,     (  \" TAG :    name =  \\  ' root \\  '    namespace =  \\  '  \\  '  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  \" TAG :    name =  \\  ' foo \\  '    namespace =  \\  '  \\  '  \\ n \"     +     \" ENDTAG :    name =  \\  ' foo \\  '    namespace =  \\  '  \\  '  \\ n \"  )     +     \" TAG :    name =  \\  ' foo \\  '    namespace =  \\  '  \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' foo \\  '    namespace =  \\  '  \\  '  \\ n \"  )     +     \" TAG :    name =  \\  ' foo \\  '    namespace =  \\  '  \\  '  \\ n \"  )     +     \" TEXT :     \\  ' aaaaaa \\  '    DISPLAY :     \\  ' aaaaaa \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' foo \\  '    namespace =  \\  '  \\  '  \\ n \"  )     +     \" TAG :    name =  \\  ' foo \\  '    namespace =  \\  '  \\  '  \\ n \"  )     +     \" TEXT :     \\  '  \\ naaa \\ n \\ naaa \\ n \\  '    DISPLAY :     \\  '  \\ naaa \\ n \\ naaa \\ n \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' foo \\  '    namespace =  \\  '  \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' root \\  '    namespace =  \\  '  \\  '  \\ n \"  )  )  ,    XmlBuilder . ProcessingOrder . TAGS _ AND _ TEXTS )  ;", "}", "METHOD_END"], "methodName": ["testComments"], "fileName": "com.intellij.codeInsight.XmlBuilderTest"}, {"methodBody": ["METHOD_START", "{", "XmlBuilderTest . doTest (  \"  < root /  >  \"  ,     (  \" TAG :    name =  \\  ' root \\  '    namespace =  \\  '  \\  '  \\ n \"     +     \" ENDTAG :    name =  \\  ' root \\  '    namespace =  \\  '  \\  '  \\ n \"  )  ,    XmlBuilder . ProcessingOrder . TAGS _ AND _ ATTRIBUTES )  ;", "}", "METHOD_END"], "methodName": ["testEmptyXml"], "fileName": "com.intellij.codeInsight.XmlBuilderTest"}, {"methodBody": ["METHOD_START", "{", "XmlBuilderTest . doTest (  (  \"  < root >  \"     +     (  (  (  \"  < foo >  \"     +     \"  < bar \"  )     +     \"  <  \"  )     +     \"  <  / root >  \"  )  )  ,     (  \" TAG :    name =  \\  ' root \\  '    namespace =  \\  '  \\  '  \\ n \"     +     (  (  (  (  (  (  (  (  (  \" TAG :    name =  \\  ' foo \\  '    namespace =  \\  '  \\  '  \\ n \"     +     \" ERROR :     \\  ' Element   foo   is   not   closed \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' foo \\  '    namespace =  \\  '  \\  '  \\ n \"  )     +     \" TAG :    name =  \\  ' bar \\  '    namespace =  \\  '  \\  '  \\ n \"  )     +     \" ERROR :     \\  ' Tag   start   is   not   closed \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' bar \\  '    namespace =  \\  '  \\  '  \\ n \"  )     +     \" TAG :    name =  \\  '  \\  '    namespace =  \\  '  \\  '  \\ n \"  )     +     \" ERROR :     \\  ' Tag   name   expected \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  '  \\  '    namespace =  \\  '  \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' root \\  '    namespace =  \\  '  \\  '  \\ n \"  )  )  ,    XmlBuilder . ProcessingOrder . TAGS _ AND _ TEXTS )  ;", "}", "METHOD_END"], "methodName": ["testErrors"], "fileName": "com.intellij.codeInsight.XmlBuilderTest"}, {"methodBody": ["METHOD_START", "{", "XmlBuilderTest . doTest (  (  \"  < c : x   xmlns : c =  \\  \" ns 1  \\  \"  >  \\ n \"     +     (  (  (  (  (  \"        < c : y /  >  \\ n \"     +     \"        < c : x   xmlns : c =  \\  \" ns 2  \\  \"  >  \\ n \"  )     +     \"              < c : y /  >  \\ n \"  )     +     \"        <  / c : x >  \\ n \"  )     +     \"        < c : y /  >  \\ n \"  )     +     \"  <  / c : x >  \\ n \"  )  )  ,     (  \" TAG :    name =  \\  ' x \\  '    namespace =  \\  ' ns 1  \\  '  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  \" ATT :    name =  \\  ' xmlns : c \\  '    value =  \\  ' ns 1  \\  '  \\ n \"     +     \" TAG :    name =  \\  ' y \\  '    namespace =  \\  ' ns 1  \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' y \\  '    namespace =  \\  ' ns 1  \\  '  \\ n \"  )     +     \" TAG :    name =  \\  ' x \\  '    namespace =  \\  ' ns 2  \\  '  \\ n \"  )     +     \" ATT :    name =  \\  ' xmlns : c \\  '    value =  \\  ' ns 2  \\  '  \\ n \"  )     +     \" TAG :    name =  \\  ' y \\  '    namespace =  \\  ' ns 2  \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' y \\  '    namespace =  \\  ' ns 2  \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' x \\  '    namespace =  \\  ' ns 2  \\  '  \\ n \"  )     +     \" TAG :    name =  \\  ' y \\  '    namespace =  \\  ' ns 1  \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' y \\  '    namespace =  \\  ' ns 1  \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' x \\  '    namespace =  \\  ' ns 1  \\  '  \\ n \"  )  )  ,    XmlBuilder . ProcessingOrder . TAGS _ AND _ ATTRIBUTES )  ;", "}", "METHOD_END"], "methodName": ["testNamespaceOverride"], "fileName": "com.intellij.codeInsight.XmlBuilderTest"}, {"methodBody": ["METHOD_START", "{", "XmlBuilderTest . doTest (  (  \"  < jsp : root   xmlns : jsp =  \\  \" http :  /  / com / JSP / Page \\  \"    xmlns =  \\  \" http :  /  / www . w 3  . org /  1  9  9  9  / xhtml \\  \"    version =  \\  \"  2  .  0  \\  \"  \\ n \"     +     (  (  (  (  (  (  (  (  \"                               xmlns : spring =  \\  \" http :  /  / www . springframework . org / tags \\  \"    xmlns : c =  \\  \" http :  /  / com / jsp / jstl / core \\  \"  >  \\ n \"     +     \"  < html >  \\ n \"  )     +     \"        < c : set   var =  \\  \" foo \\  \"    value =  \\  \"  $  {  1  }  \\  \"  /  >  \\ n \"  )     +     \"        < c : set   var =  \\  \" foobar \\  \"    value =  \\  \"  $  {  2  }  \\  \"  /  >  \\ n \"  )     +     \"        < spring : bind   path =  \\  \" test . fieldName \\  \"  >  \\ n \"  )     +     \"              < jsp : scriptlet >  <  / jsp : scriptlet >  \\ n \"  )     +     \"              <  / spring : bind >  \\ n \"  )     +     \"  <  / html >  \\ n \"  )     +     \"  <  / jsp : root >  \"  )  )  ,     (  \" TAG :    name =  \\  ' root \\  '    namespace =  \\  ' http :  /  / com / JSP / Page \\  '  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \" ATT :    name =  \\  ' xmlns : jsp \\  '    value =  \\  ' http :  /  / com / JSP / Page \\  '  \\ n \"     +     \" ATT :    name =  \\  ' xmlns \\  '    value =  \\  ' http :  /  / www . w 3  . org /  1  9  9  9  / xhtml \\  '  \\ n \"  )     +     \" ATT :    name =  \\  ' version \\  '    value =  \\  '  2  .  0  \\  '  \\ n \"  )     +     \" ATT :    name =  \\  ' xmlns : spring \\  '    value =  \\  ' http :  /  / www . springframework . org / tags \\  '  \\ n \"  )     +     \" ATT :    name =  \\  ' xmlns : c \\  '    value =  \\  ' http :  /  / com / jsp / jstl / core \\  '  \\ n \"  )     +     \" TAG :    name =  \\  ' html \\  '    namespace =  \\  ' http :  /  / www . w 3  . org /  1  9  9  9  / xhtml \\  '  \\ n \"  )     +     \" TAG :    name =  \\  ' set \\  '    namespace =  \\  ' http :  /  / com / jsp / jstl / core \\  '  \\ n \"  )     +     \" ATT :    name =  \\  ' var \\  '    value =  \\  ' foo \\  '  \\ n \"  )     +     \" ATT :    name =  \\  ' value \\  '    value =  \\  '  $  {  1  }  \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' set \\  '    namespace =  \\  ' http :  /  / com / jsp / jstl / core \\  '  \\ n \"  )     +     \" TAG :    name =  \\  ' set \\  '    namespace =  \\  ' http :  /  / com / jsp / jstl / core \\  '  \\ n \"  )     +     \" ATT :    name =  \\  ' var \\  '    value =  \\  ' foobar \\  '  \\ n \"  )     +     \" ATT :    name =  \\  ' value \\  '    value =  \\  '  $  {  2  }  \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' set \\  '    namespace =  \\  ' http :  /  / com / jsp / jstl / core \\  '  \\ n \"  )     +     \" TAG :    name =  \\  ' bind \\  '    namespace =  \\  ' http :  /  / www . springframework . org / tags \\  '  \\ n \"  )     +     \" ATT :    name =  \\  ' path \\  '    value =  \\  ' test . fieldName \\  '  \\ n \"  )     +     \" TAG :    name =  \\  ' scriptlet \\  '    namespace =  \\  ' http :  /  / com / JSP / Page \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' scriptlet \\  '    namespace =  \\  ' http :  /  / com / JSP / Page \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' bind \\  '    namespace =  \\  ' http :  /  / www . springframework . org / tags \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' html \\  '    namespace =  \\  ' http :  /  / www . w 3  . org /  1  9  9  9  / xhtml \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' root \\  '    namespace =  \\  ' http :  /  / com / JSP / Page \\  '  \\ n \"  )  )  ,    XmlBuilder . ProcessingOrder . TAGS _ AND _ ATTRIBUTES )  ;", "}", "METHOD_END"], "methodName": ["testRealJspx"], "fileName": "com.intellij.codeInsight.XmlBuilderTest"}, {"methodBody": ["METHOD_START", "{", "XmlBuilderTest . doTest (  (  \"  < jsp : root   xmlns : jsp =  \\  \" http :  /  / com / JSP / Page \\  \"    xmlns =  \\  \" http :  /  / www . w 3  . org /  1  9  9  9  / xhtml \\  \"    version =  \\  \"  2  .  0  \\  \"  \\ n \"     +     (  (  (  (  (  (  (  (  \"                               xmlns : spring =  \\  \" http :  /  / www . springframework . org / tags \\  \"    xmlns : c =  \\  \" http :  /  / com / jsp / jstl / core \\  \"  >  \\ n \"     +     \"  < html >  \\ n \"  )     +     \"        < c : set   var =  \\  \" foo \\  \"    value =  \\  \"  $  {  1  }  \\  \"  /  >  \\ n \"  )     +     \"        < c : set   var =  \\  \" foobar \\  \"    value =  \\  \"  $  {  2  }  \\  \"  /  >  \\ n \"  )     +     \"        < spring : bind   path =  \\  \" test . fieldName \\  \"  >  \\ n \"  )     +     \"              < jsp : scriptlet >  <  / jsp : scriptlet >  \\ n \"  )     +     \"              <  / spring : bind >  \\ n \"  )     +     \"  <  / html >  \\ n \"  )     +     \"  <  / jsp : root >  \"  )  )  ,     (  \" TAG :    name =  \\  ' root \\  '    namespace =  \\  ' http :  /  / com / JSP / Page \\  '  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  \" TAG :    name =  \\  ' html \\  '    namespace =  \\  ' http :  /  / www . w 3  . org /  1  9  9  9  / xhtml \\  '  \\ n \"     +     \" TAG :    name =  \\  ' set \\  '    namespace =  \\  ' http :  /  / com / jsp / jstl / core \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' set \\  '    namespace =  \\  ' http :  /  / com / jsp / jstl / core \\  '  \\ n \"  )     +     \" TAG :    name =  \\  ' set \\  '    namespace =  \\  ' http :  /  / com / jsp / jstl / core \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' set \\  '    namespace =  \\  ' http :  /  / com / jsp / jstl / core \\  '  \\ n \"  )     +     \" TAG :    name =  \\  ' bind \\  '    namespace =  \\  ' http :  /  / www . springframework . org / tags \\  '  \\ n \"  )     +     \" TAG :    name =  \\  ' scriptlet \\  '    namespace =  \\  ' http :  /  / com / JSP / Page \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' scriptlet \\  '    namespace =  \\  ' http :  /  / com / JSP / Page \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' bind \\  '    namespace =  \\  ' http :  /  / www . springframework . org / tags \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' html \\  '    namespace =  \\  ' http :  /  / www . w 3  . org /  1  9  9  9  / xhtml \\  '  \\ n \"  )     +     \" ENDTAG :    name =  \\  ' root \\  '    namespace =  \\  ' http :  /  / com / JSP / Page \\  '  \\ n \"  )  )  ,    XmlBuilder . ProcessingOrder . TAGS )  ;", "}", "METHOD_END"], "methodName": ["testRealJspxNoAttributes"], "fileName": "com.intellij.codeInsight.XmlBuilderTest"}, {"methodBody": ["METHOD_START", "{", "XmlBuilderTest . doTest (  \"  < root >  & lt ;  <  / root >  \"  ,     (  \" TAG :    name =  \\  ' root \\  '    namespace =  \\  '  \\  '  \\ n \"     +     (  \" TEXT :     \\  '  & lt ;  \\  '    DISPLAY :     \\  '  <  \\  '  \\ n \"     +     \" ENDTAG :    name =  \\  ' root \\  '    namespace =  \\  '  \\  '  \\ n \"  )  )  ,    XmlBuilder . ProcessingOrder . TAGS _ AND _ TEXTS )  ;", "}", "METHOD_END"], "methodName": ["testSimpleEntityResolution"], "fileName": "com.intellij.codeInsight.XmlBuilderTest"}, {"methodBody": ["METHOD_START", "{", "for    ( String   file    :    additional )     {", "myFixture . copyFileToProject ( file )  ;", "}", "}", "METHOD_END"], "methodName": ["copyAdditionalFiles"], "fileName": "com.intellij.codeInsight.XmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "copyAdditionalFiles ( additional )  ;", "final    . DocumentationTestContext   context    =    new    . DocumentationTestContext ( fileName )  ;", "if    ( testForElementUnderCaret )     {", "assertNotNull (  (  \" inline   help   for    \"     +    fileName )  ,    context . generateDoc (  )  )  ;", "if    ( testExternal )     {", "assertNotNull (  \" external   help \"  ,    context . documentationProvider . getUrlFor ( context . element ,    context . originalElement )  )  ;", "}", "}", "if    ( lookupObject    !  =    null )     {", "PsiElement   docElement    =    context . documentationProvider . getDocumentationElementForLookupItem ( context . psiFile . getManager (  )  ,    lookupObject ,    context . originalElement )  ;", "assertNotNull (  (  \" no   element   for    \"     +    fileName )  ,    docElement )  ;", "assertNotNull (  \" inline   help   for   lookup \"  ,    context . documentationProvider . generateDoc ( docElement ,    context . originalElement )  )  ;", "if    ( testExternal )     {", "assertNotNull (  \" external   help   for   lookup \"  ,    context . documentationProvider . getUrlFor ( docElement ,    context . originalElement )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doOneTest"], "fileName": "com.intellij.codeInsight.XmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "copyAdditionalFiles ( additional )  ;", "doOneTest ( fileName ,    lookupObject ,    testExternal ,    true ,     \" web - app _  2  _  4  . xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["doOneTest"], "fileName": "com.intellij.codeInsight.XmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlDocumentationTest . DocumentationTestContext   context    =    new   XmlDocumentationTest . DocumentationTestContext ( baseFileNames )  ;", "String   pathname    =     (  ( getTestDataPath (  )  )     +     ( baseFileNames [  0  ]  )  )     +     \"  . expected . html \"  ;", "VirtualFile   vfile    =    LocalFileSystem . getInstance (  )  . findFileByIoFile ( new   File ( pathname )  )  ;", "assertNotNull (  ( pathname    +     \"    not   found \"  )  ,    vfile )  ;", "String   expectedText    =    StringUtil . convertLineSeparators ( VfsUtilCore . loadText ( vfile )  )  ;", "String   text    =    context . generateDoc (  )  ;", "assertNotNull ( text )  ;", "assertEquals ( XmlDocumentationTest . stripFirstLine ( expectedText )  ,    XmlDocumentationTest . stripFirstLine ( StringUtil . convertLineSeparators ( text )  )  )  ;", "if    ( completionVariant    !  =    null )     {", "vfile    =    LocalFileSystem . getInstance (  )  . findFileByIoFile ( new   File (  (  (  ( getTestDataPath (  )  )     +     ( baseFileNames [  0  ]  )  )     +     \"  . expected . completion . html \"  )  )  )  ;", "expectedText    =    StringUtil . convertLineSeparators ( VfsUtilCore . loadText ( vfile )  ,     \"  \\ n \"  )  ;", "assertEquals ( XmlDocumentationTest . stripFirstLine ( expectedText )  ,    XmlDocumentationTest . stripFirstLine ( StringUtil . convertLineSeparators ( context . generateDocForCompletion ( completionVariant )  ,     \"  \\ n \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doQuickDocGenerationTestWithCheckExpectedResult"], "fileName": "com.intellij.codeInsight.XmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "doQuickDocGenerationTestWithCheckExpectedResult ( null ,    baseFileNames )  ;", "}", "METHOD_END"], "methodName": ["doQuickDocGenerationTestWithCheckExpectedResult"], "fileName": "com.intellij.codeInsight.XmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( text . startsWith (  \"  < html    \"  )  )  )", "return   text ;", "return   text . substg ( textdexOf (  '  \\ n '  )  )  ;", "}", "METHOD_END"], "methodName": ["stripFirstLine"], "fileName": "com.intellij.codeInsight.XmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "doOneTest (  \" dtd . dtd \"  ,     \" foo \"  ,    false ,    true ,     \" web - app _  2  _  4  . xsd \"  )  ;", "doOneTest (  \" dtd . xml \"  ,     \" foo \"  ,    false ,    true ,     \" web - app _  2  _  4  . xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testDtdDoc"], "fileName": "com.intellij.codeInsight.XmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "XmlDocumentationTest . DocumentationTestContext   context    =    new   XmlDocumentationTest . DocumentationTestContext (  \"  9  . xml \"  )  ;", "assertEquals (  \"  \\  \"  &  #  1  7  1  ;  \\  \"  \"  ,    context . getQuickNavigateInfo (  )  )  ;", "}", "METHOD_END"], "methodName": ["testEntityValue"], "fileName": "com.intellij.codeInsight.XmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "XmlDocumentationTest . DocumentationTestContext   context    =    new   XmlDocumentationTest . DocumentationTestContext (  \" SchemaPrefix . xml \"  )  ;", "assertEquals (  \" XML   Namespace   Prefix    \\  \" xs \\  \"     ( http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema )  \"  ,    context . getQuickNavigateInfo (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSchemaPrefix"], "fileName": "com.intellij.codeInsight.XmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "doQuickDocGenerationTestWithCheckExpectedResult (  (  ( getTestName ( false )  )     +     \"  . xml \"  )  ,     \" spring - beans . xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testScopeAttribute"], "fileName": "com.intellij.codeInsight.XmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "doOneTest (  \"  1  . xml \"  ,     \" display - name \"  ,    false ,     \" web - app _  2  _  3  . dtd \"  )  ;", "doOneTest (  \"  2  . xml \"  ,    null ,    false ,     \" web - app _  2  _  4  . xsd \"  )  ;", "doOneTest (  \"  3  . xml \"  ,    null ,    false ,     \" web - app _  2  _  4  . xsd \"  ,     \" j 2 ee _  1  _  4  . xsd \"  )  ;", "doOneTest (  \"  3  _  2  . xml \"  ,    null ,    false ,     \" web - app _  2  _  4  . xsd \"  ,     \" j 2 ee _  1  _  4  . xsd \"  )  ;", "doOneTest (  \"  3  _  3  . xml \"  ,    null ,    false ,     \" web - app _  2  _  4  . xsd \"  ,     \" j 2 ee _  1  _  4  . xsd \"  )  ;", "doOneTest (  \"  4  . xml \"  ,     \" context - param \"  ,    false ,    false ,     \" web - app _  2  _  4  . xsd \"  )  ;", "doOneTest (  \"  5  . xml \"  ,     \" aaa : context - param \"  ,    false ,    false ,     \" web - app _  2  _  4  . xsd \"  )  ;", "doOneTest (  \"  6  . xsd \"  ,     \" xs : complexType \"  ,    true ,    true )  ;", "doOneTest (  \"  7  . xml \"  ,     \" bbb \"  ,    false )  ;", "doOneTest (  \"  8  . xml \"  ,     \" bbb \"  ,    false )  ;", "doOneTest (  \"  9  . xml \"  ,     \" laquo \"  ,    false )  ;", "}", "METHOD_END"], "methodName": ["testXmlDoc"], "fileName": "com.intellij.codeInsight.XmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "doQuickDocGenerationTestWithCheckExpectedResult (  (  ( getTestName ( false )  )     +     \"  . xml \"  )  ,     \" web - app _  2  _  4  . xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testXmlDoc2"], "fileName": "com.intellij.codeInsight.XmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "doQuickDocGenerationTestWithCheckExpectedResult (  (  ( getTestName ( false )  )     +     \"  . xml \"  )  ,     \" hibernate - mapping -  3  .  0  . dtd \"  )  ;", "}", "METHOD_END"], "methodName": ["testXmlDoc3"], "fileName": "com.intellij.codeInsight.XmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "doQuickDocGenerWithCheckExpectedResult (  ( testName    +     \"  . xml \"  )  ,     ( testName    +     \"  . xsd \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testXmlDoc4"], "fileName": "com.intellij.codeInsight.XmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "doQuickDocGenerWithCheckExpectedResult (  (  ( Object )     (  \" car \"  )  )  ,     ( testName    +     \"  . xml \"  )  ,     ( testName    +     \"  . xsd \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testXmlDoc6"], "fileName": "com.intellij.codeInsight.XmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "doQuickDocGenerWithCheckExpectedResult (  (  ( Object )     (  \"  $ Paste \"  )  )  ,     ( testName    +     \"  . xml \"  )  ,     ( testName    +     \"  . xsd \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testXmlDoc7"], "fileName": "com.intellij.codeInsight.XmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "doQuickDocGenerationTestWithCheckExpectedResult (  (  ( getTestName ( false )  )     +     \"  . xml \"  )  ,     \" spring - beans . xsd \"  )  ;", "doQuickDocGenerationTestWithCheckExpectedResult (  (  ( getTestName ( false )  )     +     \"  2  . xml \"  )  ,     \" spring - beans . xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testXmlDocWithCData"], "fileName": "com.intellij.codeInsight.XmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "doQuickDocGenerationTestWithCheckExpectedResult (  (  ( Object )     (  \" apply - imports \"  )  )  ,     \" xslCompletion . xsl \"  )  ;", "}", "METHOD_END"], "methodName": ["testXslCompletion"], "fileName": "com.intellij.codeInsight.XmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "PsiFile   dtdFile    =    createLightFile (  \" test . dtd \"  ,    dtdText )  ;", "XmlNSDescriptorImpl   descriptor    =    new   XmlNSDescriptorImpl (  )  ;", "descriptor . init ( dtdFile )  ;", "return   descriptor ;", "}", "METHOD_END"], "methodName": ["createDescriptor"], "fileName": "com.intellij.codeInsight.XmlDtdTest"}, {"methodBody": ["METHOD_START", "{", "XmlFile   file    =     (  ( XmlFile )     ( PsiFileFactory . getInstance ( getProject (  )  )  . createFileFromText (  \" tag . xml \"  ,    XML ,     (  (  \"  <  \"     +    tagName )     +     \"  /  >  \"  )  )  )  )  ;", "return   file . getDocument (  )  . getRootTag (  )  ;", "}", "METHOD_END"], "methodName": ["tag"], "fileName": "com.intellij.codeInsight.XmlDtdTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlDtdTest . createDescriptor (  \"  <  ! ELEMENT   principals   ANY >  <  ! ATTLIST   principals   path   CDATA    # IMPLIED >  \"  )  ;", "final   XmlTag   tag    =    XmlDtdTest . tag (  \" principals \"  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlAttributeDescriptor   attributeDescriptor    =    elementDescriptor . getAttributeDescriptor (  \" path \"  ,    tag )  ;", "assertEquals (  \" path \"  ,    attributeDescriptor . getName (  )  )  ;", "assertTrue (  (  !  ( attributeDescriptor . isRequired (  )  )  )  )  ;", "assertTrue (  (  !  ( attributeDescriptor . isFixed (  )  )  )  )  ;", "assertTrue (  (  !  ( attributeDescriptor . isEnumerated (  )  )  )  )  ;", "assertNull ( attributeDescriptor . getDefaultValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeDescriptor1"], "fileName": "com.intellij.codeInsight.XmlDtdTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlDtdTest . createDescriptor (  \"  <  ! ELEMENT   principals   ANY >  <  ! ATTLIST   principals   path   CDATA    # IMPLIED >  \"  )  ;", "final   XmlTag   tag    =    XmlDtdTest . tag (  \" principals \"  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlAttributeDescriptor   attributeDescriptor    =    elementDescriptor . getAttributeDescriptor (  \" path \"  ,    tag )  ;", "assertTrue (  (  !  ( attributeDescriptor . isRequired (  )  )  )  )  ;", "assertTrue (  (  !  ( attributeDescriptor . isFixed (  )  )  )  )  ;", "assertTrue (  (  !  ( attributeDescriptor . isEnumerated (  )  )  )  )  ;", "assertNull ( attributeDescriptor . getDefaultValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeDescriptor2"], "fileName": "com.intellij.codeInsight.XmlDtdTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlDtdTest . createDescriptor (  \"  <  ! ELEMENT   toc   ANY >     <  ! ATTLIST   toc   version   CDATA    # FIXED    \\  \"  1  .  0  \\  \"  >  \"  )  ;", "final   XmlTag   tag    =    XmlDtdTest . tag (  \" toc \"  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlAttributeDescriptor   attributeDescriptor    =    elementDescriptor . getAttributeDescriptor (  \" version \"  ,    tag )  ;", "assertTrue (  (  !  ( attributeDescriptor . isRequired (  )  )  )  )  ;", "assertTrue ( attributeDescriptor . isFixed (  )  )  ;", "assertTrue (  (  !  ( attributeDescriptor . isEnumerated (  )  )  )  )  ;", "assertEquals (  \"  1  .  0  \"  ,    attributeDescriptor . getDefaultValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeDescriptor3"], "fileName": "com.intellij.codeInsight.XmlDtdTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlDtdTest . createDescriptor (  \"  <  ! ELEMENT   toc   ANY >     <  ! ATTLIST   toc   remote    ( true | false )     \\  \" false \\  \"  >  \"  )  ;", "final   XmlTag   tag    =    XmlDtdTest . tag (  \" toc \"  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlAttributeDescriptor   attributeDescriptor    =    elementDescriptor . getAttributeDescriptor (  \" remote \"  ,    tag )  ;", "assertTrue (  (  !  ( attributeDescriptor . isRequired (  )  )  )  )  ;", "assertTrue (  (  !  ( attributeDescriptor . isFixed (  )  )  )  )  ;", "assertTrue ( attributeDescriptor . isEnumerated (  )  )  ;", "assertEquals (  \" false \"  ,    attributeDescriptor . getDefaultValue (  )  )  ;", "String [  ]    values    =    attributeDescriptor . getEnumeratedValues (  )  ;", "assertEquals (  2  ,    values . length )  ;", "assertEquals (  \" true \"  ,    values [  0  ]  )  ;", "assertEquals (  \" false \"  ,    values [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeDescriptor4"], "fileName": "com.intellij.codeInsight.XmlDtdTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlDtdTest . createDescriptor (  \"  <  ! ELEMENT   toc   ANY >     <  ! ATTLIST   toc   remote    (  0  |  1  |  2  )     # REQUIRED >  \"  )  ;", "final   XmlTag   tag    =    XmlDtdTest . tag (  \" toc \"  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlAttributeDescriptor   attributeDescriptor    =    elementDescriptor . getAttributeDescriptor (  \" remote \"  ,    tag )  ;", "assertTrue ( attributeDescriptor . isRequired (  )  )  ;", "assertTrue (  (  !  ( attributeDescriptor . isFixed (  )  )  )  )  ;", "assertTrue ( attributeDescriptor . isEnumerated (  )  )  ;", "assertNull ( attributeDescriptor . getDefaultValue (  )  )  ;", "String [  ]    values    =    attributeDescriptor . getEnumeratedValues (  )  ;", "assertEquals (  3  ,    values . length )  ;", "assertEquals (  \"  0  \"  ,    values [  0  ]  )  ;", "assertEquals (  \"  1  \"  ,    values [  1  ]  )  ;", "assertEquals (  \"  2  \"  ,    values [  2  ]  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeDescriptor5"], "fileName": "com.intellij.codeInsight.XmlDtdTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlDtdTest . createDescriptor (  \"  <  ! ELEMENT   principals    (  # PCDATA )  >  <  ! ELEMENT   data - sources    (  # PCDATA )  >  \"  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( XmlDtdTest . tag (  \" principals \"  )  )  ;", "assertNotNull ( elementDescriptor )  ;", "elementDescriptor    =    NSDescriptor . getElementDescriptor ( XmlDtdTest . tag (  \" data - sources \"  )  )  ;", "assertNotNull ( elementDescriptor )  ;", "elementDescriptor    =    NSDescriptor . getElementDescriptor ( XmlDtdTest . tag (  \" xxx \"  )  )  ;", "assertNull ( elementDescriptor )  ;", "}", "METHOD_END"], "methodName": ["testDocumentDescriptor1"], "fileName": "com.intellij.codeInsight.XmlDtdTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlDtdTest . createDescriptor (  \"  <  ! ELEMENT   principals    (  # PCDATA )  >  <  ! ELEMENT   data - sources    (  # PCDATA )  >  \"  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( XmlDtdTest . tag (  \" principals \"  )  )  ;", "assertEquals (  \" principals \"  ,    elementDescriptor . getName (  )  )  ;", "elementDescriptor    =    NSDescriptor . getElementDescriptor ( XmlDtdTest . tag (  \" data - sources \"  )  )  ;", "assertEquals (  \" data - sources \"  ,    elementDescriptor . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testElementDescriptor1"], "fileName": "com.intellij.codeInsight.XmlDtdTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlDtdTest . createDescriptor (  (  \"  <  ! ELEMENT   principals    (  # PCDATA )  >  <  ! ELEMENT   data - sources   ANY >  \"     +     \"  <  ! ELEMENT   read - access    ( namespace - resource )  >  <  ! ELEMENT   group   EMPTY >  \"  )  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( XmlDtdTest . tag (  \" principals \"  )  )  ;", "assertEquals ( elementDescriptor . getContentType (  )  ,    XmlElementDescriptor . CONTENT _ TYPE _ MIXED )  ;", "elementDescriptor    =    NSDescriptor . getElementDescriptor ( XmlDtdTest . tag (  \" data - sources \"  )  )  ;", "assertEquals ( elementDescriptor . getContentType (  )  ,    XmlElementDescriptor . CONTENT _ TYPE _ ANY )  ;", "elementDescriptor    =    NSDescriptor . getElementDescriptor ( XmlDtdTest . tag (  \" read - access \"  )  )  ;", "assertEquals ( elementDescriptor . getContentType (  )  ,    XmlElementDescriptor . CONTENT _ TYPE _ CHILDREN )  ;", "elementDescriptor    =    NSDescriptor . getElementDescriptor ( XmlDtdTest . tag (  \" group \"  )  )  ;", "assertEquals ( elementDescriptor . getContentType (  )  ,    XmlElementDescriptor . CONTENT _ TYPE _ EMPTY )  ;", "}", "METHOD_END"], "methodName": ["testElementDescriptor2"], "fileName": "com.intellij.codeInsight.XmlDtdTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlDtdTest . createDescriptor (  (  \"  <  ! ELEMENT   principals   ANY >  <  ! ATTLIST   principals   path   CDATA    # IMPLIED   smtp - host   CDATA    # REQUIRED >  \"     +     \"  <  ! ATTLIST   principals   address   CDATA    # IMPLIED >  \"  )  )  ;", "final   XmlTag   tag    =    XmlDtdTest . tag (  \" principals \"  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlAttributeDescriptor   attributeDescriptor    =    elementDescriptor . getAttributeDescriptor (  \" path \"  ,    tag )  ;", "assertNotNull ( attributeDescriptor )  ;", "attributeDescriptor    =    elementDescriptor . getAttributeDescriptor (  \" xxx \"  ,    tag )  ;", "assertNull ( attributeDescriptor )  ;", "attributeDescriptor    =    elementDescriptor . getAttributeDescriptor (  \" smtp - host \"  ,    tag )  ;", "assertNotNull ( attributeDescriptor )  ;", "attributeDescriptor    =    elementDescriptor . getAttributeDescriptor (  \" address \"  ,    tag )  ;", "assertNotNull ( attributeDescriptor )  ;", "XmlAttributeDescriptor [  ]    descriptors    =    elementDescriptor . getAttributesDescriptors ( tag )  ;", "assertEquals (  \" path \"  ,    descriptors [  0  ]  . getName (  )  )  ;", "assertEquals (  \" smtp - host \"  ,    descriptors [  1  ]  . getName (  )  )  ;", "assertEquals (  \" address \"  ,    descriptors [  2  ]  . getName (  )  )  ;", "assertEquals (  3  ,    descriptors . length )  ;", "}", "METHOD_END"], "methodName": ["testElementDescriptor3"], "fileName": "com.intellij.codeInsight.XmlDtdTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlDtdTest . createDescriptor (  (  \"  <  ! ELEMENT   orion - application    ( ejb - module *  ,    persistence ?  ,    namespace - access )  >  \"     +     (  (  \"  <  ! ELEMENT   ejb - module   ANY >  \"     +     \"  <  ! ELEMENT   persistence   ANY >  \"  )     +     \"  <  ! ELEMENT   namespace - access   ANY >  \"  )  )  )  ;", "XmlTag   documentTag    =    XmlDtdTest . tag (  \" orion - application \"  )  ;", "XmlElementDescriptorImpl   elementDescriptor    =     (  ( XmlElementDescriptorImpl )     ( NSDescriptor . getElementDescriptor ( documentTag )  )  )  ;", "XmlElementDescriptor [  ]    elements    =    elementDescriptor . getElementsDescriptors ( documentTag )  ;", "assertEquals (  3  ,    elements . length )  ;", "assertEquals (  \" ejb - module \"  ,    elements [  0  ]  . getName (  )  )  ;", "assertEquals (  \" persistence \"  ,    elements [  1  ]  . getName (  )  )  ;", "assertEquals (  \" namespace - access \"  ,    elements [  2  ]  . getName (  )  )  ;", "elements    =    elements [  0  ]  . getElementsDescriptors ( documentTag )  ;", "assertEquals (  4  ,    elements . length )  ;", "assertEquals (  \" orion - application \"  ,    elements [  0  ]  . getName (  )  )  ;", "assertEquals (  \" ejb - module \"  ,    elements [  1  ]  . getName (  )  )  ;", "assertEquals (  \" persistence \"  ,    elements [  2  ]  . getName (  )  )  ;", "assertEquals (  \" namespace - access \"  ,    elements [  3  ]  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testElementDescriptor4"], "fileName": "com.intellij.codeInsight.XmlDtdTest"}, {"methodBody": ["METHOD_START", "{", "XmlFile   xmlFile    =     (  ( XmlFile )     ( createFile (  \" test . xml \"  ,     \"  <  ! DOCTYPE   tv    [     <  ! ELEMENT   tv    ( date )  *  >     <  ! ELEMENT   date    (  # PCDATA )  >     ]  >     < tv >  <  / tv >  \"  )  )  )  ;", "final   XmlTag   tag    =    xmlFile . getDocument (  )  . getRootTag (  )  ;", "assertNotNull ( tag )  ;", "final   XmlElementDescriptor   desc    =    xmlFile . getDocument (  )  . getRootTagNSDescriptor (  )  . getElementDescriptor ( tag )  ;", "assertNotNull ( desc )  ;", "final   XmlElementDescriptor [  ]    elements    =    desc . getElementsDescriptors ( tag )  ;", "assertEquals (  1  ,    elements . length )  ;", "assertEquals (  \" date \"  ,    elements [  0  ]  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testEmbeddedDtd1"], "fileName": "com.intellij.codeInsight.XmlDtdTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlDtdTest . createDescriptor (  \"  <  ! ENTITY    %    boolean    \\  \"  ( true | false | on | off | yes | no )  \\  \"  >     <  ! ELEMENT   toc   ANY >     <  ! ATTLIST   toc   remote    % boolean ;     \\  \" false \\  \"  \"  )  ;", "final   XmlTag   tag    =    XmlDtdTest . tag (  \" toc \"  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlAttributeDescriptor   attributeDescriptor    =    elementDescriptor . getAttributeDescriptor (  \" remote \"  ,    tag )  ;", "assertTrue (  (  !  ( attributeDescriptor . isRequired (  )  )  )  )  ;", "assertTrue (  (  !  ( attributeDescriptor . isFixed (  )  )  )  )  ;", "assertTrue ( attributeDescriptor . isEnumerated (  )  )  ;", "assertEquals (  \" false \"  ,    attributeDescriptor . getDefaultValue (  )  )  ;", "String [  ]    values    =    attributeDescriptor . getEnumeratedValues (  )  ;", "assertEquals (  6  ,    values . length )  ;", "assertEquals (  \" true \"  ,    values [  0  ]  )  ;", "assertEquals (  \" false \"  ,    values [  1  ]  )  ;", "assertEquals (  \" on \"  ,    values [  2  ]  )  ;", "assertEquals (  \" off \"  ,    values [  3  ]  )  ;", "assertEquals (  \" yes \"  ,    values [  4  ]  )  ;", "assertEquals (  \" no \"  ,    values [  5  ]  )  ;", "}", "METHOD_END"], "methodName": ["testEntityDecl1"], "fileName": "com.intellij.codeInsight.XmlDtdTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlDtdTest . createDescriptor (  \"  <  ! ENTITY    %    coreattrs    \\  \" id   D    # IMPLIED \\  \"  >     <  ! ELEMENT   a   ANY >     <  ! ATTLIST   a    % coreattrs ;    version   CDATA    # FIXED    \\  \"  1  .  0  \\  \"  \"  )  ;", "final   XmlTag   tag    =    XmlDtdTest . tag (  \" a \"  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "final   XmlAttributeDescriptor [  ]    attributes    =    elementDescriptor . getAttributesDescriptors ( tag )  ;", "assertEquals (  2  ,    attributes . length )  ;", "assertEquals (  \" id \"  ,    attributes [  0  ]  . getName (  )  )  ;", "assertEquals (  \" version \"  ,    attributes [  1  ]  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testEntityDecl2"], "fileName": "com.intellij.codeInsight.XmlDtdTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlDtdTest . createDescriptor (  \"  <  ! ENTITY    %    att 1     \\  \" id 1    D    # IMPLIED \\  \"  >     <  ! ENTITY    %    att 2     \\  \" id 2    D    # IMPLIED \\  \"  >     <  ! ELEMENT   a   ANY >     <  ! ATTLIST   a    % att 1  ;     % att 2  ;     \"  )  ;", "final   XmlTag   tag    =    XmlDtdTest . tag (  \" a \"  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "final   XmlAttributeDescriptor [  ]    attributes    =    elementDescriptor . getAttributesDescriptors ( tag )  ;", "assertEquals (  2  ,    attributes . length )  ;", "assertEquals (  \" id 1  \"  ,    attributes [  0  ]  . getName (  )  )  ;", "assertEquals (  \" id 2  \"  ,    attributes [  1  ]  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testEntityDecl3"], "fileName": "com.intellij.codeInsight.XmlDtdTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlDtdTest . createDescriptor (  \"  <  ! ENTITY    %    boolean    \\  '  ( true | false | on | off | yes | no )  \\  '  >     <  ! ENTITY    %    bool    \\  \"  % boolean ;  \\  \"  >        <  ! ELEMENT   toc   ANY >     <  ! ATTLIST   toc   remote    % bool ;     \\  \" false \\  \"  \"  )  ;", "final   XmlTag   tag    =    XmlDtdTest . tag (  \" toc \"  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlAttributeDescriptor   attributeDescriptor    =    elementDescriptor . getAttributeDescriptor (  \" remote \"  ,    tag )  ;", "assertTrue (  (  !  ( attributeDescriptor . isRequired (  )  )  )  )  ;", "assertTrue (  (  !  ( attributeDescriptor . isFixed (  )  )  )  )  ;", "assertTrue ( attributeDescriptor . isEnumerated (  )  )  ;", "assertEquals (  \" false \"  ,    attributeDescriptor . getDefaultValue (  )  )  ;", "String [  ]    values    =    attributeDescriptor . getEnumeratedValues (  )  ;", "assertEquals (  6  ,    values . length )  ;", "assertEquals (  \" true \"  ,    values [  0  ]  )  ;", "assertEquals (  \" false \"  ,    values [  1  ]  )  ;", "assertEquals (  \" on \"  ,    values [  2  ]  )  ;", "assertEquals (  \" off \"  ,    values [  3  ]  )  ;", "assertEquals (  \" yes \"  ,    values [  4  ]  )  ;", "assertEquals (  \" no \"  ,    values [  5  ]  )  ;", "}", "METHOD_END"], "methodName": ["testEntityDecl4"], "fileName": "com.intellij.codeInsight.XmlDtdTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlDtdTest . createDescriptor (  \"  <  ! ENTITY    %    boolean    \\  \" true    |    false \\  \"     >     <  ! ELEMENT   foo   EMPTY >     <  ! ATTLIST   foo   someBoolean    (  % boolean ;  )     \\  \" true \\  \"    someString   CDATA    # IMPLIED    >  \"  )  ;", "final   XmlTag   tag    =    XmlDtdTest . tag (  \" foo \"  )  ;", "final   XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "final   XmlAttributeDescriptor [  ]    attributes    =    elementDescriptor . getAttributesDescriptors ( tag )  ;", "assertEquals (  2  ,    attributes . length )  ;", "assertEquals (  \" someBoolean \"  ,    attributes [  0  ]  . getName (  )  )  ;", "assertEquals (  \" someString \"  ,    attributes [  1  ]  . getName (  )  )  ;", "assertTrue ( attributes [  0  ]  . isEnumerated (  )  )  ;", "assertEquals (  2  ,    attributes [  0  ]  . getEnumeratedValues (  )  . length )  ;", "assertEquals (  \" true \"  ,    attributes [  0  ]  . getEnumeratedValues (  )  [  0  ]  )  ;", "assertEquals (  \" false \"  ,    attributes [  0  ]  . getEnumeratedValues (  )  [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["testEntityDecl5"], "fileName": "com.intellij.codeInsight.XmlDtdTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlNSDescriptor   NSDescriptor    =    XmlDtdTest . createDescriptor (  (  \"  <  ! ENTITY    %    types    \\  \" fileset    |    patternset    \\  \"  >     <  ! ELEMENT   project    ( target    |    taskdef    |     % types ;     |    property    )  *  >     \"     +     \"  <  ! ELEMENT   target >  <  ! ELEMENT   taskdef >  <  ! ELEMENT   fileset >  <  ! ELEMENT   patternset >  <  ! ELEMENT   property >  \"  )  )  ;", "XmlTag   projectTag    =    XmlDtdTest . tag (  \" project \"  )  ;", "final   XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( projectTag )  ;", "final   XmlElementDescriptor [  ]    elements    =    elementDescriptor . getElementsDescriptors ( projectTag )  ;", "assertEquals (  5  ,    elements . length )  ;", "}", "METHOD_END"], "methodName": ["testEntityDeclElement1"], "fileName": "com.intellij.codeInsight.XmlDtdTest"}, {"methodBody": ["METHOD_START", "{", "final   PomModel   model    =    PomManager . getModel ( getProject (  )  )  ;", "final    . Listener   listener    =    new    . Listener ( model . getModelAspect ( XmlAspect . class )  )  ;", "model . addModelListener ( listener ,    getTestRootDisposable (  )  )  ;", "return   listener ;", "}", "METHOD_END"], "methodName": ["addPomListener"], "fileName": "com.intellij.codeInsight.XmlEventsTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlEventsTest . Listener   listener    =    addPomListener (  )  ;", "final   XmlTag   tagFromText    =     (  ( XmlFile )     ( createFile (  \" file . xml \"  ,    rootTagText )  )  )  . getDocument (  )  . getRootTag (  )  ;", "final   PsiFileImpl   containingFile    =     (  ( PsiFileImpl )     ( tagFromText . getContainingFile (  )  )  )  ;", "final   PsiDocumentManager   documentManager    =    PsiDocumentManager . getInstance ( getProject (  )  )  ;", "final   Document   document    =    documentManager . getDocument ( containingFile )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "document . insertString ( positionToInsert ,    stringToInsert )  ;", "documentManager . commitDocument ( document )  ;", "}  )  ;", "assertEquals ( events ,    listener . getEventString (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkEventsByDocumentChange"], "fileName": "com.intellij.codeInsight.XmlEventsTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlEventsTest . Listener   listener    =    addPomListener (  )  ;", "final   XmlTag   tagFromText    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < a /  >  \"  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "tagFromText . setAttribute (  \" a \"  ,     \" b \"  )  ;", "}  )  ;", "assertEquals (  \"  ( Attribute    \\  \" a \\  \"    for   tag    \\  \" a \\  \"    set   to    \\  \" b \\  \"  )  \\ n \"  ,    listener . getEventString (  )  )  ;", "}", "METHOD_END"], "methodName": ["test1"], "fileName": "com.intellij.codeInsight.XmlEventsTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlEventsTest . Listener   listener    =    addPomListener (  )  ;", "final   XmlTag   tagFromText    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < a > aaa <  / a >  \"  )  ;", "final   XmlTag   otherTag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < a /  >  \"  )  ;", "final   XmlText   xmlText    =    tagFromText . getValue (  )  . getTextElements (  )  [  0  ]  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "xmlText . insertAtOffset ( otherTag ,     2  )  ;", "}  )  ;", "assertEquals (  \"  ( text   changed   to    \\  ' aa \\  '    was :     \\  ' aaa \\  '  )  ,     ( child   added   to   a   child :    XmlText )  ,     ( child   added   to   a   child :    XmlTag : a )  \\ n \"  ,    listener . getEventString (  )  )  ;", "}", "METHOD_END"], "methodName": ["test2"], "fileName": "com.intellij.codeInsight.XmlEventsTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlEventsTest . Listener   listener    =    addPomListener (  )  ;", "final   XmlTag   tagFromText    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < a > aaa <  / a >  \"  )  ;", "final   XmlText   xmlText    =    tagFromText . getValue (  )  . getTextElements (  )  [  0  ]  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >    xmlText . insertText (  \" bb \"  ,     2  )  )  ;", "assertEquals (  \"  ( text   changed   to    \\  ' aabba \\  '    was :     \\  ' aaa \\  '  )  \\ n \"  ,    listener . getEventString (  )  )  ;", "}", "METHOD_END"], "methodName": ["test3"], "fileName": "com.intellij.codeInsight.XmlEventsTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlEventsTest . Listener   listener    =    addPomListener (  )  ;", "final   XmlTag   tagFromText    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < a > a    <  / a >  \"  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "tagFromText . addAfter ( tagFromText . getValue (  )  . getTextElements (  )  [  0  ]  ,    tagFromText . getValue (  )  . getTextElements (  )  [  0  ]  )  ;", "}  )  ;", "assertEquals (  \"  ( text   changed   to    \\  ' a   a    \\  '    was :     \\  ' a    \\  '  )  \\ n \"  ,    listener . getEventString (  )  )  ;", "}", "METHOD_END"], "methodName": ["test4"], "fileName": "com.intellij.codeInsight.XmlEventsTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlEventsTest . Listener   listener    =    addPomListener (  )  ;", "final   XmlTag   tagFromText    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < a > aaa <  / a >  \"  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >    tagFromText . delete (  )  )  ;", "assertEquals (  \"  ( Xml   document   changed )  \\ n \"  ,    listener . getEventString (  )  )  ;", "}", "METHOD_END"], "methodName": ["test5"], "fileName": "com.intellij.codeInsight.XmlEventsTest"}, {"methodBody": ["METHOD_START", "{", "final   String   text    =     \"  < target   name =  \\  \" old \\  \"  /  >  \"  ;", "final    . Listener   listener    =    addPomListener (  )  ;", "final   XmlTag   tag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText ( text )  ;", "final   XmlAttribute   attribute    =    tag . getAttribute (  \" name \"  ,    null )  ;", "assert   attribute    !  =    null ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >    attribute . setValue (  \" new \"  )  )  ;", "assertEquals ( attribute . getValue (  )  ,     \" new \"  )  ;", "assertEquals (  \"  ( Attribute    \\  \" name \\  \"    for   tag    \\  \" target \\  \"    set   to    \\  \"  \\  \" new \\  \"  \\  \"  )  \\ n \"  ,    listener . getEventString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeValueReplace"], "fileName": "com.intellij.codeInsight.XmlEventsTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlEventsTest . Listener   listener    =    addPomListener (  )  ;", "final   PsiFile   file    =    createFile (  \" a . xml \"  ,     \"  < a /  >  \"  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "final   Document   document    =    PsiDocumentManager . getInstance ( getProject (  )  )  . getDocument ( file )  ;", "DocumentUtil . executeInBulk ( document ,    true ,     (  )     -  >     {", "document . insertString (  0  ,     \"     \"  )  ;", "commitDocument ( document )  ;", "}  )  ;", "}  )  ;", "assertEquals (  \"  ( Xml   document   changed )  \"  ,    listener . getEventString (  )  . trim (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBulkUpdate"], "fileName": "com.intellij.codeInsight.XmlEventsTest"}, {"methodBody": ["METHOD_START", "{", "final   String   xml    =     \"  \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"  <  ? xml   version =  \\  \"  1  .  0  \\  \"    encoding =  \\  \" utf -  8  \\  \"  ?  >  \\ n \"     +     \"  < LinearLayout   xmlns : android =  \\  \" http :  /  / schemas . android . com / apk / res / android \\  \"  \\ n \"  )     +     \"             android : layout _ height =  \\  \" fill _ parent \\  \"  >  \\ n \"  )     +     \"              < include   layout =  \\  \"  @ layout / colorstrip \\  \"     /  >  \\ n \"  )     +     \"  \\ n \"  )     +     \"  \\ n \"  )     +     \"              < LinearLayout \\ n \"  )     +     \"                         android : id =  \\  \"  @  + id / noteArea \\  \"  \\ n \"  )     +     \"                         android : layout _ width =  \\  \" fill _ parent \\  \"  \\ n \"  )     +     \"                         android : layout _ height =  \\  \" wrap _ content \\  \"  \\ n \"  )     +     \"                         android : layout _ weight =  \\  \"  1  \\  \"  \\ n \"  )     +     \"                         android : layout _ margin =  \\  \"  5 dip \\  \"  >  \\ n \"  )     +     \"              <  / LinearLayout >  \\ n \"  )     +     \"  \\ n \"  )     +     \"  <  / LinearLayout >  \\ n \"  )  ;", "PsiFile   file    =    createFile (  \" file . xml \"  ,    xml )  ;", "assertTrue (  ( file   instanceof   XmlFile )  )  ;", "XmlDocument   xmlDocument    =     (  ( XmlFile )     ( file )  )  . getDocument (  )  ;", "assertNotNull ( xmlDocument )  ;", "final   XmlTag   tagFromText    =    xmlDocument . getRootTag (  )  ;", "assertNotNull ( tagFromText )  ;", "final   PsiFileImpl   containingFile    =     (  ( PsiFileImpl )     ( tagFromText . getContainingFile (  )  )  )  ;", "final   PsiDocumentManager   documentManager    =    PsiDocumentManager . getInstance ( getProject (  )  )  ;", "final   Document   document    =    documentManager . getDocument ( containingFile )  ;", "assertNotNull ( document )  ;", "final    . TestListener   listener    =    new    . TestListener (  )  ;", "PsiManager . getInstance ( getProject (  )  )  . addPsiTreeChangeListener ( listener )  ;", "CommandProcessor . getInstance (  )  . executeCommand ( getProject (  )  ,     (  )     -  >    ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >     {", "int   positionToInsert    =    xml . indexOf (  (  \"     < LinearLayout \\ n \"     +     \"                         android : id =  \\  \"  @  + id / noteArea \\  \"  \\ n \"  )  )  ;", "assertFalse (  ( positionToInsert    =  =     (  -  1  )  )  )  ;", "String   stringToInsert    =     \"  < Button   android : id =  \\  \"  @  + id / newid \\  \"     /  >  \\ n \"  ;", "document . insertString ( positionToInsert ,    stringToInsert )  ;", "documentManager . commitDocument ( document )  ;", "}  )  ,     \"  \"  ,    null )  ;", "PsiManager . getInstance ( getProject (  )  )  . removePsiTreeChangeListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["testDocumentChange"], "fileName": "com.intellij.codeInsight.XmlEventsTest"}, {"methodBody": ["METHOD_START", "{", "final   String   rootTagText    =     \"  < a /  >  \"  ;", "final   String   stringToInsert    =     \" b =  \\  \" c \\  \"  \"  ;", "final   int   positionToInsert    =     2  ;", "checkByDocumentChange ( rootTagText ,    positionToInsert ,    stringToInsert ,     \"  ( Xml   document   changed )  \\ n \"  )  ;", "}", "METHOD_END"], "methodName": ["testDocumentChange1"], "fileName": "com.intellij.codeInsight.XmlEventsTest"}, {"methodBody": ["METHOD_START", "{", "final   String   rootTagText    =     \"  < a    /  >  \"  ;", "final   String   stringToInsert    =     \" b =  \\  \" c \\  \"  \"  ;", "final   int   positionToInsert    =     3  ;", "checkByDocumentChange ( rootTagText ,    positionToInsert ,    stringToInsert ,     \"  ( Xml   document   changed )  \\ n \"  )  ;", "}", "METHOD_END"], "methodName": ["testDocumentChange2"], "fileName": "com.intellij.codeInsight.XmlEventsTest"}, {"methodBody": ["METHOD_START", "{", "final   String   rootTagText    =     \"  < b >  < a    /  >  <  / b >  \"  ;", "final   String   stringToInsert    =     \" b =  \\  \" c \\  \"  \"  ;", "final   int   positionToInsert    =     6  ;", "checkByDocumentChange ( rootTagText ,    positionToInsert ,    stringToInsert ,     \"  ( child   changed   in   b   child :    XmlTag : a )  \\ n \"  )  ;", "}", "METHOD_END"], "methodName": ["testDocumentChange3"], "fileName": "com.intellij.codeInsight.XmlEventsTest"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \"  < tag > x   y   z   a   b   c   d <  / tag >  \"  ;", "PsiFile   file    =    PsiFileFactory . gettance ( getProject (  )  )  . createFileFromText (  \" a . xml \"  ,    XMLLanguage . INSTANCE ,    text )  ;", "Document   document    =    file . getViewProvider (  )  . getDocument (  )  ;", "RangeMarker   marker    =    document . createRangeMarker ( TextRange . from ( text . indexOf (  \" a   b \"  )  ,     3  )  )  ;", "XmlTag   tag    =    PsiTreeUtil . findElementOfClassAtOffset ( file ,     0  ,    XmlTag . class ,    false )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >    tag . getValue (  )  . setText (  \" x   a   b   c   d \"  )  )  ;", "assertEquals (  \"  < tag > x   a   b   c   d <  / tag >  \"  ,    document . getText (  )  )  ;", "assertTrue ( marker . isValid (  )  )  ;", "assertEquals (  \" a   b \"  ,    document . getText ( TextRange . create ( marker )  )  )  ;", "}", "METHOD_END"], "methodName": ["testRangeMarkersShouldSurviveOnSmallTagValueModification"], "fileName": "com.intellij.codeInsight.XmlEventsTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlEventsTest . Listener   listener    =    addPomListener (  )  ;", "configureFromFileText (  \" x . xml \"  ,     \"  < a > aaa \\ n < x > xxx <  / x >  \\ n < y > yyy <  / y >  <  / a >  \"  )  ;", "final   XmlTag   x    =     (  ( XmlFile )     ( getFile (  )  )  )  . getRootTag (  )  . findSubTags (  \" x \"  )  [  0  ]  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "TextRange   range    =    x . getTextRange (  )  ;", "getEditor (  )  . getDocument (  )  . deleteString ( range . getStartOffset (  )  ,     (  ( range . getEndOffset (  )  )     +     1  )  )  ;", "PsiDocumentManager . getInstance ( getProject (  )  )  . commitAllDocuments (  )  ;", "}  )  ;", "assertEquals (  \"  ( child   removed   from   a   child :    XmlTag : x )  ,     ( child   removed   from   a   child :    XmlText )  \\ n \"  ,    listener . getEventString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTagDelete"], "fileName": "com.intellij.codeInsight.XmlEventsTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlEventsTest . Listener   listener    =    addPomListener (  )  ;", "configureFromFileText (  \" x . xml \"  ,     \"  < a > aaa \\ n < x > xxx <  / x >  \\ n < y > yyy <  / y >  <  / a >  \"  )  ;", "final   XmlTag   x    =     (  ( XmlFile )     ( getFile (  )  )  )  . getRootTag (  )  . findSubTags (  \" x \"  )  [  0  ]  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "TextRange   range    =    x . getTextRange (  )  ;", "getEditor (  )  . getDocument (  )  . insertString (  (  ( range . getEndOffset (  )  )     +     1  )  ,     \"  < z > zxzz <  / z >  \\ n \"  )  ;", "PsiDocumentManager . getInstance ( getProject (  )  )  . commitAllDocuments (  )  ;", "}  )  ;", "assertEquals (  \"  ( child   added   to   a   child :    XmlText )  ,     ( child   added   to   a   child :    XmlTag : z )  \\ n \"  ,    listener . getEventString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTagInsert"], "fileName": "com.intellij.codeInsight.XmlEventsTest"}, {"methodBody": ["METHOD_START", "{", "return   file . getDocument (  )  . getRootTagNSDescriptor (  )  ;", "}", "METHOD_END"], "methodName": ["createDescriptor"], "fileName": "com.intellij.codeInsight.XmlInsightTest"}, {"methodBody": ["METHOD_START", "{", "return    (  ( XmlFile )     ( XmlInsightTest . createFile (  \" test . xml \"  ,    text )  )  )  ;", "}", "METHOD_END"], "methodName": ["createFile"], "fileName": "com.intellij.codeInsight.XmlInsightTest"}, {"methodBody": ["METHOD_START", "{", "XmlFile   file    =    XmlInsightTest . createFile (  \"  < root >  < a   attr 1  =  '  '  >  <  / a >  < a   attr 2  =  '  '    attr 1  =  '  '  >  <  / a >  <  / root >  \"  )  ;", "XmlNSDescriptor   descriptor    =    XmlInsightTest . createDescriptor ( file )  ;", "XmlTag   rootTag    =    file . getDocument (  )  . getRootTag (  )  ;", "XmlElementDescriptor   element    =    descriptor . getElementDescriptor ( rootTag )  ;", "element    =    element . getElementsDescriptors ( rootTag )  [  0  ]  ;", "XmlAttributeDescriptor [  ]    attributes    =    element . getAttributesDescriptors ( rootTag )  ;", "assertEquals (  \" attr 1  \"  ,    attributes [  0  ]  . getName (  )  )  ;", "assertTrue ( attributes [  0  ]  . isRequired (  )  )  ;", "assertEquals (  \" attr 2  \"  ,    attributes [  1  ]  . getName (  )  )  ;", "assertTrue (  (  !  ( attributes [  1  ]  . isRequired (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeDescriptor1"], "fileName": "com.intellij.codeInsight.XmlInsightTest"}, {"methodBody": ["METHOD_START", "{", "XmlFile   file    =    XmlInsightTest . createFile (  \"  < root >  < a   c =  '  '    a =  '  '  >  <  / a >  <  / root >  \"  )  ;", "XmlNSDescriptor   descriptor    =    XmlInsightTest . createDescriptor ( file )  ;", "XmlTag   rootTag    =    file . getDocument (  )  . getRootTag (  )  ;", "XmlElementDescriptor   element    =    descriptor . getElementDescriptor ( rootTag )  ;", "element    =    element . getElementsDescriptors ( rootTag )  [  0  ]  ;", "XmlAttributeDescriptor [  ]    attributes    =    element . getAttributesDescriptors ( rootTag )  ;", "assertEquals (  \" c \"  ,    attributes [  0  ]  . getName (  )  )  ;", "assertTrue ( attributes [  0  ]  . isRequired (  )  )  ;", "assertEquals (  \" a \"  ,    attributes [  1  ]  . getName (  )  )  ;", "assertTrue ( attributes [  1  ]  . isRequired (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeDescriptor2"], "fileName": "com.intellij.codeInsight.XmlInsightTest"}, {"methodBody": ["METHOD_START", "{", "XmlFile   file    =    XmlInsightTest . createFile (  \"  < root >  < a >  <  / a >  < b >  <  / b >  < a >  <  / a >  <  / root >  \"  )  ;", "XmlNSDescriptor   descriptor    =    XmlInsightTest . createDescriptor ( file )  ;", "XmlElementDescriptor   element    =    descriptor . getElementDescriptor ( file . getDocument (  )  . getRootTag (  )  )  ;", "assertNotNull ( element )  ;", "assertEquals (  \" root \"  ,    element . getName (  )  )  ;", "element    =    descriptor . getElementDescriptor ( file . getDocument (  )  . getRootTag (  )  . getSubTags (  )  [  0  ]  )  ;", "assertNotNull ( element )  ;", "assertEquals (  \" a \"  ,    element . getName (  )  )  ;", "element    =    descriptor . getElementDescriptor ( file . getDocument (  )  . getRootTag (  )  . getSubTags (  )  [  1  ]  )  ;", "assertNotNull ( element )  ;", "assertEquals (  \" b \"  ,    element . getName (  )  )  ;", "element    =    descriptor . getElementDescriptor ( file . getDocument (  )  . getRootTag (  )  . getSubTags (  )  [  2  ]  )  ;", "assertNotNull ( element )  ;", "assertEquals (  \" a \"  ,    element . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDocumentDescriptor1"], "fileName": "com.intellij.codeInsight.XmlInsightTest"}, {"methodBody": ["METHOD_START", "{", "XmlFile   file    =    XmlInsightTest . createFile (  \"  < root >  < a >  <  / a >  < b >  <  / b >  < a >  <  / a >  <  / root >  \"  )  ;", "XmlNSDescriptor   descriptor    =    XmlInsightTest . createDescriptor ( file )  ;", "XmlTag   rootTag    =    file . getDocument (  )  . getRootTag (  )  ;", "XmlElementDescriptor   element    =    descriptor . getElementDescriptor ( rootTag )  ;", "XmlElementDescriptor [  ]    elements    =    element . getElementsDescriptors ( rootTag )  ;", "assertEquals (  2  ,    elements . length )  ;", "assertEquals (  \" a \"  ,    elements [  0  ]  . getName (  )  )  ;", "assertEquals (  \" b \"  ,    elements [  1  ]  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testElementDescriptor1"], "fileName": "com.intellij.codeInsight.XmlInsightTest"}, {"methodBody": ["METHOD_START", "{", "XmlFile   file    =    XmlInsightTest . createFile (  \"  < root >  < a >  < b /  >  <  / a >  < a >  < c /  >  <  / a >  <  / root >  \"  )  ;", "XmlNSDescriptor   descriptor    =    XmlInsightTest . createDescriptor ( file )  ;", "XmlTag   rootTag    =    file . getDocument (  )  . getRootTag (  )  ;", "XmlElementDescriptor   element    =    descriptor . getElementDescriptor ( rootTag )  ;", "element    =    element . getElementsDescriptors ( rootTag )  [  0  ]  ;", "XmlElementDescriptor [  ]    elements    =    element . getElementsDescriptors ( rootTag . getSubTags (  )  [  0  ]  )  ;", "assertEquals (  2  ,    elements . length )  ;", "assertEquals (  \" b \"  ,    elements [  0  ]  . getName (  )  )  ;", "assertEquals (  \" c \"  ,    elements [  1  ]  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testElementDescriptor2"], "fileName": "com.intellij.codeInsight.XmlInsightTest"}, {"methodBody": ["METHOD_START", "{", "XmlFile   file    =    XmlInsightTest . createFile (  \"  < root >  < a >  < b /  >  < c >  <  / c >  <  / a >  < a >  < c /  >  <  / a >  <  / root >  \"  )  ;", "XmlNSDescriptor   descriptor    =    XmlInsightTest . createDescriptor ( file )  ;", "XmlTag   rootTag    =    file . getDocument (  )  . getRootTag (  )  ;", "XmlElementDescriptor   element    =    descriptor . getElementDescriptor ( rootTag )  ;", "element    =    element . getElementsDescriptors ( rootTag )  [  0  ]  ;", "XmlElementDescriptor [  ]    elements    =    element . getElementsDescriptors ( rootTag . getSubTags (  )  [  0  ]  )  ;", "assertEquals (  2  ,    elements . length )  ;", "assertEquals (  \" b \"  ,    elements [  0  ]  . getName (  )  )  ;", "assertEquals (  \" c \"  ,    elements [  1  ]  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testElementDescriptor3"], "fileName": "com.intellij.codeInsight.XmlInsightTest"}, {"methodBody": ["METHOD_START", "{", "XmlFile   file    =    XmlInsightTest . createFile (  \"  < root >  < a   attr 2  =  '  '  >  <  / a >  < a   attr 1  =  '  '  >  <  / a >  <  / root >  \"  )  ;", "XmlNSDescriptor   descriptor    =    XmlInsightTest . createDescriptor ( file )  ;", "XmlTag   rootTag    =    file . getDocument (  )  . getRootTag (  )  ;", "XmlElementDescriptor   element    =    descriptor . getElementDescriptor ( rootTag )  ;", "element    =    element . getElementsDescriptors ( rootTag )  [  0  ]  ;", "XmlAttributeDescriptor [  ]    attributes    =    element . getAttributesDescriptors ( rootTag )  ;", "assertEquals (  2  ,    attributes . length )  ;", "assertEquals (  \" attr 1  \"  ,    attributes [  0  ]  . getName (  )  )  ;", "assertEquals (  \" attr 2  \"  ,    attributes [  1  ]  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testElementDescriptor4"], "fileName": "com.intellij.codeInsight.XmlInsightTest"}, {"methodBody": ["METHOD_START", "{", "final   String   text    =    loadFile (  \" pallada . xml \"  )  ;", "XmlLexer   lexer    =    new   XmlLexer (  )  ;", ". doLex ( lexer ,    text )  ;", "final   FilterLexer   filterLexer    =    new   FilterLexer ( new   XmlLexer (  )  ,    new   FilterLexer . SetFilter ( INSTANCE . forLanguage ( XMLLanguage . INSTANCE )  . getWhitespaceTokens (  )  )  )  ;", ". doLex ( filterLexer ,    text )  ;", ". doLex ( lexer ,    text )  ;", ". doLex ( filterLexer ,    text )  ;", ". doLex ( filterLexer ,    text )  ;", "}", "METHOD_END"], "methodName": ["_testLexerPerformance1"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   text    =    loadFile (  \" performance 2  . xml \"  )  ;", "XmlLexer   lexer    =    new   XmlLexer (  )  ;", ". doLex ( lexer ,    text )  ;", "final   FilterLexer   filterLexer    =    new   FilterLexer ( new   XmlLexer (  )  ,    new   FilterLexer . SetFilter ( INSTANCE . forLanguage ( XMLLanguage . INSTANCE )  . getWhitespaceTokens (  )  )  )  ;", ". doLex ( filterLexer ,    text )  ;", ". doLex ( lexer ,    text )  ;", "for    ( int   i    =     0  ;    i    <     2  0  ;    i +  +  )     {", ". doLex ( filterLexer ,    text )  ;", "}", "}", "METHOD_END"], "methodName": ["_testLexerPerformance2"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   text    =    loadFile (  \" pallada . xml \"  )  ;", "long   time    =    System . currentTimeMillis (  )  ;", "final   PsiFile   file    =    createFile (  \" test . xml \"  ,    text )  ;", ". transformAllChildren ( file . getNode (  )  )  ;", "System . out . println (  (  (  \" Old   parsing   took    \"     +     (  ( System . currentTimeMillis (  )  )     -    time )  )     +     \" ms \"  )  )  ;", "int   index    =     0  ;", "while    (  ( index +  +  )     <     1  0  )     {", ". newParsing ( text )  ;", "}", "LeafElement   firstLeaf    =    TreeUtil . findFirstLeaf ( file . getNode (  )  )  ;", "index    =     0  ;", "do    {", "index +  +  ;", "}    while    (  ( firstLeaf    =    TreeUtil . nextLeaf ( firstLeaf ,    null )  )     !  =    null    )  ;", "System . out . println (  (  (  \" For    \"     +    index )     +     \"    lexems \"  )  )  ;", "}", "METHOD_END"], "methodName": ["_testPerformance1"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   text    =    loadFile (  \" performance 2  . xml \"  )  ;", "long   time    =    System . currentTimeMillis (  )  ;", "final   PsiFile   file    =    createFile (  \" test . xml \"  ,    text )  ;", ". transformAllChildren ( file . getNode (  )  )  ;", "System . out . println (  (  (  \" Old   parsing   took    \"     +     (  ( System . currentTimeMillis (  )  )     -    time )  )     +     \" ms \"  )  )  ;", "int   index    =     0  ;", "while    (  ( index +  +  )     <     1  0  )     {", ". newParsing ( text )  ;", "}", "LeafElement   firstLeaf    =    TreeUtil . findFirstLeaf ( file . getNode (  )  )  ;", "index    =     0  ;", "do    {", "index +  +  ;", "}    while    (  ( firstLeaf    =    TreeUtil . nextLeaf ( firstLeaf ,    null )  )     !  =    null    )  ;", "System . out . println (  (  (  \" For    \"     +    index )     +     \"    lexems \"  )  )  ;", "}", "METHOD_END"], "methodName": ["_testPerformance2"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   text    =    loadFile (  \" performance 2  . xml \"  )  ;", "final   PsiFile   file    =    createFile (  \" test . xml \"  ,    text )  ;", ". transformAllChildren ( file . getNode (  )  )  ;", "final   Document   doc    =    PsiDocumentManager . getInstance ( getProject (  )  )  . getDocument ( file )  ;", "System . gc (  )  ;", "System . gc (  )  ;", "WriteCommandAction . writeCommandAction ( getProject (  )  ,    file )  . run (  (  )     -  >     {", "PlatformTestUtil . startPerformanceTest (  \" XML   reparse   using   PsiBuilder \"  ,     2  5  0  0  ,     (  )     -  >     {", "for    ( int   i    =     0  ;    i    <     1  0  ;    i +  +  )     {", "final   long   tm    =    System . currentTimeMillis (  )  ;", "doc . insertString (  0  ,     \"  < additional   root =  \\  \" tag \\  \"  /  >  \"  )  ;", "PsiDocumentManager . getInstance ( getProject (  )  )  . commitAllDocuments (  )  ;", "System . out . println (  (  \" Reparsed   for :     \"     +     (  ( System . currentTimeMillis (  )  )     -    tm )  )  )  ;", "}", "}  )  . useLegacyScaling (  )  . assertTiming (  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["_testReparsePerformance"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "lexer . start ( text )  ;", "long   time    =    System . currentTimeMis (  )  ;", "int   count    =     0  ;", "while    (  ( lexer . getTokenType (  )  )     !  =    null )     {", "lexer . advance (  )  ;", "count +  +  ;", "}", "System . out . println (  (  (  (  \" Plain   lexing   took    \"     +     (  ( System . currentTimeMis (  )  )     -    time )  )     +     \" ms   lexems   count :  \"  )     +    count )  )  ;", "}", "METHOD_END"], "methodName": ["doLex"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "PsiFile   file    =    createFile ( fileName ,    text )  ;", "checkResult (  (  \" test \"     +     ( getName ( false )  )  )  ,    file )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "myLanguage    =    DTDLanguage . INSTANCE ;", "do ( text ,     \" test . dtd \"  )  ;", "}", "METHOD_END"], "methodName": ["doTestDtd"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "myLanguage    =    XMLLanguage . INSTANCE ;", "do ( text ,     \" test . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["doTestXml"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "long   time    =    System . currentTimeMillis (  )  ;", "ASTFactory . lazy ( XmlElementType . XML _ FILE ,    text )  . getFirstChildNode (  )  ;", "System . out . println (  (  (  \" parsed   for    \"     +     (  ( System . currentTimeMillis (  )  )     -    time )  )     +     \" ms \"  )  )  ;", "}", "METHOD_END"], "methodName": ["newParsing"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "return    (  ( CompositeElement )     ( new   DtdParsing ( value ,    xmlElementDecl ,    parseType ,    null )  . parse (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["parseManually"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  (  \"  <  ? xml   version =  \\  \"  1  .  0  \\  \"    encoding =  \\  \" UTF -  8  \\  \"    standalone =  \\  \" yes \\  \"  ?  >  \\ n \"     +     \"  < Root >  < page >  < content >  < locatieblok >  < locatie   label =  \\  \" Locatie \\  \"  > EXAMPLE <  / locatie >  \\ u 2  0  2  9  < straat   label =  \\  \" Straat \\  \"  > EXAMPLE <  / straat >  \\ u 2  0  2  9  < postcode   label =  \\  \" Postcode \\  \"  > EXAMPLE <  / postcode >     < plaats   label =  \\  \" Plaats \\  \"  > EXAMPLE <  / plaats >  \\ u 2  0  2  9  \\ u 2  0  2  9  < telomschrijving   label =  \\  \" Telefoon   omschrijving \\  \"  > T .  <  / telomschrijving >     < telefoon   label =  \\  \" Telefoon \\  \"  > EXAMPLE <  / telefoon >  \\ u 2  0  2  9  \\ u 2  0  2  9  < internet   label =  \\  \" Internet \\  \"  > EXAMPLE <  / internet >  <  / locatieblok >  < naamblok >  < aanhefnaam   label =  \\  \" Aanhef   Naam   Achternaam \\  \"  > Aanhef   Naam   Achternaam <  / aanhefnaam >  \\ u 2  0  2  9  < functie   label =  \\  \" Functie \\  \"  > Functie <  / functie >  \\ u 2  0  2  9  < mobielomschr   label =  \\  \" Mobiel   omschrijving \\  \"  > M .  <  / mobielomschr >  \\ t < mobiel   label =  \\  \" Mobiel \\  \"  > EXAMPLE <  / mobiel >  \\ u 2  0  2  9  < emailomschr   label =  \\  \" Email   omschrijving \\  \"  > E .  <  / emailomschr >  \\ t < email   label =  \\  \" Email \\  \"  > EXAMPLE <  / email >  <  / naamblok >  <  / content >  <  / page >  <  / Root >  \\ n \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAllWhitespaces"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  \"  <  ! ATTLIST   termdef   id   ID    # REQUIRED   name   CDATA    # IMPLIED >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAttlist1"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  \"  <  ! ATTLIST   termdef   type    ( bullets | ordered | glossary )        \\  \" ordered \\  \"  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAttlist2"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  \"  <  ! ATTLIST   termdef      method      CDATA          # FIXED    \\  \" POST \\  \"  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAttlist3"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  \"  <  ! ATTLIST   termdef   default - charset    % CHARSET ;     \\  \" iso -  8  8  5  9  -  1  \\  \"  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAttlist4"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a   att 1  =  \\  ' val 1  \\  '    att 2  =  \\  \" val 2  \\  \"  >  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAttributes1"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  < b   c =  \\  \"  \\  \"     >     <  / b >     <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAttributes2"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  < b   c =  \\  \" a ,    b ,    c \\  \"     >     <  / b >     <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAttributes3"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  < b   c =  \\  \" a      b \\  \"     >     <  / b >     <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAttributes4"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  < b   c =  \\  \" a \\  \" d =  \\  \"  \\  \"     >     <  / b >     <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAttributes5"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  <  !  [ CDATA [  < greeting > Hello ,    world !  <  / greeting >  ]  ]  >  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCdata1"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  <  !  [ CDATA [ someData    <  !  -  -  <  / greeting >  -  -  >    more   data ]  ]  >  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCdata2"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  &  #  1  2  3  ;  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharRef1"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  &  # x 1  2  3  ;  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharRef2"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  &  #  1  2  3  ;  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharRef3"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  &  # xaBcD 1  2  3  ;  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharRef4"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a   attr =  \\  \" abc &  #  1  2  3  ;  \\  \"  /  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharRef5"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a > someChar \\ nData <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharacters1"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  <  : foo /  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testColonName"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  <  !  -  -    declarations   for    < head >     &     < body >     -  -  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testComment1"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  \"  <  ! ELEMENT   data - sources    (  # PCDATA )  >     <  !  -  -    abc    -  -  >     <  ! ATTLIST   data - sources   path   CDATA    # IMPLIED \"  )  ;", "}", "METHOD_END"], "methodName": ["testComment2"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  <  !  -  -  < b >  -  -  >  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testComment3"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  \"  <  !  [    INCLUDE    [     <  ! ELEMENT   data - sources   ANY >     ]  ]  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testConditionalSection1"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  (  \"  <  !  [  % sgml . features ;  [  \\ n \"     +     (  (  (  \"  <  !  [ IGNORE [  \\ n \"     +     \"  <  ! ENTITY    %    dbgenent   SYSTEM    \\  \" http :  /  / www . oasis - open . org / docbook / xml / configerror . txt \\  \"  >  \\ n \"  )     +     \"  ]  ]  >  \\ n \"  )     +     \"  ]  ]  >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testConditionalSection2"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  (  \"  <  ! ENTITY    %    dbhier . module    \\  \" INCLUDE \\  \"  >  \\ n \"     +     (  (  (  (  (  \"  <  !  [     % dbhier . module ;     [  \\ n \"     +     \"  <  ! ENTITY    %    dbhier   PUBLIC \\ n \"  )     +     \"  \\  \"  -  /  / OASIS /  / ELEMENTS   DocBook   Document   Hierarchy   V 4  .  4  /  / EN \\  \"  \\ n \"  )     +     \"  \\  \" dbhierx . mod \\  \"  >  \\ n \"  )     +     \"  % dbhier ;  \\ n \"  )     +     \"  ]  ]  >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testConditionalSection3"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "XmlFile   file    =     (  ( XmlFile )     ( createFile (  \" test . xml \"  ,     \"  < a >           \\ nxxx          \\ n <  / a >  \"  )  )  )  ;", "checkResult (  \" testContent 1  \"  ,    file )  ;", "assertTrue (  \" xxx \"  . equals ( file . getDocument (  )  . getRootTag (  )  . getValue (  )  . getTrimmedText (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testContent1"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "final   Language   language    =    new   XmlParsingTest . MyLanguage (  )  ;", "addExplicitExtension ( LanguageHtmlScriptContentProvider . INSTANCE ,    language ,    new   HtmlScriptContentProvider (  )     {", "@ Override", "public   IElementType   getScriptElementType (  )     {", "return   new   IElementType (  \" MyElementType \"  ,    language )  ;", "}", "@ Nullable", "@ Override", "public   Lexer   getHighlightingLexer (  )     {", "return   null ;", "}", "}  )  ;", "addExplicitExtension ( INSTANCE ,    HTMLLanguage . INSTANCE ,    new   HTMLParserDefinition (  )  )  ;", "addExplicitExtension ( LanguageASTFactory . INSTANCE ,    HTMLLanguage . INSTANCE ,    new   XmlASTFactory (  )  )  ;", "registerExtensionPoint ( EmbeddedTokenTypesProvider . EXTENSION _ POINT _ NAME ,    EmbeddedTokenTypesProvider . class )  ;", "myLanguage    =    HTMLLanguage . INSTANCE ;", "doTest (  \"  < script   type =  \\  \" application / custom \\  \"  > Custom   Script <  / script >  \"  ,     \" test . html \"  )  ;", "}", "METHOD_END"], "methodName": ["testCustomMimeType"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  <  ! DOCTYPE   greeting   SYSTEM    \\  \" hello . dtd \\  \"  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testDoctype1"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  (  \"  <  ! DOCTYPE   toc    \"     +     (  \" PUBLIC    \\  \"  -  /  / Sun   Microsystems   Inc .  /  / DTD   JavaHelp   TOC   Version    1  .  0  /  / EN \\  \"     \"     +     \"  \\  \" http :  /  / com / products / javahelp / toc _  1  _  0  . dtd \\  \"  >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testDoctype2"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  (  \"  <  ! DOCTYPE   greeting    [  \"     +     (  \"  <  ! ELEMENT   greeting    (  # PCDATA )  >  \"     +     \"  ]  >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testDoctype3"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  (  \"  <  ! DOCTYPE   greeting    [  \"     +     (  \"  <  ! ELEMENT   br   EMPTY >  \"     +     \"  ]  >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testDoctype4"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  (  \"  <  ! DOCTYPE   greeting    [  \"     +     (  \"  <  ! ELEMENT   p    (  # PCDATA | a | ul | b | i | em )  *  >  \"     +     \"  ]  >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testDoctype5"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  (  \"  <  ! DOCTYPE   greeting    [  \"     +     (  \"  <  ! ELEMENT    % name . para ;     % content . para ;     >  \"     +     \"  ]  >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testDoctype6"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  (  \"  <  ? xml   version =  '  1  .  0  '    encoding =  ' ISO -  8  8  5  9  -  1  '     ?  >  \"     +     (  (  \"  <  ! DOCTYPE   toc   SYSTEM    ' dtds / ejb - jar _  2  _  0  . dtd '  >  \"     +     \"  < test >  \"  )     +     \"  <  / test >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testDoctype7"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  \"  <  ! ELEMENT   data - sources    (  # PCDATA )  >     <  ! ATTLIST   data - sources   path   CDATA    # IMPLIED >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testDtd1"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "XmlFile   file    =     (  ( XmlFile )     ( createFile (  \" test . xml \"  ,     \"  <  ! DOCTYPE   greeting   SYSTEM    \\  \" hello . dtd \\  \"  >  \"  )  )  )  ;", "XmlDocument   document    =    file . getDocument (  )  ;", "rolog   prolog    =    document . getProlog (  )  ;", "XmlDoctype   doctype    =    prolog . getDoctype (  )  ;", "String   url    =    doctype . getDtdUri (  )  ;", "assertTrue (  \" testDtdUrl 1  \"  ,     \" hello . dtd \"  . equals ( url )  )  ;", "}", "METHOD_END"], "methodName": ["testDtdUrl1"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  <  < a >  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEditing1"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  < b /  >     <     < c /  >  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEditing2"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  < b    < c /  >  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEditing3"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  < b >  <     < c /  >  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEditing4"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  < b >  <  /     < c /  >  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEditing5"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < one >                 < two    , b \\  \"  /  >  <  / one >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEditing6"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < one >                 < two   a , b \\  \"  /  >  <  / one >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEditing7"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < one >                 < two   a   b =  \\  \"  \\  \"  /  >  <  / one >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEditing8"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < one >     < two   a   b =  \\  \"  \\  \"  >    ashdgjkasgd    < aksjhdk >  <  / two >  <  / one >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEditing9"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  \"  <  ! ELEMENT   data - sources   EMPTY >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testElementDecl1"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  \"  <  ! ELEMENT   data - sources   ANY >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testElementDecl2"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  \"  <  ! ELEMENT   xxx   EMPTY >  \\ n <  ! ELEMENT   xxx 2    ANY >  \\ n <  ! ELEMENT    % name . para ;     % content . para ;     >  \\ n <  ! ELEMENT   xxx 3     (  # PCDATA    |    a )     >  \\ n <  ! ELEMENT   xxx 4     >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testElementDeclaration"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testElements1"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a /  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testElements2"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  < b >  < c /  >  < d /  >  <  / b >  < e /  >  < f >  < g /  >  <  / f >  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testElements3"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  (  \"  < project   name =  \\  \" IDEA _ ZKM \\  \"  >  \\ n \"     +     (  (  \"  <  !  -  -    set   global   properties   for   this   build    -  -  >  \\ n \"     +     \"  < property   value =  \\  \" off \\  \"     /  >  \\ n \"  )     +     \"  <  / project >  \\ n \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testElements4"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < ns 1  : a >  < ns 2  : b /  >  <  / ns 1  : a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testElements5"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  (  \"  <  ! DOCTYPE   project    [  \"     +     (  (  (  \"  <  ! ENTITY   targets   SYSTEM    \\  \" file :  .  .  / myproject / targets . xml \\  \"  >  \"     +     \"  ]  >  \"  )     +     \"  < project >  \"  )     +     \"  <  / project >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testElements6"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  <  !  -  -  -  -  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEmptyCommentParsing"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  (  \"  <  ! ELEMENT    >  \\ n <  ! ELEMENT   name    (  ,  )  \\ n <  ! ATTLIST    >     <  ! ELEMENT   zzz    ( aa ?  ,    bb )  +  >     <  ! ELEMENT   xxx ( aaa ,  )  >  \"     +     \"  <  ! ATTLIST    % aaa ;  >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testEmptyElementsInDtd"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  \"  <  ! ENTITY    %    types    \\  \" fileset    |    patternset   mapper \\  \"  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEntityDecl1"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  \"  <  ! ENTITY   types    \\  \" fileset    |    patternset   mapper \\  \"  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEntityDecl2"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  \"  <  ! ENTITY   build - common   SYSTEM    \\  \" common . xml \\  \"  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEntityDecl3"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  \"  <  ! ENTITY   open - hatch   PUBLIC    \\  \"  -  /  / Textuality /  / TEXT   Standard   open - hatch   boilerplate /  / EN \\  \"     \\  \" http :  /  / www . textuality . com / boilerplate / OpenHatch . xml \\  \"  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEntityDecl4"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  \"  <  ! ENTITY   xxx    >     <  ! ENTITY    >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEntityDeclaration"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "String   s    =     \"  |     % pre . qname ;     |     % blockquote . qname ;     |     % address . qname ;  \"  ;", "CompositeElement   element    =     . parseManually ( s ,    XmlElementType . XML _ ELEMENT _ CONTENT _ SPEC ,    XmlEntityDecl . EntityContextType . ELEMENT _ CONTENT _ SPEC )  ;", "checkResult (  \" testEntityDeclaration 2  . txt \"  ,    DebugUtil . treeToString ( element ,    false )  )  ;", "}", "METHOD_END"], "methodName": ["testEntityDeclaration2"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  \"  <  ! ATTLIST    % span . qname ;                    % Common . attrib ;  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEntityInAttlistDeclaration"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a   href =  \\  \"  & n \\  \"  /  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEntityInAttr"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >     & n    <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEntityInContent"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  % types ;  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEntityRef1"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  \"  <  ! ELEMENT   project    ( target    |    taskdef    |     % types ;     |    property    )  *  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEntityRef3"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a   b =  \\  \" aa    & gt ;    bb \\  \"     /  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEntityRef4"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  \"  <  ! ATTLIST   a    % coreattrs ;    version   CDATA    # FIXED    \\  \"  1  .  0  \\  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEntityRef5"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  \"  & common ;  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEntityRef6"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  \"  <  ! ATTLIST   foo   someBoolean    (  % boolean ;  )     \\  \" true \\  \"    someString   CDATA    # IMPLIED    >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEntityRef7"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  >  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGtInTagContent"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  (  \"  <  ! ELEMENT   FIELD   ANY >  \\ n \"     +     (  (  (  \"  <  ! ELEMENT   PUBLIC   ANY >  \\ n \"     +     \"  <  ! ELEMENT   EMPTY   ANY >  \\ n \"  )     +     \"  <  ! ELEMENT   ANY   ANY >  \\ n \"  )     +     \"  <  ! ELEMENT   AND    ( FIELD | PUBLIC | EMPTY | ANY )  *  >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testKeywordsAsName"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "String   value    =     \"  < a >  < b   c =  \\  \"  \\  \"     >     <  / b >     <  / a >  \"  ;", "final   CompositeElement   element    =     . parseManually ( value ,    XmlElementType . XML _ ELEMENT _ DECL ,    XmlEntityDecl . EntityContextType . GENERIC _ XML )  ;", "checkResult (  \" testManualEmptyAttributeParsing . txt \"  ,    DebugUtil . treeToString ( element ,    false )  )  ;", "}", "METHOD_END"], "methodName": ["testManualEmptyAttributeParsing"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml ( loadFile (  \" manyErrors . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testManyErrors"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a   href =  \\  \"  \\  \"  /  >     < b /  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testMultyRoots"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a   href =  \\  \"  \\  \"  /  >     <  / ss >  < b /  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testMultyRootsWithErrorsBetween"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNewParsing1"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a   asd =  \\  \" asd \\  \"  >     < s >     <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNewParsing10"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  <  !  -  -     <  !  -  -     -  -  >     < a   asd =  \\  \" asd \\  \"  >     < s >     <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNewParsing11"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  < a   ajsdg < a >  <  / a >  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNewParsing12"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  (  \"  < a >  < b >  < c >  \\ n \"     +     (  (  \" xxx    \\ n \"     +     \" xxxx \\ n \"  )     +     \"  <  <  / b >  <  / a >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testNewParsing13"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  < a   ajsdg    =     \\  \"  \\  \"  >  <  / a >  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNewParsing14"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  <  ! DOCTYPE   a    [  <  ! ELEMENT   a    ( a )  >  ]  >     < a >  < a   ajsdg    =     \\  \"  \\  \"  >  <  / a >  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNewParsing15"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  (  \"  <  ! DOCTYPE   aaa    [  \"     +     (  (  (  (  (  \"  <  ! ELEMENT   a    # EMPTY >  \"     +     \"  <  ! ATTLIST   a \"  )     +     \"    xx   CDATA    # IMPLIED \"  )     +     \"    yy       # IMPLIED \"  )     +     \"    zz   CDATA    # IMPLIED >  ]  >  \\ n \"  )     +     \"  < a >     < b >     <  / b >     <  / a >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testNewParsing19"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >           <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNewParsing2"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  (  \"  <  ! DOCTYPE   root    [  \\ n \"     +     (  (  (  (  \"  <  !  \\ n \"     +     \"  ]  >  \\ n \"  )     +     \"  < root >  \\ n \"  )     +     \"  \\ n \"  )     +     \"  <  / root >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testNewParsing20"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a          <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNewParsing3"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >     < b >     <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNewParsing4"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >     < b /  >     <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNewParsing5"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  <  ! DOCTYPE   greeting   SYSTEM    \\  \" hello . dtd \\  \"     [  <  ! ELEMENT   greeting   EMPTY >  ]  >     < a >     < b /  >     <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNewParsing6"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >     < b >     < c >     < d >     <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNewParsing7"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a   blah =  \\  \" blah \\  \"  /  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNewParsing8"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a   asd =  \\  \" asd \\  \"  >  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNewParsing9"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  \"  <  ! NOTATION   data - sources   SYSTEM    \\  \" x 3  \\  \"  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNotation1"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  <  ! DOCTYPE   x 3     [  <  ! NOTATION   data - sources   SYSTEM    \\  \" x 3  \\  \"  >  ]  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNotation2"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  <  ? This   is =  \\  \" PI \\  \"  ?  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testProcessingInstruction1"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  <  ? This   is =  \\  \" PI \\  \"  ?  >  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testProcessingInstruction2"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  (  \"  <  ? xml   version =  \\  \"  1  .  0  \\  \"    encoding =  \\  \" UTF -  8  \\  \"  ?  >  \"     +     (  (  (  (  \"  <  ? xml - stylesheet   type =  \\  \" text / xsl \\  \"    href =  \\  \" document . xsl \\  \"  ?  >  \"     +     \"  <  !  -  -     @  (  #  )     $ Id $     -  -  >  \"  )     +     \"  <  ! DOCTYPE   api   SYSTEM    \\  \" document . dtd \\  \"  >  \"  )     +     \"  < api >  \"  )     +     \"  <  / api >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testProcessingInstruction3"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  (  \"  <  ? xml   version =  \\  \"  1  .  0  \\  \"    encoding =  \\  \" ISO -  8  8  5  9  -  1  \\  \"  ?  >  \\ n \"     +     (  (  \"  <  ! ELEMENT   idea - plugin >  \\ n \"     +     \"  <  ! ATTLIST   idea - plugin \\ n \"  )     +     \"             url   CDATA    # IMPLIED >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrologInDtd"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestDtd (  (  \"  <  ! ELEMENT   name    -     -     (  % inline ;  )  *     +  ( A )  >     <  ! ATTLIST    ( A | B )     >  \\ n \"     +     (  \"  <  ! ELEMENT    ( E | E 2  )     -    O    (  % flow ;  )  *                       -  -    table   header   cell ,    table   data   cell -  -  >  \\ n \"     +     \"  <  ! ELEMENT   BODY   O   O    (  % block ;  | SCRIPT )  +     +  ( INS | DEL )     -  -    document   body    -  -  >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSGMLDtd"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  < b >  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testUnbalanced1"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  < b >  < c >  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testUnbalanced2"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  < b >  <  / bb >  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testUnbalanced3"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  < b >  < b /  >  <  / c >  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testUnbalanced4"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "XmlFile   file    =     (  ( XmlFile )     ( createFile (  \" test . xml \"  ,     \"  < a > xxx \"  )  )  )  ;", "checkResult (  \" testUnclosedTag \"  ,    file )  ;", "assertTrue (  \" xxx \"  . equals ( file . getDocument (  )  . getRootTag (  )  . getValue (  )  . getText (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testUnclosedTag"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a \"  )  ;", "}", "METHOD_END"], "methodName": ["testUnclosedTag2"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  <  / foo >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testUnopenedTag1"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  < a >  <    a <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testWhitespaceBeforeName"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  <  ? xml   version =  \\  \"  1  .  0  \\  \"    encoding =  \\  ' cp 1  2  5  1  \\  '     ?  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testXmlDecl"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  <  ? xml   version =  \\  \"  1  .  0  \\  \"    encoding =  \\  ' cp 1  2  5  1  \\  '     ?  >     < foo >  <  / foo >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testXmlDecl2"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestXml (  \"  <  ? xml   version =  \\  \"  1  .  0  \\  \"    encoding =  \\  ' cp 1  2  5  1  \\  '     >     < foo >  <  / foo >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testXmlDecl3"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "for    ( ASTNode   child    =    file . getFirstChildNode (  )  ;    child    !  =    null ;    child    =    child . getTreeNext (  )  )     {", ". transformAllChildren ( child )  ;", "}", "}", "METHOD_END"], "methodName": ["transformAllChildren"], "fileName": "com.intellij.codeInsight.XmlParsingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  (  (  ( getBasePath (  )  )     +     ( getTestName ( false )  )  )     +     \"  . xml \"  )  )  ;", "doHighlighting (  )  ;", "myEditor . getSelectionModel (  )  . setSelection (  0  ,    myEditor . getDocument (  )  . getTextLength (  )  )  ;", "PlatformTestUtil . start (  (  \" indent / unindent    \"     +    time )  ,    time ,     (  )     -  >     {", "EditorActionManager . getInstance (  )  . getActionHandler (  \" EditorIndentSelection \"  )  . execute ( myEditor ,    DataManager . getInstance (  )  . getDataContext (  )  )  ;", "EditorActionManager . getInstance (  )  . getActionHandler (  \" EditorUnindentSelection \"  )  . execute ( myEditor ,    DataManager . getInstance (  )  . getDataContext (  )  )  ;", "}  )  . useLegacyScaling (  )  . assertTiming (  )  ;", "final   int   startOffset    =    myEditor . getCaretModel (  )  . getOffset (  )  ;", "myEditor . getSelectionModel (  )  . setSelection ( startOffset ,    startOffset )  ;", "checkResultByFile (  (  (  ( getBasePath (  )  )     +     ( getTestName ( false )  )  )     +     \"  . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["doIndentTest"], "fileName": "com.intellij.codeInsight.XmlPerformanceTest"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  {     \" UnusedDeclaration \"     }  )", "Class   clazz    =    IdeaUtil . class ;", "}", "METHOD_END"], "methodName": ["testDummy"], "fileName": "com.intellij.codeInsight.XmlPerformanceTest"}, {"methodBody": ["METHOD_START", "{", "doIndentTest (  2  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["testIndentUnindent"], "fileName": "com.intellij.codeInsight.XmlPerformanceTest"}, {"methodBody": ["METHOD_START", "{", "doIndentTest (  2  0  0  1  )  ;", "}", "METHOD_END"], "methodName": ["testIndentUnindent2"], "fileName": "com.intellij.codeInsight.XmlPerformanceTest"}, {"methodBody": ["METHOD_START", "{", "int   i    =    document . getText (  )  . indexOf ( XmlReparseTest . marker )  ;", "if    ( i    =  =     (  -  1  )  )", "return ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >    document . replaceString ( i ,     ( i    +     ( XmlReparseTest . marker . length (  )  )  )  ,     \"  \"  )  )  ;", "removeGarbage ( document )  ;", "}", "METHOD_END"], "methodName": ["removeGarbage"], "fileName": "com.intellij.codeInsight.XmlReparseTest"}, {"methodBody": ["METHOD_START", "{", "String   s 1     =     \"  < a >  \"  ;", "String   s 2     =     \"  <  / a >  \"  ;", "prepareFile ( s 1  ,    s 2  )  ;", "final   String   before    =    DebugUtil . treeToString (  (  ( XmlFileImpl )     ( myDummyFile )  )  . getTreeElement (  )  ,    true )  ;", "insert (  \"  \"  )  ;", "assertEquals (  \" Tree   changed   after   empty   reparse \"  ,    before ,    DebugUtil . treeToString (  (  ( XmlFileImpl )     ( myDummyFile )  )  . getTreeElement (  )  ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["test1"], "fileName": "com.intellij.codeInsight.XmlReparseTest"}, {"methodBody": ["METHOD_START", "{", "String   s 1     =     \"  < one >                 < two    \"  ;", "String   s 2     =     \"  , b \\  \"  /  >  <  / one >  \"  ;", "preFile ( s 1  ,    s 2  )  ;", "insert (  \" a \"  )  ;", "insert (  \" t \"  )  ;", "insert (  \" t \"  )  ;", "insert (  \" r \"  )  ;", "insert (  \"  =  \"  )  ;", "insert (  \"  \\  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSCR5925"], "fileName": "com.intellij.codeInsight.XmlReparseTest"}, {"methodBody": ["METHOD_START", "{", "String   s 1     =     \"  < a >  \"  ;", "String   s 2     =     \"  <  / a >  \"  ;", "preFile ( s 1  ,    s 2  )  ;", "insert (  \" x \"  )  ;", "insert (  \"     \"  )  ;", "insert (  \" xxxxx \"  )  ;", "insert (  \"  \\ n \"  )  ;", "insert (  \" xxxxx \"  )  ;", "}", "METHOD_END"], "methodName": ["testTagData1"], "fileName": "com.intellij.codeInsight.XmlReparseTest"}, {"methodBody": ["METHOD_START", "{", "String   s 1     =     \"  < a >  < b >  \\ nSomeDataHere \"  ;", "String   s 2     =     \"  \\ n <  / b >  <  / a >  \"  ;", "preFile ( s 1  ,    s 2  )  ;", "PsiElement   element 1     =     (  ( XmlFile )     ( myDummyFile )  )  . getDocument (  )  . getRootTag (  )  ;", "insert (  \" x \"  )  ;", "insert (  \"     \"  )  ;", "insert (  \" xxxxx \"  )  ;", "insert (  \"  \\ n \"  )  ;", "insert (  \" xxxxx \"  )  ;", "assertSame ( element 1  ,     (  ( XmlFile )     ( myDummyFile )  )  . getDocument (  )  . getRootTag (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTagData2"], "fileName": "com.intellij.codeInsight.XmlReparseTest"}, {"methodBody": ["METHOD_START", "{", "String   s 1     =     \"  < a >  < b >  \"  ;", "String   s 2     =     \"  <  / b >  <  / a >  \"  ;", "preFile ( s 1  ,    s 2  )  ;", "insert (  \"  <  \"  )  ;", "insert (  \" c \"  )  ;", "insert (  \"  /  \"  )  ;", "insert (  \"  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTagInTag1"], "fileName": "com.intellij.codeInsight.XmlReparseTest"}, {"methodBody": ["METHOD_START", "{", "String   s 1     =     \"  < a >  < b >  \"  ;", "String   s 2     =     \"  <  / b >  <  / a >  \"  ;", "preFile ( s 1  ,    s 2  )  ;", "insert (  \"  <  \"  )  ;", "insert (  \" c \"  )  ;", "insert (  \"  >  \"  )  ;", "insert (  \"  \\ nxxx    \\ nxxxx \\ n \"  )  ;", "insert (  \"  <  \"  )  ;", "insert (  \"  /  \"  )  ;", "insert (  \" c \"  )  ;", "insert (  \"  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTagInTag2"], "fileName": "com.intellij.codeInsight.XmlReparseTest"}, {"methodBody": ["METHOD_START", "{", "String   s 1     =     \"  < a >  < b >  \"  ;", "String   s 2     =     \"  <  / b >  <  / a >  \"  ;", "preFile ( s 1  ,    s 2  )  ;", "insert (  \"  <  \"  )  ;", "insert (  \"  /  \"  )  ;", "insert (  \" b \"  )  ;", "insert (  \"  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTagInTag3"], "fileName": "com.intellij.codeInsight.XmlReparseTest"}, {"methodBody": ["METHOD_START", "{", "setFileType ( XML )  ;", "String   text 2     =     \"  <  / root >  \"  ;", "final   String   text 1     =     \"  < root >  / n \"  ;", "preFile ( text 1  ,    text 2  )  ;", "insert (  \"  <  \"  )  ;", "PsiElement   element    =    myDummyFile . findElementAt (  1  0  )  ;", "assert   element    !  =    null ;", "assertNotNull ( element . getTextRange (  )  )  ;", "}", "METHOD_END"], "methodName": ["testXml"], "fileName": "com.intellij.codeInsight.XmlReparseTest"}, {"methodBody": ["METHOD_START", "{", "PsiFile   file    =    myFixture . addFileToProject (  \" x . xml \"  ,     (  (  (  (  (  (  (  (  (  (  (  (  \"  <  ! DOCTYPE   name    [  \\ n \"     +     \"        <  ! ELEMENT   name    (  \"  )     +     ( XmlReparseTest . marker )  )     +     \" a   b   c   d \"  )     +     ( XmlReparseTest . marker )  )     +     \"  )  >  \\ n \"  )     +     \"        <  ! ELEMENT   name 2     (  \"  )     +     ( XmlReparseTest . marker )  )     +     \"  % entity ;  \"  )     +     ( XmlReparseTest . marker )  )     +     \"  )  >  \\ n \"  )     +     \"  ]  >  \\ n \"  )     +     \"  < name >  <  / name >  \"  )  )  ;", "PsiDocumentManager   documentManager    =    PsiDocumentManager . getInstance ( getProject (  )  )  ;", "Document   document    =    documentManager . getDocument ( file )  ;", "removeGarbage ( document )  ;", "documentManager . commitAllDocuments (  )  ;", "String   myFullDataPath    =     ( getTestDataPath (  )  )     +     \" psi /  \"  ;", "ParsingTestCase . doCheckResult ( myFullDataPath ,    file ,    true ,     \" testXmlDeclDtd \"  ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testXmlDeclDtd"], "fileName": "com.intellij.codeInsight.XmlReparseTest"}, {"methodBody": ["METHOD_START", "{", "prepareFile (  (  \"  < table >  \\ n \"     +     (  (  \"              < tr >  \\ n \"     +     \"  < td >  \\ n \"  )     +     \"  < table   width \"  )  )  ,     (  \"     <  / td >  \\ n \"     +     (  \"              <  / tr >  \\ n \"     +     \"  <  / table >  \"  )  )  )  ;", "insert (  \"  =  \"  )  ;", "}", "METHOD_END"], "methodName": ["testXmlReparseProblem"], "fileName": "com.intellij.codeInsight.XmlReparseTest"}, {"methodBody": ["METHOD_START", "{", "PsiFile   dtdFile    =    createFile (  \" test . xml \"  ,    dtdText )  ;", "return   new   XmlNSDescriptorImpl (  (  ( XmlFile )     ( dtdFile )  )  )  ;", "}", "METHOD_END"], "methodName": ["createDescriptor"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "PsiFile   dtdFile    =    createFile (  \" test . xml \"  ,     (  \"  < xsd : schema   targetNamespace =  \\  \" http :  /  / foo \\  \"    xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"     >  \"     +     (  (  (  (  (  (  (  \"        < xsd : element   name =  \\  \" root \\  \"  >  \"     +     \"              < xsd : complexType >  \"  )     +     \"                    < xsd : sequence   minOccurs =  \\  \"  1  \\  \"    maxOccurs =  \\  \"  1  \\  \"  >  \"  )     +     \"                          < xsd : any   namespace =  \\  \"  #  # other \\  \"    minOccurs =  \\  \"  0  \\  \"    maxOccurs =  \\  \" unbounded \\  \"    processContents =  \\  \" skip \\  \"  /  >  \"  )     +     \"                    <  / xsd : sequence >  \"  )     +     \"              <  / xsd : complexType >  \"  )     +     \"        <  / xsd : element >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "XmlNSDescriptor   NSDescriptor    =    new   XmlNSDescriptorImpl (  (  ( XmlFile )     ( dtdFile )  )  )  ;", "XmlFile   xmlFile    =     (  ( XmlFile )     ( createFile (  \" file . xml \"  ,     (  \"  < foo : root   xmlns : foo =  \\  \" http :  /  / foo \\  \"  >  \"     +     (  \"        < foo : a   xmlns : a =  \\  \" http :  /  / bar \\  \"     /  >  \"     +     \"  <  / foo : root >  \"  )  )  )  )  )  ;", "XmlElementDescriptor   rootDescriptor    =    NSDescriptor . getElementDescriptor ( xmlFile . getDocument (  )  . getRootTag (  )  )  ;", "assertNotNull ( rootDescriptor )  ;", "XmlTag   aTag    =    xmlFile . getDocument (  )  . getRootTag (  )  . findFirstSubTag (  \" foo : a \"  )  ;", "assertNotNull ( aTag )  ;", "}", "METHOD_END"], "methodName": ["testAny2"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   targetNamespace =  \\  \" http :  /  / foo \\  \"    xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"     >  \"     +     (  (  (  (  (  \"        < xsd : element   name =  \\  \" root \\  \"  >  \"     +     \"              < xsd : complexType >  \"  )     +     \"                          < xsd : anyAttribute   namespace =  \\  \"  #  # other \\  \"    processContents =  \\  \" skip \\  \"  /  >  \"  )     +     \"              <  / xsd : complexType >  \"  )     +     \"        <  / xsd : element >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "XmlFile   xmlFile    =     (  ( XmlFile )     ( createFile (  \" file . xml \"  ,     (  \"  < root   xmlns =  \\  \" http :  /  / foo \\  \"    y : a =  \\  \"  1  \\  \"  >  \"     +     \"  <  / root >  \"  )  )  )  )  ;", "final   XmlTag   rootTag    =    xmlFile . getDocument (  )  . getRootTag (  )  ;", "XmlElementDescriptor   rootDescriptor    =    NSDescriptor . getElementDescriptor ( rootTag )  ;", "assertNotNull ( rootDescriptor )  ;", "XmlAttribute   attribute    =    rootTag . getAttribute (  \" y : a \"  ,    XmlUtil . EMPTY _ URI )  ;", "assertNotNull ( attribute )  ;", "XmlAttributeDescriptor   aDescriptor    =    rootDescriptor . getAttributeDescriptor (  \" y : a \"  ,    rootTag )  ;", "assertNotNull ( aDescriptor )  ;", "}", "METHOD_END"], "methodName": ["testAny3"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   targetNamespace =  \\  \" http :  /  / foo \\  \"    xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"     >  \"     +     (  (  (  (  (  \"        < xsd : element   name =  \\  \" root \\  \"  >  \"     +     \"              < xsd : complexType >  \"  )     +     \"                          < xsd : anyAttribute   namespace =  \\  \"  #  # other \\  \"    processContents =  \\  \" skip \\  \"  /  >  \"  )     +     \"              <  / xsd : complexType >  \"  )     +     \"        <  / xsd : element >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "XmlFile   xmlFile    =     (  ( XmlFile )     ( createFile (  \" file . xml \"  ,     (  \"  < root   xmlns =  \\  \" http :  /  / foo \\  \"    a =  \\  \"  1  \\  \"  >  \"     +     \"  <  / root >  \"  )  )  )  )  ;", "final   XmlTag   rootTag    =    xmlFile . getDocument (  )  . getRootTag (  )  ;", "XmlElementDescriptor   rootDescriptor    =    NSDescriptor . getElementDescriptor ( rootTag )  ;", "assertNotNull ( rootDescriptor )  ;", "XmlAttribute   attribute    =    rootTag . getAttribute (  \" a \"  ,    XmlUtil . EMPTY _ URI )  ;", "assertNotNull ( attribute )  ;", "XmlAttributeDescriptor   aDescriptor    =    rootDescriptor . getAttributeDescriptor (  \" a \"  ,    rootTag )  ;", "assertNull ( aDescriptor )  ;", "attribute    =    rootTag . getAttribute (  \" a \"  ,     \" http :  /  / foo \"  )  ;", "assertNull ( attribute )  ;", "attribute    =    rootTag . getAttribute (  \" a \"  ,    XmlUtil . ANT _ URI )  ;", "assertNull ( attribute )  ;", "}", "METHOD_END"], "methodName": ["testAny4"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  (  (  (  \"  < xsd : element   name =  \\  \" purchaseOrder \\  \"    type =  \\  \" PurchaseOrderType \\  \"  /  >  \"     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType \\  \"  >  \"  )     +     \"           < xsd : attribute   name =  \\  \" orderDate \\  \"    type =  \\  \" xsd : date \\  \"  /  >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "final   XmlTag   tag    =    XmlTestUtil . tag (  \" purchaseOrder \"  ,    getProject (  )  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlAttributeDescriptor   attribute    =    elementDescriptor . getAttributeDescriptor (  \" orderDate \"  ,    tag )  ;", "assertTrue (  (  !  ( attribute . isEnumerated (  )  )  )  )  ;", "assertTrue (  (  !  ( attribute . isFixed (  )  )  )  )  ;", "assertTrue (  (  !  ( attribute . isRequired (  )  )  )  )  ;", "assertNull ( attribute . getDefaultValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeDescriptor1"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  (  (  (  \"  < xsd : element   name =  \\  \" purchaseOrder \\  \"    type =  \\  \" PurchaseOrderType \\  \"  /  >  \"     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType \\  \"  >  \"  )     +     \"           < xsd : attribute   name =  \\  \" orderDate \\  \"    type =  \\  \" xsd : date \\  \"    use =  \\  \" required \\  \"    default =  \\  \"     2  0  0  2     \\  \"  /  >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "final   XmlTag   tag    =    XmlTestUtil . tag (  \" purchaseOrder \"  ,    getProject (  )  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlAttributeDescriptor   attribute    =    elementDescriptor . getAttributeDescriptor (  \" orderDate \"  ,    tag )  ;", "assertTrue (  (  !  ( attribute . isEnumerated (  )  )  )  )  ;", "assertTrue (  (  !  ( attribute . isFixed (  )  )  )  )  ;", "assertTrue ( attribute . isRequired (  )  )  ;", "assertEquals (  \"     2  0  0  2     \"  ,    attribute . getDefaultValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeDescriptor2"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  (  (  (  \"  < xsd : element   name =  \\  \" purchaseOrder \\  \"    type =  \\  \" PurchaseOrderType \\  \"  /  >  \"     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType \\  \"  >  \"  )     +     \"           < xsd : attribute   name =  \\  \" orderDate \\  \"    type =  \\  \" xsd : date \\  \"    fixed =  \\  \"  1     0  1     2  0  0  1  \\  \"  /  >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "final   XmlTag   tag    =    XmlTestUtil . tag (  \" purchaseOrder \"  ,    getProject (  )  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlAttributeDescriptor   attribute    =    elementDescriptor . getAttributeDescriptor (  \" orderDate \"  ,    tag )  ;", "assertTrue (  (  !  ( attribute . isEnumerated (  )  )  )  )  ;", "assertTrue ( attribute . isFixed (  )  )  ;", "assertTrue (  (  !  ( attribute . isRequired (  )  )  )  )  ;", "assertEquals (  \"  1     0  1     2  0  0  1  \"  ,    attribute . getDefaultValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeDescriptor3"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  (  (  (  (  \"  < xsd : element   name =  \\  \" purchaseOrder \\  \"    type =  \\  \" PurchaseOrderType \\  \"  /  >  \"     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType \\  \"  >  \"  )     +     \"           < xsd : attribute   ref =  \\  \" orderDate \\  \"    use =  \\  \" required \\  \"  /  >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"           < xsd : attribute   name =  \\  \" orderDate \\  \"    type =  \\  \" xsd : date \\  \"    fixed =  \\  \"  1     0  1     2  0  0  1  \\  \"  /  >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "final   XmlTag   tag    =    XmlTestUtil . tag (  \" purchaseOrder \"  ,    getProject (  )  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlAttributeDescriptor   attribute    =    elementDescriptor . getAttributeDescriptor (  \" orderDate \"  ,    tag )  ;", "assertNotNull ( attribute )  ;", "assertTrue (  (  !  ( attribute . isEnumerated (  )  )  )  )  ;", "assertTrue ( attribute . isFixed (  )  )  ;", "assertTrue ( attribute . isRequired (  )  )  ;", "assertEquals (  \"  1     0  1     2  0  0  1  \"  ,    attribute . getDefaultValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeDescriptor4"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  (  (  (  \"  < xsd : element   name =  \\  \" purchaseOrder \\  \"    type =  \\  \" PurchaseOrderType \\  \"  /  >  \"     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType \\  \"  >  \"  )     +     \"           < xsd : attribute   name =  \\  \" orderDate \\  \"    type =  \\  \" xsd : date \\  \"    use =  \\  \" prohibited \\  \"     /  >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "final   XmlTag   tag    =    XmlTestUtil . tag (  \" purchaseOrder \"  ,    getProject (  )  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlAttributeDescriptor [  ]    attributes    =    elementDescriptor . getAttributesDescriptors ( tag )  ;", "assertEquals (  0  ,    attributes . length )  ;", "}", "METHOD_END"], "methodName": ["testAttributeDescriptorProhibited"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"  < xsd : element   name =  \\  \" purchaseOrder \\  \"    type =  \\  \" PurchaseOrderType \\  \"  /  >  \"     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType \\  \"  >  \"  )     +     \"              < xsd : complexContent >  \"  )     +     \"                 < xsd : restriction   base =  \\  \" PurchaseOrderType 2  \\  \"  >  \"  )     +     \"                       < xsd : attribute   name =  \\  \" orderDate \\  \"    type =  \\  \" xsd : date \\  \"    use =  \\  \" prohibited \\  \"  /  >  \"  )     +     \"                 <  / xsd : restriction >  \"  )     +     \"              <  / xsd : complexContent >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType 2  \\  \"  >  \"  )     +     \"           < xsd : sequence >  \"  )     +     \"                 < xsd : attribute   name =  \\  \" orderDate \\  \"    type =  \\  \" xsd : date \\  \"  /  >  \"  )     +     \"                 < xsd : attribute   name =  \\  \" name \\  \"    type =  \\  \" xsd : string \\  \"  /  >  \"  )     +     \"           <  / xsd : sequence >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "final   XmlTag   tag    =    XmlTestUtil . tag (  \" purchaseOrder \"  ,    getProject (  )  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlAttributeDescriptor [  ]    attributes    =    elementDescriptor . getAttributesDescriptors ( tag )  ;", "assertEquals (  1  ,    attributes . length )  ;", "assertEquals (  \" name \"  ,    attributes [  0  ]  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeDescriptorProhibited2"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  (  \"  < xsd : element   name =  \\  \" purchaseOrder \\  \"    type =  \\  \" PurchaseOrderType \\  \"  /  >  \"     +     \"  < xsd : element   name =  \\  \" comment \\  \"    type =  \\  \" xsd : string \\  \"  /  >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "assertNotNull ( NSDescriptor )  ;", "assertNotNull ( NSDescriptor . getElementDescriptor ( XmlTestUtil . tag (  \" purchaseOrder \"  ,    getProject (  )  )  )  )  ;", "assertNotNull ( NSDescriptor . getElementDescriptor ( XmlTestUtil . tag (  \" comment \"  ,    getProject (  )  )  )  )  ;", "assertNull ( NSDescriptor . getElementDescriptor ( UNKNOWN _ TAG )  )  ;", "}", "METHOD_END"], "methodName": ["testDocumentDescriptor1"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  (  \"  < xsd : element   name =  \\  \" purchaseOrder \\  \"    type =  \\  \" PurchaseOrderType \\  \"  /  >  \"     +     \"  < xsd : element   name =  \\  \" comment \\  \"    type =  \\  \" xsd : string \\  \"  /  >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( XmlTestUtil . tag (  \" purchaseOrder \"  ,    getProject (  )  )  )  ;", "assertEquals (  \" purchaseOrder \"  ,    elementDescriptor . getName (  )  )  ;", "elementDescriptor    =    NSDescriptor . getElementDescriptor ( XmlTestUtil . tag (  \" comment \"  ,    getProject (  )  )  )  ;", "assertEquals (  \" comment \"  ,    elementDescriptor . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testElementDescriptor1"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  (  (  (  (  (  (  (  \"  < xsd : element   name =  \\  \" purchaseOrder \\  \"    type =  \\  \" PurchaseOrderType \\  \"  /  >  \"     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType \\  \"  >  \"  )     +     \"              < xsd : attributeGroup   ref =  \\  \" ddd : bookAttributes \\  \"  /  >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  < xsd : attributeGroup   name =  \\  \" bookAttributes \\  \"  >  \"  )     +     \"           < xsd : attribute   name =  \\  \" isbn \\  \"    type =  \\  \" xs : string \\  \"    use =  \\  \" required \\  \"  /  >  \"  )     +     \"           < xsd : attribute   name =  \\  \" available \\  \"    type =  \\  \" xs : string \\  \"  /  >  \"  )     +     \"  <  / xsd : attributeGroup >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "final   XmlTag   tag    =    XmlTestUtil . tag (  \" purchaseOrder \"  ,    getProject (  )  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlAttributeDescriptor [  ]    attributes    =    elementDescriptor . getAttributesDescriptors ( tag )  ;", "assertEquals (  2  ,    attributes . length )  ;", "assertEquals (  \" isbn \"  ,    attributes [  0  ]  . getName (  )  )  ;", "assertEquals (  \" available \"  ,    attributes [  1  ]  . getName (  )  )  ;", "assertEquals (  \" isbn \"  ,    elementDescriptor . getAttributeDescriptor (  \" isbn \"  ,    tag )  . getName (  )  )  ;", "assertNull ( elementDescriptor . getAttributeDescriptor (  \" xxx \"  ,    tag )  )  ;", "}", "METHOD_END"], "methodName": ["testElementDescriptor10"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"  < xsd : element   name =  \\  \" purchaseOrder \\  \"    type =  \\  \" PurchaseOrderType \\  \"  /  >  \"     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType \\  \"  >  \"  )     +     \"              < xsd : complexContent >  \"  )     +     \"                 < xsd : restriction   base =  \\  \" PurchaseOrderType 2  \\  \"  >  \"  )     +     \"                       < xsd : element   name =  \\  \" shipTo 2  \\  \"    type =  \\  \" USAddress \\  \"  /  >  \"  )     +     \"                       < xsd : element   name =  \\  \" items \\  \"    type =  \\  \" Items \\  \"  /  >  \"  )     +     \"                 <  / xsd : restriction >  \"  )     +     \"              <  / xsd : complexContent >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType 2  \\  \"  >  \"  )     +     \"           < xsd : sequence >  \"  )     +     \"                 < xsd : element   name =  \\  \" shipTo \\  \"    type =  \\  \" USAddress \\  \"  /  >  \"  )     +     \"                 < xsd : element   name =  \\  \" billTo \\  \"    type =  \\  \" USAddress \\  \"  /  >  \"  )     +     \"                 < xsd : element   name =  \\  \" items \\  \"    type =  \\  \" Items \\  \"  /  >  \"  )     +     \"           <  / xsd : sequence >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "XmlTag   tag    =    XmlTestUtil . tag (  \" purchaseOrder \"  ,    getProject (  )  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlElementDescriptor [  ]    elements    =    elementDescriptor . getElementsDescriptors ( tag )  ;", "assertEquals (  4  ,    elements . length )  ;", "assertEquals (  \" shipTo \"  ,    elements [  0  ]  . getName (  )  )  ;", "assertEquals (  \" billTo \"  ,    elements [  1  ]  . getName (  )  )  ;", "assertEquals (  \" shipTo 2  \"  ,    elements [  2  ]  . getName (  )  )  ;", "assertEquals (  \" items \"  ,    elements [  3  ]  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testElementDescriptor11"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"  < xsd : element   name =  \\  \" purchaseOrder \\  \"    type =  \\  \" PurchaseOrderType \\  \"  /  >  \"     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType \\  \"  >  \"  )     +     \"              < xsd : complexContent >  \"  )     +     \"                 < xsd : restriction   base =  \\  \" PurchaseOrderType 2  \\  \"  >  \"  )     +     \"                       < xsd : attribute   name =  \\  \" orderDate 2  \\  \"    type =  \\  \" xsd : date \\  \"  /  >  \"  )     +     \"                       < xsd : attribute   name =  \\  \" name \\  \"    type =  \\  \" xsd : date \\  \"  /  >  \"  )     +     \"                 <  / xsd : restriction >  \"  )     +     \"              <  / xsd : complexContent >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType 2  \\  \"  >  \"  )     +     \"           < xsd : sequence >  \"  )     +     \"                 < xsd : attribute   name =  \\  \" orderDate \\  \"    type =  \\  \" xsd : date \\  \"  /  >  \"  )     +     \"                 < xsd : attribute   name =  \\  \" name \\  \"    type =  \\  \" xsd : string \\  \"  /  >  \"  )     +     \"           <  / xsd : sequence >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "final   XmlTag   tag    =    XmlTestUtil . tag (  \" purchaseOrder \"  ,    getProject (  )  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlAttributeDescriptor [  ]    attributes    =    elementDescriptor . getAttributesDescriptors ( tag )  ;", "assertEquals (  3  ,    attributes . length )  ;", "assertEquals (  \" orderDate \"  ,    attributes [  0  ]  . getName (  )  )  ;", "assertEquals (  \" orderDate 2  \"  ,    attributes [  1  ]  . getName (  )  )  ;", "assertEquals (  \" name \"  ,    attributes [  2  ]  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testElementDescriptor12"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  (  (  (  (  (  (  (  \"  < xsd : element   name =  \\  \" purchaseOrder \\  \"  >  \"     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType \\  \"  >  \"  )     +     \"           < xsd : sequence >  \"  )     +     \"                 < xsd : element   ref =  \\  \" shipTo \\  \"  /  >  \"  )     +     \"           <  / xsd : sequence >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  <  / xsd : element >  \"  )     +     \"  < xsd : element   name =  \\  \" shipTo \\  \"    abstract =  \\  \" true \\  \"  >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "XmlTag   tag    =    XmlTestUtil . tag (  \" purchaseOrder \"  ,    getProject (  )  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "final   XmlElementDescriptor [  ]    elements    =    elementDescriptor . getElementsDescriptors ( tag )  ;", "assertEquals (  0  ,    elements . length )  ;", "}", "METHOD_END"], "methodName": ["testElementDescriptor13"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   targetNamespace =  \\  \" http :  /  / www . deansoft . com / AddressBook \\  \"    xmlns : ab =  \\  \" http :  /  / www . deansoft . com / AddressBook \\  \"    xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"  < xsd : element   name =  \\  \" purchaseOrder \\  \"  >  \"     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType \\  \"  >  \"  )     +     \"           < xsd : sequence >  \"  )     +     \"                 < xsd : element   ref =  \\  \" shipTo \\  \"  /  >  \"  )     +     \"           <  / xsd : sequence >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  <  / xsd : element >  \"  )     +     \"  < xsd : element   name =  \\  \" shipTo \\  \"    abstract =  \\  \" true \\  \"  >  \"  )     +     \"           < xsd : complexType   name =  \\  \" USAddress \\  \"  >  \"  )     +     \"                       < xsd : attribute   name =  \\  \" orderDate \\  \"    type =  \\  \" xsd : date \\  \"  /  >  \"  )     +     \"                       < xsd : element   name =  \\  \" items \\  \"    type =  \\  \" Items \\  \"  /  >  \"  )     +     \"           <  / xsd : complexType >  \"  )     +     \"  <  / xsd : element >  \"  )     +     \"  < xsd : element   name =  \\  \" name \\  \"    substitutionGroup =  \\  \" ab : shipTo \\  \"  /  >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "XmlTag   tag    =    XmlTestUtil . tag (  \" purchaseOrder \"  ,     \" http :  /  / www . deansoft . com / AddressBook \"  ,    getProject (  )  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "final   XmlElementDescriptor [  ]    elements    =    elementDescriptor . getElementsDescriptors ( tag )  ;", "assertEquals (  1  ,    elements . length )  ;", "assertEquals (  \" name \"  ,    elements [  0  ]  . getName (  )  )  ;", "XmlAttributeDescriptor [  ]    attrs    =    elements [  0  ]  . getAttributesDescriptors ( tag )  ;", "assertEquals (  1  ,    attrs . length )  ;", "assertEquals (  \" orderDate \"  ,    attrs [  0  ]  . getName (  )  )  ;", "XmlElementDescriptor [  ]    element 0 Descriptors    =    elements [  0  ]  . getElementsDescriptors ( tag . findFirstSubTag ( elements [  0  ]  . getName (  )  )  )  ;", "assertEquals (  1  ,    element 0 Descriptors . length )  ;", "assertEquals (  \" items \"  ,    element 0 Descriptors [  0  ]  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testElementDescriptor14"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"  < xsd : element   name =  \\  \" purchaseOrder \\  \"    type =  \\  \" PurchaseOrderType \\  \"  /  >  \"     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType \\  \"  >  \"  )     +     \"              < xsd : complexContent >  \"  )     +     \"                 < xsd : extension   base =  \\  \" PurchaseOrderType 2  \\  \"  >  \"  )     +     \"                       < xsd : element   name =  \\  \" shipTo 2  \\  \"    type =  \\  \" USAddress \\  \"  /  >  \"  )     +     \"                 <  / xsd : extension >  \"  )     +     \"              <  / xsd : complexContent >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType 2  \\  \"  >  \"  )     +     \"           < xsd : sequence >  \"  )     +     \"                 < xsd : element   name =  \\  \" shipTo \\  \"    type =  \\  \" USAddress \\  \"  /  >  \"  )     +     \"                 < xsd : element   name =  \\  \" billTo \\  \"    type =  \\  \" USAddress \\  \"  /  >  \"  )     +     \"                 < xsd : element   name =  \\  \" items \\  \"    type =  \\  \" Items \\  \"  /  >  \"  )     +     \"           <  / xsd : sequence >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "XmlTag   tag    =    XmlTestUtil . tag (  \" purchaseOrder \"  ,    getProject (  )  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlElementDescriptor [  ]    elements    =    elementDescriptor . getElementsDescriptors ( tag )  ;", "assertEquals (  4  ,    elements . length )  ;", "assertEquals (  \" shipTo \"  ,    elements [  0  ]  . getName (  )  )  ;", "assertEquals (  \" billTo \"  ,    elements [  1  ]  . getName (  )  )  ;", "assertEquals (  \" items \"  ,    elements [  2  ]  . getName (  )  )  ;", "assertEquals (  \" shipTo 2  \"  ,    elements [  3  ]  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testElementDescriptor15"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  \"  < xsd : element   name =  \\  \" comment \\  \"    type =  \\  \" xsd : string \\  \"  /  >  \"     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "XmlTag   tag    =    XmlTestUtil . tag (  \" comment \"  ,    getProject (  )  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlElementDescriptor [  ]    elements    =    elementDescriptor . getElementsDescriptors ( tag )  ;", "assertEquals (  0  ,    elements . length )  ;", "XmlAttributeDescriptor [  ]    descriptors    =    elementDescriptor . getAttributesDescriptors ( tag )  ;", "assertEquals (  0  ,    descriptors . length )  ;", "assertEquals ( elementDescriptor . getContentType (  )  ,    XmlElementDescriptor . CONTENT _ TYPE _ MIXED )  ;", "}", "METHOD_END"], "methodName": ["testElementDescriptor2"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  (  (  (  (  (  (  (  \"  < xsd : element   name =  \\  \" purchaseOrder \\  \"    type =  \\  \" PurchaseOrderType \\  \"  /  >  \"     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType \\  \"  >  \"  )     +     \"           < xsd : sequence >  \"  )     +     \"                 < xsd : element   name =  \\  \" shipTo \\  \"    type =  \\  \" USAddress \\  \"  /  >  \"  )     +     \"                 < xsd : element   name =  \\  \" billTo \\  \"    type =  \\  \" USAddress \\  \"  /  >  \"  )     +     \"                 < xsd : element   name =  \\  \" items \\  \"    type =  \\  \" Items \\  \"  /  >  \"  )     +     \"           <  / xsd : sequence >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "XmlTag   tag    =    XmlTestUtil . tag (  \" purchaseOrder \"  ,    getProject (  )  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlElementDescriptor [  ]    elements    =    elementDescriptor . getElementsDescriptors ( tag )  ;", "assertEquals (  3  ,    elements . length )  ;", "assertEquals (  \" shipTo \"  ,    elements [  0  ]  . getName (  )  )  ;", "assertEquals (  \" billTo \"  ,    elements [  1  ]  . getName (  )  )  ;", "assertEquals (  \" items \"  ,    elements [  2  ]  . getName (  )  )  ;", "assertEquals (  \" shipTo \"  ,    elementDescriptor . getElementDescriptor ( SHIP _ TO ,    null )  . getName (  )  )  ;", "assertNull ( elementDescriptor . getElementDescriptor ( UNKNOWN _ TAG ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["testElementDescriptor3"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  (  (  (  (  \"  < xsd : element   name =  \\  \" purchaseOrder \\  \"    type =  \\  \" PurchaseOrderType \\  \"  /  >  \"     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType \\  \"  >  \"  )     +     \"           < xsd : attribute   name =  \\  \" orderDate \\  \"    type =  \\  \" xsd : date \\  \"  /  >  \"  )     +     \"           < xsd : attribute   name =  \\  \" name \\  \"    type =  \\  \" xsd : string \\  \"  /  >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "final   XmlTag   tag    =    XmlTestUtil . tag (  \" purchaseOrder \"  ,    getProject (  )  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlAttributeDescriptor [  ]    attributes    =    elementDescriptor . getAttributesDescriptors ( tag )  ;", "assertEquals (  2  ,    attributes . length )  ;", "assertEquals (  \" orderDate \"  ,    attributes [  0  ]  . getName (  )  )  ;", "assertEquals (  \" name \"  ,    attributes [  1  ]  . getName (  )  )  ;", "assertEquals (  \" name \"  ,    elementDescriptor . getAttributeDescriptor (  \" name \"  ,    tag )  . getName (  )  )  ;", "assertNull ( elementDescriptor . getAttributeDescriptor (  \" xxx \"  ,    tag )  )  ;", "}", "METHOD_END"], "methodName": ["testElementDescriptor4"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"  < xsd : element   name =  \\  \" purchaseOrder \\  \"    type =  \\  \" PurchaseOrderType \\  \"  /  >  \"     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType \\  \"  >  \"  )     +     \"           < xsd : sequence >  \"  )     +     \"                 < xsd : element   name =  \\  \" shipTo \\  \"    type =  \\  \" USAddress \\  \"  /  >  \"  )     +     \"                 < xsd : element   name =  \\  \" billTo \\  \"    type =  \\  \" USAddress \\  \"  /  >  \"  )     +     \"                 < xsd : element   name =  \\  \" items \\  \"    type =  \\  \" Items \\  \"  /  >  \"  )     +     \"           <  / xsd : sequence >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  < xsd : complexType   name =  \\  \" USAddress \\  \"  >  \"  )     +     \"        < xsd : sequence >  \"  )     +     \"              < xsd : element   name =  \\  \" name \\  \"    type =  \\  \" xsd : string \\  \"  /  >  \"  )     +     \"              < xsd : element   name =  \\  \" street \\  \"    type =  \\  \" xsd : string \\  \"  /  >  \"  )     +     \"              < xsd : element   name =  \\  \" city \\  \"    type =  \\  \" xsd : string \\  \"  /  >  \"  )     +     \"              < xsd : element   name =  \\  \" state \\  \"    type =  \\  \" xsd : string \\  \"  /  >  \"  )     +     \"              < xsd : element   name =  \\  \" zip \\  \"    type =  \\  \" xsd : decimal \\  \"  /  >  \"  )     +     \"        <  / xsd : sequence >  \"  )     +     \"        < xsd : attribute   name =  \\  \" country \\  \"    type =  \\  \" xsd : NMTOKEN \\  \"    fixed =  \\  \" US \\  \"  /  >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "XmlTag   tag    =    XmlTestUtil . tag (  \" purchaseOrder \"  ,    getProject (  )  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  . getElementDescriptor ( SHIP _ TO ,    null )  ;", "XmlElementDescriptor [  ]    elements    =    elementDescriptor . getElementsDescriptors ( tag )  ;", "assertEquals (  5  ,    elements . length )  ;", "assertEquals (  \" name \"  ,    elements [  0  ]  . getName (  )  )  ;", "assertEquals (  \" street \"  ,    elements [  1  ]  . getName (  )  )  ;", "assertEquals (  \" city \"  ,    elements [  2  ]  . getName (  )  )  ;", "assertEquals (  \" state \"  ,    elements [  3  ]  . getName (  )  )  ;", "assertEquals (  \" zip \"  ,    elements [  4  ]  . getName (  )  )  ;", "final   XmlTag   context    =    tag . findFirstSubTag ( elements [  2  ]  . getName (  )  )  ;", "assertEquals (  0  ,    elements [  2  ]  . getElementsDescriptors ( context )  . length )  ;", "XmlAttributeDescriptor [  ]    attributes    =    elementDescriptor . getAttributesDescriptors ( context )  ;", "assertEquals (  1  ,    attributes . length )  ;", "assertEquals (  \" country \"  ,    attributes [  0  ]  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testElementDescriptor5"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"  < xsd : element   name =  \\  \" purchaseOrder \\  \"    type =  \\  \" PurchaseOrderType \\  \"  /  >  \"     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType \\  \"  >  \"  )     +     \"           < xsd : sequence >  \"  )     +     \"                 < xsd : element   name =  \\  \" shipTo \\  \"  >  \"  )     +     \"                       < xsd : complexType   name =  \\  \" USAddress \\  \"  >  \"  )     +     \"                             < xsd : sequence >  \"  )     +     \"                                   < xsd : element   name =  \\  \" name \\  \"    type =  \\  \" xsd : string \\  \"  /  >  \"  )     +     \"                                   < xsd : element   name =  \\  \" street \\  \"    type =  \\  \" xsd : string \\  \"  /  >  \"  )     +     \"                                   < xsd : element   name =  \\  \" city \\  \"    type =  \\  \" xsd : string \\  \"  /  >  \"  )     +     \"                                   < xsd : element   name =  \\  \" state \\  \"    type =  \\  \" xsd : string \\  \"  /  >  \"  )     +     \"                                   < xsd : element   name =  \\  \" zip \\  \"    type =  \\  \" xsd : decimal \\  \"  /  >  \"  )     +     \"                             <  / xsd : sequence >  \"  )     +     \"                             < xsd : attribute   name =  \\  \" country \\  \"    type =  \\  \" xsd : NMTOKEN \\  \"    fixed =  \\  \" US \\  \"  /  >  \"  )     +     \"                       <  / xsd : complexType >  \"  )     +     \"                 <  / xsd : element >  \"  )     +     \"           <  / xsd : sequence >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "XmlTag   tag    =    XmlTestUtil . tag (  \" purchaseOrder \"  ,    getProject (  )  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  . getElementDescriptor ( SHIP _ TO ,    null )  ;", "XmlElementDescriptor [  ]    elements    =    elementDescriptor . getElementsDescriptors ( tag )  ;", "assertEquals (  5  ,    elements . length )  ;", "assertEquals (  \" name \"  ,    elements [  0  ]  . getName (  )  )  ;", "assertEquals (  \" street \"  ,    elements [  1  ]  . getName (  )  )  ;", "assertEquals (  \" city \"  ,    elements [  2  ]  . getName (  )  )  ;", "assertEquals (  \" state \"  ,    elements [  3  ]  . getName (  )  )  ;", "assertEquals (  \" zip \"  ,    elements [  4  ]  . getName (  )  )  ;", "final   XmlTag   context    =    tag . findFirstSubTag ( elements [  2  ]  . getName (  )  )  ;", "assertEquals (  0  ,    elements [  2  ]  . getElementsDescriptors ( context )  . length )  ;", "XmlAttributeDescriptor [  ]    attributes    =    elementDescriptor . getAttributesDescriptors ( context )  ;", "assertEquals (  1  ,    attributes . length )  ;", "assertEquals (  \" country \"  ,    attributes [  0  ]  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testElementDescriptor6"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"  < xsd : element   name =  \\  \" purchaseOrder \\  \"  >  \"     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType \\  \"  >  \"  )     +     \"           < xsd : sequence >  \"  )     +     \"                 < xsd : element   name =  \\  \" shipTo \\  \"  >  \"  )     +     \"                       < xsd : complexType   name =  \\  \" USAddress \\  \"  >  \"  )     +     \"                             < xsd : sequence >  \"  )     +     \"                                   < xsd : element   name =  \\  \" name \\  \"    type =  \\  \" xsd : string \\  \"  /  >  \"  )     +     \"                                   < xsd : element   name =  \\  \" street \\  \"    type =  \\  \" xsd : string \\  \"  /  >  \"  )     +     \"                                   < xsd : element   name =  \\  \" city \\  \"    type =  \\  \" xsd : string \\  \"  /  >  \"  )     +     \"                                   < xsd : element   name =  \\  \" state \\  \"    type =  \\  \" xsd : string \\  \"  /  >  \"  )     +     \"                                   < xsd : element   name =  \\  \" zip \\  \"    type =  \\  \" xsd : decimal \\  \"  /  >  \"  )     +     \"                             <  / xsd : sequence >  \"  )     +     \"                             < xsd : attribute   name =  \\  \" country \\  \"    type =  \\  \" xsd : NMTOKEN \\  \"    fixed =  \\  \" US \\  \"  /  >  \"  )     +     \"                       <  / xsd : complexType >  \"  )     +     \"                 <  / xsd : element >  \"  )     +     \"           <  / xsd : sequence >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  <  / xsd : element >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "XmlTag   tag    =    XmlTestUtil . tag (  \" purchaseOrder \"  ,    getProject (  )  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlAttributeDescriptor [  ]    attributes    =    elementDescriptor . getAttributesDescriptors ( tag )  ;", "assertEquals (  0  ,    attributes . length )  ;", "XmlElementDescriptor [  ]    elements    =    elementDescriptor . getElementsDescriptors ( tag )  ;", "assertEquals (  1  ,    elements . length )  ;", "assertEquals (  \" shipTo \"  ,    elements [  0  ]  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testElementDescriptor7"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  (  (  (  (  (  (  \"  < xsd : element   name =  \\  \" purchaseOrder \\  \"    type =  \\  \" PurchaseOrderType \\  \"  /  >  \"     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType \\  \"  >  \"  )     +     \"           < xsd : sequence >  \"  )     +     \"                 < xsd : element   ref =  \\  \" items \\  \"  /  >  \"  )     +     \"           <  / xsd : sequence >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  < xsd : element   name =  \\  \" items \\  \"    type =  \\  \" xsd : string \\  \"  /  >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "XmlTag   tag    =    XmlTestUtil . tag (  \" purchaseOrder \"  ,    getProject (  )  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlElementDescriptor [  ]    elements    =    elementDescriptor . getElementsDescriptors ( tag )  ;", "assertEquals (  1  ,    elements . length )  ;", "assertEquals (  \" items \"  ,    elements [  0  ]  . getName (  )  )  ;", "assertEquals (  \" items \"  ,    elementDescriptor . getElementDescriptor ( XmlTestUtil . tag (  \" items \"  ,    getProject (  )  )  ,    null )  . getName (  )  )  ;", "assertNull ( elementDescriptor . getElementDescriptor ( UNKNOWN _ TAG ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["testElementDescriptor8"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  (  (  (  (  (  (  (  (  (  (  (  \"  < xsd : element   name =  \\  \" purchaseOrder \\  \"    type =  \\  \" PurchaseOrderType \\  \"  /  >  \"     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType \\  \"  >  \"  )     +     \"           < xsd : sequence >  \"  )     +     \"                 < xsd : group   ref =  \\  \" ddd : mainBookElements \\  \"  /  >  \"  )     +     \"           <  / xsd : sequence >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  < xsd : group   name =  \\  \" mainBookElements \\  \"  >  \"  )     +     \"           < xsd : sequence >  \"  )     +     \"                       < xsd : element   name =  \\  \" title \\  \"    type =  \\  \" nameType \\  \"  /  >  \"  )     +     \"                       < xsd : element   name =  \\  \" author \\  \"    type =  \\  \" nameType \\  \"  /  >  \"  )     +     \"           <  / xsd : sequence >  \"  )     +     \"  <  / xsd : group >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "XmlTag   tag    =    XmlTestUtil . tag (  \" purchaseOrder \"  ,    getProject (  )  )  ;", "XmlElementDescriptor   elementDescriptor    =    NSDescriptor . getElementDescriptor ( tag )  ;", "XmlElementDescriptor [  ]    elements    =    elementDescriptor . getElementsDescriptors ( tag )  ;", "assertEquals (  2  ,    elements . length )  ;", "assertEquals (  \" title \"  ,    elements [  0  ]  . getName (  )  )  ;", "assertEquals (  \" author \"  ,    elements [  1  ]  . getName (  )  )  ;", "assertEquals (  \" title \"  ,    elementDescriptor . getElementDescriptor ( XmlTestUtil . tag (  \" title \"  ,    getProject (  )  )  ,    null )  . getName (  )  )  ;", "assertNull ( elementDescriptor . getElementDescriptor ( UNKNOWN _ TAG ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["testElementDescriptor9"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xs : schema   xmlns : xs =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  (  \"  < xs : element   name =  \\  \" purchaseOrder \\  \"    type =  \\  \" PurchaseOrderType \\  \"  /  >  \"     +     \"  < xs : element   name =  \\  \" comment \\  \"    type =  \\  \" xs : string \\  \"  /  >  \"  )     +     \"  <  / xs : schema >  \"  )  )  )  ;", "assertNotNull ( NSDescriptor )  ;", "assertNotNull ( NSDescriptor . getElementDescriptor ( XmlTestUtil . tag (  \" purchaseOrder \"  ,    getProject (  )  )  )  )  ;", "assertNotNull ( NSDescriptor . getElementDescriptor ( XmlTestUtil . tag (  \" comment \"  ,    getProject (  )  )  )  )  ;", "assertNull ( NSDescriptor . getElementDescriptor ( UNKNOWN _ TAG )  )  ;", "}", "METHOD_END"], "methodName": ["testNamespace1"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xsd : schema   targetNamespace =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"    xmlns : xsd =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"     >  \"     +     (  (  (  (  (  (  (  \"  < xsd : element   name =  \\  \" purchaseOrder \\  \"    type =  \\  \" PurchaseOrderType \\  \"  /  >  \"     +     \"  < xsd : complexType   name =  \\  \" PurchaseOrderType \\  \"  >  \"  )     +     \"           < xsd : sequence >  \"  )     +     \"                 < xsd : element   ref =  \\  \" xsd : items \\  \"  /  >  \"  )     +     \"           <  / xsd : sequence >  \"  )     +     \"  <  / xsd : complexType >  \"  )     +     \"  < xsd : element   name =  \\  \" items \\  \"    type =  \\  \" xsd : string \\  \"  /  >  \"  )     +     \"  <  / xsd : schema >  \"  )  )  )  ;", "XmlTag   tag    =    XmlTestUtil . tag (  \" purchaseOrder \"  ,     \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \"  ,    getProject (  )  )  ;", "XmlElementDescriptorImpl   elementDescriptor    =     (  ( XmlElementDescriptorImpl )     ( NSDescriptor . getElementDescriptor ( tag )  )  )  ;", "XmlElementDescriptor [  ]    elements    =    elementDescriptor . getElementsDescriptors ( tag )  ;", "assertEquals (  1  ,    elements . length )  ;", "assertEquals (  \" items \"  ,    elements [  0  ]  . getName (  )  )  ;", "assertEquals (  \" items \"  ,    elementDescriptor . getElementDescriptor (  \" items \"  )  . getName (  )  )  ;", "assertNull ( elementDescriptor . getElementDescriptor (  \" xxx \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testNamespace2"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   NSDescriptor    =    XmlSchemaTest . createDescriptor (  (  \"  < xs : schema   xmlns =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"    xmlns : xs =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \"     +     (  (  \"  < xs : element   name =  \\  \" purchaseOrder \\  \"    type =  \\  \" PurchaseOrderType \\  \"  /  >  \"     +     \"  < element   name =  \\  \" comment \\  \"    type =  \\  \" xs : string \\  \"  /  >  \"  )     +     \"  <  / xs : schema >  \"  )  )  )  ;", "assertNotNull ( NSDescriptor )  ;", "assertNotNull ( NSDescriptor . getElementDescriptor ( XmlTestUtil . tag (  \" purchaseOrder \"  ,     \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \"  ,    getProject (  )  )  )  )  ;", "assertNotNull ( NSDescriptor . getElementDescriptor ( XmlTestUtil . tag (  \" comment \"  ,     \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \"  ,    getProject (  )  )  )  )  ;", "assertNull ( NSDescriptor . getElementDescriptor ( UNKNOWN _ TAG )  )  ;", "}", "METHOD_END"], "methodName": ["testNamespace3"], "fileName": "com.intellij.codeInsight.XmlSchemaTest"}, {"methodBody": ["METHOD_START", "{", "return   XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  (  (  \"  < foo >  \"     +    value )     +     \"  <  / foo >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["createTag"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =     (  ( XmlFile )     ( PsiFileFactory . getInstance ( getProject (  )  )  . createFileFromText ( name ,    XML ,    text ,    LocalTimeCounter . currentTime (  )  ,    true )  )  )  ;", "return   file . getDocument (  )  . getRootTag (  )  ;", "}", "METHOD_END"], "methodName": ["createTag"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "XmlTagTest . doCoordinateMappingConsistentFromEscapedText ( XmlTagTest . toEscapedText ( text )  )  ;", "}", "METHOD_END"], "methodName": ["doCoordinateMappingConsistentFromDisplayText"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "String   text    =    XmlTagTest . toDisplay ( tagText )  ;", "XmlTag   tag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  (  (  \"  < a >  \"     +    tagText )     +     \"  <  / a >  \"  )  )  ;", "final   PsiElement [  ]    children    =    tag . getValue (  )  . getTextElements (  )  ;", "assertEquals (  1  ,    children . length )  ;", "final   XmlText   xmlText    =     (  ( XmlText )     ( children [  0  ]  )  )  ;", "assertEquals ( tagText ,    xmlText . getText (  )  )  ;", "for    ( int   i    =     0  ;    i    <  =     ( text . length (  )  )  ;    i +  +  )     {", "final   int   physical    =    xmlText . displayToPhysical ( i )  ;", "final   int   display    =    xmlText . physicalToDisplay ( physical )  ;", "assertEquals (  (  (  (  \" Coords   mapping   failed   for :     '  \"     +    tagText )     +     \"  '     -     \"  )     +    physical )  ,    display ,    i )  ;", "}", "assertEquals (  (  (  \" Coords   mapping   failed   for :     '  \"     +    tagText )     +     \"  '  \"  )  ,     0  ,    xmlText . physicalToDisplay (  0  )  )  ;", "assertEquals ( tagText . length (  )  ,    xmlText . displayToPhysical ( text . length (  )  )  )  ;", "assertEquals ( text . length (  )  ,    xmlText . physicalToDisplay ( tagText . length (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["doCoordinateMappingConsistentFromEscapedText"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >     {", "String   tagText    =    toEscapedText ( text )  ;", "for    ( int   i    =     0  ;    i    <     ( text . length (  )  )  ;    i +  +  )     {", "for    ( int   j    =    i ;    j    <     ( text . length (  )  )  ;    j +  +  )     {", "tag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createXHTMLTagFromText (  (  (  \"  < a >  \"     +    tagText )     +     \"  <  / a >  \"  )  )  ;", "final   PsiElement [  ]    children    =    tag . getValue (  )  . getTextElements (  )  ;", "assertEquals (  1  ,    children . length )  ;", "final   XmlText   xmlText    =     (  ( XmlText )     ( children [  0  ]  )  )  ;", "assertEquals ( tagText ,    xmlText . getText (  )  )  ;", "xmlText . removeText ( i ,    j )  ;", "final   StringBuilder   expectedDisplay    =    new   StringBuilder ( text . replace (  '  _  '  ,     '     '  )  )  ;", "expectedDisplay . delete ( i ,    j )  ;", "assertEquals ( expectedDisplay . toString (  )  ,    xmlText . getValue (  )  )  ;", "final   String   expectedText    =    toEscapedText ( expectedDisplay . toString (  )  )  ;", "assertEquals ( expectedText ,    xmlText . getText (  )  )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["doTestEscapedDeletion"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "String   tagText    =    XmlTagTest . toEscapedText ( text )  ;", "for    ( int   i    =     0  ;    i    <  =     ( text . length (  )  )  ;    i +  +  )     {", "XmlTag   tag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createXHTMLTagFromText (  (  (  \"  < a >  \"     +    tagText )     +     \"  <  / a >  \"  )  )  ;", "final   PsiElement [  ]    children    =    tag . getValue (  )  . getTextElements (  )  ;", "assertEquals (  1  ,    children . length )  ;", "final   XmlText   xmlText    =     (  ( XmlText )     ( children [  0  ]  )  )  ;", "assertEquals ( tagText ,    xmlText . getText (  )  )  ;", "xmlText . insertText ( textToInsert ,    i )  ;", "final   StringBuilder   expectedDisplay    =    new   StringBuilder ( text . replace (  '  _  '  ,     '  \\ u 0  0 a 0  '  )  )  ;", "expectedDisplay . insert ( i ,    textToInsert )  ;", "assertEquals ( expectedDisplay . toString (  )  ,    xmlText . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doTestEscapedInsertion"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >     {", "for    ( int   i    =     0  ;    i    <     ( text . length (  )  )  ;    i +  +  )     {", "for    ( int   j    =    i ;    j    <     ( text . length (  )  )  ;    j +  +  )     {", "tag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createXHTMLTagFromText (  (  (  \"  < a >  \"     +    text )     +     \"  <  / a >  \"  )  )  ;", "final   PsiElement [  ]    children    =    tag . getValue (  )  . getTextElements (  )  ;", "assertEquals (  1  ,    children . length )  ;", "final   XmlText   xmlText    =     (  ( XmlText )     ( children [  0  ]  )  )  ;", "assertEquals ( text ,    xmlText . getText (  )  )  ;", "xmlText . removeText ( i ,    j )  ;", "final   StringBuilder   expected    =    new   StringBuilder ( text )  ;", "expected . delete ( i ,    j )  ;", "assertEquals ( expected . toString (  )  ,    xmlText . getValue (  )  )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["doTestSimpleDeletion"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >     {", "for    ( int   i    =     0  ;    i    <  =     ( text . length (  )  )  ;    i +  +  )     {", "tag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createXHTMLTagFromText (  (  (  \"  < a >  \"     +    text )     +     \"  <  / a >  \"  )  )  ;", "final   PsiElement [  ]    children    =    tag . getValue (  )  . getTextElements (  )  ;", "assertEquals (  1  ,    children . length )  ;", "final   XmlText   xmlText    =     (  ( XmlText )     ( children [  0  ]  )  )  ;", "assertEquals ( text ,    xmlText . getValue (  )  )  ;", "xmlText . insertText ( textToInsert ,    i )  ;", "final   StringBuilder   expected    =    new   StringBuilder ( text )  ;", "expected . insert ( i ,    textToInsert )  ;", "assertEquals ( expected . toString (  )  ,    xmlText . getValue (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["doTestSimpleInsertion"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "XmlTagTest . doTestEscapedDeletion (  \"  &  \"  )  ;", "XmlTagTest . doTestEscapedDeletion (  \"  &  &  \"  )  ;", "XmlTagTest . doTestEscapedDeletion (  \"     &  &  \"  )  ;", "XmlTagTest . doTestEscapedDeletion (  \"     &     &  \"  )  ;", "XmlTagTest . doTestEscapedDeletion (  \"     &     &     \"  )  ;", "XmlTagTest . doTestEscapedDeletion (  \"     &  &     \"  )  ;", "XmlTagTest . doTestEscapedDeletion (  \"  &  &     \"  )  ;", "XmlTagTest . doTestEscapedDeletion (  \"  &     \"  )  ;", "XmlTagTest . doTestEscapedDeletion (  \"     \"  )  ;", "XmlTagTest . doTestEscapedDeletion (  \"  & abc \"  )  ;", "XmlTagTest . doTestEscapedDeletion (  \" a & bc \"  )  ;", "XmlTagTest . doTestEscapedDeletion (  \" ab & c \"  )  ;", "XmlTagTest . doTestEscapedDeletion (  \" abc &  \"  )  ;", "XmlTagTest . doTestEscapedDeletion (  \"     & abc \"  )  ;", "XmlTagTest . doTestEscapedDeletion (  \" a    & bc \"  )  ;", "XmlTagTest . doTestEscapedDeletion (  \" ab    & c \"  )  ;", "XmlTagTest . doTestEscapedDeletion (  \" abc    &  \"  )  ;", "XmlTagTest . doTestEscapedDeletion (  \"  &    abc \"  )  ;", "XmlTagTest . doTestEscapedDeletion (  \" a &    bc \"  )  ;", "XmlTagTest . doTestEscapedDeletion (  \" ab &    c \"  )  ;", "XmlTagTest . doTestEscapedDeletion (  \" abc &     \"  )  ;", "}", "METHOD_END"], "methodName": ["notestEscapedDeletion"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "XmlFile   file    =     (  ( XmlFile )     ( createFile (  \" file . xml \"  ,     \"  < a > x   y <  / a >  \"  )  )  )  ;", "tag    =    file . getDocument (  )  . getRootTag (  )  ;", "final   XmlText   xmlText    =    tag . getValue (  )  . getTextElements (  )  [  0  ]  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >    CommandProcessor . getInstance (  )  . executeCommand ( getProject (  )  ,     (  )     -  >     {", "try    {", "xmlText . insertText (  \" z \"  ,     1  )  ;", "}    catch    (    e )     {", "throw   new    < e > RuntimeException (  )  ;", "}", "}  ,     \"  \"  ,    null ,    UndoConfirmationPolicy . DO _ NOT _ REQUEST _ CONFIRMATION )  )  ;", "assertEquals (  \"  < a > xz   y <  / a >  \"  ,    tag . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["test2"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   root    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < a >  1  < b >  2  3  4  <  / b >  4  5  6  <  / a >  \"  )  ;", "final   XmlTag   tag    =    root . findFirstSubTag (  \" b \"  )  ;", "final   XmlTagChild   child    =    tag . getValue (  )  . getChildren (  )  [  0  ]  ;", "assertTrue (  (  ( child   instanceof   XmlText )     &  &     ( child . getText (  )  . equals (  \"  2  3  4  \"  )  )  )  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "assertNotNull ( tag . getParent (  )  . addBefore ( child ,    tag )  )  ;", "tag . delete (  )  ;", "}  )  ;", "assertEquals (  1  ,    root . getValue (  )  . getChildren (  )  . length )  ;", "assertEquals (  \"  1  2  3  4  4  5  6  \"  ,    root . getValue (  )  . getChildren (  )  [  0  ]  . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["test3"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   root    =    XmlElementFactory . getInstance ( getProject (  )  )  . createXHTMLTagFromText (  \"  < a >  1  < b >  2  3  4  <  / b >  4  5  6  <  / a >  \"  )  ;", "final   XmlTag   tag    =    root . findFirstSubTag (  \" b \"  )  ;", "final   XmlTagChild   child    =    tag . getValue (  )  . getChildren (  )  [  0  ]  ;", "assertTrue (  (  ( child   instanceof   XmlText )     &  &     ( child . getText (  )  . equals (  \"  2  3  4  \"  )  )  )  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "assertNotNull ( tag . getParent (  )  . addBefore ( child ,    tag )  )  ;", "tag . delete (  )  ;", "}  )  ;", "assertEquals (  1  ,    root . getValue (  )  . getChildren (  )  . length )  ;", "assertEquals (  \"  1  2  3  4  4  5  6  \"  ,    root . getValue (  )  . getChildren (  )  [  0  ]  . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["test3XHTML"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlElementFactory   elementFactory    =    XmlElementFactory . getInstance ( getProject (  )  )  ;", "final      aTag    =    elementFactory . createTagFromText (  \"  < a >  1  <  / a >  \"  )  ;", "final   XmlText   displayText    =    elementFactory . createDisplayText (  \"  2  \"  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "final   PsiElement   psiElement    =    aTag . addAfter ( displayText ,    aTag . getValue (  )  . getChildren (  )  [  0  ]  )  ;", "assertEquals ( psiElement . getContainingFile (  )  ,    aTag . getContainingFile (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testAddText"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tagFromText    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < a /  >  \"  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >    tagFromText . getValue (  )  . setText (  \"  <  \"  )  )  ;", "assertEquals (  \"  <  \"  ,    tagFromText . getValue (  )  . getTextElements (  )  [  0  ]  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBrace"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "XmlTag   tag    =    XmlTagTest . createTag (  \" foo <  !  [ CDATA [  <  >  &  \\  '  \\  \"  ]  ]  > bar \"  )  ;", "assertEquals (  \" foo <  >  &  \\  '  \\  \" bar \"  ,    tag . getValue (  )  . getTrimmedText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCDATA"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "String [  ]    names    =    XmlTagUtil . getCharacterEntityNames (  )  ;", "for    ( String   name    :    names )     {", "XmlTag   tag    =     . createTag (  (  (  \" foo &  \"     +    name )     +     \"  ; bar \"  )  )  ;", "assertEquals (  (  (  \" foo \"     +     ( XmlTagUtil . getCharacterByEntityName ( name )  )  )     +     \" bar \"  )  ,    tag . getValue (  )  . getTrimmedText (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCharRefs"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < foo >  <  / foo >  \"  )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >     {", "tag . collapseIfEmpty (  )  ;", "assertEquals (  \"  < foo /  >  \"  ,    tag . getText (  )  )  ;", "final   XmlTag   tag 1     =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < foo > abc <  / foo >  \"  )  ;", "tag 1  . collapseIfEmpty (  )  ;", "assertEquals (  \"  < foo /  >  \"  ,    tag 1  . getText (  )  )  ;", "final   XmlTag   tag 2     =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < foo >  < boo /  >  <  / foo >  \"  )  ;", "tag 2  . collapseIfEmpty (  )  ;", "assertEquals (  \"  < foo >  < boo /  >  <  / foo >  \"  ,    tag 2  . getText (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testCollapse"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "XmlTagTest . doCoordinateMappingConsistentFromDisplayText (  \" abc \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromDisplayText (  \"    abc \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromDisplayText (  \"    a   bc \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromDisplayText (  \"    a   b   c \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromDisplayText (  \"    a   b   c    \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromDisplayText (  \"    ab   c    \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromDisplayText (  \"    abc    \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromDisplayText (  \" abc    \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromDisplayText (  \"     \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromDisplayText (  \"  &  \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromDisplayText (  \"  & abc \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromDisplayText (  \"     & abc \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromDisplayText (  \"    a &    bc \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromDisplayText (  \"    a    & b   c \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromDisplayText (  \"    a   b &    c    \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromDisplayText (  \"    ab   c &     \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromDisplayText (  \"    ab & c    \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromDisplayText (  \" abc    &  \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromDisplayText (  \" abc &  \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromDisplayText (  \" ab & c &  \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromDisplayText (  \" ab & c \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromDisplayText (  \" a & b & c \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromEscapedText (  \"  <  !  [ CDATA [     ]  ]  >  \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromEscapedText (  \"  <  !  [ CDATA [ x ]  ]  >  \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromEscapedText (  \" xxx <  !  [ CDATA [ x ]  ]  >  \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromEscapedText (  \" xxx <  !  [ CDATA [ x ]  ]  > xxx \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromEscapedText (  \" xxx & amp ;  <  !  [ CDATA [ x ]  ]  > xxx \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromEscapedText (  \" xxx & amp ;  <  !  [ CDATA [ x ]  ]  >  & amp ; xxx \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromEscapedText (  \" xxx <  !  [ CDATA [ x ]  ]  >  & amp ; xxx \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromEscapedText (  \" xxx <  !  [ CDATA [ xas ]  ]  >  & amp ; xxx \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromEscapedText (  \" xxx <  !  [ CDATA [ xa > s ]  ]  >  & amp ; xxx \"  )  ;", "XmlTagTest . doCoordinateMappingConsistentFromEscapedText (  \" xxx <  !  [ CDATA [ x < a > s ]  ]  >  & amp ; xxx \"  )  ;", "}", "METHOD_END"], "methodName": ["testCoordinateMappingConsistent"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   rootTag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < a   xmlns =  \\  \" aNamespace \\  \"  /  >  \"  )  ;", "final   XmlTag   childTag    =    rootTag . createChildTag (  \" b \"  ,     \" bNamespace \"  ,    null ,    true )  ;", "assertEquals (  \" bNamespace \"  ,    childTag . getNamespace (  )  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "XmlTag   beanTag    =     (  ( XmlTag )     ( rootTag . add ( childTag )  )  )  ;", "assertEquals (  \" bNamespace \"  ,    beanTag . getNamespace (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testCreateChildTag"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "XmlTag   aTag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < a >  < b /  >     <  / a >  \"  )  ;", "final   XmlTag   bTag    =    aTag . findFirstSubTag (  \" b \"  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >    bTag . delete (  )  )  ;", "assertEquals (  0  ,    aTag . getSubTags (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testDeleteTag"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    XmlTagTest . createTag (  \" foo . xhtml \"  ,     \"  < p > a < div /  > b <  / p >  \"  )  ;", "final   XmlTag   div    =    tag . getSubTags (  )  [  0  ]  ;", "WriteCommandAction . writeCommandAction ( getProject (  )  ,    tag . getContainingFile (  )  )  . run (  (  )     -  >     {", "div . delete (  )  ;", "}  )  ;", "assertEquals (  \"  < p > ab <  / p >  \"  ,    tag . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDeleteTagBetweenText"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =     (  ( XmlFile )     ( PsiFileFactory . getInstance ( getProject (  )  )  . createFileFromText (  \" test . xml \"  ,     \"  < a >  \\ n       < a /  >  \\ n <  / a >  \"  )  )  )  ;", "final      tagB    =    file . getDocument (  )  . getRootTag (  )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >    tagB . getSubTags (  )  [  0  ]  . delete (  )  )  ;", "assertEquals (  \"  < a >  \\ n       <  / a >  \"  ,    tagB . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDeleteTagWithMultilineWhitespace1"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =     (  ( XmlFile )     ( PsiFileFactory . getInstance ( getProject (  )  )  . createFileFromText (  \" test . xml \"  ,     \"  < a >  \\ n             < a >  \\ n    < b >  \\ n               hasgdgasjdgasdg            asgdjhasgd <  / b >  \\ n    <  / a >  \\ n <  / a >  \"  )  )  )  ;", "final      tagB    =    file . getDocument (  )  . getRootTag (  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >    tagB . getSubTags (  )  [  0  ]  . getSubTags (  )  [  0  ]  . delete (  )  )  ;", "assertEquals (  \"  < a >  \\ n             < a >  \\ n    <  / a >  \\ n <  / a >  \"  ,    tagB . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDeleteTagWithMultilineWhitespace2"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"        < foo /  >  \"  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "tag . add ( XmlElementFactory . getInstance ( getProject (  )  )  . createDisplayText (  \" aaa \\ nbbb \"  )  )  ;", "}  )  ;", "assertEquals (  \" aaa \\ nbbb \"  ,    tag . getValue (  )  . getTextElements (  )  [  0  ]  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDisplayText"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   String   text    =     \"  < a >  <  / a >  \"  ;", "final   String   name    =     \" test . xhtml \"  ;", "XmlTag   rootTag    =     . createTag ( name ,    text )  ;", "TextRange   textRange    =    rootTag . getValue (  )  . getTextRange (  )  ;", "assertEquals (  3  ,    textRange . getStartOffset (  )  )  ;", "assertEquals (  3  ,    textRange . getEndOffset (  )  )  ;", "}", "METHOD_END"], "methodName": ["testEmptyTextRange"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "XmlTagTest . doTestEscapedInsertion (  \" xyz \"  ,     \"  &  \"  )  ;", "XmlTagTest . doTestEscapedInsertion (  \" xyz \"  ,     \"  &  &  \"  )  ;", "XmlTagTest . doTestEscapedInsertion (  \" xyz \"  ,     \"  & x &  \"  )  ;", "XmlTagTest . doTestEscapedInsertion (  \"  & xyz \"  ,     \" a \"  )  ;", "XmlTagTest . doTestEscapedInsertion (  \"  & xyz \"  ,     \"     \"  )  ;", "XmlTagTest . doTestEscapedInsertion (  \" x & yz \"  ,     \" a \"  )  ;", "XmlTagTest . doTestEscapedInsertion (  \" x & yz \"  ,     \"     \"  )  ;", "XmlTagTest . doTestEscapedInsertion (  \" xy & z \"  ,     \" a \"  )  ;", "XmlTagTest . doTestEscapedInsertion (  \" xy & z \"  ,     \"     \"  )  ;", "XmlTagTest . doTestEscapedInsertion (  \" xyz &  \"  ,     \" a \"  )  ;", "XmlTagTest . doTestEscapedInsertion (  \" xyz &  \"  ,     \"     \"  )  ;", "XmlTagTest . doTestEscapedInsertion (  \"  & x & y & z &  \"  ,     \" a \"  )  ;", "XmlTagTest . doTestEscapedInsertion (  \"    x & y & z &  \"  ,     \" a \"  )  ;", "XmlTagTest . doTestEscapedInsertion (  \"    x   y & z &  \"  ,     \" a \"  )  ;", "XmlTagTest . doTestEscapedInsertion (  \"  & x   y & z &  \"  ,     \" a \"  )  ;", "XmlTagTest . doTestEscapedInsertion (  \"  & x   y & z    \"  ,     \" a \"  )  ;", "XmlTagTest . doTestEscapedInsertion (  \"  & x & y & z &  \"  ,     \"  <  \"  )  ;", "XmlTagTest . doTestEscapedInsertion (  \"  & x & y & z &  \"  ,     \"  >  \"  )  ;", "XmlTagTest . doTestEscapedInsertion (  \"  _ xyz \"  ,     \" a \"  )  ;", "XmlTagTest . doTestEscapedInsertion (  \" x _ yz \"  ,     \" a \"  )  ;", "XmlTagTest . doTestEscapedInsertion (  \" xy _ z \"  ,     \" a \"  )  ;", "XmlTagTest . doTestEscapedInsertion (  \" xyz _  \"  ,     \" a \"  )  ;", "XmlTagTest . doTestEscapedInsertion (  \"  _ xyz _  \"  ,     \" a \"  )  ;", "XmlTagTest . doTestEscapedInsertion (  \"  _ x _ y _ z _  \"  ,     \" a \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapedInsertion"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" bar \"  ,    XmlTagTest . createTag (  \" bar \"  )  . getValue (  )  . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetTextValue"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "String   html    =     \"  < html >  < head    /  >  < body >  < hr    /  >  <  / body >  \\ n <  / html >  \"  ;", "XmlFile   file    =     (  ( XmlFile )     ( PsiFileFactory . getInstance ( getProject (  )  )  . createFileFromText (  \" xxx . xhtml \"  ,    html )  )  )  ;", "body    =    file . getDocument (  )  . getRootTag (  )  . findFirstSubTag (  \" body \"  )  ;", "final      hr    =    body . getSubTags (  )  [  0  ]  ;", "final   XmlText   text    =    XmlElementFactory . getInstance ( getProject (  )  )  . createDisplayText (  \" p \"  )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >     {", "PsiElement   element    =    hr . getParentTag (  )  . addAfter ( text ,    hr )  ;", "assertEquals ( element . getParent (  )  ,    hr . getParentTag (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testInsert"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < foo   xmlns =  ' aaa '    xmlns : a =  ' bbbb '  /  >  \"  )  ;", "final   Object [  ]    nsPrefixes    =    ArrayUtil . toObjectArray ( tag . getLocalNamespaceDeclarations (  )  . keySet (  )  )  ;", "Arrays . sort ( nsPrefixes )  ;", "assertEquals (  2  ,    nsPrefixes . length )  ;", "assertEquals (  \" a \"  ,    nsPrefixes [  1  ]  )  ;", "assertEquals (  \"  \"  ,    nsPrefixes [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testLocalNSDeclarations"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tagA    =    XmlElementFactory . getInstance ( getProject (  )  )  . createXHTMLTagFromText (  \"  < a >  1  < b >  & nbsp ;  <  / b >  <  / a >  \"  )  ;", "final   XmlTag   tagB    =    tagA . findFirstSubTag (  \" b \"  )  ;", "final   XmlTagChild   nbsp    =    tagB . getValue (  )  . getChildren (  )  [  0  ]  ;", "assertEquals (  \"  & nbsp ;  \"  ,    nbsp . getText (  )  )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >     {", "tagA . addBefore ( nbsp . copy (  )  ,    tagB )  ;", "}  )  ;", "XmlTagChild   nbsp 1     =    tagA . getValue (  )  . getChildren (  )  [  0  ]  ;", "assertEquals (  \"  1  & nbsp ;  \"  ,    nbsp 1  . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNBSP"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \"  < wpd >  < methods >     <  / methods >  <  / wpd >  \"  ;", "final   File   tempFile    =    FileUtil . createTempFile (  \" idea - test \"  ,     \"  . xml \"  )  ;", "tempFile . createNewFile (  )  ;", "FileUtil . writeToFile ( tempFile ,    text )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >    CommandProcessor . getInstance (  )  . executeCommand ( getProject (  )  ,     (  )     -  >     {", "VirtualFileManager . getInstance (  )  . syncRefresh (  )  ;", "XmlFile   file ;", "try    {", "file    =     (  ( XmlFile )     ( getPsiManager (  )  . findFile ( VfsUtil . findFileByURL ( tempFile . toURL (  )  )  )  )  )  ;", "}    catch    (    e )     {", "throw   new    < e > RuntimeException (  )  ;", "}", "final      methodTag    =    file . getDocument (  )  . getRootTag (  )  . findFirstSubTag (  \" methods \"  )  ;", "try    {", "methodTag . add ( XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < method /  >  \"  )  )  ;", "}    catch    (    e )     {", "throw   new    < e > RuntimeException (  )  ;", "}", "}  ,     \"  \"  ,    null ,    UndoConfirmationPolicy . DO _ NOT _ REQUEST _ CONFIRMATION )  )  ;", "}", "METHOD_END"], "methodName": ["testPsiToDocumentSynchronizationFailed"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =     (  ( XmlFile )     ( createFile (  \" file . xhtml \"  ,     \"  < a >  1  2  3  4  < b >  <  / b >  5  6  7  <  / a >  \"  )  )  )  ;", "final      root    =    file . getDocument (  )  . getRootTag (  )  ;", "final      tag    =    root . findFirstSubTag (  \" b \"  )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >    CommandProcessor . getInstance (  )  . executeCommand ( getProject (  )  ,     (  )     -  >     {", "final   int   offset    =    tag . getTextOffset (  )  ;", "Document   document    =    PsiDocumentManager . getInstance ( getProject (  )  )  . getDocument ( root . getContainingFile (  )  )  ;", "RangeMarker   marker    =    document . createRangeMarker (  ( offset    -     3  )  ,    offset )  ;", "tag . delete (  )  ;", "assertEquals (  4  ,    marker . getStartOffset (  )  )  ;", "assertEquals (  7  ,    marker . getEndOffset (  )  )  ;", "}  ,     \"  \"  ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["testRangeMarker1"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   root    =    XmlTagTest . createTag (  \" file . xhtml \"  ,     \"  < a >  1  < b >  2  3  4  <  / b >  5  6  7  <  / a >  \"  )  ;", "final   XmlTag   tag    =    root . findFirstSubTag (  \" b \"  )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >    CommandProcessor . getInstance (  )  . executeCommand ( getProject (  )  ,     (  )     -  >     {", "Document   document    =    PsiDocumentManager . getInstance ( getProject (  )  )  . getDocument ( root . getContainingFile (  )  )  ;", "XmlTagChild   child    =    tag . getValue (  )  . getChildren (  )  [  0  ]  ;", "assertTrue (  (  ( child   instanceof   XmlText )     &  &     ( child . getText (  )  . equals (  \"  2  3  4  \"  )  )  )  )  ;", "try    {", "tag . getParent (  )  . addBefore ( child ,    tag )  ;", "assertEquals (  7  ,    tag . getTextOffset (  )  )  ;", "RangeMarker   marker    =    document . createRangeMarker (  4  ,     7  )  ;", "tag . delete (  )  ;", "assertEquals (  4  ,    marker . getStartOffset (  )  )  ;", "assertEquals (  7  ,    marker . getEndOffset (  )  )  ;", "}    catch    (    e )     {", "}", "}  ,     \"  \"  ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["testRangeMarker2"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   aTag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < a >  < b /  >  <  / a >  \"  )  ;", "final   XmlTag   bTag    =    aTag . findFirstSubTag (  \" b \"  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "PsiElement   cTag    =    bTag . replace ( XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < c /  >  \"  )  )  ;", "assertEquals (  1  ,    aTag . getSubTags (  )  . length )  ;", "assertEquals ( cTag ,    aTag . getSubTags (  )  [  0  ]  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testReplaceTag"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   rootTag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < html /  >  \"  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "rootTag . setAttribute (  \" foo \"  ,     \" bar \"  )  ;", "}  )  ;", "assertEquals (  1  ,    rootTag . getAttributes (  )  . length )  ;", "assertEquals (  \" bar \"  ,    rootTag . getAttributeValue (  \" foo \"  )  )  ;", "assertEquals (  \" foo \"  ,    rootTag . getAttributes (  )  [  0  ]  . getName (  )  )  ;", "assertEquals (  \"  < html   foo =  \\  \" bar \\  \"  /  >  \"  ,    rootTag . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetAttribute"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   String   value    =     \" a    \\  \" b \\  \"    c \"  ;", "final      rootTag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  (  (  \"  < html   foo =  '  \"     +    value )     +     \"  '  /  >  \"  )  )  ;", "assertEquals (  1  ,    rootTag . getAttributes (  )  . length )  ;", "assertEquals ( value ,    rootTag . getAttributeValue (  \" foo \"  )  )  ;", "final   XmlAttribute   foo    =    rootTag . getAttribute (  \" foo \"  )  ;", "final   String   text    =    foo . getValueElement (  )  . getText (  )  ;", "assertEquals (  (  (  \"  '  \"     +    value )     +     \"  '  \"  )  ,    text )  ;", "(  ( PsiLanguageInjectionHost )     ( foo . getValueElement (  )  )  )  . updateText ( text )  ;", "assertEquals (  (  (  \"  < html   foo =  '  \"     +    value )     +     \"  '  /  >  \"  )  ,    rootTag . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetAttributeUpdateText"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "XmlFile   file    =     (  ( XmlFile )     ( PsiFileFactory . getInstance ( getProject (  )  )  . createFileFromText (  \" dummy . xml \"  ,    XmlFileType . INSTANCE ,     \"  < fooBarGoo   attr >  1  <  / fooBarGoo >  \"  ,     0  ,    true )  )  )  ;", "final      tag    =    file . getDocument (  )  . getRootTag (  )  ;", "final   Document   document    =    file . getViewProvider (  )  . getDocument (  )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >     {", "tag . setAttribute (  \" attr \"  ,     \"  \"  )  ;", "assertEquals (  \"  < fooBarGoo   attr =  \\  \"  \\  \"  >  1  <  / fooBarGoo >  \"  ,    tag . getText (  )  )  ;", "assertEquals (  \"  < fooBarGoo   attr =  \\  \"  \\  \"  >  1  <  / fooBarGoo >  \"  ,    document . getText (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testSetAttributeValue"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   rootTag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < ns : tag   xmlns : ns =  \\  \" xxx \\  \"  /  >  \"  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "rootTag . setAttribute (  \" foo \"  ,     \"  \"  ,     \" bar \"  )  ;", "}  )  ;", "assertEquals (  2  ,    rootTag . getAttributes (  )  . length )  ;", "assertEquals (  \" bar \"  ,    rootTag . getAttributeValue (  \" foo \"  )  )  ;", "assertEquals (  \" foo \"  ,    rootTag . getAttributes (  )  [  1  ]  . getName (  )  )  ;", "assertEquals (  \"  < ns : tag   xmlns : ns =  \\  \" xxx \\  \"    foo =  \\  \" bar \\  \"  /  >  \"  ,    rootTag . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetAttributeWithNamespaces"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   rootTag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < html /  >  \"  )  ;", "final   String   value    =     \" a    \\  \" b \\  \"    c \"  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "rootTag . setAttribute (  \" foo \"  ,    value )  ;", "}  )  ;", "assertEquals (  1  ,    rootTag . getAttributes (  )  . length )  ;", "assertEquals ( value ,    rootTag . getAttributeValue (  \" foo \"  )  )  ;", "assertEquals (  \" foo \"  ,    rootTag . getAttributes (  )  [  0  ]  . getName (  )  )  ;", "assertEquals (  (  (  \"  < html   foo =  '  \"     +    value )     +     \"  '  /  >  \"  )  ,    rootTag . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetAttributeWithQuotes"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   rootTag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < html /  >  \"  )  ;", "final   String   value    =     \"  \\  ' a    \\  \" b \\  \"    c \\  '  \"  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "rootTag . setAttribute (  \" foo \"  ,    value )  ;", "}  )  ;", "final   String   expected    =    value . replaceAll (  \"  \\  \"  \"  ,     \"  & quot ;  \"  )  ;", "assertEquals (  1  ,    rootTag . getAttributes (  )  . length )  ;", "assertEquals ( expected ,    rootTag . getAttributeValue (  \" foo \"  )  )  ;", "assertEquals ( value ,    rootTag . getAttribute (  \" foo \"  )  . getDisplayValue (  )  )  ;", "assertEquals (  \" foo \"  ,    rootTag . getAttributes (  )  [  0  ]  . getName (  )  )  ;", "assertEquals (  (  (  \"  < html   foo =  \\  \"  \"     +    expected )     +     \"  \\  \"  /  >  \"  )  ,    rootTag . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetAttributeWithQuotes2"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "XmlFile   xhtmlFile    =     (  ( XmlFile )     ( PsiFileFactory . getInstance ( getProject (  )  )  . createFileFromText (  \" dummy . xhtml \"  ,     \"  < html /  >  \"  )  )  )  ;", "final      rootTag    =    xhtmlFile . getDocument (  )  . getRootTag (  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "rootTag . setAttribute (  \" foo \"  ,     \" bar \"  )  ;", "}  )  ;", "assertEquals (  1  ,    rootTag . getAttributes (  )  . length )  ;", "assertEquals (  \" bar \"  ,    rootTag . getAttributeValue (  \" foo \"  )  )  ;", "assertEquals (  \" foo \"  ,    rootTag . getAttributes (  )  [  0  ]  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetAttribute_ForXhtml"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "XmlFile   file    =     (  ( XmlFile )     ( PsiFileFactory . getInstance ( getProject (  )  )  . createFileFromText (  \" dummy . xml \"  ,    XmlFileType . INSTANCE ,     \"  < fooBarGoo >  1  <  / fooBarGoo >  \"  ,     0  ,    true )  )  )  ;", "final      tag    =    file . getDocument (  )  . getRootTag (  )  ;", "final   Document   document    =    file . getViewProvider (  )  . getDocument (  )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >     {", "tag . setName (  \" xxx \"  )  ;", "assertEquals (  \"  < xxx >  1  <  / xxx >  \"  ,    tag . getText (  )  )  ;", "assertEquals (  \"  < xxx >  1  <  / xxx >  \"  ,    document . getText (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testSetName"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "XmlFile   xhtmlFile    =     (  ( XmlFile )     ( PsiFileFactory . getInstance ( getProject (  )  )  . createFileFromText (  \" dummy . xml \"  ,     \"  < html >  < body /  >  <  / html >  \"  )  )  )  ;", "final      rootTag    =    xhtmlFile . getDocument (  )  . getRootTag (  )  ;", "rootTag . getSubTags (  )  [  0  ]  . getNamespace (  )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >     {", "rootTag . setAttribute (  \" xmlns \"  ,     \" http :  /  / www . ru \"  )  ;", "}  )  ;", "assertEquals (  \" http :  /  / www . ru \"  ,    rootTag . getSubTags (  )  [  0  ]  . getNamespace (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetNamespace"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "XmlTagTest . doTestSimpleDeletion (  \" xyz \"  )  ;", "XmlTagTest . doTestSimpleDeletion (  \"    xyz \"  )  ;", "XmlTagTest . doTestSimpleDeletion (  \" x   yz \"  )  ;", "XmlTagTest . doTestSimpleDeletion (  \" xy   z \"  )  ;", "XmlTagTest . doTestSimpleDeletion (  \" xyz    \"  )  ;", "XmlTagTest . doTestSimpleDeletion (  \"    xyz    \"  )  ;", "XmlTagTest . doTestSimpleDeletion (  \"    x   y   z    \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleTextDeletion"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "XmlTagTest . doTestSimpleInsertion (  \" xyz \"  ,     \" a \"  )  ;", "XmlTagTest . doTestSimpleInsertion (  \"    xyz \"  ,     \" a \"  )  ;", "XmlTagTest . doTestSimpleInsertion (  \" x   yz \"  ,     \" a \"  )  ;", "XmlTagTest . doTestSimpleInsertion (  \" xy   z \"  ,     \" a \"  )  ;", "XmlTagTest . doTestSimpleInsertion (  \" xyz    \"  ,     \" a \"  )  ;", "XmlTagTest . doTestSimpleInsertion (  \"    xyz    \"  ,     \" a \"  )  ;", "XmlTagTest . doTestSimpleInsertion (  \"    x   y   z    \"  ,     \" a \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleTextInsertion"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < a /  >  \"  )  . getValue (  )  . setText (  \"  @  #  $  %  @  $  %  $  $  {  $  {  '  '  }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testStrangeCharactesInText"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   rootTag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < html > aaa <  / html >  \"  )  ;", "final   XmlText   xmlText    =    rootTag . getValue (  )  . getTextElements (  )  [  0  ]  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >    xmlText . removeText (  0  ,     3  )  )  ;", "assertEquals (  \"  < html >  <  / html >  \"  ,    rootTag . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTextEdit1"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   rootTag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < html > a & lt ; a <  / html >  \"  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >    rootTag . getValue (  )  . getTextElements (  )  [  0  ]  . removeText (  0  ,     3  )  )  ;", "assertEquals (  \"  < html >  <  / html >  \"  ,    rootTag . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTextEdit2"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   rootTag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < html > a & lt ; a <  / html >  \"  )  ;", "final   XmlText   xmlText    =    rootTag . getValue (  )  . getTextElements (  )  [  0  ]  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >    xmlText . removeText (  1  ,     2  )  )  ;", "assertEquals (  1  ,    xmlText . getChildren (  )  . length )  ;", "assertEquals (  \"  < html > aa <  / html >  \"  ,    rootTag . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTextEdit3"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   rootTag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < html > aaa <  / html >  \"  )  ;", "final   XmlText   xmlText    =    rootTag . getValue (  )  . getTextElements (  )  [  0  ]  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >    xmlText . removeText (  1  ,     2  )  )  ;", "assertEquals (  1  ,    xmlText . getChildren (  )  . length )  ;", "assertEquals (  \"  < html > aa <  / html >  \"  ,    rootTag . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTextEdit4"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   rootTag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < html >  < x > xxx <  / x >  \\ n < y > yyy <  / y >  <  / html >  \"  )  ;", "final   XmlTag   y    =    rootTag . findFirstSubTag (  \" y \"  )  ;", "final   PsiFile   file    =    y . getContainingFile (  )  ;", "String   text    =    y . getValue (  )  . getText (  )  ;", "TextRange   textRange    =    y . getValue (  )  . getTextRange (  )  ;", "assertEquals ( text ,    textRange . substring ( file . getText (  )  )  )  ;", "WriteCommandAction . writeCommandAction ( getProject (  )  ,    file )  . run (  (  )     -  >     {", "CodeStyleManager . getInstance ( getProject (  )  )  . adjustLineIndent ( file ,    y . getTextOffset (  )  )  ;", "}  )  ;", "text    =    y . getValue (  )  . getText (  )  ;", "textRange    =    y . getValue (  )  . getTextRange (  )  ;", "assertEquals ( text ,    textRange . substring ( file . getText (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testTextEdit5"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   rootTag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < html > a < b >  1  <  / b > c <  / html >  \"  )  ;", "final   XmlTag   xmlTag    =    rootTag . findFirstSubTag (  \" b \"  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >    xmlTag . delete (  )  )  ;", "assertEquals (  \"  < html > ac <  / html >  \"  ,    rootTag . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTextEdit6"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "XmlTagTest . doTestSimpleDeletion (  \"    xyz \"  )  ;", "XmlTagTest . doTestSimpleDeletion (  \" x   yz \"  )  ;", "XmlTagTest . doTestSimpleDeletion (  \" xy   z \"  )  ;", "XmlTagTest . doTestSimpleDeletion (  \" xyz    \"  )  ;", "XmlTagTest . doTestSimpleDeletion (  \"    xyz    \"  )  ;", "XmlTagTest . doTestSimpleDeletion (  \"    x   y   z    \"  )  ;", "}", "METHOD_END"], "methodName": ["testWhitespaceDeletion"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < p /  >  \"  )  . getValue (  )  . setText (  \"  \\ n \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testWhitespaceInsideTag"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "XmlTagTest . doTestSimpleInsertion (  \" xyz \"  ,     \"     \"  )  ;", "}", "METHOD_END"], "methodName": ["testWhitespaceTextInsertion"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "XmlTag   tag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < a   c = d > b <  / a >  \"  )  ;", "assertEquals (  \" b \"  ,    tag . getValue (  )  . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWhitespacesInAttributes"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createXHTMLTagFromText (  \"  < a >     < b /  >     <  / a >  \"  )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >    tag . findFirstSubTag (  \" b \"  )  . delete (  )  )  ;", "assertEquals (  \"  < a >        <  / a >  \"  ,    tag . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWhitespacesInEmptyXHTMLTag"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =     (  ( XmlFile )     ( PsiFileFactory . getInstance ( getProject (  )  )  . createFileFromText (  \" test . xhtml \"  ,     \"  < a > a    < b >  1  2  3  <  / b >    c <  / a >  \"  )  )  )  ;", "final      tagB    =    file . getDocument (  )  . getRootTag (  )  . findFirstSubTag (  \" b \"  )  ;", "final   Child [  ]    tagElements    =    tagB . getValue (  )  . getChildren (  )  ;", "final   PsiElement   parent    =    tagB . getParent (  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "PsiElement   first    =    parent . addBefore ( tagElements [  0  ]  ,    tagB )  ;", "assertNotNull ( first )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testXHTMLAddBefore1"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =     (  ( XmlFile )     ( PsiFileFactory . getInstance ( getProject (  )  )  . createFileFromText (  \" test . xhtml \"  ,     \"  < a >  & nbsp ;  <  / a >  \"  )  )  )  ;", "final      tagB    =    file . getDocument (  )  . getRootTag (  )  ;", "assertEquals ( tagB . getValue (  )  . getTextElements (  )  . length ,     1  )  ;", "assertEquals ( tagB . getValue (  )  . getTextElements (  )  [  0  ]  . getValue (  )  ,     \"  \\ u 0  0 a 0  \"  )  ;", "}", "METHOD_END"], "methodName": ["testXHTMLNbsp1"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "XmlTag   tag    =    XmlTagTest . createTag (  \" file . xhtml \"  ,     \"  < a > xyz <  / a >  \"  )  ;", "PsiFile   psiFile    =    tag . getContainingFile (  )  ;", "Document   document    =    PsiDocumentManager . getInstance ( psiFile . getProject (  )  )  . getDocument ( psiFile )  ;", "RangeMarker   rangeMarker    =    document . createRangeMarker (  5  ,     5  )  ;", "final   XmlText   text    =     (  ( XmlText )     ( tag . getValue (  )  . getChildren (  )  [  0  ]  )  )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >    CommandProcessor . getInstance (  )  . executeCommand ( getProject (  )  ,     (  )     -  >     {", "try    {", "text . removeText (  2  ,     3  )  ;", "}    catch    (    ioe )     {", "}", "}  ,     \"  \"  ,    null ,    UndoConfirmationPolicy . DO _ NOT _ REQUEST _ CONFIRMATION )  )  ;", "assertEquals (  5  ,    rangeMarker . getStartOffset (  )  )  ;", "assertEquals (  5  ,    rangeMarker . getEndOffset (  )  )  ;", "}", "METHOD_END"], "methodName": ["testXHTMLRangeMarkers2"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "WriteCommandAction . writeCommandAction ( getProject (  )  )  . run (  (  )     -  >     {", "final   XmlFile   file    =     (  ( XmlFile )     ( PsiFileFactory . getInstance ( getProject (  )  )  . createFileFromText (  \" test . xhtml \"  ,     \"  < a /  >  \"  )  )  )  ;", "final      tagB    =    file . getDocument (  )  . getRootTag (  )  ;", "tagB . setAttribute (  \" a \"  ,     \"  \"  )  ;", "assertEquals (  \"  < a   a =  \\  \"  \\  \"  /  >  \"  ,    tagB . getText (  )  )  ;", "tagB . setAttribute (  \" b \"  ,     \"  \"  )  ;", "assertEquals (  \"  < a   a =  \\  \"  \\  \"    b =  \\  \"  \\  \"  /  >  \"  ,    tagB . getText (  )  )  ;", "tagB . setAttribute (  \" c \"  ,     \"  \"  )  ;", "assertEquals (  \"  < a   a =  \\  \"  \\  \"    b =  \\  \"  \\  \"    c =  \\  \"  \\  \"  /  >  \"  ,    tagB . getText (  )  )  ;", "tagB . getAttributes (  )  [  1  ]  . delete (  )  ;", "assertEquals (  \"  < a   a =  \\  \"  \\  \"       c =  \\  \"  \\  \"  /  >  \"  ,    tagB . getText (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testXHTMLSetAttribute1"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createXHTMLTagFromText (  \"  < a > xyz <  / a >  \"  )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >    tag . getValue (  )  . getTextElements (  )  [  0  ]  . insertText (  \"  <  \"  ,     1  )  )  ;", "assertEquals (  \"  < a > x & lt ; yz <  / a >  \"  ,    tag . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testXHTMLTextInsert"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < foo > bar <  / foo >  \"  )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >     {", "tag . add ( XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < bar /  >  \"  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testXmlFormattingException"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "text    =    text . replaceAll (  \"  & lt ;  \"  ,     \"  <  \"  )  ;", "text    =    text . replaceAll (  \"  & gt ;  \"  ,     \"  >  \"  )  ;", "text    =    text . replaceAll (  \"  & amp ;  \"  ,     \"  &  \"  )  ;", "text    =    text . replaceAll (  \"  & apos ;  \"  ,     \"  '  \"  )  ;", "text    =    text . replaceAll (  \"  & quot ;  \"  ,     \"  \\  \"  \"  )  ;", "text    =    text . replaceAll (  \"  <  !  \\  \\  [ CDATA \\  \\  [  \"  ,     \"  \"  )  ;", "text    =    text . replaceAll (  \"  \\  \\  ]  \\  \\  ]  >  \"  ,     \"  \"  )  ;", "return   text . replaceAll (  \"  & nbsp ;  \"  ,     \"  _  \"  )  ;", "}", "METHOD_END"], "methodName": ["toDisplay"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "String   text    =    original . replaceAll (  \"  <  \"  ,     \"  & lt ;  \"  )  ;", "text    =    text . replaceAll (  \"  >  \"  ,     \"  & gt ;  \"  )  ;", "text    =    text . replaceAll (  \"  &  \"  ,     \"  & amp ;  \"  )  ;", "text    =    text . replaceAll (  \"  '  \"  ,     \"  & apos ;  \"  )  ;", "text    =    text . replaceAll (  \"  \\  \"  \"  ,     \"  & quot ;  \"  )  ;", "text    =    text . replaceAll (  \"  _  \"  ,     \"  & nbsp ;  \"  )  ;", "assertEquals ( original ,     . toDisplay ( text )  )  ;", "return   text ;", "}", "METHOD_END"], "methodName": ["toEscapedText"], "fileName": "com.intellij.codeInsight.XmlTagTest"}, {"methodBody": ["METHOD_START", "{", "XmlElementFactory   elementFactory    =    XmlElementFactory . getInstance ( getProject (  )  )  ;", "final      xmlTag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < tag 1  /  >  \"  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "xmlTag . add ( xmlTag . createChildTag (  \" tag 2  \"  ,    XmlUtil . EMPTY _ URI ,    null ,    false )  )  ;", "}  )  ;", "assertEquals (  \"  < tag 1  >  < tag 2  /  >  <  / tag 1  >  \"  ,    xmlTag . getText (  )  )  ;", "createdFromText    =    elementFactory . createTagFromText ( xmlTag . getText (  )  )  ;", "assertEquals (  \" tag 1  \"  ,    createdFromText . getName (  )  )  ;", "assertEquals (  1  ,    createdFromText . getSubTags (  )  . length )  ;", "assertEquals (  \" tag 2  \"  ,    createdFromText . getSubTags (  )  [  0  ]  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["test1"], "fileName": "com.intellij.codeInsight.XmlTagWriteTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   xmlTag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < tag 1  >  <  / tag 1  >  \"  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "xmlTag . add ( xmlTag . createChildTag (  \" tag 2  \"  ,    XmlUtil . EMPTY _ URI ,    null ,    false )  )  ;", "}  )  ;", "assertEquals (  \"  < tag 1  >  < tag 2  /  >  <  / tag 1  >  \"  ,    xmlTag . getText (  )  )  ;", "XmlTag   createdFromText    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText ( xmlTag . getText (  )  )  ;", "assertEquals (  \" tag 1  \"  ,    createdFromText . getName (  )  )  ;", "assertEquals (  1  ,    createdFromText . getSubTags (  )  . length )  ;", "assertEquals (  \" tag 2  \"  ,    createdFromText . getSubTags (  )  [  0  ]  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["test2"], "fileName": "com.intellij.codeInsight.XmlTagWriteTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < b >  \\ n 0  1  2  3  4  5  6  <  / b >  \"  )  ;", "final   XmlText   text    =     (  ( XmlText )     ( tag . getValue (  )  . getChildren (  )  [  0  ]  )  )  ;", "String   textS    =    text . getText (  )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >    text . insertText (  \" lala \"  ,     2  )  )  ;", "XmlText   text 2     =     (  ( XmlText )     ( tag . getValue (  )  . getChildren (  )  [  0  ]  )  )  ;", "assertEquals (  (  (  ( textS . substring (  0  ,     2  )  )     +     \" lala \"  )     +     ( textS . substring (  2  )  )  )  ,    text 2  . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["test3"], "fileName": "com.intellij.codeInsight.XmlTagWriteTest"}, {"methodBody": ["METHOD_START", "{", "return    !  ( parent   instanceof   XmlAttribute )  ;", "}", "METHOD_END"], "methodName": ["isAcceptableNamedParent"], "fileName": "com.intellij.codeInsight.XmlTargetElementEvaluator"}, {"methodBody": ["METHOD_START", "{", "XmlFile   file    =     (  ( XmlFile )     ( PsiFileFactory . getInstance ( project )  . createFileFromText (  \" tag . xml \"  ,     (  (  \"  <  \"     +    tagName )     +     \"  /  >  \"  )  )  )  )  ;", "return   file . getDocument (  )  . getRootTag (  )  ;", "}", "METHOD_END"], "methodName": ["tag"], "fileName": "com.intellij.codeInsight.XmlTestUtil"}, {"methodBody": ["METHOD_START", "{", "XmlFile   file    =     (  ( XmlFile )     ( PsiFileFactory . getInstance ( project )  . createFileFromText (  \" tag . xml \"  ,     (  (  (  (  \"  <  \"     +    tagName )     +     \"    xmlns =  \\  \"  \"  )     +    namespace )     +     \"  \\  \"  /  >  \"  )  )  )  )  ;", "return   file . getDocument (  )  . getRootTag (  )  ;", "}", "METHOD_END"], "methodName": ["tag"], "fileName": "com.intellij.codeInsight.XmlTestUtil"}, {"methodBody": ["METHOD_START", "{", "String   xml    =     \"  < div >  & amp ; abc <  / div >  \"  ;", "XmlFile   file    =     (  ( XmlFile )     ( PsiFileFactory . getInstance ( getProject (  )  )  . createFileFromText (  \" foo . xml \"  ,    xml )  )  )  ;", "XmlTag   root    =    file . getDocument (  )  . getRootTag (  )  ;", "final      text    =    root . getValue (  )  . getTextElements (  )  [  0  ]  ;", "assertEquals (  \"  & abc \"  ,    text . getValue (  )  )  ;", "assertEquals (  0  ,    text . displayToPhysical (  0  )  )  ;", "assertEquals (  5  ,    text . displayToPhysical (  1  )  )  ;", "assertEquals (  6  ,    text . displayToPhysical (  2  )  )  ;", "assertEquals (  7  ,    text . displayToPhysical (  3  )  )  ;", "assertEquals (  8  ,    text . displayToPhysical (  4  )  )  ;", "}", "METHOD_END"], "methodName": ["testDisplayToPhysical"], "fileName": "com.intellij.codeInsight.XmlTextTest"}, {"methodBody": ["METHOD_START", "{", "String   xml    =     \"  < div >  <  !  [ CDATA [     ]  ]  >  <  / div >  \"  ;", "XmlFile   file    =     (  ( XmlFile )     ( PsiFileFactory . getInstance ( getProject (  )  )  . createFileFromText (  \" foo . xml \"  ,    xml )  )  )  ;", "XmlTag   root    =    file . getDocument (  )  . getRootTag (  )  ;", "final      text    =    root . getValue (  )  . getTextElements (  )  [  0  ]  ;", "assertEquals (  \"     \"  ,    text . getValue (  )  )  ;", "assertEquals (  9  ,    text . displayToPhysical (  0  )  )  ;", "assertEquals (  1  3  ,    text . displayToPhysical (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["testDisplayToPhysical2"], "fileName": "com.intellij.codeInsight.XmlTextTest"}, {"methodBody": ["METHOD_START", "{", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "String   xml    =     \"  < root >  0  1  2  3  4  5  6  7  8  9  <  / root >  \"  ;", "XmlFile   file    =     (  ( XmlFile )     ( PsiFileFactory . getInstance ( getProject (  )  )  . createFileFromText (  \" foo . xml \"  ,    StdFileTypes . XML ,    xml ,     (  ( long )     (  1  )  )  ,    true ,    false )  )  )  ;", "XmlTag   root    =    file . getDocument (  )  . getRootTag (  )  ;", "final      text 1     =    root . getValue (  )  . getTextElements (  )  [  0  ]  ;", "assertFalse ( CodeEditUtil . isNodeGenerated ( root . getNode (  )  )  )  ;", "final      text    =    text 1  ;", "final   XmlElement   element    =    text . insertAtOffset ( XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < bar /  >  \"  )  ,     5  )  ;", "assertNotNull ( element )  ;", "assertTrue (  ( element   instanceof    )  )  ;", "assertEquals (  \"  0  1  2  3  4  \"  ,    element . getText (  )  )  ;", "assertEquals (  \"  < root >  0  1  2  3  4  < bar /  >  5  6  7  8  9  <  / root >  \"  ,    text . getContainingFile (  )  . getText (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testInsertAtOffset"], "fileName": "com.intellij.codeInsight.XmlTextTest"}, {"methodBody": ["METHOD_START", "{", "String   xml    =     \"  < div >  & amp ; abc <  / div >  \"  ;", "XmlFile   file    =     (  ( XmlFile )     ( PsiFileFactory . getInstance ( getProject (  )  )  . createFileFromText (  \" foo . xml \"  ,    xml )  )  )  ;", "XmlTag   root    =    file . getDocument (  )  . getRootTag (  )  ;", "final      text    =    root . getValue (  )  . getTextElements (  )  [  0  ]  ;", "assertEquals (  \"  & abc \"  ,    text . getValue (  )  )  ;", "assertEquals (  0  ,    text . physicalToDisplay (  0  )  )  ;", "assertEquals (  1  ,    text . physicalToDisplay (  5  )  )  ;", "assertEquals (  2  ,    text . physicalToDisplay (  6  )  )  ;", "assertEquals (  3  ,    text . physicalToDisplay (  7  )  )  ;", "assertEquals (  4  ,    text . physicalToDisplay (  8  )  )  ;", "}", "METHOD_END"], "methodName": ["testPhysicalToDisplayIfHasGaps2"], "fileName": "com.intellij.codeInsight.XmlTextTest"}, {"methodBody": ["METHOD_START", "{", "doAllTests (  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "com.intellij.codeInsight.XmlWrongClosingTagNameInspectionTest"}, {"methodBody": ["METHOD_START", "{", "if    ( psiFile   instanceof   XmlFile )     {", "final   XmlDocument   document    =     (  ( XmlFile )     ( psiFile )  )  . getDocument (  )  ;", "if    (  ( document    !  =    null )     &  &     (  ( document . getRootTag (  )  )     !  =    null )  )     {", "return   document ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findSuitableXmlDocument"], "fileName": "com.intellij.codeInsight.actions.GenerateDTDAction"}, {"methodBody": ["METHOD_START", "{", "final   PsiElementProcessor   processor    =    new   PsiElementProcessor (  )     {", "@ Override", "public   boolean   execute (  @ NotNull", "final   PsiElement   element )     {", "if    ( element   instanceof   XmlEntityDecl )     {", "final   XmlEntityDecl   xmlEntityDecl    =     (  ( XmlEntityDecl )     ( element )  )  ;", "String   name    =    xmlEntityDecl . getName (  )  ;", "if    (  ( name    !  =    null )     &  &     ( xmlEntityDecl . isInternalReference (  )  )  )     {", "result . addElement ( LookupElementBuilder . create ( name )  . withInsertHandler ( Xml . ENTITY _ INSERT _ HANDLER )  )  ;", "}", "}", "return   true ;", "}", "}  ;", "XmlUtil . processXmlElements (  (  ( XmlFile )     ( position . getContainingFile (  )  . getOriginalFile (  )  )  )  ,    processor ,    true )  ;", "}", "METHOD_END"], "methodName": ["addEntityCompletions"], "fileName": "com.intellij.codeInsight.completion.DtdCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "for    ( String   keyword    :    DtdCompletionContributor . KEYWORDS )     {", "result . addElement ( LookupElementBuilder . create ( keyword )  . withInsertHandler ( DtdCompletionContributor . INSERT _ HANDLER )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addKeywordCompletions"], "fileName": "com.intellij.codeInsight.completion.DtdCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  ( prev . textMatches (  \"  #  \"  )  )     |  |     ( prev . textMatches (  \"  !  \"  )  )  )     |  |     ( prev . textMatches (  \"  (  \"  )  )  )     |  |     ( prev . textMatches (  \"  ,  \"  )  )  )     |  |     ( prev . textMatches (  \"  |  \"  )  )  )     |  |     ( prev . textMatches (  \"  [  \"  )  )  )     |  |     (  ( prev . getNode (  )  . getElementType (  )  )     =  =     ( XmlTokenType . XML _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["hasDtdKeywordCompletion"], "fileName": "com.intellij.codeInsight.completion.DtdCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   prevLeaf    =    PsiTreeUtil . prevLeaf ( position )  ;", "final   PsiElement   prevPrevLeaf    =     ( prevLeaf    !  =    null )     ?    PsiTreeUtil . prevLeaf ( prevLeaf )     :    null ;", "if    ( prevLeaf    !  =    null )     {", "final   String   prevLeafText    =    prevLeaf . getText (  )  ;", "if    (  \"  #  \"  . equals ( prevLeafText )  )     {", "prefix    =     \"  #  \"     +    prefix ;", "} else", "if    (  (  (  \"  !  \"  . equals ( prevLeafText )  )     &  &     ( prevPrevLeaf    !  =    null )  )     &  &     (  \"  <  \"  . equals ( prevPrevLeaf . getText (  )  )  )  )     {", "prefix    =     \"  <  !  \"     +    prefix ;", "}", "}", "return   prefix ;", "}", "METHOD_END"], "methodName": ["keywordPrefix"], "fileName": "com.intellij.codeInsight.completion.DtdCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "super . handleInsert ( context ,    item )  ;", "}", "METHOD_END"], "methodName": ["doDefault"], "fileName": "com.intellij.codeInsight.completion.ExtendedTagInsertHandler"}, {"methodBody": ["METHOD_START", "{", "return   XmlNamespaceHelper . getHelper ( file )  . getNamespacesByTagName ( myElementName ,    file )  ;", "}", "METHOD_END"], "methodName": ["getNamespaces"], "fileName": "com.intellij.codeInsight.completion.ExtendedTagInsertHandler"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    file . getRootTag (  )  ;", "return   tag    =  =    null    ?    null    :    tag . getPrefixByNamespace ( namespace )  ;", "}", "METHOD_END"], "methodName": ["getPrefixByNamespace"], "fileName": "com.intellij.codeInsight.completion.ExtendedTagInsertHandler"}, {"methodBody": ["METHOD_START", "{", "PsiElement   parent    =    psiElement . getParent (  )  ;", "if    (  !  ( parent   instanceof   XmlTag )  )", "return   false ;", "final   XmlTag   tag    =     (  ( XmlTag )     ( parent )  )  ;", "final   XmlElementDescriptor   tagDescriptor    =    tag . getDescriptor (  )  ;", "final   String   tagNamespace    =    tag . getNamespace (  )  ;", "as    ( myNamespace )     !  =    null ;", "return    (  ( tagDescriptor    !  =    null )     &  &     (  !  ( tagDescriptor   instanceof   AnyXmlElementDescriptor )  )  )     &  &     ( myNamespace . equals ( tagNamespace )  )  ;", "}", "METHOD_END"], "methodName": ["isNamespaceBound"], "fileName": "com.intellij.codeInsight.completion.ExtendedTagInsertHandler"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   tag    =    element . getParent (  )  ;", "if    ( tag   instanceof   XmlTag )     {", "final   String   prefix    =     (  ( XmlTag )     ( tag )  )  . getNamespacePrefix (  )  ;", "if    (  (  !  ( prefix . equals ( namespacePrefix )  )  )     &  &     ( StringUtil . isNotEmpty ( namespacePrefix )  )  )     {", "final   String   name    =     ( namespacePrefix    +     \"  :  \"  )     +     (  (  ( XmlTag )     ( tag )  )  . getLocalName (  )  )  ;", "try    {", "(  ( XmlTag )     ( tag )  )  . setName ( name )  ;", "}    catch    ( IncorrectOperationException   e )     {", ". LOG . error ( e )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["qualifyWithPrefix"], "fileName": "com.intellij.codeInsight.completion.ExtendedTagInsertHandler"}, {"methodBody": ["METHOD_START", "{", "ExtendedTagInsertHandler . qualifyWithPrefix ( namespacePrefix ,    element )  ;", "}", "METHOD_END"], "methodName": ["qualifyWithPrefix"], "fileName": "com.intellij.codeInsight.completion.ExtendedTagInsertHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( namespace    =  =    null )     {", "return   null ;", "}", "for    ( XmlSchemaProvider   provider    :    XmlSchemaProvider . getAvailableProviders ( file )  )     {", "String   prefix    =    provider . getDefaultPrefix ( namespace ,    file )  ;", "if    ( prefix    !  =    null )     {", "return   prefix ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["suggestPrefix"], "fileName": "com.intellij.codeInsight.completion.ExtendedTagInsertHandler"}, {"methodBody": ["METHOD_START", "{", "@ NonNls", "String   name    =    attribute . getName (  )  ;", "final   XmlTag   tag    =    attribute . getParent (  )  ;", "if    ( tag    =  =    null )", "return   ArrayUtil . EMPTY _ STRING _ ARRAY ;", "@ NonNls", "String   tagName    =    tag . getName (  )  ;", "if    (  ( tag . getDescriptor (  )  )    instanceof   HtmlElementDescriptorImpl )     {", "name    =    name . toLowerCase (  )  ;", "tagName    =    tagName . toLowerCase (  )  ;", "}", "final   String   namespace    =    tag . getNamespace (  )  ;", "if    (  ( XmlUtil . XHTML _ URI . equals ( namespace )  )     |  |     ( XmlUtil . HTML _ URI . equals ( namespace )  )  )     {", "if    (  (  \" target \"  . equals ( name )  )     |  |     (  \" formtarget \"  . equals ( name )  )  )     {", "return    . TARGET ;", "} else", "if    (  \" enctype \"  . equals ( name )  )     {", "return    . ENCTYPE ;", "} else", "if    (  (  \" rel \"  . equals ( name )  )     |  |     (  \" rev \"  . equals ( name )  )  )     {", "return    . REL ;", "} else", "if    (  \" media \"  . equals ( name )  )     {", "return    . MEDIA ;", "} else", "if    (  \" language \"  . equals ( name )  )     {", "return    . LANGUAGE ;", "} else", "if    (  \" sandbox \"  . equals ( name )  )     {", "return    . SANDBOX ;", "} else", "if    (  (  \" type \"  . equals ( name )  )     &  &     (  \" link \"  . equals ( tagName )  )  )     {", "return    . TYPE ;", "} else", "if    (  (  \" http - equiv \"  . equals ( name )  )     &  &     (  \" meta \"  . equals ( tagName )  )  )     {", "return   com . intellij . xml . util . HtmlUtil . RFC 2  6  1  6  _ HEADERS ;", "} else", "if    (  (  (  \" content \"  . equals ( name )  )     &  &     (  \" meta \"  . equals ( tagName )  )  )     &  &     (  ( tag . getAttribute (  \" name \"  )  )     =  =    null )  )     {", "return   com . intellij . xml . util . HtmlUtil . CONTENT _ TYPES ;", "} else", "if    (  (  \" accept \"  . equals ( name )  )     &  &     (  \" input \"  . equals ( tagName )  )  )     {", "return   com . intellij . xml . util . HtmlUtil . CONTENT _ TYPES ;", "} else", "if    (  (  \" accept - charset \"  . equals ( name )  )     |  |     (  \" charset \"  . equals ( name )  )  )     {", "Charset [  ]    charSets    =    com . intellij . openapi . vfs . CharsetToolkit . getAvailableCharsets (  )  ;", "String [  ]    names    =    new   String [ charSets . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( names . length )  ;    i +  +  )     {", "names [ i ]     =    charSets [ i ]  . toString (  )  ;", "}", "return   names ;", "} else", "if    (  (  \" itemprop \"  . equals ( name )  )     &  &     (  !  ( com . intellij . openapi . project . DumbService . isDumb ( attribute . getProject (  )  )  )  )  )     {", "XmlTag   scopeTag    =    com . intellij . html . impl . util . MicrodataUtil . findScopeTag ( tag )  ;", "return   scopeTag    !  =    null    ?     . findItemProperties ( scopeTag )     :    ArrayUtil . EMPTY _ STRING _ ARRAY ;", "}", "}", "return   ArrayUtil . EMPTY _ STRING _ ARRAY ;", "}", "METHOD_END"], "methodName": ["addSpecificCompletions"], "fileName": "com.intellij.codeInsight.completion.HtmlCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "final   XmlAttribute   typeAttribute    =    tag . getAttribute ( MicrodataUtil . ITEM _ TYPE )  ;", "if    ( typeAttribute    !  =    null )     {", "final   XmlAttributeValue   valueElement    =    typeAttribute . getValueElement (  )  ;", "final   PsiReference [  ]    references    =     ( valueElement    !  =    null )     ?    valueElement . getReferences (  )     :    PsiReference . EMPTY _ ARRAY ;", "List < String >    result    =    new   ArrayList <  >  (  )  ;", "for    ( PsiReference   reference    :    references )     {", "final   PsiElement   target    =     ( reference    !  =    null )     ?    reference . resolve (  )     :    null ;", "if    ( target   instanceof   PsiFile )     {", "result . addAll ( MicrodataUtil . extractProperties (  (  ( PsiFile )     ( target )  )  ,    StringUtil . unquoteString ( reference . getCanonicalText (  )  )  )  )  ;", "}", "}", "return   ArrayUtil . toStringArray ( result )  ;", "}", "return   ArrayUtil . EMPTY _ STRING _ ARRAY ;", "}", "METHOD_END"], "methodName": ["findItemProperties"], "fileName": "com.intellij.codeInsight.completion.HtmlCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( PsiTreeUtil . getParentOfType ( position ,    HtmlTag . class ,    false )  )     !  =    null )     {", "return   true ;", "}", "XmlTag   xmlTag    =    PsiTreeUtil . getParentOfType ( position ,    XmlTag . class ,    false )  ;", "return    ( xmlTag    !  =    null )     &  &     (  ( xmlTag . getLanguage (  )  )     =  =     ( XHTMLLanguage . INSTANCE )  )  ;", "}", "METHOD_END"], "methodName": ["hasHtmlAttributesCompletion"], "fileName": "com.intellij.codeInsight.completion.HtmlCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "ASTNode   node    =    contextElement . getNode (  )  ;", "if    (  ( node    !  =    null )     &  &     (  ( node . getElementType (  )  )     =  =     ( XmlTokenType . XML _ DATA _ CHARACTERS )  )  )     {", "PsiElement   parent    =    contextElement . getParent (  )  ;", "if    (  ( parent   instanceof   X )     |  |     ( parent   instanceof   XmlDocument )  )     {", "String   contextElementText    =    contextElement . getText (  )  ;", "int   endOffset    =    offset    -     ( contextElement . getTextRange (  )  . getStartOffset (  )  )  ;", "String   prefix    =    contextElementText . substring (  0  ,    Math . min ( contextElementText . length (  )  ,    endOffset )  )  ;", "return    (  !  ( StringUtil . startsWithChar ( prefix ,     '  <  '  )  )  )     &  &     (  !  ( StringUtil . startsWithChar ( prefix ,     '  &  '  )  )  )  ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["shouldSkipAutopopupInHtml"], "fileName": "com.intellij.codeInsight.completion.HtmlTextCompletionConfidence"}, {"methodBody": ["METHOD_START", "{", "PsiElement   element    =    tagNameReference . getElement (  )  ;", "if    ( element   instanceof   XmlTag )     {", "if    (  !  ( tagNameReference . isStartTagFlag (  )  )  )     {", "consumer . consume (  . createClosingTagLookupElement (  (  ( XmlTag )     ( element )  )  ,    false ,    tagNameReference . getNameElement (  )  )  )  ;", "} else    {", "XmlTag   tag    =     (  ( XmlTag )     ( element )  )  ;", "for    ( LookupElement   variant    :     . getTagNameVariants ( tag ,    tag . getNamespacePrefix (  )  )  )     {", "consumer . consume ( variant )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["collectCompletionVariants"], "fileName": "com.intellij.codeInsight.completion.TagNameReferenceCompletionProvider"}, {"methodBody": ["METHOD_START", "{", "LookupElementBuilder   builder    =    LookupElementBuilder . create (  ( includePrefix    |  |     (  !  ( nameElement . getText (  )  . contains (  \"  :  \"  )  )  )     ?    tag . getName (  )     :    tag . getLocalName (  )  )  )  ;", "return   LookupElementDecorator . withInsertHandler ( TailTypeDecorator . withTail ( GIVE _ CHANCE _ TO _ OVERWRITE . applyPolicy ( builder )  ,    TailType . createSimpleTailType (  '  >  '  )  )  ,    XmlClosingTagInsertHandler . INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["createClosingTagLookupElement"], "fileName": "com.intellij.codeInsight.completion.TagNameReferenceCompletionProvider"}, {"methodBody": ["METHOD_START", "{", "List < LookupElement >    elements    =    new   ArrayList <  >  (  )  ;", "for    ( XmlTagName   tagName    :    XmlTagName . EP _ NAME . getExtensions (  )  )     {", "tagName . addTagNameVariants ( elements ,    tag ,    prefix )  ;", "}", "return   elements . toArray ( EMPTY _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["getTagNameVariants"], "fileName": "com.intellij.codeInsight.completion.TagNameReferenceCompletionProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( context . getNamespaceByPrefix ( basePrefix )  . isEmpty (  )  )     {", "return   basePrefix ;", "}", "int   i    =     1  ;", "while    (  !  ( context . getNamespaceByPrefix (  ( basePrefix    +    i )  )  . isEmpty (  )  )  )     {", "i +  +  ;", "}", "return   basePrefix    +    i ;", "}", "METHOD_END"], "methodName": ["makePrefixUnique"], "fileName": "com.intellij.codeInsight.completion.XmlAttributeInsertHandler"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   parent    =    context . getParent (  )  ;", "if    ( parent   instanceof   XmlAttribute )     {", "final   XmlAttribute   attribute    =     (  ( XmlAttribute )     ( parent )  )  ;", "final   String   prefix    =    attribute . getNamespacePrefix (  )  ;", "if    (  (  !  ( prefix . equals ( namespacePrefix )  )  )     &  &     ( StringUtil . isNotEmpty ( namespacePrefix )  )  )     {", "final   String   name    =     ( namespacePrefix    +     \"  :  \"  )     +     ( attribute . getLocalName (  )  )  ;", "try    {", "attribute . setName ( name )  ;", "}    catch    ( IncorrectOperationException   e )     {", ". LOG . error ( e )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["qualifyWithPrefix"], "fileName": "com.intellij.codeInsight.completion.XmlAttributeInsertHandler"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   declarationTag    =    reference . getElement (  )  . getParent (  )  ;", ". LOG . assertTrue ( declarationTag . isValid (  )  )  ;", "final   XmlElementDescriptor   parentDescriptor    =    declarationTag . getDescriptor (  )  ;", "if    ( parentDescriptor    !  =    null )     {", "final   XmlAttribute [  ]    attributes    =    declarationTag . getAttributes (  )  ;", "XmlAttributeDescriptor [  ]    descriptors    =    parentDescriptor . getAttributesDescriptors ( declarationTag )  ;", "descriptors    =    HtmlUtil . appendHtmlSpecificAttributeCompletions ( declarationTag ,    descriptors ,    reference . getElement (  )  )  ;", ". addVariants ( result ,    attributes ,    descriptors ,    reference . getElement (  )  ,    replacementInsertHandler )  ;", "}", "}", "METHOD_END"], "methodName": ["addAttributeReferenceCompletionVariants"], "fileName": "com.intellij.codeInsight.completion.XmlAttributeReferenceCompletionProvider"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    attribute . getParent (  )  ;", "final   PsiFile   file    =    tag . getContainingFile (  )  ;", "final   XmlExtension   extension    =    XmlExtension . getExtension ( file )  ;", "final   String   prefix    =     (  ( attribute . getName (  )  . contains (  \"  :  \"  )  )     &  &     (  (  (  ( XmlAttributeImpl )     ( attribute )  )  . getRealLocalName (  )  . length (  )  )     >     0  )  )     ?     ( attribute . getNamespacePrefix (  )  )     +     \"  :  \"     :    null ;", "for    ( XmlAttributeDescriptor   descriptor    :    descriptors )     {", "if    (  . isValidVariant ( attribute ,    descriptor ,    attributes ,    extension )  )     {", "String   name    =    descriptor . getName ( tag )  ;", "InsertHandler < LookupElement >    insertHandler    =    XmlAttributeInsertHandler . INSTANCE ;", "if    (  (  ( tag   instanceof   HtmlTag )     &  &     ( HtmlUtil . isShortNotationOfBooleanAttributePreferred (  )  )  )     &  &     ( HtmlUtil . isBooleanAttribute ( descriptor ,    tag )  )  )     {", "insertHandler    =    null ;", "}", "if    ( replacementInsertHandler    !  =    null )     {", "insertHandler    =    replacementInsertHandler ;", "} else", "if    ( descriptor   instanceof   com . intellij . xml . NamespaceAwareXmlAttributeDescriptor )     {", "final   String   namespace    =     (  ( com . intellij . xml . NamespaceAwareXmlAttributeDescriptor )     ( descriptor )  )  . getNamespace ( tag )  ;", "if    (  (  (  (  ( file   instanceof   com . intellij . psi . xml . XmlFile )     &  &     ( namespace    !  =    null )  )     &  &     (  ( namespace . length (  )  )     >     0  )  )     &  &     (  !  ( name . contains (  \"  :  \"  )  )  )  )     &  &     (  ( tag . getPrefixByNamespace ( namespace )  )     =  =    null )  )     {", "insertHandler    =    new   XmlAttributeInsertHandler ( namespace )  ;", "}", "}", "if    (  ( prefix    =  =    null )     |  |     ( name . startsWith ( prefix )  )  )     {", "if    (  ( prefix    !  =    null )     &  &     (  ( name . length (  )  )     >     ( prefix . length (  )  )  )  )     {", "name    =    descriptor . getName ( tag )  . substring ( prefix . length (  )  )  ;", "}", "LookupElementBuilder   element    =    LookupElementBuilder . create ( name )  ;", "if    ( descriptor   instanceof   PsiPresentableMetaData )     {", "element    =    element . withIcon (  (  ( PsiPresentableMetaData )     ( descriptor )  )  . getIcon (  )  )  ;", "}", "final   int   separator    =    name . indexOf (  '  :  '  )  ;", "if    ( separator    >     0  )     {", "element    =    element . withLookupString ( name . substring (  ( separator    +     1  )  )  )  ;", "}", "element    =    element . withCaseSensitivity (  (  (  !  ( descriptor   instanceof   HtmlAttributeDescriptorImpl )  )     |  |     (  (  ( HtmlAttributeDescriptorImpl )     ( descriptor )  )  . isCaseSensitive (  )  )  )  )  . withInsertHandler ( insertHandler )  ;", "result . addElement (  ( descriptor . isRequired (  )     ?    PrioritizedLookupElement . withPriority ( element . appendTailText (  \"  ( required )  \"  ,    true )  ,     1  0  0  )     :    HtmlUtil . isOwnHtmlAttribute ( descriptor )     ?    PrioritizedLookupElement . withPriority ( element ,     5  0  )     :    element )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["addVariants"], "fileName": "com.intellij.codeInsight.completion.XmlAttributeReferenceCompletionProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( extension . isIndirectSyntax ( descriptor )  )", "return   false ;", "String   descriptorName    =    descriptor . getName ( attribute . getParent (  )  )  ;", "if    ( descriptorName    =  =    null )     {", ". LOG . error (  (  (  (  (  \" Null   descriptor   name   for    \"     +    descriptor )     +     \"     \"  )     +     ( descriptor . getClass (  )  )  )     +     \"     \"  )  )  ;", "return   false ;", "}", "for    ( final   XmlAttribute   otherAttr    :    attributes )     {", "if    (  ( otherAttr    !  =    attribute )     &  &     ( otherAttr . getName (  )  . equals ( descriptorName )  )  )", "return   false ;", "}", "return    !  ( descriptorName . contains ( CompletionInitializationContext . DUMMY _ IDENTIFIER _ TRIMMED )  )  ;", "}", "METHOD_END"], "methodName": ["isValidVariant"], "fileName": "com.intellij.codeInsight.completion.XmlAttributeReferenceCompletionProvider"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText ( fileType ,    fileText )  ;", "type ( typeString )  ;", "assertNull ( getLookup (  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestNoPopup"], "fileName": "com.intellij.codeInsight.completion.XmlAutopopupTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText ( fileType ,    fileText )  ;", "type ( typeString )  ;", "assertNotNull ( getLookup (  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestPopup"], "fileName": "com.intellij.codeInsight.completion.XmlAutopopupTest"}, {"methodBody": ["METHOD_START", "{", "doTestPopup ( HtmlFileType . INSTANCE ,     \"  < div >  &  < caret >  <  / div >  \"  ,     \" t \"  )  ;", "}", "METHOD_END"], "methodName": ["testAfterAmpersand"], "fileName": "com.intellij.codeInsight.completion.XmlAutopopupTest"}, {"methodBody": ["METHOD_START", "{", "doTestPopup ( HtmlFileType . INSTANCE ,     \"  < div >  < caret >  <  / div >  \"  ,     \"  <  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAfterTagOpen"], "fileName": "com.intellij.codeInsight.completion.XmlAutopopupTest"}, {"methodBody": ["METHOD_START", "{", "doTestPopup ( XHtmlFileType . INSTANCE ,     \"  < div >  < caret >  <  / div >  \"  ,     \"  <  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAfterTagOpenXhtml"], "fileName": "com.intellij.codeInsight.completion.XmlAutopopupTest"}, {"methodBody": ["METHOD_START", "{", "doTestNoPopup ( HtmlFileType . INSTANCE ,     \"  < div >  \\  \"  < caret >  <  / div >  \"  ,     \" s \"  )  ;", "}", "METHOD_END"], "methodName": ["testDoNotShowPopupAfterQuotedSymbol"], "fileName": "com.intellij.codeInsight.completion.XmlAutopopupTest"}, {"methodBody": ["METHOD_START", "{", "doTestNoPopup ( HtmlFileType . INSTANCE ,     \"  < div >  < caret >  <  / div >  \"  ,     \" p \"  )  ;", "}", "METHOD_END"], "methodName": ["testDoNotShowPopupInText"], "fileName": "com.intellij.codeInsight.completion.XmlAutopopupTest"}, {"methodBody": ["METHOD_START", "{", "doTestNoPopup ( XHtmlFileType . INSTANCE ,     \"  < div >  < caret >  <  / div >  \"  ,     \" p \"  )  ;", "}", "METHOD_END"], "methodName": ["testDoNotShowPopupInTextXhtml"], "fileName": "com.intellij.codeInsight.completion.XmlAutopopupTest"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( lookup . isCompletion (  )  )  )", "return   false ;", "PsiElement   psiElement    =    lookup . getPsiElement (  )  ;", "PsiFile   file    =    lookup . getPsiFile (  )  ;", "if    (  (  !  ( file   instanceof   XmlFile )  )     &  &     ( psiElement    !  =    null )  )     {", "file    =    psiElement . getContainingFile (  )  ;", "}", "if    ( file   instanceof   XmlFile )     {", "if    ( psiElement    !  =    null )     {", "PsiElement   elementToTest    =    psiElement ;", "if    ( elementToTest   instanceof   PsiWhiteSpace )     {", "elementToTest    =    elementToTest . getParent (  )  ;", "}", "final   Language   language    =    elementToTest . getLanguage (  )  ;", "if    (  !  ( language   instanceof   XMLLanguage )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isInXmlContext"], "fileName": "com.intellij.codeInsight.completion.XmlCharFilter"}, {"methodBody": ["METHOD_START", "{", "if    ( XmlCharFilter . isInXmlContext ( lookup )  )     {", "PsiElement   psiElement    =    lookup . getPsiElement (  )  ;", "final   PsiElement   parentElement    =     ( psiElement    !  =    null )     ?    psiElement . getParent (  )     :    null ;", "if    ( parentElement   instanceof   XmlTag )", "return   true ;", "if    (  ( parentElement   instanceof   PsiErrorElement )     &  &     (  ( parentElement . getParent (  )  )    instanceof   XmlDocument )  )", "return   true ;", "return    (  ( parentElement   instanceof   XmlDocument )     |  |     ( parentElement   instanceof   XmlText )  )     &  &     (  ( psiElement . textMatches (  \"  <  \"  )  )     |  |     ( psiElement . textMatches (  \"  \\  \"  \"  )  )  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isWithinTag"], "fileName": "com.intellij.codeInsight.completion.XmlCharFilter"}, {"methodBody": ["METHOD_START", "{", "XmlFile   containingFile    =    null ;", "XmlFile   descriptorFile    =    null ;", "final   XmlTag   tag    =    PsiTreeUtil . getParentOfType ( context ,    XmlTag . class )  ;", "if    ( tag    !  =    null )     {", "containingFile    =     (  ( XmlFile )     ( tag . getContainingFile (  )  )  )  ;", "descriptorFile    =    XmlUtil . findDescriptorFile ( tag ,    containingFile )  ;", "}", "if    ( HtmlUtil . isHtml 5 Context ( tag )  )     {", "descriptorFile    =    XmlUtil . findXmlFile ( containingFile ,    Html 5 SchemaProvider . getCharsDtdLocation (  )  )  ;", "} else", "if    ( tag    =  =    null )     {", "final   com . intellij . psi . xml . XmlDocument   document    =    PsiTreeUtil . getParentOfType ( context ,    com . intellij . psi . xml . XmlDocument . class )  ;", "if    ( document    !  =    null )     {", "containingFile    =     (  ( XmlFile )     ( document . getContainingFile (  )  )  )  ;", "final   com . intellij . openapi . fileTypes . FileType   ft    =    containingFile . getFileType (  )  ;", "if    ( HtmlUtil . isHtml 5 Document ( document )  )     {", "descriptorFile    =    XmlUtil . findXmlFile ( containingFile ,    Html 5 SchemaProvider . getCharsDtdLocation (  )  )  ;", "} else", "if    ( ft    !  =     ( StdFileTypes . XML )  )     {", "final   String   namespace    =     (  ( ft    =  =     ( StdFileTypes . XHTML )  )     |  |     ( ft    =  =     ( StdFileTypes . JSPX )  )  )     ?    XmlUtil . XHTML _ URI    :    XmlUtil . HTML _ URI ;", "final   com . intellij . xml . XmlNSDescriptor   nsDescriptor    =    document . getDefaultNSDescriptor ( namespace ,    true )  ;", "if    ( nsDescriptor    !  =    null )     {", "descriptorFile    =    nsDescriptor . getDescriptorFile (  )  ;", "}", "}", "}", "}", "if    (  ( descriptorFile    !  =    null )     &  &     ( containingFile    !  =    null )  )     {", "final   boolean   acceptSystemEntities    =     ( containingFile . getFileType (  )  )     =  =     ( StdFileTypes . XML )  ;", "final   PsiElementProcessor   processor    =    new   PsiElementProcessor (  )     {", "@ Override", "public   boolean   execute (  @ NotNull", "final   PsiElement   element )     {", "if    ( element   instanceof   XmlEntityDecl )     {", "final   XmlEntityDecl   xmlEntityDecl    =     (  ( XmlEntityDecl )     ( element )  )  ;", "if    (  ( xmlEntityDecl . isInternalReference (  )  )     |  |    acceptSystemEntities )     {", "final   LookupElementBuilder    _ item    =     . buildEntityLookupItem ( xmlEntityDecl )  ;", "if    (  _ item    !  =    null )     {", "resultSet . addElement (  _ item )  ;", "resultSet . stopHere (  )  ;", "}", "}", "}", "return   true ;", "}", "}  ;", "XmlUtil . processXmlElements ( descriptorFile ,    processor ,    true )  ;", "if    (  ( descriptorFile    !  =    containingFile )     &  &    acceptSystemEntities )     {", "final   XmlProlog   element    =    containingFile . getDocument (  )  . getProlog (  )  ;", "if    ( element    !  =    null )", "XmlUtil . processXmlElements ( element ,    processor ,    true )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addEntityRefCompletions"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    decl . getName (  )  ;", "if    ( name    =  =    null )     {", "return   null ;", "}", "final   LookupElementBuilder   result    =    LookupElementBuilder . create ( name )  . withInsertHandler (  . ENTITY _ INSERT _ HANDLER )  ;", "final   XmlAttributeValue   value    =    decl . getValueElement (  )  ;", "final   ASTNode   node    =    value . getNode (  )  ;", "if    ( node    !  =    null )     {", "final   ASTNode [  ]    nodes    =    node . getChildren ( TokenSet . create ( XmlTokenType . XML _ CHAR _ ENTITY _ REF )  )  ;", "if    (  ( nodes . length )     =  =     1  )     {", "final   String   valueText    =    nodes [  0  ]  . getText (  )  ;", "final   int   i    =    valueText . indexOf (  '  #  '  )  ;", "if    ( i    >     0  )     {", "String   s    =    valueText . substring (  ( i    +     1  )  )  ;", "s    =    StringUtil . trimEnd ( s ,     \"  ;  \"  )  ;", "try    {", "final   int   unicodeChar    =    Integer . valueOf ( s )  . intValue (  )  ;", "return   result . withTypeText ( String . valueOf (  (  ( char )     ( unicodeChar )  )  )  )  ;", "}    catch    ( NumberFormatException   e )     {", "return   result ;", "}", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["buildEntityLookupItem"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "PsiElement   element    =    parameters . getPosition (  )  ;", "if    (  !  (  . isXmlNameCompletion ( parameters )  )  )", "return ;", "PsiElement   parent    =    element . getParent (  )  ;", "if    (  (  !  ( parent   instanceof   XmlTag )  )     |  |     (  !  (  ( parameters . getOriginalFile (  )  )    instanceof   XmlFile )  )  )     {", "return ;", "}", "result . stopHere (  )  ;", "final   XmlTag   tag    =     (  ( XmlTag )     ( parent )  )  ;", "final   String   namespace    =    tag . getNamespace (  )  ;", "final   String   prefix    =    result . getPrefixMatcher (  )  . getPrefix (  )  ;", "final   int   pos    =    prefix . indexOf (  '  :  '  )  ;", "final   PsiReference   reference    =    tag . getReference (  )  ;", "String   namespacePrefix    =    tag . getNamespacePrefix (  )  ;", "if    (  (  ( reference    !  =    null )     &  &     (  !  ( namespace . isEmpty (  )  )  )  )     &  &     (  !  ( namespacePrefix . isEmpty (  )  )  )  )     {", "result . runRemainingContributors ( parameters ,    true )  ;", "} else    {", "final   CompletionResultSet   newResult    =    result . withPrefixMatcher (  ( pos    >  =     0     ?    prefix . substring (  ( pos    +     1  )  )     :    prefix )  )  ;", "final   XmlFile   file    =     (  ( XmlFile )     ( parameters . getOriginalFile (  )  )  )  ;", "final   List < XmlExtension . TagInfo >    names    =    XmlExtension . getExtension ( file )  . getAvailableTagNames ( file ,    tag )  ;", "for    ( XmlExtension . TagInfo   info    :    names )     {", "final   LookupElement   item    =     . createLookupElement ( info ,    info . namespace ,     ( namespacePrefix . isEmpty (  )     ?    null    :    namespacePrefix )  )  ;", "newResult . addElement ( item )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["completeTagName"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "LookupElementBuilder   builder    =    LookupElementBuilder . create ( tagInfo ,    tagInfo . name )  . withInsertHandler ( new   ExtendedTagInsertHandler ( tagInfo . name ,    tagInfo . namespace ,    namespacePrefix )  )  ;", "if    (  !  ( StringUtil . isEmpty ( tailText )  )  )     {", "builder    =    builder . withTypeText ( tailText ,    true )  ;", "}", "return   builder ;", "}", "METHOD_END"], "methodName": ["createLookupElement"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "Ref < Boolean >    hasRef    =    Ref . create ( false )  ;", "Legacy . processReferences ( parameters ,    result ,     (    reference ,    resultSet )     -  >     {", "if    ( reference   instanceof   XmlEnumeratedValueReference )     {", "hasRef . set ( true )  ;", "}", "}  )  ;", "return   hasRef . get (  )  ;", "}", "METHOD_END"], "methodName": ["hasEnumerationReference"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   node    =    parameters . getPosition (  )  . getNode (  )  ;", "return    ( node    !  =    null )     &  &     (  ( node . getElementType (  )  )     =  =     ( XmlTokenType . XML _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["isXmlNameCompletion"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "configureByFiles (  ( testName    +     \"  . xml \"  )  ,     ( testName    +     \"  . xsd \"  )  ,     ( testName    +     \"  - vm . xsd \"  )  ,     ( testName    +     \"  - jms . xsd \"  )  ,     ( testName    +     \"  - stdio . xsd \"  )  ,     ( testName    +     \"  - schemadoc . xsd \"  )  )  ;", "e (  )  ;", "checkResultByFile (  ( testName    +     \"  _ after . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["_testIDEADEV_32773"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "final   ExternalResourceManager   manager    =    ExternalResourceManager . getInstance (  )  ;", "final   String   old    =    manager . getResourceLoca ( url ,     (  ( String )     ( null )  )  )  ;", "if    (  ( old    !  =    null )     &  &     ( old    !  =    url )  )     {", "return ;", "}", "ExternalResourceManagerExImpl . addTestResource ( url ,    loca ,    myFixture . getTestRootDisposable (  )  )  ;", "}", "METHOD_END"], "methodName": ["addResource"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =     ( getTestName ( false )  )     +    ext ;", "configureByFile (  ( testName    +     \"  . xml \"  )  )  ;", "checkResultByFile (  ( testName    +     \"  _ after . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["basicDoTest"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . checkResultByFile ( s )  ;", "}", "METHOD_END"], "methodName": ["checkResultByFile"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "return   myFixture . completeBasic (  )  ;", "}", "METHOD_END"], "methodName": ["complete"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile ( s )  ;", "myFixtureeBasic (  )  ;", "}", "METHOD_END"], "methodName": ["configureByFile"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFiles ( files )  ;", "}", "METHOD_END"], "methodName": ["configureByFiles"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  ( name    +     \"  . dtd \"  )  )  ;", "checkResultByFile (  ( name    +     \"  _ after . dtd \"  )  )  ;", "}", "METHOD_END"], "methodName": ["doCompletionTest"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "addResource ( url ,    location )  ;", "configureByFiles (  (  ( testName    +     \"  .  \"  )     +    ext )  ,    location )  ;", "e (  )  ;", "checkResultByFile (  (  ( testName    +     \"  _ after .  \"  )     +    ext )  )  ;", "}", "METHOD_END"], "methodName": ["doCompletionTest"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "return   CodeStyle . getSettings ( myFixture . getProject (  )  )  . getCustomSettings ( HtmlCodeStyleSettings . class )  ;", "}", "METHOD_END"], "methodName": ["getHtmlSettings"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "final   LookupImpl   lookup    =     (  ( LookupImpl )     ( LookupManager . getActiveLookup ( myFixture . getEditor (  )  )  )  )  ;", "lookup . setCurrentItem ( element )  ;", "lookup . finishLookup ( ch )  ;", "}", "METHOD_END"], "methodName": ["selectItem"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . testCompletion (  \" Substitute / testAfterPrefix . xml \"  ,     \" Substitute / testAfterPrefix _ after . xml \"  ,     \" Substitute / schema - a . xsd \"  ,     \" Substitute / schema - b . xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testAfterPrefix"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  (  ( getTestName ( false )  )     +     \"  . xml \"  )  )  ;", "e (  )  ;", "assertEmpty ( myFixture . getLookupElements (  )  )  ;", "checkResultByFile (  (  ( getTestName ( false )  )     +     \"  _ after . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeNameInAttributeValue"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "boolean   oldInsertQuotes    =    WebEditorOptions . getInstance (  )  . isInsertQuotesForAttributeValue (  )  ;", "WebEditorOptions . getInstance (  )  . setInsertQuotesForAttributeValue ( false )  ;", "try    {", "configureByFile (  (  ( getTestName ( false )  )     +     \"  . xml \"  )  )  ;", "selectItem ( myFixture . getLookupElements (  )  [  0  ]  ,     '  \\ t '  )  ;", "checkResultByFile (  (  ( getTestName ( false )  )     +     \"  _ after . xml \"  )  )  ;", "}    finally    {", "WebEditorOptions . getInstance (  )  . setInsertQuotesForAttributeValue ( oldInsertQuotes )  ;", "}", "}", "METHOD_END"], "methodName": ["testAttributeNoQuotes"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText (  \" foo . xml \"  ,     (  \"  < schema   xmlns =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \\ n \"     +     (  \"              < element   name =  \\  \" a \\  \"    abstract =  < caret >  \\  \"  \\  \"  /  >  \\ n \"     +     \"  <  / schema >  \"  )  )  )  ;", "LookupElement [  ]    elements    =    myFixtureeBasic (  )  ;", "assertEquals (  0  ,    elements . length )  ;", "}", "METHOD_END"], "methodName": ["testAttributeValueToken"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFiles (  \" foo . xsd \"  ,     \" bar . xsd \"  )  ;", "basicDo (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeWildcardFromAnotherNamespace"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "TemplateManagerImpl . setTemplateTesting ( getProject (  )  ,    myFixture . getTestRootDisposable (  )  )  ;", "configureByFile (  (  ( getTestName ( false )  )     +     \"  . xml \"  )  )  ;", "type (  ' b '  )  ;", "type (  ' e '  )  ;", "type (  ' a '  )  ;", "type (  ' n '  )  ;", "type (  '     '  )  ;", "checkResultByFile (  (  ( getTestName ( false )  )     +     \"  _ after . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributesTemplateFinishWithSpace"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  (  ( getTestName ( true )  )     +     \"  . xml \"  )  )  ;", "selectItem ( myFixture . getLookupElements (  )  [  0  ]  ,     '  \\ t '  )  ;", "checkResultByFile (  (  ( getTestName ( true )  )     +     \"  _ after . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBeforeAttributeNameWithPrefix"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  (  ( getTestName ( true )  )     +     \"  . xml \"  )  )  ;", "assertEmpty ( myFixture . getLookupElements (  )  )  ;", "checkResultByFile (  (  ( getTestName ( true )  )     +     \"  . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBeforeAttributeValue"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "final   int   old    =    CodeInsightSettings . getInstance (  )  . COMPLETION _ CASE _ SENSITIVE ;", "CodeInsightSettings . getInstance (  )  . COMPLETION _ CASE _ SENSITIVE    =    CodeInsightSettings . NONE ;", "String   location    =     \"  3  0  . dtd \"  ;", "try    {", "addResource ( location ,    location )  ;", "configureByFiles (  \"  3  0  . xml \"  ,    location )  ;", "complete (  )  ;", "assertOrderedEquals ( myFixture . getLookupElementStrings (  )  ,     \" map \"  ,     \" Map \"  )  ;", "}    finally    {", "CodeInsightSettings . getInstance (  )  . COMPLETION _ CASE _ SENSITIVE    =    old ;", "}", "}", "METHOD_END"], "methodName": ["testCasePreference"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . addClass (  \" package   foo ;    public   class   SomeClass    {  }  \"  )  ;", "final   String   testName    =    getTestName ( false )  ;", "myFixture . configureByFile (  ( testName    +     \"  . xml \"  )  )  ;", "myFixturee ( BASIC ,     2  )  ;", "selectItem ( assertOneElement ( myFixture . getLookupElements (  )  )  ,    NORMAL _ SELECT _ CHAR )  ;", "checkResultByFile (  ( testName    +     \"  _ after . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testClassNamesOutrankWords"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  (  ( getTestName ( false )  )     +     \"  . xml \"  )  )  ;", "type (  ' f '  )  ;", "type (  ' o '  )  ;", "type (  ' o '  )  ;", "type (  '  :  '  )  ;", "assertNotNull ( LookupManager . getActiveLookup ( myFixture . getEditor (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testColonInTagName"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "configureByFiles (  ( testName    +     \"  . xml \"  )  ,     ( testName    +     \"  _ importedSchema . xsd \"  )  ,     ( testName    +     \"  _ outerSchema . xsd \"  )  )  ;", "e (  )  ;", "checkResultByFile (  ( testName    +     \"  _ after . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteEnumeration"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFiles (  \" foo . xsd \"  ,     \" bar . xsd \"  )  ;", "basicDo (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteQualifiedTopLevelTags"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "String   url    =     \" urn : test \"  ;", "do (  \" xml \"  ,    url ,     ( testName    +     \"  . xsd \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteTagWithXsiTypeInParent"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "boolean   old    =    CodeInsightSettings . getInstance (  )  . AUTOCOMPLETE _ ON _ CODE _ COMPLETION ;", "CodeInsightSettings . getInstance (  )  . AUTOCOMPLETE _ ON _ CODE _ COMPLETION    =    false ;", "try    {", "final   String   testName    =    getTestName ( false )  ;", "configureByFiles (  ( testName    +     \"  . xml \"  )  ,     ( testName    +     \"  . xsd \"  )  )  ;", "complete (  )  ;", "selectItem ( myFixture . getLookupElements (  )  [  0  ]  ,     '  \\  \"  '  )  ;", "checkResultByFile (  ( testName    +     \"  _ after . xml \"  )  )  ;", "}    finally    {", "CodeInsightSettings . getInstance (  )  . AUTOCOMPLETE _ ON _ CODE _ COMPLETION    =    old ;", "}", "}", "METHOD_END"], "methodName": ["testCompleteWhenNoNsSchemaLocation"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "configureByFiles (  ( testName    +     \"  . xml \"  )  ,     ( testName    +     \"  . xsd \"  )  )  ;", "e (  )  ;", "checkResultByFile (  ( testName    +     \"  _ after . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteWhenUnqualifiedElements"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "String   location    =     \"  2  9  . xsd \"  ;", "addResource (  \" aaa \"  ,    location )  ;", "configureByFiles (  \"  2  9  . xml \"  ,    location )  ;", "e (  )  ;", "checkResultByFile (  \"  2  9  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteWithAnyInSchema"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFiles (  \"  3  2  . xml \"  ,     \"  3  2  . xsd \"  ,     \"  3  2  _  2  . xsd \"  )  ;", "e (  )  ;", "checkResultByFile (  \"  /  3  2  _ after . xml \"  )  ;", "configureByFiles (  \"  3  2  _  2  . xml \"  ,     \"  3  2  . xsd \"  ,     \"  3  2  _  2  . xsd \"  )  ;", "e (  )  ;", "checkResultByFile (  \"  3  2  _  2  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteWithAnyInSchema2"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "addResource (  \" http :  /  / www . springframework . org / schema / tx \"  ,     (  ( getTestDataPath (  )  )     +     \"  / spring - tx -  2  .  0  . xsd \"  )  )  ;", "addResource (  \" http :  /  / www . springframework . org / schema / util \"  ,     (  ( getTestDataPath (  )  )     +     \"  / spring - util -  2  .  0  . xsd \"  )  )  ;", "configureByFiles (  \"  3  6  . xml \"  )  ;", "e (  )  ;", "checkResultByFile (  \"  3  6  _ after . xml \"  )  ;", "configureByFiles (  \"  3  6  _  2  . xml \"  )  ;", "e (  )  ;", "checkResultByFile (  \"  3  6  _  2  _ after . xml \"  )  ;", "configureByFiles (  \"  3  6  _  3  . xml \"  )  ;", "e (  )  ;", "myFixture . type (  '  \\ n '  )  ;", "checkResultByFile (  \"  3  6  _  3  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteWithAnyInSchema3"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFiles (  (  ( getTestName ( false )  )     +     \"  . xml \"  )  ,     \" mule . xsd \"  ,     \" mule - management . xsd \"  )  ;", "e (  )  ;", "myFixture . type (  '  \\ n '  )  ;", "checkResultByFile (  (  ( getTestName ( false )  )     +     \"  _ after . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteWithSubstitutionGroup"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . addClass (  \" public   class   ABxxZ    {  }  \"  )  ;", "final   String   testName    =    getTestName ( false )  ;", "myFixture . configureByFile (  ( testName    +     \"  . xml \"  )  )  ;", "myFixturee ( BASIC ,     2  )  ;", "assertEquals (  \" ABxxZ \"  ,    myFixture . getLookupElements (  )  [  0  ]  . getLookupString (  )  )  ;", "assertEquals (  \" ABxxCDEF \"  ,    myFixture . getLookupElements (  )  [  1  ]  . getLookupString (  )  )  ;", "selectItem ( myFixture . getLookupElements (  )  [  1  ]  ,    NORMAL _ SELECT _ CHAR )  ;", "checkResultByFile (  ( testName    +     \"  _ after . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteWords"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "basicDoTest (  \"  \"  )  ;", "basicDoTest (  \"  _  2  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteXmlLang"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "addResource (  \" http :  /  / maven . apache . org / xsd / archetype - descriptor -  1  .  0  .  0  . xsd \"  ,     (  ( getTestDataPath (  )  )     +     \" archetype - descriptor -  1  .  0  .  0  . xsd \"  )  )  ;", "basicDoTest (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteXmlTag"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "basicDoTest (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteXsl"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  \" CorrectPrefixInsertion . xml \"  )  ;", "checkResultByFile (  \" CorrectPrefixInsertion _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testCorrectPrefixInsertion"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "(  ( StatisticsManagerImpl )     ( StatisticsManager . getInstance (  )  )  )  . enableStatistics ( myFixture . getTestRootDisposable (  )  )  ;", "addResource (  \" http :  /  / hibernate . sourcefnet / hibernate - mapping -  3  .  0  . dtd \"  ,     (  ( getTestDataPath (  )  )     +     \"  / hibernate - mapping -  3  .  0  . dtd \"  )  )  ;", "configureByFile (  \" CorrectSelectionInsertion . xml \"  )  ;", "selectItem ( myFixture . getLookupElements (  )  [  4  ]  ,     '  \\ t '  )  ;", "checkResultByFile (  \" CorrectSelectionInsertion _ after . xml \"  )  ;", "StatisticsUpdate . applyLastStatisticsUpdate (  )  ;", "configureByFile (  \" CorrectSelectionInsertion 2  . xml \"  )  ;", "myFixture . getEditor (  )  . getSelectionModel (  )  . removeSelection (  )  ;", "selectItem ( myFixture . getLookupElements (  )  [  0  ]  ,     '  \\ t '  )  ;", "checkResultByFile (  \" CorrectSelectionInsertion 2  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testCorrectSelectionInsertion"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  \" doNotInsertClosingTagB 4 Text . xml \"  )  ;", "selectItem ( myFixture . getLookupElements (  )  [  0  ]  ,     '  >  '  )  ;", "checkResultByFile (  \" doNotInsertClosingTagB 4 Text _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testDoNotInsertClosingTagB4Text"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  \" doNotInsertClosingTagWithoutTagName . xml \"  )  ;", "type (  '  >  '  )  ;", "checkResultByFile (  \" doNotInsertClosingTagWithoutTagName _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testDoNotInsertClosingTagWithoutTagName"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText (  \" foo . xsd \"  ,     (  \"  < xs : schema   xmlns : xs =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \\ n \"     +     (  \"              <  < caret >  \\ n \"     +     \"  <  / xs : schema >  \"  )  )  )  ;", "myFixtureeBasic (  )  ;", "assertSameElements ( myFixture . getLookupElementStrings (  )  ,     \" xs : annotation \"  ,     \" xs : attribute \"  ,     \" xs : attributeGroup \"  ,     \" xs : complexType \"  ,     \" xs : element \"  ,     \" xs : group \"  ,     \" xs : import \"  ,     \" xs : include \"  ,     \" xs : notation \"  ,     \" xs : redefine \"  ,     \" xs : simpleType \"  )  ;", "}", "METHOD_END"], "methodName": ["testDoNotProcessAnyInRestrictions"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "basicDoTest (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testDoNotSuggestAbstractElementsFromSchema"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  \" DoNotSuggestExistingAttributes . xml \"  )  ;", "myFixtureeBasic (  )  ;", "List < String >    strings    =    myFixture . getLookupElementStrings (  )  ;", "assertNotNull ( strings )  ;", "assertFalse ( strings . contains (  \" xsi : schemaLocation \"  )  )  ;", "assertSameElements ( strings ,     \" attributeFormDefault \"  ,     \" blockDefault \"  ,     \" elementFormDefault \"  ,     \" finalDefault \"  ,     \" id \"  ,     \" targetNamespace \"  ,     \" version \"  ,     \" xml : base \"  ,     \" xml : id \"  ,     \" xml : lang \"  ,     \" xml : space \"  ,     \" xsi : nill \"  ,     \" xsi : noNamespaceSchemaLocation \"  ,     \" xsi : type \"  )  ;", "}", "METHOD_END"], "methodName": ["testDoNotSuggestExistingAttributes"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "basicDoTest (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testDoNotSuggestTagsFromOtherNsInXslt"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "configureByFile (  ( testName    +     \"  . xml \"  )  )  ;", "myFixture . type (  '  \\ n '  )  ;", "checkResultByFile (  ( testName    +     \"  _ after . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testDoNotSuggestTagsFromOtherNsInXslt_2"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "configureByFile (  ( testName    +     \"  . xml \"  )  )  ;", "myFixture . type (  '  \\ n '  )  ;", "checkResultByFile (  ( testName    +     \"  _ after . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testDoNotSuggestTagsFromOtherNsInXslt_3"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "basicDoTest (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testDoNotSuggestTagsInXHtml"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "final   String   baseTestFileName    =    getTestName ( false )  ;", "configureByFile (  ( baseTestFileName    +     \"  . dtd \"  )  )  ;", "selectItem ( myFixture . getLookupElements (  )  [  0  ]  ,     (  ( char )     (  0  )  )  )  ;", "checkResultByFile (  ( baseTestFileName    +     \"  _ after . dtd \"  )  )  ;", "do (  ( baseTestFileName    +     \"  2  \"  )  )  ;", "configureByFile (  ( baseTestFileName    +     \"  3  . dtd \"  )  )  ;", "checkResultByFile (  ( baseTestFileName    +     \"  3  _ after . dtd \"  )  )  ;", "configureByFile (  ( baseTestFileName    +     \"  4  . dtd \"  )  )  ;", "checkResultByFile (  ( baseTestFileName    +     \"  4  _ after . dtd \"  )  )  ;", "configureByFile (  ( baseTestFileName    +     \"  5  . dtd \"  )  )  ;", "checkResultByFile (  ( baseTestFileName    +     \"  5  _ after . dtd \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testDtdCompletion"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "String   location    =     \"  2  1  . xsd \"  ;", "String   location 2     =     \"  2  1  _  2  . xsd \"  ;", "addResource ( location ,    location )  ;", "addResource ( location 2  ,    location 2  )  ;", "configureByFiles (  \"  2  1  . xml \"  ,    location ,    location 2  )  ;", "e (  )  ;", "checkResultByFile (  \"  2  1  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testElementFromSchemaIncludeCompletion"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "boolean   old    =    CodeInsightSettings . getInstance (  )  . AUTOCOMPLETE _ ON _ CODE _ COMPLETION ;", "CodeInsightSettings . getInstance (  )  . AUTOCOMPLETE _ ON _ CODE _ COMPLETION    =    false ;", "try    {", "configureByFile (  \"  2  7  . xsd \"  )  ;", "selectItem ( myFixture . getLookupElements (  )  [  0  ]  ,     '  \\  '  '  )  ;", "checkResultByFile (  \"  2  7  _ after . xsd \"  )  ;", "}    finally    {", "CodeInsightSettings . getInstance (  )  . AUTOCOMPLETE _ ON _ CODE _ COMPLETION    =    old ;", "}", "}", "METHOD_END"], "methodName": ["testElementRefCompletionInSchema"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  \"  1  3  . xml \"  )  ;", "checkResultByFile (  \"  1  3  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testEntityRefCompletion"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFiles (  \"  2  8  . xml \"  ,     \"  2  8  . ent \"  )  ;", "e (  )  ;", "type (  '  \\ n '  )  ;", "checkResultByFile (  \"  2  8  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testEntityRefCompletion2"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  \"  1  3  _  3  . xml \"  )  ;", "checkResultByFile (  \"  1  3  _  3  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testEntityRefCompletion3"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  \"  1  3  _  2  . xml \"  )  ;", "checkResultByFile (  \"  1  3  _  2  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testEntityRefCompletion_2"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  \" tagValue / enumerated . xsd \"  )  ;", "myFixture . testVariants (  \" tagValue / completeEnum . xml \"  ,     \" none \"  ,     \" standard \"  )  ;", "myFixture . testVariants (  \" tagValue / completeBoolean . xml \"  ,     \" false \"  ,     \" true \"  )  ;", "}", "METHOD_END"], "methodName": ["testEnumeratedTagValue"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  \"  1  5  . xml \"  )  ;", "checkResultByFile (  \"  1  5  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testFilePathCompletionInSchema"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  \"  1  4  . xml \"  )  ;", "checkResultByFile (  \"  1  4  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testFilePathCompletionInSystem"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFiles (  \" InheritedAttr / test . xsd \"  ,     \" InheritedAttr / library . xsd \"  )  ;", "myFixture . testVariants (  \" InheritedAttr / test . xml \"  ,     \" buz \"  ,     \" library : boo \"  ,     \" xml : base \"  ,     \" xml : id \"  ,     \" xml : lang \"  ,     \" xml : space \"  )  ;", "}", "METHOD_END"], "methodName": ["testInheritedAttribute"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  \"  3  7  . xml \"  )  ;", "selectItem ( myFixture . getLookupElements (  )  [  0  ]  ,     '  \\ t '  )  ;", "checkResultByFile (  \"  3  7  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testInsertExtraRequiredAttribute"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "final   HtmlCodeStyleSettings   settings    =    getHtmlSettings (  )  ;", "final   CodeStyleSettings . QuoteStyle   quote    =    settings . HTML _ QUOTE _ STYLE ;", "try    {", "settings . HTML _ QUOTE _ STYLE    =    QuoteStyle . None ;", "configureByFile (  (  ( getTestName ( true )  )     +     \"  . html \"  )  )  ;", "checkResultByFile (  (  ( getTestName ( true )  )     +     \"  _ after . html \"  )  )  ;", "}    finally    {", "settings . HTML _ QUOTE _ STYLE    =    quote ;", "}", "}", "METHOD_END"], "methodName": ["testInsertExtraRequiredAttributeNoneQuote"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "final   HtmlCodeStyleSettings   settings    =    getHtmlSettings (  )  ;", "final   CodeStyleSettings . QuoteStyle   quote    =    settings . HTML _ QUOTE _ STYLE ;", "try    {", "settings . HTML _ QUOTE _ STYLE    =    QuoteStyle . Single ;", "configureByFile (  (  ( getTestName ( true )  )     +     \"  . html \"  )  )  ;", "checkResultByFile (  (  ( getTestName ( true )  )     +     \"  _ after . html \"  )  )  ;", "}    finally    {", "settings . HTML _ QUOTE _ STYLE    =    quote ;", "}", "}", "METHOD_END"], "methodName": ["testInsertExtraRequiredAttributeSingleQuote"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "List < String >    variants    =    myFixture . getCompletionVariants (  \" MultipleImports / agg . xsd \"  ,     \" MultipleImports / toimport 1  . xsd \"  ,     \" MultipleImports / toimport 2  . xsd \"  )  ;", "assertSameElements ( variants ,     \" int \"  ,     \" integer \"  ,     \" invisibleType \"  )  ;", "}", "METHOD_END"], "methodName": ["testMultipleImports"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText (  \" foo . xml \"  ,     \"  < schema   xmlns =  \\  \"  < caret >  \\  \"  /  >  \"  )  ;", "LookupElement [  ]    elements    =    myFixtureeBasic (  )  ;", "assertEquals (  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \"  ,    elements [  0  ]  . getLookupString (  )  )  ;", "myFixture . configureByText (  \" unknown . xml \"  ,     \"  < unknown _ tag _ name   xmlns =  \\  \"  < caret >  \\  \"  /  >  \"  )  ;", "myFixtureeBasic (  )  ;", "assertTrue (  (  ( myFixture . getLookupElementStrings (  )  . size (  )  )     >     3  )  )  ;", "}", "METHOD_END"], "methodName": ["testNamespaceCompletion"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "TemplateManagerImpl . setTemplateTesting ( getProject (  )  ,    myFixture . getTestRootDisposable (  )  )  ;", "configureByFile (  (  ( getTestName ( false )  )     +     \"  . xml \"  )  )  ;", "type (  ' d '  )  ;", "type (  ' e '  )  ;", "type (  '     '  )  ;", "checkResultByFile (  (  ( getTestName ( false )  )     +     \"  _ after . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testNoAttributesTemplateFinishWithSpace"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "basicDoTest (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNoFixedAttrComplete"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText (  \" foo . xml \"  ,     \"  <  < caret >  \"  )  ;", "myFixtureeBasic (  )  ;", "myFixture . type (  '  ?  '  )  ;", "myFixture . type (  '  \\ n '  )  ;", "myFixture . checkResult (  \"  <  ? xml   version =  \\  \"  1  .  0  \\  \"    encoding =  \\  \"  < caret >  \\  \"     ?  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testPi"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText (  \" foo . html \"  ,     \"  < img    < caret >  \"  )  ;", "myFixtureeBasic (  )  ;", "List < String >    strings    =    myFixture . getLookupElementStrings (  )  ;", "assertNotNull ( strings )  ;", "assertEquals (  \" alt \"  ,    strings . get (  0  )  )  ;", "assertEquals (  \" src \"  ,    strings . get (  1  )  )  ;", "assertEquals (  \" align \"  ,    strings . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["testRequiredAttributesOnTop"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "boolean   old    =    CodeInsightSettings . getInstance (  )  . AUTOCOMPLETE _ ON _ CODE _ COMPLETION ;", "CodeInsightSettings . getInstance (  )  . AUTOCOMPLETE _ ON _ CODE _ COMPLETION    =    false ;", "try    {", "myFixture . configureByText (  \" foo . xml \"  ,     \"  < schem < caret >  \"  )  ;", "myFixture . completeBasic (  )  ;", "myFixture . type (  '  \\ n '  )  ;", "myFixture . checkResult (  \"  < schema   xmlns =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  < caret >  \"  )  ;", "}    finally    {", "CodeInsightSettings . getInstance (  )  . AUTOCOMPLETE _ ON _ CODE _ COMPLETION    =    old ;", "}", "}", "METHOD_END"], "methodName": ["testRootTagCompletion"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  \" SchemaBooleanCompletion . xsd \"  )  ;", "checkResultByFile (  \" SchemaBooleanCompletion _ after . xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testSchemaBooleanCompletion"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "addResource (  \" http :  /  / com / xml / ns / j 2 ee / web - app _  2  _  4  . xsd \"  ,     (  ( getTestDataPath (  )  )     +     \"  / web - app _  2  _  4  . xsd \"  )  )  ;", "configureByFile (  \"  1  2  . xml \"  )  ;", "e (  )  ;", "checkResultByFile (  \"  1  2  _ after . xml \"  )  ;", "configureByFile (  \"  1  2  _  3  . xml \"  )  ;", "e (  )  ;", "checkResultByFile (  \"  1  2  _  3  _ after . xml \"  )  ;", "configureByFiles (  \"  1  2  _  4  . xml \"  ,     \"  1  2  _  4  _ sample . xsd \"  ,     \"  1  2  _  4  _ included - sample . xsd \"  )  ;", "e (  )  ;", "checkResultByFile (  \"  1  2  _  4  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testSchemaEnumerationCompletion"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFiles (  \" spring - beans . xsd \"  )  ;", "myFixture . testVariants (  \" SchemaLocation . xml \"  ,     \" http :  /  / www . springframework . org / schema / beans    \"  ,     \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema    \"  ,     \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema - instance    \"  )  ;", "myFixture . testVariants (  \" SchemaLocation 2  . xml \"  ,     \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema . xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testSchemaLocation"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFiles (  \"  3  3  . xml \"  ,     \"  3  3  . xsd \"  ,     \"  3  3  _  2  . xsd \"  )  ;", "e (  )  ;", "checkResultByFile (  \"  3  3  _ after . xml \"  )  ;", "configureByFiles (  \"  3  3  _  2  . xml \"  ,     \"  3  3  . xsd \"  ,     \"  3  3  _  2  . xsd \"  )  ;", "e (  )  ;", "checkResultByFile (  \"  3  3  _  2  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testSchemaNonAllowedElementCompletion"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  \"  2  2  . xsd \"  )  ;", "checkResultByFile (  \"  2  2  _ after . xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testSchemaTypeReferenceCompletion"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  \"  2  3  . xsd \"  )  ;", "checkResultByFile (  \"  2  3  _ after . xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testSchemaTypeReferenceCompletion2"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  \"  3  4  . xsd \"  )  ;", "checkResultByFile (  \"  3  4  _ after . xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testSchemaTypeReferenceCompletion3"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  \"  3  5  . xsd \"  )  ;", "checkResultByFile (  \"  3  5  _ after . xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testSchemaTypeReferenceCompletion4"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "addResource (  \" http :  /  / www . springframework . org / dtd / spring - beans . dtd \"  ,     (  ( getTestDataPath (  )  )     +     \"  / spring - beans -  2  .  0  . dtd \"  )  )  ;", "basicDoTest (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSingleCompletionVariantAtRootTag"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFiles (  \" Substitute / schema - a . xsd \"  ,     \" Substitute / schema - b . xsd \"  )  ;", "myFixture . testVariants (  \" Substitute / test . xml \"  ,     \" b : instance \"  ,     \" instance \"  )  ;", "}", "METHOD_END"], "methodName": ["testSubstitute"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "basicDoTest (  \"  \"  )  ;", "basicDoTest (  \"  _  2  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSuggestTagsInXHtml"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  \"  2  0  . xml \"  )  ;", "e (  )  ;", "checkResultByFile (  \"  2  0  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testUrlCompletionInDtd"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "String   url    =     \" http :  /  / www . w 3  . org /  1  9  9  9  / xhtml \"  ;", "String   loca    =     \" xhtml 1  - strict . xsd \"  ;", "addResource ( url ,    loca )  ;", "configureByFile (  \"  1  6  . xml \"  )  ;", "assertNullOrEmpty ( myFixture . getLookupElementStrings (  )  )  ;", "checkResultByFile (  \"  1  6  _ after . xml \"  )  ;", "configureByFile (  \"  1  7  . xml \"  )  ;", "assertNullOrEmpty ( myFixture . getLookupElementStrings (  )  )  ;", "checkResultByFile (  \"  1  7  _ after . xml \"  )  ;", "configureByFile (  \"  3  1  . xml \"  )  ;", "assertNullOrEmpty ( myFixture . getLookupElementStrings (  )  )  ;", "checkResultByFile (  \"  3  1  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testUrlCompletionInSchema"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  \" XIncludeCompletion . xsd \"  )  ;", "checkResultByFile (  \" XIncludeCompletion _ after . xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testXIncludeCompletion"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "String   location    =     \" xslt . xsd \"  ;", "String   location 2     =     \" xhtml 1  - strict . xsd \"  ;", "String   url    =     \" http :  /  / www . w 3  . org /  1  9  9  9  / XSL / Transform \"  ;", "addResource ( url ,    location )  ;", "String   url 2     =     \" http :  /  / www . w 3  . org /  1  9  9  9  / xhtml \"  ;", "addResource ( url 2  ,    location 2  )  ;", "configureByFiles (  \"  1  0  . xml \"  ,    location ,    location 2  )  ;", "e (  )  ;", "checkResultByFile (  \"  /  1  0  _ after . xml \"  )  ;", "configureByFiles (  \"  1  1  . xml \"  ,    location ,    location 2  )  ;", "e (  )  ;", "checkResultByFile (  \"  /  1  1  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testXmlCompletion"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureByFiles (  \" XmlCompletionWhenTagsWithSemicolon . xml \"  ,     \" XmlCompletionWhenTagsWithSemicolon . dtd \"  )  ;", "complete (  )  ;", "checkResultByFile (  \" XmlCompletionWhenTagsWithSemicolon _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testXmlCompletionWhenTagsWithSemicolon"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "String   location    =     \"  2  5  . xsd \"  ;", "String   url    =     \" http :  /  / www . dummy - temp - address \"  ;", "addResource ( url ,    location )  ;", "configureByFiles (  \"  2  5  . xml \"  ,    location )  ;", "e (  )  ;", "checkResultByFile (  \"  2  5  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testXmlNonQualifiedElementCompletion"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . type ( c )  ;", "}", "METHOD_END"], "methodName": ["type"], "fileName": "com.intellij.codeInsight.completion.XmlCompletionTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =     (  ( XmlFile )     ( myElement . getContainingFile (  )  )  )  ;", "PsiElement   parent    =    myElement . getParent (  )  ;", "final   Set < Object >    preferred    =    new   HashSet <  >  (  )  ;", "if    (  ( parent   instanceof   XmlAttribute )     &  &     (  \" xmlns \"  . equals (  (  ( XmlAttribute )     ( parent )  )  . getName (  )  )  )  )     {", "XmlNamespaceHelper   helper    =    XmlNamespaceHelper . getHelper ( file )  ;", "preferred . addAll ( helper . guessUnboundNamespaces ( parent . getParent (  )  ,    file )  )  ;", "}", "Set < String >    list    =    new   HashSet <  >  (  )  ;", "for    ( XmlSchemaProvider   provider    :    Extensions . getExtensions ( XmlSchemaProvider . EP _ NAME )  )     {", "if    ( provider . isAvailable ( file )  )     {", "list . addAll ( provider . getAvailableNamespaces ( file ,    null )  )  ;", "}", "}", "if    (  !  ( list . isEmpty (  )  )  )     {", "return   ArrayUtil . toObjectArray ( list )  ;", "}", "Object [  ]    resourceUrls    =    ExternalResourceManagerEx . getInstanceEx (  )  . getUrlsByNamespace ( myElement . getProject (  )  )  . keySet (  )  . toArray (  )  ;", "final   XmlDocument   document    =    file . getDocument (  )  ;", "assert   document    !  =    null ;", "XmlTag   rootTag    =    document . getRootTag (  )  ;", "final   ArrayList < String >    additionalNs    =    new   ArrayList <  >  (  )  ;", "if    ( rootTag    !  =    null )", "psi . impl . source . resolve . reference . impl . providers . URLReference . processWsdlSchemas ( rootTag ,     (    xmlTag )     -  >     {", "final   String   s    =    xmlTag . getAttributeValue ( URLReference . TARGET _ NAMESPACE _ ATTR _ NAME )  ;", "if    ( s    !  =    null )     {", "additionalNs . add ( s )  ;", "}", "return   true ;", "}  )  ;", "resourceUrls    =    ArrayUtil . mergeArrays ( resourceUrls ,    ArrayUtil . toStringArray ( additionalNs )  )  ;", "return   ContainerUtil . map 2 Array ( resourceUrls ,     (    o )     -  >     {", "LookupElementBuilder   builder    =    LookupElementBuilder . create ( o )  ;", "return   preferred . contains ( o )     ?    PrioritizedLookupElement . withPriority ( builder ,     1  0  0  )     :    builder ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["completeNamespace"], "fileName": "com.intellij.codeInsight.completion.XmlLocationCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "XmlTag   tag    =     (  ( XmlTag )     ( element . getParent (  )  . getParent (  )  )  )  ;", "XmlAte [  ]    ates    =    tag . getAtes (  )  ;", "final   PsiReference [  ]    refs    =    element . getReferences (  )  ;", "return   ContainerUtil . mapNotNull ( ates ,     (    ate )     -  >     {", "final   String   ateValue    =    ate . getValue (  )  ;", "return    (  ( ateValue    !  =    null )     &  &     ( ate . isNamespaceDeclaration (  )  )  )     &  &     (  ( ContainerUtil . find ( refs ,     (    ref )     -  >    ref . getCanonicalText (  )  . equals ( ateValue )  )  )     =  =    null )     ?    ateValue    +     \"     \"     :    null ;", "}  ,    EMPTY _ OBJECT _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["completeSchemaLocation"], "fileName": "com.intellij.codeInsight.completion.XmlLocationCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "XmlTagInsertHandler   insertHandler    =    XmlTagInsertHandler . INSTANCE ;", "if    ( descriptor   instanceof   XmlElementDescriptorImpl )     {", "String   name    =    descriptor . getName (  )  ;", "if    ( name    !  =    null )     {", "insertHandler    =    new   ExtendedTagInsertHandler ( name ,     (  ( XmlElementDescriptorImpl )     ( descriptor )  )  . getNamespace (  )  ,    null )  ;", "}", "}", "result . addElement (  . createLookupElement ( descriptor )  . withInsertHandler ( insertHandler )  )  ;", "}", "METHOD_END"], "methodName": ["addElementToResult"], "fileName": "com.intellij.codeInsight.completion.XmlSmartCompletionProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( XmlCompletionContributor . isXmlNameCompletion ( parameters )  )  )     {", "return ;", "}", "result . stopHere (  )  ;", "if    (  !  (  ( element . getParent (  )  )    instanceof   XmlTag )  )     {", "return ;", "}", "final   XmlTag   tag    =     (  ( XmlTag )     ( element . getParent (  )  )  )  ;", "final   XmlTag   parentTag    =    tag . getParentTag (  )  ;", "if    ( parentTag    =  =    null )", "return ;", "final   XmlContentDFA   dfa    =    XmlContentDFA . getContentDFA ( parentTag )  ;", "if    ( dfa    =  =    null )", "return ;", "ApplicationManager . getApplication (  )  . runReadAction (  (  )     -  >     {", "for    ( XmlTag   subTag    :    parentTag . getSubTags (  )  )     {", "if    ( subTag    =  =    tag )     {", "break ;", "}", "dfa . transition ( subTag )  ;", "}", "List < XmlElementDescriptor >    elements    =    dfa . getPossibleElements (  )  ;", "for    ( XmlElementDescriptor   elementDescriptor    :    elements )     {", "addElementToResult ( elementDescriptor ,    result )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["complete"], "fileName": "com.intellij.codeInsight.completion.XmlSmartCompletionProvider"}, {"methodBody": ["METHOD_START", "{", "LookupElementBuilder   builder    =    LookupElementBuilder . create ( descriptor . getName (  )  )  ;", "if    ( descriptor   instanceof   XmlElementDescriptorImpl )     {", "builder    =    builder . withTypeText (  (  ( XmlElementDescriptorImpl )     ( descriptor )  )  . getNamespace (  )  ,    true )  ;", "}", "return   builder ;", "}", "METHOD_END"], "methodName": ["createLookupElement"], "fileName": "com.intellij.codeInsight.completion.XmlSmartCompletionProvider"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText (  \" a . xml \"  ,    before )  ;", "myFixturee ( SMART )  ;", "myFixture . checkResult ( after )  ;", "}", "METHOD_END"], "methodName": ["doForText"], "fileName": "com.intellij.codeInsight.completion.XmlSmartCompletionTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFiles ( files )  ;", "LookupElement [  ]    elements ;", "try    {", "CSettings . getInstance (  )  . AUTOCOMPLETE _ ON _ SMART _ TYPE _ COMPLETION    =    false ;", "elements    =    myFixture . complete ( SMART )  ;", "}    finally    {", "CSettings . getInstance (  )  . AUTOCOMPLETE _ ON _ SMART _ TYPE _ COMPLETION    =    true ;", "}", "assert   elements    !  =    null ;", "List < String >    strings    =    ContainerUtil . map ( elements ,    LookupElement :  : getLookupString )  ;", "assertEquals ( Arrays . asList ( items )  ,    strings )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.codeInsight.completion.XmlSmartCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( new   String [  ]  {     \" testCompletion . xml \"  ,     \" test . xsd \"     }  ,     \" b \"  )  ;", "}", "METHOD_END"], "methodName": ["testCompletion"], "fileName": "com.intellij.codeInsight.completion.XmlSmartCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( new   String [  ]  {     \" testCompletion 3  . xml \"  ,     \" test . xsd \"     }  ,     \" c \"  ,     \" d \"  )  ;", "}", "METHOD_END"], "methodName": ["testCompletion3"], "fileName": "com.intellij.codeInsight.completion.XmlSmartCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( new   String [  ]  {     \" testCompletionNext . xml \"  ,     \" test . xsd \"     }  ,     \" c \"  )  ;", "}", "METHOD_END"], "methodName": ["testCompletionNext"], "fileName": "com.intellij.codeInsight.completion.XmlSmartCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doForText (  (  \"  < xs : schema   xmlns : xs =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \\ n \"     +     (  \"              < ann < caret >  \\ n \"     +     \"  <  / xs : schema >  \"  )  )  ,     (  \"  < xs : schema   xmlns : xs =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \\ n \"     +     (  \"              < xs : annotation \\ n \"     +     \"  <  / xs : schema >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrefix"], "fileName": "com.intellij.codeInsight.completion.XmlSmartCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( new   String [  ]  {     \" Servlet . xml \"     }  ,     \" icon \"  ,     \" servlet - name \"  )  ;", "}", "METHOD_END"], "methodName": ["testServlet"], "fileName": "com.intellij.codeInsight.completion.XmlSmartCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doForText (  (  \"  <  ! DOCTYPE   web - app \\ n \"     +     (  (  (  (  (  (  (  \"                         PUBLIC    \\  \"  -  /  / Sun   Microsystems ,    Inc .  /  / DTD   Web   Application    2  .  3  /  / EN \\  \"  \\ n \"     +     \"                          \\  \" http :  /  / com / j 2 ee / dtds / web - app _  2  _  3  . dtd \\  \"  >  \\ n \"  )     +     \"  < web - app >  \\ n \"  )     +     \"  \\ n \"  )     +     \"              < servlet >  \\ n \"  )     +     \"                          < s < caret >  \\ n \"  )     +     \"              <  / servlet >  \\ n \"  )     +     \"  <  / web - app >  \"  )  )  ,     (  \"  <  ! DOCTYPE   web - app \\ n \"     +     (  (  (  (  (  (  (  \"                         PUBLIC    \\  \"  -  /  / Sun   Microsystems ,    Inc .  /  / DTD   Web   Application    2  .  3  /  / EN \\  \"  \\ n \"     +     \"                          \\  \" http :  /  / com / j 2 ee / dtds / web - app _  2  _  3  . dtd \\  \"  >  \\ n \"  )     +     \"  < web - app >  \\ n \"  )     +     \"  \\ n \"  )     +     \"              < servlet >  \\ n \"  )     +     \"                          < servlet - name \\ n \"  )     +     \"              <  / servlet >  \\ n \"  )     +     \"  <  / web - app >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testServletName"], "fileName": "com.intellij.codeInsight.completion.XmlSmartCompletionTest"}, {"methodBody": ["METHOD_START", "{", "if    ( isUncommited ( project )  )     {", "commit ( editor )  ;", "if    ( tagToReformat    =  =    null )     {", "tagToReformat    =    PsiTreeUtil . getParentOfType ( getStatementAtCaret ( editor ,    psiFile )  ,    XmlTag . class )  ;", "}", "editor . getCaretModel (  )  . moveToOffset ( caretOffset )  ;", "}", "if    ( tagToReformat    !  =    null )     {", "reformat ( tagToReformat )  ;", "}", "commit ( editor )  ;", "}", "METHOD_END"], "methodName": ["commitChanges"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterProcessor"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   atCaret    =    getStatementAtCaret ( editor ,    psiFile )  ;", "XmlTag   tagAtCaret    =    PsiTreeUtil . getParentOfType ( atCaret ,    XmlTag . class )  ;", "if    ( tagAtCaret    =  =    null )     {", "return   false ;", "}", "try    {", "final   ASTNode   emptyTagEnd    =    XmlChildRole . EMPTY _ TAG _ END _ FINDER . findChild ( tagAtCaret . getNode (  )  )  ;", "final   ASTNode   endTagEnd    =    XmlChildRole . START _ TAG _ END _ FINDER . findChild ( tagAtCaret . getNode (  )  )  ;", "final   Document   doc    =    editor . getDocument (  )  ;", "if    (  ( emptyTagEnd    =  =    null )     &  &     ( endTagEnd    =  =    null )  )     {", "int   insertionOffset    =    tagAtCaret . getTextRange (  )  . getEndOffset (  )  ;", "int   caretAt    =    editor . getCaretModel (  )  . getOffset (  )  ;", "final   CharSequence   text    =    doc . getCharsSequence (  )  ;", "final   int   probableCommaOffset    =    CharArrayUtil . shiftForward ( text ,    insertionOffset ,     \"     \\ t \"  )  ;", "final   PsiElement   sibling    =    tagAtCaret . getNextSibling (  )  ;", "int   caretTo    =    caretAt ;", "char   ch ;", "if    ( caretAt    <    probableCommaOffset )     {", "final   XmlAttribute   xmlAttribute    =    PsiTreeUtil . getParentOfType ( atCaret ,    XmlAttribute . class ,    false ,    XmlTag . class )  ;", "CharSequence   tagNameText    =    null ;", "if    ( xmlAttribute    !  =    null )     {", "final   ASTNode   node    =    tagAtCaret . getNode (  )  ;", "if    ( node    !  =    null )     {", "final   ASTNode   tagName    =    XmlChildRole . START _ TAG _ NAME _ FINDER . findChild ( node )  ;", "if    ( tagName    !  =    null )     {", "tagNameText    =    tagName . getText (  )  ;", "}", "}", "final   XmlAttributeValue   valueElement    =    xmlAttribute . getValueElement (  )  ;", "final   TextRange   textRange    =    xmlAttribute . getTextRange (  )  ;", "caretAt    =     ( valueElement    =  =    null )     ?    textRange . getStartOffset (  )     :     (  . getClosingQuote ( xmlAttribute )  . length (  )  )     =  =     0     ?    textRange . getEndOffset (  )     :    caretAt ;", "}", "if    ( tagNameText    =  =    null )     {", "tagNameText    =    text . subSequence (  (  ( tagAtCaret . getTextRange (  )  . getStartOffset (  )  )     +     1  )  ,    caretAt )  ;", "}", "final   PsiElement   element    =    psiFile . findElementAt ( probableCommaOffset )  ;", "final   XmlTag   tag    =    PsiTreeUtil . getParentOfType ( element ,    XmlTag . class )  ;", "boolean   shouldInsertClosingTag    =     ( shouldAfterWrapTextWithTag ( caretAt ,    probableCommaOffset )  )     |  |     ( shouldInsertClosingTag ( xmlAttribute ,    tagAtCaret )  )  ;", "final   CharSequence   text 2 insert    =    getClosingPart ( xmlAttribute ,    tagAtCaret ,     (  ! shouldInsertClosingTag )  )  ;", "if    (  ( tag    !  =    null )     &  &     (  ( tag . getTextRange (  )  . getStartOffset (  )  )     =  =    probableCommaOffset )  )     {", "doc . insertString ( caretAt ,    text 2 insert )  ;", "if    ( shouldInsertClosingTag )     {", "doc . insertString (  (  ( tag . getTextRange (  )  . getEndOffset (  )  )     +     ( text 2 insert . length (  )  )  )  ,     (  (  \"  <  /  \"     +     ( tagAtCaret . getName (  )  )  )     +     \"  >  \"  )  )  ;", "}", "caretTo    =     ( tag . getTextRange (  )  . getEndOffset (  )  )     +     ( text 2 insert . length (  )  )  ;", "} else    {", "doc . insertString ( caretAt ,    text 2 insert )  ;", "if    ( shouldInsertClosingTag )     {", "doc . insertString (  ( probableCommaOffset    +     ( text 2 insert . length (  )  )  )  ,     (  (  \"  <  /  \"     +    tagNameText )     +     \"  >  \"  )  )  ;", "}", "caretTo    =    probableCommaOffset    +     ( text 2 insert . length (  )  )  ;", "}", "} else", "if    (  ( sibling   instanceof   XmlTag )     &  &     (  ( sibling . getTextRange (  )  . getStartOffset (  )  )     =  =    caretAt )  )     {", "final   XmlAttribute   xmlAttribute    =    PsiTreeUtil . getParentOfType ( atCaret ,    XmlAttribute . class ,    false ,    XmlTag . class )  ;", "final   CharSequence   text 2 insert    =    getClosingPart ( xmlAttribute ,    tagAtCaret ,    false )  ;", "doc . insertString ( caretAt ,    text 2 insert )  ;", "if    ( shouldInsertClosingTag ( xmlAttribute ,    tagAtCaret )  )     {", "doc . insertString (  (  ( sibling . getTextRange (  )  . getEndOffset (  )  )     +     ( text 2 insert . length (  )  )  )  ,     (  (  \"  <  /  \"     +     ( tagAtCaret . getName (  )  )  )     +     \"  >  \"  )  )  ;", "}", "caretTo    =     ( sibling . getTextRange (  )  . getEndOffset (  )  )     +     ( text 2 insert . length (  )  )  ;", "} else", "if    (  ( probableCommaOffset    >  =     ( text . length (  )  )  )     |  |     (  (  ( ch    =    text . charAt ( probableCommaOffset )  )     !  =     '  /  '  )     &  &     ( ch    !  =     '  >  '  )  )  )     {", "final   XmlAttribute   xmlAttribute    =    PsiTreeUtil . getParentOfType ( atCaret ,    XmlAttribute . class ,    false ,    XmlTag . class )  ;", "final   String   text 2 insert    =    getClosingPart ( xmlAttribute ,    tagAtCaret ,    true )  ;", "doc . insertString ( insertionOffset ,    text 2 insert )  ;", "caretTo    =     ( insertionOffset    +     ( text 2 insert . indexOf (  '  >  '  )  )  )     +     1  ;", "}", "commitChanges ( project ,    editor ,    psiFile ,    caretTo ,    null )  ;", "return   true ;", "} else    {", "final   XmlTag   unclosedTag    =     . findClosestUnclosedTag ( tagAtCaret )  ;", "if    ( unclosedTag    =  =    null )     {", "return   false ;", "}", "final   String   closingTagString    =     (  \"  <  /  \"     +     ( unclosedTag . getName (  )  )  )     +     \"  >  \"  ;", "final   XmlTag   parentTag    =    unclosedTag . getParentTag (  )  ;", "final   ASTNode   parentEndTagNode    =     ( parentTag    !  =    null )     ?    XmlChildRole . CLOSING _ TAG _ START _ FINDER . findChild ( parentTag . getNode (  )  )     :    null ;", "final   int   offset    =     ( parentEndTagNode    !  =    null )     ?    parentEndTagNode . getTextRange (  )  . getStartOffset (  )     :    unclosedTag . getTextRange (  )  . getEndOffset (  )  ;", "doc . insertString ( offset ,    closingTagString )  ;", "commitChanges ( project ,    editor ,    psiFile ,    offset ,     ( parentTag    !  =    null    ?    parentTag    :    unclosedTag )  )  ;", "return   true ;", "}", "}    catch    ( IncorrectOperationException   e )     {", ". LOG . error ( e )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["completeEndTag"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterProcessor"}, {"methodBody": ["METHOD_START", "{", "XmlTag   unclosedTag    =    tag ;", "while    ( unclosedTag    !  =    null )     {", "final   PsiElement   lastChild    =    unclosedTag . getLastChild (  )  ;", "if    (  . isTagUnclosed ( lastChild )  )     {", "return   unclosedTag ;", "}", "final   XmlTag   prevTag    =    PsiTreeUtil . getPrevSiblingOfType ( unclosedTag ,    XmlTag . class )  ;", "unclosedTag    =     ( prevTag    !  =    null )     ?    prevTag    :    PsiTreeUtil . getParentOfType ( unclosedTag ,    XmlTag . class )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findClosestUnclosedTag"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterProcessor"}, {"methodBody": ["METHOD_START", "{", "return    ( XmlSmartEnterProcessor . getClosingQuote ( xmlAttribute )  )     +     ( emptyTag    ?    CheckEmptyTagInspection . isTagWithEmptyEndNotAllowed ( tagAtCaret )     ?     (  \"  >  <  /  \"     +     ( tagAtCaret . getName (  )  )  )     +     \"  >  \"     :     \"  /  >  \"     :     \"  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["getClosingPart"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( attribute    =  =    null )     {", "return    \"  \"  ;", "}", "final   AttributeValue   element    =    attribute . getValueElement (  )  ;", "if    ( element    =  =    null )     {", "return    \"  \"  ;", "}", "final   String   s    =    element . getText (  )  ;", "if    (  ( s    !  =    null )     &  &     (  ( s . length (  )  )     >     0  )  )     {", "if    (  (  ( s . charAt (  0  )  )     =  =     '  \"  '  )     &  &     (  ( s . charAt (  (  ( s . length (  )  )     -     1  )  )  )     !  =     '  \"  '  )  )     {", "return    \"  \\  \"  \"  ;", "} else", "if    (  (  ( s . charAt (  0  )  )     =  =     '  \\  '  '  )     &  &     (  ( s . charAt (  (  ( s . length (  )  )     -     1  )  )  )     !  =     '  \\  '  '  )  )     {", "return    \"  '  \"  ;", "}", "}", "return    \"  \"  ;", "}", "METHOD_END"], "methodName": ["getClosingQuote"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterProcessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( lastChild    !  =    null )     &  &     (  ( lastChild . getNode (  )  . getElementType (  )  )     !  =     ( XmlTokenType . XML _ TAG _ END )  )  )     &  &     (  ( lastChild . getNode (  )  . getElementType (  )  )     !  =     ( XmlTokenType . XML _ EMPTY _ ELEMENT _ END )  )  ;", "}", "METHOD_END"], "methodName": ["isTagUnclosed"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterProcessor"}, {"methodBody": ["METHOD_START", "{", "return   probableCommaOffset    >    caretAt ;", "}", "METHOD_END"], "methodName": ["shouldAfterWrapTextWithTag"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterProcessor"}, {"methodBody": ["METHOD_START", "{", "return    ( xmlAttribute    =  =    null )     |  |     (  ( XmlSmartEnterProcessor . getClosingQuote ( xmlAttribute )  . length (  )  )     !  =     0  )  ;", "}", "METHOD_END"], "methodName": ["shouldInsertClosingTag"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterProcessor"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  (  (  ( XmlSmartEnterTest . BASE _ PATH )     +     \"  /  \"  )     +    filename )  )  ;", "performSmartEnterAction (  )  ;", "checkResultByFile (  \"  \"  ,     (  (  ( XmlSmartEnterTest . BASE _ PATH )     +     \"  /  \"  )     +    filename _ after )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["_doTest"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  (  (  ( XmlSmartEnterTest . BASE _ PATH )     +     \"  /  \"  )     +    name )  )  ;", "performCompletionAction (  )  ;", "select ( COMPLETE _ STATEMENT _ SELECT _ CHAR )  ;", "checkResultByFile (  (  (  ( XmlSmartEnterTest . BASE _ PATH )     +     \"  /  \"  )     +    after _ name )  )  ;", "}", "METHOD_END"], "methodName": ["_doTestCompletion"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "_ doTestCompletion (  ( baseName    +     \"  . xml \"  )  ,     ( baseName    +     \"  _ after . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["doCompletionPopupTest"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "_ doTest (  ( baseName    +     \"  . xml \"  )  ,     ( baseName    +     \"  _ after . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["doSmartEnterTest"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "return    \"  \"  ;", "}", "METHOD_END"], "methodName": ["getBasePath"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "new   CodeCompletionHandlerBase ( CompletionType . BASIC )  . invokeCompletion ( getProject (  )  ,    getEditor (  )  )  ;", "final   LookupImpl   lookup    =     (  ( LookupImpl )     ( LookupManager . getActiveLookup ( getEditor (  )  )  )  )  ;", "myItems    =     ( lookup    =  =    null )     ?    null    :    lookup . getItems (  )  . toArray ( EMPTY _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["performCompletionAction"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "WriteCommandAction . writeCommandAction ( getProject (  )  )  . run (  (  )     -  >     {", "new   Processor (  )  . process ( getProject (  )  ,    getEditor (  )  ,    getFile (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["performSmartEnterAction"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( LookupEvent . isSpecialCompletionChar ( c )  )  )     {", "type ( c )  ;", "return ;", "}", "final   LookupManagerImpl   manager    =     (  ( LookupManagerImpl )     ( LookupManager . getInstance ( getProject (  )  )  )  )  ;", "final   Lookup   lookup    =    manager . getActiveLookup (  )  ;", "if    ( lookup    !  =    null )     {", "manager . forceSelection ( c ,    lookup . getCurrentItem (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["select"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "_ doTest (  \" Tag . xml \"  ,     \" Tag _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testComplete1"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "_ doTestCompletion (  \" EmptyHtml . html \"  ,     \" EmptyHtml _ after . html \"  )  ;", "_ doTestCompletion (  \" EmptyHtml 2  . html \"  ,     \" EmptyHtml 2  _ after . html \"  )  ;", "}", "METHOD_END"], "methodName": ["testEmptyHtml"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "doSmartEnterTest (  \" OpenAttribute \"  )  ;", "}", "METHOD_END"], "methodName": ["testOpenAttribute"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  (  (  ( XmlSmartEnterTest . BASE _ PATH )     +     \"  /  \"  )     +     \" CompleteMissingTag . xml \"  )  )  ;", "performSmartEnterAction (  )  ;", "checkResultByFile (  \"  \"  ,     (  (  ( XmlSmartEnterTest . BASE _ PATH )     +     \"  /  \"  )     +     \" CompleteMissingTag _ after _  1  . xml \"  )  ,    true )  ;", "performSmartEnterAction (  )  ;", "checkResultByFile (  \"  \"  ,     (  (  ( XmlSmartEnterTest . BASE _ PATH )     +     \"  /  \"  )     +     \" CompleteMissingTag _ after _  2  . xml \"  )  ,    true )  ;", "performSmartEnterAction (  )  ;", "checkResultByFile (  \"  \"  ,     (  (  ( XmlSmartEnterTest . BASE _ PATH )     +     \"  /  \"  )     +     \" CompleteMissingTag _ after _  3  . xml \"  )  ,    true )  ;", "performSmartEnterAction (  )  ;", "checkResultByFile (  \"  \"  ,     (  (  ( XmlSmartEnterTest . BASE _ PATH )     +     \"  /  \"  )     +     \" CompleteMissingTag _ after _  4  . xml \"  )  ,    true )  ;", "performSmartEnterAction (  )  ;", "checkResultByFile (  \"  \"  ,     (  (  ( XmlSmartEnterTest . BASE _ PATH )     +     \"  /  \"  )     +     \" CompleteMissingTag _ after _  5  . xml \"  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["testSmartCloseTag"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "_ doTest (  \" idea 1  0  3  4  1  7  _  1  . xml \"  ,     \" idea 1  0  3  4  1  7  _  1  _ after . xml \"  )  ;", "_ doTest (  \" idea 1  0  3  4  1  7  _  2  . xml \"  ,     \" idea 1  0  3  4  1  7  _  2  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testSmartCloseTag2"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "doCompletionPopupTest ( getTestName ( false )  )  ;", "}", "METHOD_END"], "methodName": ["testSmartFinish1"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "boolean   old    =    CodeInsightSettings . getInstance (  )  . AUTOCOMPLETE _ ON _ CODE _ COMPLETION ;", "CodeInsightSettings . getInstance (  )  . AUTOCOMPLETE _ ON _ CODE _ COMPLETION    =    false ;", "try    {", "doCompletionPopupTest ( getTestName ( false )  )  ;", "}    finally    {", "CodeInsightSettings . getInstance (  )  . AUTOCOMPLETE _ ON _ CODE _ COMPLETION    =    old ;", "}", "}", "METHOD_END"], "methodName": ["testSmartFinish2"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "doSmartEnterTest (  \" SmartFinish 1  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSmartFinish3"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "doSmartEnterTest (  \" SmartFinish 2  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSmartFinish4"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "doSmartEnterTest (  \" SmartFinish 3  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSmartFinish5"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "doSmartEnterTest (  \" WrongAttribute \"  )  ;", "}", "METHOD_END"], "methodName": ["testSmartFinishWithWrongAttribute"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "doSmartEnterTest (  \" IDEADEV _  2  9  6  2  8  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSmartFinish_IDEADEV_29628"], "fileName": "com.intellij.codeInsight.completion.XmlSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  (  \"  < div   class =  \\  \" container \\  \"  >  \\ n \"     +     (  (  (  (  \"              < div   class =  \\  \" row \\  \"  >  \\ n \"     +     \"                          < div   class =  \\  \" col - xs -  2  \\  \"  >  <  / div >  \\ n \"  )     +     \"                          <  < selection > div <  / selection >    class =  \\  \" col - xs -  1  0  \\  \"  >  <  / div >  \\ n \"  )     +     \"              <  / div >  \\ n \"  )     +     \"  <  / div >  \"  )  )  ,     \" a \"  ,     (  \"  < div   class =  \\  \" container \\  \"  >  \\ n \"     +     (  (  (  (  \"              < div   class =  \\  \" row \\  \"  >  \\ n \"     +     \"                          < div   class =  \\  \" col - xs -  2  \\  \"  >  <  / div >  \\ n \"  )     +     \"                          < a   class =  \\  \" col - xs -  1  0  \\  \"  >  <  / a >  \\ n \"  )     +     \"              <  / div >  \\ n \"  )     +     \"  <  / div >  \"  )  )  )  ;", "myFixture . performEditorAction ( ACTION _ UNDO )  ;", "type (  \" a \"  )  ;", "myFixture . checkResult (  (  \"  < div   class =  \\  \" container \\  \"  >  \\ n \"     +     (  (  (  (  \"              < div   class =  \\  \" row \\  \"  >  \\ n \"     +     \"                          < div   class =  \\  \" col - xs -  2  \\  \"  >  <  / div >  \\ n \"  )     +     \"                          < a   class =  \\  \" col - xs -  1  0  \\  \"  >  <  / a >  \\ n \"  )     +     \"              <  / div >  \\ n \"  )     +     \"  <  / div >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testAfterUndo"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagCommunityTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \"  < html >  < body >  <  / body >  < b < caret >  >  <  / b >  < html >  \"  ,    null ,     \"  < html >  < body >  <  / body >  < body >  <  / body >  < html >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCompletionSimple"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagCommunityTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \"  < html >  < body >  <  / body >  < bertran >  <  / bertran >  < b < caret >  >  <  / b >  < html >  \"  ,     \" e \\ n \"  ,     \"  < html >  < body >  <  / body >  < bertran >  <  / bertran >  < bertran >  <  / bertran >  < html >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCompletionWithLookup"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagCommunityTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \"  < html >  < body >  <  / body >  < bertran >  <  / bertran >  < b < caret >  >  <  / b >  < html >  \"  ,     \" e \"  ,     \"  < html >  < body >  <  / body >  < bertran >  <  / bertran >  < be >  <  / be >  < html >  \"  )  ;", "assertNotNull ( myFixture . getLookup (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCompletionWithLookupAfterTyping"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagCommunityTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  < div > text <  / span >  < caret >  <  / div >  \"  ,     \"  \\ b \\ b \\ b \\ b \\ b \\ b \\ b \"  ,     \"  < div > text <  / div >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testDeletingIncorrectTag"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagCommunityTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText ( XmlFileType . INSTANCE ,     \"  < di < caret >  >  <  / di >  \"  )  ;", "type (  \" v \"  )  ;", "Ref < Boolean >    eventSent    =    Ref . create ( false )  ;", "myFixture . getEditor (  )  . getDocument (  )  . addDocumentListener ( new   DocumentListener (  )     {", "@ Override", "public   void   documentChanged ( DocumentEvent   e )     {", "eventSent . set ( true )  ;", "}", "}  ,    myFixture . getRootDisposable (  )  )  ;", "myFixture . testAction ( new   MoveCaretLeftAction (  )  )  ;", "assertFalse ( eventSent . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDoNotFireDocumentChangeEventIfTagWasNotChanged"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagCommunityTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  < soap : some < caret >  : some >  <  / soap : some : some >  \"  ,     \" a \"  ,     \"  < soap : somea : some >  <  / soap : somea : some >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testDoubleColonError"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagCommunityTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  < div >  <  / div >  < caret >  <  / div >  \"  ,     \"  \\ b \\ b \\ b \\ b \\ b \\ b \"  ,     \"  < div >  <  / div >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEndTagEnd"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagCommunityTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  < div >  <  / div < caret >  >  \"  ,     \" v \"  ,     \"  < divv >  <  / divv >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEndToStart"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagCommunityTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  < div < caret >  >  <  / div >  \"  ,     \"  \\ b \\ b \\ b \"  ,     \"  <  >  <  /  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testLastCharDeleted"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagCommunityTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  < a < caret >    alt =  '  <  /  >  '  >  <  / a >  \"  ,     \"  \\ bb \"  ,     \"  < b   alt =  '  <  /  >  '  >  <  / b >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testLastCharDeletedAndNewAdded"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagCommunityTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  (  \"  < div < caret >  >  <  / div >  \\ n \"     +     \"  < div < caret >  >  <  / div >  \\ n \"  )  ,     \" v \"  ,     (  \"  < divv >  <  / divv >  \\ n \"     +     \"  < divv >  <  / divv >  \\ n \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultiCaret"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagCommunityTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  (  \"  < div < caret >  >  <  / div >  \\ n \"     +     \"  < div >  <  / div >  \\ n \"  )  ,     \"  \\ b \\ b \\ biii \"  ,     (  \"  < iii >  <  / iii >  \\ n \"     +     \"  < div >  <  / div >  \\ n \"  )  )  ;", "myFixture . getEditor (  )  . getCaretModel (  )  . addCaret ( new   VisualPosition (  1  ,     4  )  )  ;", "type (  \"  \\ b \"  )  ;", "myFixture . checkResult (  (  \"  < ii >  <  / ii >  \\ n \"     +     \"  < di >  <  / di >  \\ n \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultiCaretAdding"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagCommunityTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  (  \"  < div < caret >  >  \\ n \"     +     (  \"  < div < caret >  >  <  / div >  \\ n \"     +     \"  <  / div >  \"  )  )  ,     \" v \"  ,     (  \"  < divv >  \\ n \"     +     (  \"  < divv >  <  / divv >  \\ n \"     +     \"  <  / divv >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultiCaretNested"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagCommunityTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText ( XmlFileType . INSTANCE ,     \"  < div < caret >  >  <  / div >  \"  )  ;", "final   Editor   editor    =    EditorFactory . getInstance (  )  . createEditor ( myFixture . getEditor (  )  . getDocument (  )  )  ;", "EditorFactory . getInstance (  )  . releaseEditor ( editor )  ;", "type (  \" v \"  )  ;", "myFixture . checkResult (  \"  < divv >  <  / divv >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testMultipleEditors"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagCommunityTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  < divv < caret >  >  <  / div >  \"  ,     \"  \\ bd \"  ,     \"  < divd >  <  / divd >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRecommence"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagCommunityTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  < div >                 \\ n             \\ n <  / div >  < caret >  \"  ,     \"  \\ n \"  ,     \"  < div >                 \\ n             \\ n <  / div >  \\ n \"  )  ;", "final   PsiFile   file    =    myFixture . getFile (  )  ;", "myFixture . getEditor (  )  . getCaretModel (  )  . moveToOffset (  (  ( myFixture . getDocument ( file )  . getTextLength (  )  )     -     2  )  )  ;", "file . getVirtualFile (  )  . putUserData ( OVERRIDE _ STRIP _ TRAILING _ SPACES _ KEY ,    STRIP _ TRAILING _ SPACES _ WHOLE )  ;", "FileDocumentManager . getInstance (  )  . saveDocument ( myFixture . getDocument ( file )  )  ;", "myFixture . checkResult (  \"  < div >  \\ n \\ n <  / div >  \\ n \"  )  ;", "}", "METHOD_END"], "methodName": ["testSave"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagCommunityTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  <  < selection > div <  / selection >  >  <  / div >  \"  ,     \" b \"  ,     \"  < b >  <  / b >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSelection"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagCommunityTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  < div < caret >  >  <  / div >  \"  ,     \"     \"  ,     \"  < div    >  <  / div >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSpace"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagCommunityTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  < div < caret >  >  <  / div >  \"  ,     \" v \"  ,     \"  < divv >  <  / divv >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testStartToEnd"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagCommunityTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  < div < caret >  >  <  / div >  \"  ,     \" v \"  ,     \"  < divv >  <  / divv >  \"  )  ;", "myFixture . getEditor (  )  . getCaretModel (  )  . moveToOffset (  1  2  )  ;", "type (  \"  \\ b \"  )  ;", "myFixture . checkResult (  \"  < div >  <  / div >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testStartToEndAndEndToStart"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagCommunityTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  < div < caret >  >  <  / div >  \"  ,     \" v \"  ,     \"  < divv >  <  / divv >  \"  )  ;", "myFixture . performEditorAction ( ACTION _ UNDO )  ;", "myFixture . checkResult (  \"  < div >  <  / div >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testUndo"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagCommunityTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText ( fileType ,    text )  ;", "type ( toType )  ;", "myFixture . checkResult ( result )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( XmlFileType . INSTANCE ,    text ,    toType ,    result )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText ( fileType ,    text )  ;", "myFixtureeBasic (  )  ;", "if    ( toType    !  =    null )", "myFixture . type ( toType )  ;", "myFixture . checkResult ( result )  ;", "}", "METHOD_END"], "methodName": ["doTestCompletion"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion ( XmlFileType . INSTANCE ,    text ,    toType ,    result )  ;", "}", "METHOD_END"], "methodName": ["doTestCompletion"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . type ( toType )  ;", "}", "METHOD_END"], "methodName": ["type"], "fileName": "com.intellij.codeInsight.completion.XmlSyncTagTest"}, {"methodBody": ["METHOD_START", "{", "Set < String >    notRequiredAttributes    =    Collections . emptySet (  )  ;", "if    ( tag   instanceof   HtmlTag )     {", "final   InspectionProfile   profile    =    InspectionProjectProfileManager . getInstance ( tag . getProject (  )  )  . getCurrentProfile (  )  ;", "XmlEntitiesInspection   inspection    =     (  ( XmlEntitiesInspection )     ( profile . getUnwrappedTool ( XmlEntitiesInspection . REQUIRED _ ATTRIBUTES _ SHORT _ NAME ,    tag )  )  )  ;", "if    ( inspection    !  =    null )     {", "StringTokenizer   tokenizer    =    new   StringTokenizer ( inspection . getAdditionalEntries (  )  )  ;", "notRequiredAttributes    =    new   HashSet <  >  (  )  ;", "while    ( tokenizer . hasMoreElements (  )  )", "notRequiredAttributes . add ( tokenizer . nextToken (  )  )  ;", "}", "}", "XmlAttributeDescriptor [  ]    attributes    =    descriptor . getAttributesDescriptors ( tag )  ;", "StringBuilder   indirectRequiredAttrs    =    null ;", "if    ( WebEditorOptions . getInstance (  )  . isAutomaticallyInsertRequiredAttributes (  )  )     {", "final   XmlExtension   extension    =    XmlExtension . getExtension ( containingFile )  ;", "for    ( XmlAttributeDescriptor   attributeDecl    :    attributes )     {", "String   attributeName    =    attributeDecl . getName ( tag )  ;", "boolean   shouldBeInserted    =    extension . shouldBeInserted ( attributeDecl )  ;", "if    (  ! shouldBeInserted )", "continue ;", "XmlExtension . AttributeValuePresentation   presenter    =    extension . getAttributeValuePresentation ( attributeDecl ,    XmlEditUtil . getAttributeQuote ( containingFile )  )  ;", "boolean   htmlCode    =     ( HtmlUtil . hasHtml ( containingFile )  )     |  |     ( HtmlUtil . supportsXmlTypedHandlers ( containingFile )  )  ;", "if    (  ( tag    =  =    null )     |  |     (  ( tag . getAttributeValue ( attributeName )  )     =  =    null )  )     {", "if    (  !  ( notRequiredAttributes . contains ( attributeName )  )  )     {", "if    (  !  ( extension . isIndirectSyntax ( attributeDecl )  )  )     {", "template . addTextSegment (  (  (  (  \"     \"     +    attributeName )     +     \"  =  \"  )     +     ( presenter . getPrefix (  )  )  )  )  ;", "template . addVariable (  ( presenter . showAutoPopup (  )     ?    new   template . impl . MacroCallNode ( new   CompleteMacro (  )  )     :    new   EmptyExpression (  )  )  ,    true )  ;", "template . addTextSegment ( presenter . getPostfix (  )  )  ;", "} else    {", "if    ( indirectRequiredAttrs    =  =    null )", "indirectRequiredAttrs    =    new   StringBuilder (  )  ;", "indirectRequiredAttrs . append (  \"  \\ n < jsp : attribute   name =  \\  \"  \"  )  . append ( attributeName )  . append (  \"  \\  \"  >  <  / jsp : attribute >  \\ n \"  )  ;", "}", "}", "} else", "if    (  (  ( attributeDecl . isFixed (  )  )     &  &     (  ( attributeDecl . getDefaultValue (  )  )     !  =    null )  )     &  &     (  ! htmlCode )  )     {", "template . addTextSegment (  (  (  (  (  (  \"     \"     +    attributeName )     +     \"  =  \"  )     +     ( presenter . getPrefix (  )  )  )     +     ( attributeDecl . getDefaultValue (  )  )  )     +     ( presenter . getPostfix (  )  )  )  )  ;", "}", "}", "}", "return   indirectRequiredAttrs ;", "}", "METHOD_END"], "methodName": ["addRequiredAttributes"], "fileName": "com.intellij.codeInsight.completion.XmlTagInsertHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( WebEditorOptions . getInstance (  )  . isAutomaticallyInsertRequiredSubTags (  )  )  )", "return   false ;", "List < XmlElementDescriptor >    requiredSubTags    =    GenerateXmlTagAction . getRequiredSubTags ( descriptor )  ;", "if    (  !  ( requiredSubTags . isEmpty (  )  )  )     {", "template . addTextSegment (  \"  >  \"  )  ;", "template . setToReformat ( true )  ;", "}", "for    ( XmlElementDescriptor   subTag    :    requiredSubTags )     {", "if    ( subTag    =  =    null )     {", "template . addTextSegment (  \"  <  \"  )  ;", "template . addVariable ( new   template . impl . MacroCallNode ( new   CompleteSmartMacro (  )  )  ,    true )  ;", "continue ;", "}", "String   qname    =    subTag . getName (  )  ;", "if    ( subTag   instanceof   XmlElementDescriptorImpl )     {", "String   prefixByNamespace    =    context . getPrefixByNamespace (  (  ( XmlElementDescriptorImpl )     ( subTag )  )  . getNamespace (  )  )  ;", "if    ( StringUtil . isNotEmpty ( prefixByNamespace )  )     {", "qname    =     ( prefixByNamespace    +     \"  :  \"  )     +     ( subTag . getName (  )  )  ;", "}", "}", "template . addTextSegment (  (  \"  <  \"     +    qname )  )  ;", "XmlTagInsertHandler . addRequiredAttributes ( subTag ,    null ,    template ,    file )  ;", "XmlTagInsertHandler . completeTagTail ( template ,    subTag ,    file ,    context ,    false )  ;", "}", "if    (  !  ( requiredSubTags . isEmpty (  )  )  )     {", "XmlTagInsertHandler . addTagEnd ( template ,    descriptor ,    context )  ;", "}", "return    !  ( requiredSubTags . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["addRequiredSubTags"], "fileName": "com.intellij.codeInsight.completion.XmlTagInsertHandler"}, {"methodBody": ["METHOD_START", "{", "template . addTextSegment (  (  (  \"  <  /  \"     +     ( descriptor . getName ( context )  )  )     +     \"  >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["addTagEnd"], "fileName": "com.intellij.codeInsight.completion.XmlTagInsertHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( completionChar    =  =     '  >  '  )     |  |     (  ( completionChar    =  =     '  /  '  )     &  &     ( indirectRequiredAttrs    !  =    null )  )  )     {", "template . addTextSegment (  \"  >  \"  )  ;", "boolean   toInsertCDataEnd    =    false ;", "if    ( descriptor   instanceof   XmlElementDescriptorWithCDataContent )     {", "final   XmlElementDescriptorWithCDataContent   cDataContainer    =     (  ( XmlElementDescriptorWithCDataContent )     ( descriptor )  )  ;", "if    ( cDataContainer . requiresCdataBracesInContext ( tag )  )     {", "template . addTextSegment (  \"  <  !  [ CDATA [  \\ n \"  )  ;", "toInsertCDataEnd    =    true ;", "}", "}", "if    ( indirectRequiredAttrs    !  =    null )", "template . addTextSegment ( indirectRequiredAttrs . toString (  )  )  ;", "template . addEndVariable (  )  ;", "if    ( toInsertCDataEnd )", "template . addTextSegment (  \"  \\ n ]  ]  >  \"  )  ;", "if    (  (  (  !  ( tag   instanceof   HtmlTag )  )     |  |     (  !  ( HtmlUtil . isSingleHtmlTag ( tag ,    true )  )  )  )     &  &     (  ( tag . getAttributes (  )  . length )     =  =     0  )  )     {", "if    ( WebEditorOptions . getInstance (  )  . isAutomaticallyInsertClosingTag (  )  )     {", "final   String   name    =    descriptor . getName ( tag )  ;", "if    ( name    !  =    null )     {", "template . addTextSegment (  \"  <  /  \"  )  ;", "template . addTextSegment ( name )  ;", "template . addTextSegment (  \"  >  \"  )  ;", "}", "}", "}", "} else", "if    ( completionChar    =  =     '  /  '  )     {", "template . addTextSegment ( XmlTagInsertHandler . closeTag ( tag )  )  ;", "} else", "if    (  ( completionChar    =  =     '     '  )     &  &     (  ( template . getSegmentsCount (  )  )     =  =     0  )  )     {", "if    (  ( WebEditorOptions . getInstance (  )  . isAutomaticallyStartAttribute (  )  )     &  &     (  (  ( descriptor . getAttributesDescriptors ( tag )  . length )     >     0  )     |  |     (  ( XmlTagInsertHandler . isTagFromHtml ( tag )  )     &  &     (  !  ( HtmlUtil . isTagWithoutAttributes ( tag . getName (  )  )  )  )  )  )  )     {", "XmlTagInsertHandler . completeAttribute ( tag . getContainingFile (  )  ,    template )  ;", "return   true ;", "}", "} else", "if    (  (  ( completionChar    =  =     ( lookup . Lookup . AUTO _ INSERT _ SELECT _ CHAR )  )     |  |     ( completionChar    =  =     ( lookup . Lookup . NORMAL _ SELECT _ CHAR )  )  )     |  |     ( completionChar    =  =     ( lookup . Lookup . REPLACE _ SELECT _ CHAR )  )  )     {", "if    (  (  ( WebEditorOptions . getInstance (  )  . isAutomaticallyInsertClosingTag (  )  )     &  &    isHtmlCode )     &  &     ( HtmlUtil . isSingleHtmlTag ( tag ,    true )  )  )     {", "template . addTextSegment (  ( HtmlUtil . isHtmlTag ( tag )     ?     \"  >  \"     :    XmlTagInsertHandler . closeTag ( tag )  )  )  ;", "} else    {", "if    (  (  (  ( XmlTagInsertHandler . needAlLeastOneAttribute ( tag )  )     &  &     ( WebEditorOptions . getInstance (  )  . isAutomaticallyStartAttribute (  )  )  )     &  &     (  ( tag . getAttributes (  )  . length )     =  =     0  )  )     &  &     (  ( template . getSegmentsCount (  )  )     =  =     0  )  )     {", "XmlTagInsertHandler . completeAttribute ( tag . getContainingFile (  )  ,    template )  ;", "return   true ;", "} else    {", "XmlTagInsertHandler . completeTagTail ( template ,    descriptor ,    tag . getContainingFile (  )  ,    tag ,    true )  ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["addTail"], "fileName": "com.intellij.codeInsight.completion.XmlTagInsertHandler"}, {"methodBody": ["METHOD_START", "{", "CodeStyleSettings   settings    =    CodeStyleSettingsManager . getSettings ( tag . getProject (  )  )  ;", "boolean   html    =    HtmlUtil . isHt ( tag )  ;", "boolean   needsSpace    =     ( html    &  &     ( settings . getCustomSettings ( HtmlCodeStyleSettings . class )  . HTML _ SPACE _ INSIDE _ EMPTY _ TAG )  )     |  |     (  (  ! html )     &  &     ( settings . getCustomSettings ( XmlCodeStyleSettings . class )  . XML _ SPACE _ INSIDE _ EMPTY _ TAG )  )  ;", "return   needsSpace    ?     \"     /  >  \"     :     \"  /  >  \"  ;", "}", "METHOD_END"], "methodName": ["closeTag"], "fileName": "com.intellij.codeInsight.completion.XmlTagInsertHandler"}, {"methodBody": ["METHOD_START", "{", "template . addTextSegment (  \"     \"  )  ;", "template . addVariable ( new   template . impl . MacroCallNode ( new   CompleteMacro (  )  )  ,    true )  ;", "template . addTextSegment (  (  \"  =  \"     +     ( XmlEditUtil . getAttributeQuote ( file )  )  )  )  ;", "template . addEndVariable (  )  ;", "template . addTextSegment ( XmlEditUtil . getAttributeQuote ( file )  )  ;", "}", "METHOD_END"], "methodName": ["completeAttribute"], "fileName": "com.intellij.codeInsight.completion.XmlTagInsertHandler"}, {"methodBody": ["METHOD_START", "{", "boolean   completeIt    =     (  ! firstLevel )     |  |     (  ( descriptor . getAttributesDescriptors ( null )  . length )     =  =     0  )  ;", "switch    ( descriptor . getContentType (  )  )     {", "case   XmlElementDescriptor . CONTENT _ TYPE _ UNKNOWN    :", "return ;", "case   XmlElementDescriptor . CONTENT _ TYPE _ EMPTY    :", "if    ( completeIt )     {", "template . addTextSegment ( XmlTagInsertHandler . closeTag ( context )  )  ;", "}", "break ;", "case   XmlElementDescriptor . CONTENT _ TYPE _ MIXED    :", "if    ( completeIt )     {", "template . addTextSegment (  \"  >  \"  )  ;", "if    ( firstLevel )     {", "template . addEndVariable (  )  ;", "} else    {", "template . addVariable ( new   template . impl . MacroCallNode ( new   CompleteMacro (  )  )  ,    true )  ;", "}", "XmlTagInsertHandler . addTagEnd ( template ,    descriptor ,    context )  ;", "}", "break ;", "default    :", "if    (  !  ( XmlTagInsertHandler . addRequiredSubTags ( template ,    descriptor ,    file ,    context )  )  )     {", "if    ( completeIt )     {", "template . addTextSegment (  \"  >  \"  )  ;", "template . addEndVariable (  )  ;", "XmlTagInsertHandler . addTagEnd ( template ,    descriptor ,    context )  ;", "}", "}", "break ;", "}", "}", "METHOD_END"], "methodName": ["completeTagTail"], "fileName": "com.intellij.codeInsight.completion.XmlTagInsertHandler"}, {"methodBody": ["METHOD_START", "{", "XmlElementDescriptor   descriptor    =    tag . getDescriptor (  )  ;", "final   Project   project    =    editor . getProject (  )  ;", "TemplateManager   templateManager    =    TemplateManager . getInstance ( project )  ;", "Template   template    =    templateManager . createTemplate (  \"  \"  ,     \"  \"  )  ;", "template . setToIndent ( true )  ;", "PsiFile   containingFile    =    tag . getContainingFile (  )  ;", "boolean   htmlCode    =     ( HtmlUtil . hasHtml ( containingFile )  )     |  |     ( HtmlUtil . supportsXmlTypedHandlers ( containingFile )  )  ;", "template . setToReformat (  (  ! htmlCode )  )  ;", "StringBuilder   indirectRequiredAttrs    =     . addRequiredAttributes ( descriptor ,    tag ,    template ,    containingFile )  ;", "final   boolean   chooseAttributeName    =     . addTail ( completionChar ,    descriptor ,    htmlCode ,    tag ,    template ,    indirectRequiredAttrs )  ;", "templateManager . startTemplate ( editor ,    template ,    new   TemplateEditingAdapter (  )     {", "private   RangeMarker   myAttrValueMarker ;", "@ Override", "public   void   waitingForInput ( Template   template )     {", "int   offset    =    editor . getCaretModel (  )  . getOffset (  )  ;", "myAttrValueMarker    =    editor . getDocument (  )  . createRangeMarker (  ( offset    +     1  )  ,     ( offset    +     4  )  )  ;", "}", "@ Override", "public   void   templateFinished ( final   Template   template ,    boolean   brokenOff )     {", "final   int   offset    =    editor . getCaretModel (  )  . getOffset (  )  ;", "if    ( chooseAttributeName    &  &     ( offset    >     0  )  )     {", "char   c    =    editor . getDocument (  )  . getCharsSequence (  )  . charAt (  ( offset    -     1  )  )  ;", "if    (  ( c    =  =     '  /  '  )     |  |     (  ( c    =  =     '     '  )     &  &    brokenOff )  )     {", "WriteCommandAction . writeCommandAction ( project )  . run (  (  )     -  >    editor . getDocument (  )  . replaceString ( offset ,     ( offset    +     3  )  ,     \"  >  \"  )  )  ;", "}", "}", "}", "@ Override", "public   void   templateCancelled ( final   Template   template )     {", "if    (  ( myAttrValueMarker )     =  =    null )     {", "return ;", "}", "final   UndoManager   manager    =    UndoManager . getInstance ( project )  ;", "if    (  ( manager . isUndoInProgress (  )  )     |  |     ( manager . isRedoInProgress (  )  )  )     {", "return ;", "}", "if    ( chooseAttributeName    &  &     ( myAttrValueMarker . isValid (  )  )  )     {", "final   int   startOffset    =    myAttrValueMarker . getStartOffset (  )  ;", "final   int   endOffset    =    myAttrValueMarker . getEndOffset (  )  ;", "WriteCommandAction . writeCommandAction ( project )  . run (  (  )     -  >    editor . getDocument (  )  . replaceString ( startOffset ,    endOffset ,     \"  >  \"  )  )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["insertIncompleteTag"], "fileName": "com.intellij.codeInsight.completion.XmlTagInsertHandler"}, {"methodBody": ["METHOD_START", "{", "final   String   ns    =    tag . getNamespace (  )  ;", "return    ( Util . XHTML _ URI . equals ( ns )  )     |  |     ( Util . HTML _ URI . equals ( ns )  )  ;", "}", "METHOD_END"], "methodName": ["isTagFromHtml"], "fileName": "com.intellij.codeInsight.completion.XmlTagInsertHandler"}, {"methodBody": ["METHOD_START", "{", "for    ( XmlTagRuleProvider   ruleProvider    :    XmlTagRuleProvider . EP _ NAME . getExtensions (  )  )     {", "for    ( XmlTagRuleProvider . Rule   rule    :    ruleProvider . getTagRule ( tag )  )     {", "if    ( rule . needAtLeastOneAttribute ( tag )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["needAlLeastOneAttribute"], "fileName": "com.intellij.codeInsight.completion.XmlTagInsertHandler"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText ( XmlFileType . INSTANCE ,    text )  ;", "myFixture . type ( c )  ;", "myFixture . checkResult ( result )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "return   CodeStyle . getSettings ( myFixture . getProject (  )  )  . getCustomSettings ( HtmlCodeStyleSettings . class )  ;", "}", "METHOD_END"], "methodName": ["getHtmlSettings"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  (  \"  < div >  \\ n \"     +     (  (  (  \"              < p >  \\ n \"     +     \"                         Some   text \\ n \"  )     +     \"              <  / p >  \\ n \"  )     +     \"              <  < caret >  \"  )  )  ,     '  /  '  ,     (  \"  < div >  \\ n \"     +     (  (  (  \"              < p >  \\ n \"     +     \"                         Some   text \\ n \"  )     +     \"              <  / p >  \\ n \"  )     +     \"  <  / div >  < caret >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutoindentEndTag"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  (  \"  < bar >  \\ n \"     +     (  (  \"  < foo < caret >  \\ n \"     +     \"  < foo < caret >  \\ n \"  )     +     \"  <  / bar >  \"  )  )  ,     '  >  '  ,     (  \"  < bar >  \\ n \"     +     (  (  \"  < foo >  < caret >  <  / foo >  \\ n \"     +     \"  < foo >  < caret >  <  / foo >  \\ n \"  )     +     \"  <  / bar >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testCloseTagOnGtWithMultiCarets"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  (  \"  < bar >  \\ n \"     +     (  (  \"  < foo < caret >  \\ n \"     +     \"  < fiz < caret >  \\ n \"  )     +     \"  <  / bar >  \"  )  )  ,     '  >  '  ,     (  \"  < bar >  \\ n \"     +     (  (  \"  < foo >  < caret >  <  / foo >  \\ n \"     +     \"  < fiz >  < caret >  <  / fiz >  \\ n \"  )     +     \"  <  / bar >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testCloseTagOnGtWithMultiCaretsInDifferentContexts"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  (  \"  < bar >  \\ n \"     +     (  (  \"  < foo >  <  < caret >  \\ n \"     +     \"  < foo >  <  < caret >  \\ n \"  )     +     \"  <  / bar >  \"  )  )  ,     '  /  '  ,     (  \"  < bar >  \\ n \"     +     (  (  \"              < foo >  <  / foo >  < caret >  \\ n \"     +     \"              < foo >  <  / foo >  < caret >  \\ n \"  )     +     \"  <  / bar >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testCloseTagOnSlashWithMultiCarets"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  (  \"  < bar >  \\ n \"     +     (  (  \"  < foo >  <  < caret >  \\ n \"     +     \"  < fiz >  <  < caret >  \\ n \"  )     +     \"  <  / bar >  \"  )  )  ,     '  /  '  ,     (  \"  < bar >  \\ n \"     +     (  (  \"              < foo >  <  / foo >  < caret >  \\ n \"     +     \"              < fiz >  <  / fiz >  < caret >  \\ n \"  )     +     \"  <  / bar >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testCloseTagOnSlashWithMultiCaretsInDifferentContexts"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  < foo >  <  < caret >  \"  ,     '  /  '  ,     \"  < foo >  <  / foo >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testClosingTag"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  (  \"  < foo >  \\ n \"     +     (  \"        < bar < caret >  <  / bar >  \\ n \"     +     \"  <  / foo >  \"  )  )  ,     '  >  '  ,     (  \"  < foo >  \\ n \"     +     (  \"        < bar >  <  / bar >  \\ n \"     +     \"  <  / foo >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testFooBar"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  < foo >  <  < caret > foo >  \"  ,     '  /  '  ,     \"  < foo >  <  / foo >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGreedyClosing"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "final   HtmlCodeStyleSettings   settings    =    getHtmlSettings (  )  ;", "final   CodeStyleSettings . QuoteStyle   quote    =    settings . HTML _ QUOTE _ STYLE ;", "try    {", "settings . HTML _ QUOTE _ STYLE    =    QuoteStyle . None ;", "myFixture . configureByText ( HtmlFile . INSTANCE ,     \"  < foo   bar < caret >  > text \"  )  ;", "myFixture . type (  '  =  '  )  ;", "myFixture . checkResult (  \"  < foo   bar =  < caret >  > text \"  )  ;", "}    finally    {", "settings . HTML _ QUOTE _ STYLE    =    quote ;", "}", "}", "METHOD_END"], "methodName": ["testNoneQuotes"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  <  < caret >  \"  ,     '  ?  '  ,     \"  <  ?  < caret >     ?  >  \"  )  ;", "doTest (  \"  < caret >  \"  ,     '  ?  '  ,     \"  ?  \"  )  ;", "doTest (  \"  <  < caret >     ?  >  \"  ,     '  ?  '  ,     \"  <  ?  < caret >     ?  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testPi"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "boolean   surround    =    CodeInsightSettings . getInstance (  )  . SURROUND _ SELECTION _ ON _ QUOTE _ TYPED ;", "try    {", "CodeInsightSettings . getInstance (  )  . SURROUND _ SELECTION _ ON _ QUOTE _ TYPED    =    true ;", "doTest (  \"  < selection >  < div >  <  / div >  <  / selection >  \"  ,     '  (  '  ,     \"  (  < div >  <  / div >  )  \"  )  ;", "}    finally    {", "CodeInsightSettings . getInstance (  )  . SURROUND _ SELECTION _ ON _ QUOTE _ TYPED    =    surround ;", "}", "}", "METHOD_END"], "methodName": ["testSelectionBraces"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "boolean   surround    =    CodeInsightSettings . getInstance (  )  . SURROUND _ SELECTION _ ON _ QUOTE _ TYPED ;", "try    {", "CodeInsightSettings . getInstance (  )  . SURROUND _ SELECTION _ ON _ QUOTE _ TYPED    =    true ;", "doTest (  \"  < div >  < selection >  <  / div >  <  / selection >  \"  ,     '  (  '  ,     \"  < div >  (  <  / div >  )  \"  )  ;", "}    finally    {", "CodeInsightSettings . getInstance (  )  . SURROUND _ SELECTION _ ON _ QUOTE _ TYPED    =    surround ;", "}", "}", "METHOD_END"], "methodName": ["testSelectionBracesEnd"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "boolean   surround    =    CodeInsightSettings . getInstance (  )  . SURROUND _ SELECTION _ ON _ QUOTE _ TYPED ;", "try    {", "CodeInsightSettings . getInstance (  )  . SURROUND _ SELECTION _ ON _ QUOTE _ TYPED    =    true ;", "doTest (  \"  < div >  < selection >  < div >  <  / div >  <  / selection >  <  / div >  \"  ,     '  (  '  ,     \"  < div >  (  < div >  <  / div >  )  <  / div >  \"  )  ;", "}    finally    {", "CodeInsightSettings . getInstance (  )  . SURROUND _ SELECTION _ ON _ QUOTE _ TYPED    =    surround ;", "}", "}", "METHOD_END"], "methodName": ["testSelectionBracesInner"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "boolean   surround    =    CodeInsightSettings . getInstance (  )  . SURROUND _ SELECTION _ ON _ QUOTE _ TYPED ;", "try    {", "CodeInsightSettings . getInstance (  )  . SURROUND _ SELECTION _ ON _ QUOTE _ TYPED    =    true ;", "doTest (  \"  < selection >  < div /  >  <  / selection >  \"  ,     '  (  '  ,     \"  (  < div /  >  )  \"  )  ;", "}    finally    {", "CodeInsightSettings . getInstance (  )  . SURROUND _ SELECTION _ ON _ QUOTE _ TYPED    =    surround ;", "}", "}", "METHOD_END"], "methodName": ["testSelectionBracesShort"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "boolean   surround    =    CodeInsightSettings . getInstance (  )  . SURROUND _ SELECTION _ ON _ QUOTE _ TYPED ;", "try    {", "CodeInsightSettings . getInstance (  )  . SURROUND _ SELECTION _ ON _ QUOTE _ TYPED    =    true ;", "doTest (  \"  < div >  < selection >  < div /  >  <  / selection >  <  / div >  \"  ,     '  (  '  ,     \"  < div >  (  < div /  >  )  <  / div >  \"  )  ;", "}    finally    {", "CodeInsightSettings . getInstance (  )  . SURROUND _ SELECTION _ ON _ QUOTE _ TYPED    =    surround ;", "}", "}", "METHOD_END"], "methodName": ["testSelectionBracesShortInner"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "boolean   surround    =    CodeInsightSettings . getInstance (  )  . SURROUND _ SELECTION _ ON _ QUOTE _ TYPED ;", "try    {", "CodeInsightSettings . getInstance (  )  . SURROUND _ SELECTION _ ON _ QUOTE _ TYPED    =    true ;", "doTest (  \"  < selection >  < div >  <  / selection >  <  / div >  \"  ,     '  (  '  ,     \"  (  < div >  )  <  / div >  \"  )  ;", "}    finally    {", "CodeInsightSettings . getInstance (  )  . SURROUND _ SELECTION _ ON _ QUOTE _ TYPED    =    surround ;", "}", "}", "METHOD_END"], "methodName": ["testSelectionBracesStart"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "final   HtmlCodeStyleSettings   settings    =    getHtmlSettings (  )  ;", "final   CodeStyleSettings . QuoteStyle   quote    =    settings . HTML _ QUOTE _ STYLE ;", "try    {", "settings . HTML _ QUOTE _ STYLE    =    QuoteStyle . Single ;", "myFixture . configureByText ( HtmlFile . INSTANCE ,     \"  < foo   bar < caret >  \"  )  ;", "myFixture . type (  '  =  '  )  ;", "myFixture . checkResult (  \"  < foo   bar =  '  < caret >  '  \"  )  ;", "}    finally    {", "settings . HTML _ QUOTE _ STYLE    =    quote ;", "}", "}", "METHOD_END"], "methodName": ["testSingleQuotes"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  < foo   bar < caret >  \"  ,     '  =  '  ,     \"  < foo   bar =  \\  \"  < caret >  \\  \"  \"  )  ;", "WebEditorOptions . getInstance (  )  . setInsertQuotesForAttributeValue ( false )  ;", "try    {", "doTest (  \"  < foo   bar < caret >  \"  ,     '  =  '  ,     \"  < foo   bar =  < caret >  \"  )  ;", "}    finally    {", "WebEditorOptions . getInstance (  )  . setInsertQuotesForAttributeValue ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["testValueQuotas"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  < foo   bar < caret >  >  < foo   bar < caret >  >  \"  ,     '  =  '  ,     \"  < foo   bar =  \\  \"  < caret >  \\  \"  >  < foo   bar =  \\  \"  < caret >  \\  \"  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testValueQuotesWithMultiCarets"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  < foo   bar < caret >  \\ n < foo   bar < caret >  \"  ,     '  =  '  ,     \"  < foo   bar =  \\  \"  < caret >  \\  \"  \\ n < foo   bar =  \\  \"  < caret >  \\  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testValueQuotesWithMultiCaretsMultiline"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  < foo   bar    < caret >  >  < foo   bar < caret >  >  \"  ,     '  =  '  ,     \"  < foo   bar    =  < caret >  >  < foo   bar =  \\  \"  < caret >  \\  \"  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testValueQuotesWithMultiCaretsWithDifferentContexts"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  (  \"  < a   foo =  \\  \"  1  \\  \"  \\ n \"     +     \"          bar =  \\  \"  2  \\  \"  >  < caret >  <  / a >  \"  )  ,     '  \\ n '  ,     (  \"  < a   foo =  \\  \"  1  \\  \"  \\ n \"     +     (  (  \"          bar =  \\  \"  2  \\  \"  >  \\ n \"     +     \"              < caret >  \\ n \"  )     +     \"  <  / a >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testWeb13982"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  (  \"  < h 1  > Title <  / h 1  >  \\ n \"     +     \"  < p > body   text <  / p >  < caret >  \"  )  ,     '  \\ n '  ,     (  \"  < h 1  > Title <  / h 1  >  \\ n \"     +     (  \"  < p > body   text <  / p >  \\ n \"     +     \"  < caret >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testWeb392"], "fileName": "com.intellij.codeInsight.completion.XmlTypedHandlersTest"}, {"methodBody": ["METHOD_START", "{", "ResourceBundle   bundle    =    SoftReference . dereference ( XmlErrorMessages . ourBundle )  ;", "if    ( bundle    =  =    null )     {", "bundle    =    ResourceBundle . getBundle ( XmlErrorMessages . BUNDLE )  ;", "XmlErrorMessages . ourBundle    =    new   SoftReference <  >  ( bundle )  ;", "}", "return   bundle ;", "}", "METHOD_END"], "methodName": ["getBundle"], "fileName": "com.intellij.codeInsight.daemon.XmlErrorMessages"}, {"methodBody": ["METHOD_START", "{", "return   CommonBundle . message ( XmlErrorMessages . getBundle (  )  ,    key ,    params )  ;", "}", "METHOD_END"], "methodName": ["message"], "fileName": "com.intellij.codeInsight.daemon.XmlErrorMessages"}, {"methodBody": ["METHOD_START", "{", "if    (  ( tag . getAttributeValue ( name )  )     !  =    null )     {", "ContainerUtil . addAll ( refs ,    tag . getAttribute ( name ,    null )  . getValueElement (  )  . getReferences (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addRefsInPresent"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   attrNs    =    xmlAttribute . getNamespace (  )  ;", "assertEquals ( expectedNs ,    attrNs )  ;", "final   XmlTag   parent    =    xmlAttribute . getParent (  )  ;", "assertEquals ( parent . getAttribute ( xmlAttribute . getLocalName (  )  ,    attrNs )  ,    xmlAttribute )  ;", "assertEquals ( parent . getAttributeValue ( xmlAttribute . getLocalName (  )  ,    attrNs )  ,    xmlAttribute . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkAttribute"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "String   attributeValue    =    tag . getAttributeValue ( schemaAttrName )  ;", "if    ( attributeValue    !  =    null )     {", "XmlAttribute   attribute    =    tag . getAttribute ( schemaAttrName ,    null )  ;", "PsiReference [  ]    references    =    attribute . getValueElement (  )  . getReferences (  )  ;", "assertTrue (  (  \" There   should   resolvable   reference   to    \"     +    schemaAttrName )  ,     (  ( references . length )     >     0  )  )  ;", "for    ( PsiReference   reference    :    references )     {", "PsiElement   element    =    reference . resolve (  )  ;", "if    (  ( element    !  =    null )     &  &     ( element . getContainingFile (  )  . getName (  )  . equals ( resolveFileName )  )  )     {", "return ;", "}", "}", "assertTrue (  (  (  \" There   should   resolvable   reference   to    \"     +    schemaAttrName )     +     \"  ,     2  \"  )  ,    true )  ;", "}", "}", "METHOD_END"], "methodName": ["checkOneTagForSchemaAttribute"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   ExternalResourceManagerEx   manager    =    ExternalResourceManagerEx . getInstanceEx (  )  ;", "myOldDoctype    =    manager . getDefaultHtmlDoctype ( getProject (  )  )  ;", "manager . setDefaultHtmlDoctype (  \" fake \"  ,    getProject (  )  )  ;", "}", "METHOD_END"], "methodName": ["disableHtmlSupport"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "String [  ]    testNames    =    new   String [  ( resources    !  =    null    ?    resources . length    :     0  )     +     1  ]  ;", "testNames [  0  ]     =     (  (  (  . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  .  \"  )     +    ext ;", "if    ( resources    !  =    null )     {", "int   curResource    =     0  ;", "for    ( String [  ]    resource    :    resources )     {", "ExternalResourceManagerExImpl . registerResourceTemporarily ( resource [  0  ]  ,     (  (  ( getTestDataPath (  )  )     +     (  . BASE _ PATH )  )     +     ( resource [  1  ]  )  )  ,    getTestRootDisposable (  )  )  ;", "testNames [  (  +  + curResource )  ]     =     (  . BASE _ PATH )     +     ( resource [  1  ]  )  ;", "}", "}", "configureByFiles ( null ,    testNames )  ;", "}", "METHOD_END"], "methodName": ["doConfigureWithLocations"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  (  ( s    +     \"  .  \"  )     +    ext )  )  ;", "Collection < Info >    infos    =    doDoTest ( true ,    false )  ;", "findAndInvokeIntentionAction ( infos ,     \" Create   Entity   Declaration   entity \"  ,    myEditor ,    myFile )  ;", "checkResultByFile (  (  (  ( s    +     \"  _ after \"  )     +     \"  .  \"  )     +    ext )  )  ;", "}", "METHOD_END"], "methodName": ["doDtdEntityRefWithQuickFixTest"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  (  ( s    +     \"  .  \"  )     +    extension )  )  ;", "Collection < HighlightInfo >    infos    =    doDoTest ( true ,    false )  ;", "findAndInvokeIntentionAction ( infos ,     \" Create   Element   Declaration   aaa \"  ,    myEditor ,    myFile )  ;", "checkResultByFile (  (  ( s    +     \"  _ after .  \"  )     +    extension )  )  ;", "PsiDocumentManager . getInstance ( myProject )  . commitDocument ( myEditor . getDocument (  )  )  ;", "infos    =    do (  )  ;", "findAndInvokeIntentionAction ( infos ,     \" Create   Entity   Declaration   entity \"  ,    myEditor ,    myFile )  ;", "checkResultByFile (  (  ( s    +     \"  _ after 2  .  \"  )     +    extension )  )  ;", "PsiDocumentManager . getInstance ( myProject )  . commitDocument ( myEditor . getDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["doDtdRefsWithQuickFixTestSequence"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "List < VirtualFile >    files    =    new   ArrayList <  >  (  )  ;", "files . add ( getVirtualFile ( getFullRelativeTestName (  )  )  )  ;", "final   VirtualFile   virtualFile    =    getVirtualFile (  (  (  . BASE _ PATH )     +     ( getTestName ( false )  )  )  )  ;", "ContainerUtil . addAll ( files ,    virtualFile . getChildren (  )  )  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily ( url ,    UriUtil . findRelativeFile ( mainDtdName ,    virtualFile )  . getPath (  )  ,    getTestRootDisposable (  )  )  ;", "doTest ( VfsUtilCore . toVirtualFileArray ( files )  ,    true ,    false )  ;", "if    ( additionalTestAction    !  =    null )", "additionalTestAction . run (  )  ;", "}", "METHOD_END"], "methodName": ["doManyFilesFromSeparateDirTest"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "try    {", "List < VirtualFile >    files    =    new   ArrayList <  >  (  6  )  ;", "files . add ( getVirtualFile (  (  (  (  . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  . xml \"  )  )  )  ;", "final   Set < VirtualFile >    usedFiles    =    new   gnu . trove . THashSet (  )  ;", "final   String   base    =     (  (  . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \" Schemas /  \"  ;", "for    ( String [  ]    pair    :    urls )     {", "final   String   url    =    pair [  0  ]  ;", "final   String   filename    =     (  ( pair . length )     >     1  )     ?    pair [  1  ]     :     ( url . substring (  (  ( url . lastIndexOf (  '  /  '  )  )     +     1  )  )  )     +     ( url . endsWith (  \"  . xsd \"  )     ?     \"  \"     :     \"  . xsd \"  )  ;", "final   VirtualFile   virtualFile    =    getVirtualFile (  ( base    +    filename )  )  ;", "usedFiles . add ( virtualFile )  ;", "if    ( url    !  =    null )", "com . intellij . registerResourceTemporarily ( url ,    virtualFile . getPath (  )  ,    getTestRootDisposable (  )  )  ;", "files . add ( virtualFile )  ;", "}", "for    ( VirtualFile   file    :    LocalFileSystem . getInstance (  )  . findFileByPath (  (  ( getTestDataPath (  )  )     +     ( base . substring (  0  ,     (  ( base . length (  )  )     -     1  )  )  )  )  )  . getChildren (  )  )     {", "if    (  !  ( usedFiles . contains ( file )  )  )     {", "files . add ( file )  ;", "}", "}", "doTest ( VfsUtilCore . toVirtualFileArray ( files )  ,    true ,    false )  ;", "if    ( additionalTestingProcessor    !  =    null )", "additionalTestingProcessor . process ( files )  ;", "}    finally    {", ". unregisterResources ( urls )  ;", "}", "}", "METHOD_END"], "methodName": ["doSchemaTestWithManyFilesFromSeparateDir"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( false )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( getFullRelativeTestName (  )  ,    checkWarnings ,    false )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "try    {", "doConfigureWithLocations ( resources ,    ext )  ;", "doDoTest ( true ,    false )  ;", "}    finally    {", ". unregisterResources ( resources )  ;", "}", "}", "METHOD_END"], "methodName": ["doTestWithLocations"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  ( s    +     \"  . xml \"  )  )  ;", "Collection < Info >    infos    =    doDoTest ( true ,    withInfos )  ;", "findAndInvokeIntentionAction ( infos ,    intentionActionName ,    myEditor ,    myFile )  ;", "checkResultByFile (  ( s    +     \"  _ after . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestWithQuickFix"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestWithQuickFix ( s ,    XmlHighlightingTest . CREATE _ NAMESPACE _ DECLARATION _ INTENTION _ NAME ,    false )  ;", "}", "METHOD_END"], "methodName": ["doTestWithUnboundNSQuickFix"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "ExternalResourceManagerEx . getInstanceEx (  )  . setDefaultHtmlDoctype ( myOldDoctype ,    getProject (  )  )  ;", "}", "METHOD_END"], "methodName": ["enableHtmlSupport"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "for    ( Iterator < HighlightInfo >    i    =    highlightInfos . iterator (  )  ;    i . hasNext (  )  ;  )     {", "final   HighlightInfo   highlightInfo    =    i . next (  )  ;", "if    (  ( highlightInfo . getSeverity (  )  )     =  =     ( HighlightSeverity . INFORMATION )  )", "i . remove (  )  ;", "}", "return   highlightInfos ;", "}", "METHOD_END"], "methodName": ["filterInfos"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "return   getFullRelativeTestName (  \"  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["getFullRelativeTestName"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "return    (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )     +    ext ;", "}", "METHOD_END"], "methodName": ["getFullRelativeTestName"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "Method   method ;", "try    {", "method    =    testClass . getMethod (  (  \" test \"     +    testName )  )  ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "final    . HighlightingFlags   annotation    =    method . getAnnotation (  . HighlightingFlags . class )  ;", "if    ( annotation    !  =    null )     {", "final    . HighlightingFlag [  ]    testOptions    =    annotation . value (  )  ;", "if    ( testOptions    !  =    null )     {", "Arrays . sort ( testOptions )  ;", "return    ( Arrays . binarySearch ( testOptions ,    flag )  )     >  =     0  ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["methodOfTestHasAnnotation"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFiles ( null ,     (  ( XmlHighlightingTest . BASE _ PATH )     +     \" anyAttribute . xml \"  )  ,     (  ( XmlHighlightingTest . BASE _ PATH )     +     \" services -  1  .  0  . xsd \"  )  )  ;", "doDoTest ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testAnyAttribute"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFiles ( null ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" AnyAttributeNavigation / test . xml \"  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" AnyAttributeNavigation / test . xsd \"  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" AnyAttributeNavigation / library . xsd \"  )  )  )  ;", "PsiReference   at    =    getFile (  )  . findReferenceAt ( getEditor (  )  . getCaretModel (  )  . getOffset (  )  )  ;", "XmlTag   tag    =    PsiTreeUtil . getParentOfType ( at . getElement (  )  ,    XmlTag . class )  ;", "XmlElementDescriptorImpl   descriptor    =     (  ( XmlElementDescriptorImpl )     ( tag . getDescriptor (  )  )  )  ;", "XmlAttributeDescriptor [  ]    descriptors    =    descriptor . getAttributesDescriptors ( tag )  ;", "System . out . println ( Arrays . asList ( descriptors )  )  ;", "doDoTest ( true ,    false )  ;", "PsiElement   resolve    =    at . resolve (  )  ;", "assertTrue (  ( resolve   instanceof   XmlTag )  )  ;", "}", "METHOD_END"], "methodName": ["testAnyAttributeNavigation"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestWithLocations ( new   String [  ]  [  ]  {    new   String [  ]  {     \" http :  /  / www . foo . org / test \"  ,     ( getTestName ( false )  )     +     \"  . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . bar . org / test \"  ,     ( getTestName ( false )  )     +     \"  _  2  . xsd \"     }     }  ,     \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testAnyAttributesInAttrGroup"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" badXmlns . xml \"  )  )  ;", "doHighlighting (  )  ;", "}", "METHOD_END"], "methodName": ["testBadXmlns"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFiles ( null ,     (  ( XmlHighlightingTest . BASE _ PATH )     +     \" BillionLaughs . xml \"  )  )  ;", "XmlFile   file    =     (  ( XmlFile )     ( getFile (  )  )  )  ;", "int [  ]    count    =    new   int [  ]  {     0     }  ;", "XmlUtil . processXmlElements ( file . getRootTag (  )  ,     (    element )     -  >     {", "( count [  0  ]  )  +  +  ;", "return   true ;", "}  ,    false )  ;", "assertEquals (  9  ,    count [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testBillionLaughs"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFiles ( null ,     (  ( XmlHighlightingTest . BASE _ PATH )     +     \" BillionLaughs . xml \"  )  )  ;", "doDoTest ( false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testBillionLaughsValidation"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "enableInspectionTool ( new   XmlWrongRootElementInspection (  )  )  ;", "final   String   testName    =    getTestName ( false )  ;", "configureByFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  . xml \"  )  )  ;", "Collection < HighlightInfo >    infos    =    doDoTest ( true ,    false )  ;", "findAndInvokeIntentionAction ( infos ,     \" Change   root   tag   name   to   xxx \"  ,    myEditor ,    myFile )  ;", "checkResultByFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  _ after . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testChangeRootElement"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testClosedTag2"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testCommentBeforeProlog"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testCommentBeforeProlog_2"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "String   location    =     \" Tapestry _  3  _  0  . dtd \"  ;", "String   url    =     \" http :  /  / jakarta . apache . org / tapestry / dtd / Tapestry _  3  _  0  . dtd \"  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily ( url ,    location ,    getTestRootDisposable (  )  )  ;", "myTestJustJaxpValidation    =    true ;", "doTest ( new   VirtualFile [  ]  {    getVirtualFile ( getFullRelativeTestName (  )  )  ,    getVirtualFile (  (  (  . BASE _ PATH )     +    location )  )     }  ,    false ,    false )  ;", "myTestJustJaxpValidation    =    false ;", "}", "METHOD_END"], "methodName": ["testComplexDtdValidation"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "String   location    =     ( getTestName ( false )  )     +     \"  . dtd \"  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily ( location ,    location ,    getTestRootDisposable (  )  )  ;", "myTestJustJaxpValidation    =    true ;", "doTest ( new   VirtualFile [  ]  {    getVirtualFile ( getFullRelativeTestName (  )  )  ,    getVirtualFile (  (  (  . BASE _ PATH )     +    location )  )     }  ,    false ,    false )  ;", "myTestJustJaxpValidation    =    false ;", "}", "METHOD_END"], "methodName": ["testComplexDtdValidation2"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String [  ]  [  ]    urls    =    new   String [  ]  [  ]  {    new   String [  ]  {     \" http :  /  / graphml . graphdrawing . org / xmlns \"  ,     \" graphml . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / graphml . graphdrawing . org / xmlns /  1  .  0  / graphml - structure . xsd \"  ,     \" graphml - structure . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . w 3  . org /  1  9  9  9  / xlink \"  ,     \" xlink . xsd \"     }     }  ;", "doSchemaWithManyFilesFromSeparateDir ( urls ,    null )  ;", "}", "METHOD_END"], "methodName": ["testComplexRedefine"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String [  ]  [  ]    urls    =    new   String [  ]  [  ]  {    new   String [  ]  {     \" http :  /  / www . yworks . com / xml / schema / graphml /  1  .  0  / ygraphml . xsd \"  ,     \" ygraphml . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / graphml . graphdrawing . org / xmlns /  1  .  0  / xlink . xsd \"  ,     \" xlink . xsd \"     }     }  ;", "doSchemaWithManyFilesFromSeparateDir ( urls ,    null )  ;", "}", "METHOD_END"], "methodName": ["testComplexRedefine2"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "VirtualFile [  ]    files    =    new   VirtualFile [  ]  {    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  _  2  . xsd \"  )  )  ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  _  3  . xsd \"  )  )     }  ;", "doTest ( files ,    true ,    false )  ;", "files    =    new   VirtualFile [  ]  {    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  . xsd \"  )  )  ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  _  2  . xsd \"  )  )  ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  _  3  . xsd \"  )  )     }  ;", "doTest ( files ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testComplexRedefine3"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "VirtualFile [  ]    files    =    new   VirtualFile [  ]  {    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  . xml \"  )  )  ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  . xsd \"  )  )  ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  _  2  . xsd \"  )  )     }  ;", "doTest ( files ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testComplexRedefine4"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "String [  ]  [  ]    urls    =    new   String [  ]  [  ]  {    new   String [  ]  {     \" http :  /  / extended \"  ,    testName    +     \"  . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / simple \"  ,    testName    +     \"  _  2  . xsd \"     }     }  ;", "doTestWithLocations ( urls ,     \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testComplexRedefine5"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "String [  ]  [  ]    urls    =    new   String [  ]  [  ]  {    new   String [  ]  {     \" urn : jboss : bean - deployer :  2  .  0  \"  ,    testName    +     \"  . xsd \"     }  ,    new   String [  ]  {     \"  \"  ,    testName    +     \"  _  2  . xsd \"     }     }  ;", "doTestWithLocations ( urls ,     \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testComplexRedefine6"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFiles ( null ,     (  (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  . xml \"  )  ,     (  ( XmlHighlightingTest . BASE _ PATH )     +     \" mylib . jar \"  )  )  ;", "String   path    =     ( myFile . getVirtualFile (  )  . getParent (  )  . getPath (  )  )     +     \"  /  \"  ;", "String [  ]  [  ]    urls    =    new   String [  ]  [  ]  {    new   String [  ]  {     \" http :  /  / graphml . graphdrawing . org / xmlns \"  ,    path    +     \" mylib . jar !  / graphml . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / graphml . graphdrawing . org / xmlns /  1  .  0  / graphml - structure . xsd \"  ,    path    +     \" mylib . jar !  / graphml - structure . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . w 3  . org /  1  9  9  9  / xlink \"  ,    path    +     \" mylib . jar !  / xlink . xsd \"     }     }  ;", "for    ( String [  ]    s    :    urls )", "com . intellij . registerResourceTemporarily ( s [  0  ]  ,    s [  1  ]  ,    getTestRootDisposable (  )  )  ;", "doDoTest ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testComplexRedefineFromJar"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "try    {", "do ( getFullRelativeName (  )  ,    false ,    false )  ;", "}    finally    {", "}", "}", "METHOD_END"], "methodName": ["testComplexSchemaValidation"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "final   String   basePath    =     (  . BASE _ PATH )     +    testName ;", "configureByFiles ( null ,    getVirtualFile (  ( basePath    +     \"  . xsd \"  )  )  ,    getVirtualFile (  ( basePath    +     \"  _  2  . xsd \"  )  )  )  ;", "doDoTest ( true ,    false )  ;", "final   List < PsiReference >    refs    =    new   ArrayList <  >  (  2  )  ;", "myFile . acceptChildren ( new   XmlRecursiveElementVisitor (  )     {", "@ Override", "public   void   visitXmlTag ( XmlTag   tag )     {", "super . visitXmlTag ( tag )  ;", ". addRefsInPresent ( tag ,     \" base \"  ,    refs )  ;", "if    (  \" group \"  . equals ( tag . getLocalName (  )  )  )     {", ". addRefsInPresent ( tag ,     \" ref \"  ,    refs )  ;", "}", "}", "}  )  ;", "assertEquals (  2  ,    refs . size (  )  )  ;", "PsiElement   psiElement    =    refs . get (  0  )  . resolve (  )  ;", "assertNotNull ( psiElement )  ;", "assertEquals (  (  ( getTestName ( false )  )     +     \"  _  2  . xsd \"  )  ,    psiElement . getContainingFile (  )  . getName (  )  )  ;", "psiElement    =    refs . get (  1  )  . resolve (  )  ;", "assertNotNull ( psiElement )  ;", "assertEquals (  (  ( getTestName ( false )  )     +     \"  _  2  . xsd \"  )  ,    psiElement . getContainingFile (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testComplexSchemaValidation10"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "doTestWithLocations ( new   String [  ]  [  ]  {    new   String [  ]  {     \" http :  /  / www . springframework . org / schema / beans \"  ,    testName    +     \"  . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . springframework . org / schema / util \"  ,    testName    +     \"  _  2  . xsd \"     }     }  ,     \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testComplexSchemaValidation11"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   basePath    =     ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  ;", "configureByFile (  ( basePath    +     \"  . xsd \"  )  ,    null )  ;", "doDoTest ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testComplexSchemaValidation12"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestWithLocations ( new   String [  ]  [  ]  {    new   String [  ]  {     \" urn : test \"  ,     ( getTestName ( false )  )     +     \"  _  2  . xsd \"     }     }  ,     \" xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testComplexSchemaValidation13"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestWithLocations ( new   String [  ]  [  ]  {    new   String [  ]  {     \" parent \"  ,     ( getTestName ( false )  )     +     \"  . xsd \"     }     }  ,     \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testComplexSchemaValidation14"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( getFullRelativeTestName (  \"  . xsd \"  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testComplexSchemaValidation14_2"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestWithLocations ( new   String [  ]  [  ]  {    new   String [  ]  {     \" http :  /  / www . linkedin . com / lispring \"  ,     ( getTestName ( false )  )     +     \"  . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . springframework . org / schema / beans \"  ,     ( getTestName ( false )  )     +     \"  _  2  . xsd \"     }     }  ,     \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testComplexSchemaValidation15"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestWithLocations ( new   String [  ]  [  ]  {    new   String [  ]  {     \" http :  /  / www . inversoft . com / schemas / savant -  2  .  0  / project \"  ,     ( getTestName ( false )  )     +     \"  . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . inversoft . com / schemas / savant -  2  .  0  / base \"  ,     ( getTestName ( false )  )     +     \"  _  2  . xsd \"     }     }  ,     \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testComplexSchemaValidation16"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestWithLocations ( new   String [  ]  [  ]  {    new   String [  ]  {     \" urn : test \"  ,     ( getTestName ( false )  )     +     \"  . xsd \"     }     }  ,     \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testComplexSchemaValidation17"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "doTest ( new   VirtualFile [  ]  {    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  . xml \"  )  )  ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  . xsd \"  )  )  ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  _  2  . xsd \"  )  )     }  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testComplexSchemaValidation18"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "doTest ( new   VirtualFile [  ]  {    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  . xml \"  )  )  ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  . xsd \"  )  )  ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  _  2  . xsd \"  )  )     }  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testComplexSchemaValidation19"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( new   VirtualFile [  ]  {    getVirtualFile ( getFullRelativeTestName (  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" jdo _  2  _  0  . xsd \"  )  )     }  ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testComplexSchemaValidation2"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "doTest ( new   VirtualFile [  ]  {    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  . xml \"  )  )  ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  . xsd \"  )  )  ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  _  2  . xsd \"  )  )     }  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testComplexSchemaValidation20"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "List < VirtualFile >    files    =    new   ArrayList <  >  (  )  ;", "files . add ( getVirtualFile ( getFullRelativeTestName (  )  )  )  ;", "final   VirtualFile   virtualFile    =    getVirtualFile (  (  (  . BASE _ PATH )     +     \" ComplexSchemaValidation 3 Schemas \"  )  )  ;", "ContainerUtil . addAll ( files ,    virtualFile . getChildren (  )  )  ;", "doTest ( VfsUtilCore . toVirtualFileArray ( files )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testComplexSchemaValidation3"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "String [  ]  [  ]    urls    =    new   String [  ]  [  ]  {    new   String [  ]  {     \" http :  /  / www . unece . org / etrades / unedocs / repository / codelists / xml / CountryCode . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . swissdec . ch / schema / sd /  2  0  0  5  0  9  0  2  / SalaryDeclarationServiceTypes \"     }  ,    new   String [  ]  {     \" http :  /  / www . swissdec . ch / schema / sd /  2  0  0  5  0  9  0  2  / SalaryDeclarationContainer \"     }  ,    new   String [  ]  {     \" http :  /  / www . swissdec . ch / schema / sd /  2  0  0  5  0  9  0  2  / SalaryDeclaration \"     }     }  ;", "doSchemaTestWithManyFilesFromSeparateDir ( urls ,    null )  ;", "}", "METHOD_END"], "methodName": ["testComplexSchemaValidation4"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "String   location    =     ( getTestName ( false )  )     +     \"  . xsd \"  ;", "String   url    =     \" http :  /  / www . etas . com / TELEGY / Test \"  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily ( url ,    location ,    getTestRootDisposable (  )  )  ;", "doTest ( new   VirtualFile [  ]  {    getVirtualFile ( getFullRelativeTestName (  )  )  ,    getVirtualFile (  (  (  . BASE _ PATH )     +    location )  )     }  ,    false ,    false )  ;", "final   XmlTag [  ]    subTags    =     (  ( XmlFile )     ( myFile )  )  . getDocument (  )  . getRootTag (  )  . getSubTags (  )  ;", "for    ( XmlTag   t    :    subTags )     {", "final   PsiReference   reference    =    t . getReference (  )  ;", "assertNotNull ( reference )  ;", "final   PsiElement   psiElement    =    reference . resolve (  )  ;", "assertTrue (  (  ( psiElement   instanceof   XmlTag )     &  &     (  \" xsd : element \"  . equals (  (  ( XmlTag )     ( psiElement )  )  . getName (  )  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testComplexSchemaValidation5"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "String   location    =     ( getTestName ( false )  )     +     \"  . xsd \"  ;", "String   url    =     \" http :  /  / abcde / pg . html \"  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily ( url ,    location ,    getTestRootDisposable (  )  )  ;", "doTest ( new   VirtualFile [  ]  {    getVirtualFile ( getFullRelativeTestName (  )  )  ,    getVirtualFile (  (  (  . BASE _ PATH )     +    location )  )     }  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testComplexSchemaValidation6"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "String [  ]  [  ]    urlLocationPairs    =    new   String [  ]  [  ]  {    new   String [  ]  {     \" http :  /  / schemas . xmlsoap . org / wsdl /  \"  ,     \" wsdl . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / schemas . xmlsoap . org / wsdl / soap /  \"  ,     \" soap . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / schemas . xmlsoap . org / soap / encoding /  \"  ,     \" encoding . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / schemas . xmlsoap . org / wsdl / mime /  \"  ,     \" mime . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / schemas . xmlsoap . org / wsdl / http /  \"  ,     \" http . xsd \"     }     }  ;", "doSchemaTestWithManyFilesFromSeparateDir ( urlLocationPairs ,     (    files )     -  >     {", "try    {", "files . set (  0  ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  _  2  . xml \"  )  )  )  ;", "doTest ( VfsUtilCore . toVirtualFileArray ( files )  ,    true ,    false )  ;", "return   true ;", "}    catch    (    e )     {", "throw   new    < e > RuntimeException (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testComplexSchemaValidation7"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( new   VirtualFile [  ]  {    getVirtualFile ( getFullRelativeTestName (  )  )  ,    getVirtualFile ( getFullRelativeTestName (  \"  . xsd \"  )  )     }  ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testComplexSchemaValidation7_"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "String   location    =    testName    +     \"  . xsd \"  ;", "String   location 2     =    testName    +     \"  _  2  . xsd \"  ;", "String   url    =     \" http :  /  / drools . org / rules \"  ;", "String   url 2     =     \" http :  /  / drools . org / semantics / groovy \"  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily ( url ,    location ,    getTestRootDisposable (  )  )  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily ( url 2  ,    location 2  ,    getTestRootDisposable (  )  )  ;", "final   String   basePath    =     (  . BASE _ PATH )     +    testName ;", "configureByFiles ( null ,    getVirtualFile (  ( basePath    +     \"  . xml \"  )  )  ,    getVirtualFile (  ( basePath    +     \"  . xsd \"  )  )  ,    getVirtualFile (  ( basePath    +     \"  _  2  . xsd \"  )  )  )  ;", "doDoTest ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testComplexSchemaValidation8"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   basePath    =     ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  ;", "configureByFiles ( null ,    getVirtualFile (  ( basePath    +     \"  . xml \"  )  )  ,    getVirtualFile (  ( basePath    +     \"  . xsd \"  )  )  )  ;", "doDoTest ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testComplexSchemaValidation9"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  (  (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  . xml \"  )  )  ;", "Collection < HighlightInfo >    infos    =    XmlHighlightingTest . filterInfos ( doHighlighting (  )  )  ;", "assertEquals (  2  ,    infos . size (  )  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >    EditorModificationUtil . deleteSelectedText ( myEditor )  )  ;", "infos    =    XmlHighlightingTest . filterInfos ( doHighlighting (  )  )  ;", "assertEquals (  1  1  ,    infos . size (  )  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >    EditorModificationUtil . insertStringAtCaret ( myEditor ,     \"  <  \"  )  )  ;", "new   completion . CodeCompletionHandlerBase ( CompletionType . BASIC )  . invokeCompletion ( myProject ,    myEditor )  ;", "infos    =    XmlHighlightingTest . filterInfos ( doHighlighting (  )  )  ;", "assertEquals (  2  ,    infos . size (  )  )  ;", "LookupManager . getInstance ( myProject )  . hideActiveLookup (  )  ;", "}", "METHOD_END"], "methodName": ["testCorrectGeneratedDtdUpdate"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFiles ( null ,     (  ( XmlHighlightingTest . BASE _ PATH )     +     \" CustomBoolean . xml \"  )  ,     (  ( XmlHighlightingTest . BASE _ PATH )     +     \" CustomBoolean . xsd \"  )  )  ;", "doDoTest ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testCustomBoolean"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \"  <  ! ENTITY    %    Charsets    \\  \" CDATA \\  \"  >  \"  ;", "Editorer   dtder    =    erFactory . createer ( DTD ,    EditorColorsManager . getInstance (  )  . getGlobalScheme (  )  ,    myProject )  ;", "dtder . setText ( text )  ;", "erIterator   iterator    =    dtder . createIterator (  3  )  ;", "assertSame (  \" Xml   entity   name \"  ,    iterator . getTokenType (  )  ,    XmlTokenType . XML _ ENTITY _ DECL _ START )  ;", "iterator    =    dtder . createIterator (  1  3  )  ;", "assertSame (  \" Xml   name   in   dtd \"  ,    iterator . getTokenType (  )  ,    XmlTokenType . XML _ NAME )  ;", "iterator    =    dtder . createIterator (  2  3  )  ;", "assertSame (  \" Xml   attribute   value   in   dtd \"  ,    iterator . getTokenType (  )  ,    XmlTokenType . XML _ ATTRIBUTE _ VALUE _ TOKEN )  ;", "text    =     \"  <  ! ELEMENT   base   EMPTY >  \\ n <  ! ATTLIST   base   id   ID    # IMPLIED >  \"  ;", "dtder . setText ( text )  ;", "iterator    =    dtder . createIterator (  3  )  ;", "assertSame (  \" Xml   element   name \"  ,    iterator . getTokenType (  )  ,    XmlTokenType . XML _ ELEMENT _ DECL _ START )  ;", "iterator    =    dtder . createIterator (  2  5  )  ;", "assertSame (  \" Xml   attr   list \"  ,    iterator . getTokenType (  )  ,    XmlTokenType . XML _ ATTLIST _ DECL _ START )  ;", "iterator    =    dtder . createIterator (  1  4  )  ;", "assertSame (  \" Xml   attr   list \"  ,    iterator . getTokenType (  )  ,    WHITE _ SPACE )  ;", "iterator    =    dtder . createIterator (  2  1  )  ;", "assertSame (  \" Xml   attr   list \"  ,    iterator . getTokenType (  )  ,    WHITE _ SPACE )  ;", "text    =     \"  <  !  [  % sgml ;  [  <  !  [ IGNORE [  <  !  [    INCLUDE    [  <  ! ENTITY    %    aaa   SYSTEM    ' zzz '  >  ]  ]  >  ]  ]  >  ]  ]  >  \"  ;", "dtder . setText ( text )  ;", "iterator    =    dtder . createIterator (  2  )  ;", "assertEquals (  \" Xml   conditional   section   start \"  ,    XmlTokenType . XML _ CONDITIONAL _ SECTION _ START ,    iterator . getTokenType (  )  )  ;", "iterator    =    dtder . createIterator (  6  7  )  ;", "assertEquals (  \" Xml   conditional   section   end \"  ,    XmlTokenType . XML _ CONDITIONAL _ SECTION _ END ,    iterator . getTokenType (  )  )  ;", "iterator    =    dtder . createIterator (  5  )  ;", "assertEquals (  \" entity   ref   in   conditional   section \"  ,    XmlTokenType . XML _ ENTITY _ REF _ TOKEN ,    iterator . getTokenType (  )  )  ;", "iterator    =    dtder . createIterator (  1  5  )  ;", "assertEquals (  \" ignore   in   conditional   section \"  ,    XmlTokenType . XML _ CONDITIONAL _ IGNORE ,    iterator . getTokenType (  )  )  ;", "iterator    =    dtder . createIterator (  2  7  )  ;", "assertEquals (  \" include   in   conditional   section \"  ,    XmlTokenType . XML _ CONDITIONAL _ INCLUDE ,    iterator . getTokenType (  )  )  ;", "iterator    =    dtder . createIterator (  9  )  ;", "assertEquals (  \" markup   start   in   conditional   section \"  ,    XmlTokenType . XML _ MARKUP _ START ,    iterator . getTokenType (  )  )  ;", "iterator    =    dtder . createIterator (  3  3  )  ;", "assertEquals (  \" entity   decl   start   in   conditional   section \"  ,    XmlTokenType . XML _ ENTITY _ DECL _ START ,    iterator . getTokenType (  )  )  ;", "text    =     \"  <  ! ENTITY    %    ContentType    \\  \" CDATA \\  \"  \\ n             -  -    media   type ,    as   per    [ RFC 2  0  4  5  ]  \\ n             -  -     -  - xxx -  -  >  \"  ;", "dtder . setText ( text )  ;", "iterator    =    dtder . createIterator (  3  5  )  ;", "assertEquals (  \" Dtd   comment   start \"  ,    XmlTokenType . XML _ COMMENT _ START ,    iterator . getTokenType (  )  )  ;", "iterator    =    dtder . createIterator (  4  0  )  ;", "assertEquals (  \" Dtd   comment   content \"  ,    XmlTokenType . XML _ COMMENT _ CHARACTERS ,    iterator . getTokenType (  )  )  ;", "iterator    =    dtder . createIterator (  7  1  )  ;", "assertEquals (  \" Dtd   comment   end \"  ,    XmlTokenType . XML _ COMMENT _ END ,    iterator . getTokenType (  )  )  ;", "iterator    =    dtder . createIterator (  7  8  )  ;", "assertEquals (  \" Dtd   comment   content \"  ,    XmlTokenType . XML _ COMMENT _ CHARACTERS ,    iterator . getTokenType (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDTDEditorHighlighting"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestWithLocations ( null ,     \" xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultAndFixedInSchema"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestWithLocations ( new   String [  ]  [  ]  {    new   String [  ]  {     \" http :  /  / docbook . org / ns / docbook \"  ,     \" DocBookV 5  . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . w 3  . org /  1  9  9  9  / xlink \"  ,     \" xlink . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . w 3  . org / XML /  1  9  9  8  / namespace \"  ,     \" xml . xsd \"     }     }  ,     \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testDocBook5"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doManyFilesFromSeparateDirTest (  \" http :  /  / www . oasis - open . org / docbook / xml /  4  .  4  / docbookx . dtd \"  ,     \" docbookx . dtd \"  ,     (  )     -  >     {", "XmlTag   rootTag    =     (  ( XmlFile )     ( myFile )  )  . getDocument (  )  . getRootTag (  )  ;", "PsiElement   psiElement    =    rootTag . getReferences (  )  [  0  ]  . resolve (  )  ;", "assertTrue (  (  ( Navigatable )     ( psiElement )  )  . canNavigate (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testDocBookHighlighting"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doManyFilesFromSeparateDirTest (  \" http :  /  / www . oasis - open . org / docbook / xml /  4  .  5  / docbookx . dtd \"  ,     \" docbookx . dtd \"  ,    null )  ;", "}", "METHOD_END"], "methodName": ["testDocBookHighlighting2"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestWithLocations ( new   String [  ]  [  ]  {    new   String [  ]  {     \" http :  /  / docbook . org / ns / docbook \"  ,     \" DocBookV 5  . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . w 3  . org /  1  9  9  9  / xlink \"  ,     \" xlink . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . w 3  . org / XML /  1  9  9  8  / namespace \"  ,     \" xml . xsd \"     }     }  ,     \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testDocBookRole"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestWithLocations ( new   String [  ]  [  ]  {    new   String [  ]  {     \" http :  /  / docbook . org / ns / docbook \"  ,     \" DocBookV 5  . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . w 3  . org /  1  9  9  9  / xlink \"  ,     \" xlink . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . w 3  . org / XML /  1  9  9  8  / namespace \"  ,     \" xml . xsd \"     }     }  ,     \" xml \"  )  ;", "doTestWithLocations ( new   String [  ]  [  ]  {    new   String [  ]  {     \" http :  /  / www . w 3  . org /  1  9  9  9  / xlink \"  ,     \" xlink . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . w 3  . org / XML /  1  9  9  8  / namespace \"  ,     \" xml . xsd \"     }     }  ,     \" xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testDocBookV5"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   baseName    =     ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  ;", "configureByFiles ( null ,    getVirtualFile (  ( baseName    +     \"  . xml \"  )  )  ,    getVirtualFile (  ( baseName    +     \"  . ent \"  )  )  )  ;", "doDoTest ( true ,    false )  ;", "myFile . accept ( new   XmlRecursiveElementVisitor (  )     {", "@ Override", "public   void   visitXmlAttributeValue ( XmlAttributeValue   value )     {", "final   PsiElement [  ]    children    =    value . getChildren (  )  ;", "for    ( PsiElement   child    :    children )     {", "if    ( child   instanceof   XmlEntityRef )     {", "PsiElement   psiElement    =    child . getReferences (  )  [  0  ]  . resolve (  )  ;", "assertNotNull ( psiElement )  ;", "assertEquals (  (  ( getTestName ( false )  )     +     \"  . ent \"  )  ,    psiElement . getContainingFile (  )  . getVirtualFile (  )  . getName (  )  )  ;", "assertTrue (  (  ( Navigatable )     ( psiElement )  )  . canNavigate (  )  )  ;", "}", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testDoctypeWithoutSchema"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   baseName    =     ( XmlHighlightingTest . BASE _ PATH )     +     \" DoctypeWithoutSchema \"  ;", "configureByFiles ( null ,    getVirtualFile (  ( baseName    +     \"  . xml \"  )  )  ,    getVirtualFile (  ( baseName    +     \"  . ent \"  )  )  )  ;", "doDoTest ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testDoctypeWithoutSchema2"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "try    {", "DumbServiceImpl . getInstance ( myProject )  . setDumb ( true )  ;", "configureByFiles ( null ,    getVirtualFile (  (  (  . BASE _ PATH )     +     \" AnyAttributeNavigation / test . xml \"  )  )  ,    getVirtualFile (  (  (  . BASE _ PATH )     +     \" AnyAttributeNavigation / test . xsd \"  )  )  ,    getVirtualFile (  (  (  . BASE _ PATH )     +     \" AnyAttributeNavigation / library . xsd \"  )  )  )  ;", "PsiReference   at    =    getFile (  )  . findReferenceAt ( getEditor (  )  . getCaretModel (  )  . getOffset (  )  )  ;", "XmlTag   tag    =    PsiTreeUtil . getParentOfType ( at . getElement (  )  ,    XmlTag . class )  ;", "XmlElementDescriptor   descriptor    =    tag . getDescriptor (  )  ;", "XmlAttributeDescriptor [  ]    descriptors    =    descriptor . getAttributesDescriptors ( tag )  ;", "System . out . println ( Arrays . asList ( descriptors )  )  ;", "}    finally    {", "DumbServiceImpl . getInstance ( myProject )  . setDumb ( false )  ;", "}", "doDoTest ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testDropAnyAttributeCacheOnExitFromDumbMode"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( new   VirtualFile [  ]  {    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" nuancevoicexml -  2  -  0  . xml \"  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" nuancevoicexml -  2  -  0  . dtd \"  )  )     }  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testDtdAutodetection"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestWithLocations ( new   String [  ]  [  ]  {    new   String [  ]  {     \" http :  /  / example . com / persistence \"  ,     \" XIncludeTestSchema . xsd \"     }     }  ,     \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testDtdElementRefs"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "doTestWithLocations ( new   String [  ]  [  ]  {    new   String [  ]  {     \" http :  /  / www . w 3  . org / TR / xhtml - modularization / DTD / xhtml - inlstyle -  1  . mod \"  ,    testName    +     \"  . mod \"     }     }  ,     \" dtd \"  )  ;", "}", "METHOD_END"], "methodName": ["testDtdHighlighting"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( new   VirtualFile [  ]  {    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" DtdWithXsd / help . xml \"  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" DtdWithXsd / helptopic . xsd \"  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" DtdWithXsd / html - entities . dtd \"  )  )     }  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testDtdWithXsd"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testDuplicateIdAttribute"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testDuplicateIdAttribute2"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doSchemaTestWithManyFilesFromSeparateDir ( new   String [  ]  [  ]  {    new   String [  ]  {     \" http :  /  / www . springframework . org / schema / beans / spring - beans -  2  .  5  . xsd \"  ,     \" spring - beans -  2  .  5  . xsd \"     }     }  ,    null )  ;", "}", "METHOD_END"], "methodName": ["testDuplicateNameAttribute"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestWithLocations ( null ,     \" xsd \"  )  ;", "doTestWithLocations ( null ,     \" dtd \"  )  ;", "doTestWithLocations ( null ,     \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testDuplicates"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \"  < html >  <  / html >  \"  ;", "EditorHighlighter   xmlHighlighter    =    erFactory . createXMLHighlighter ( EditorColorsManager . getInstance (  )  . getGlobalScheme (  )  )  ;", "xmlHighlighter . setText ( text )  ;", "HighlighterIterator   iterator    =    xmlHighlighter . createIterator (  1  )  ;", "assertSame (  \" Xml   tag   name \"  ,    iterator . getTokenType (  )  ,    XmlTokenType . XML _ TAG _ NAME )  ;", "iterator    =    xmlHighlighter . createIterator (  8  )  ;", "assertSame (  \" Xml   tag   name   at   end   of   tag \"  ,    iterator . getTokenType (  )  ,    XmlTokenType . XML _ TAG _ NAME )  ;", "text    =     \"  < a : xxx    /  >     < a : xxx   attr    =     \\  \"  1  1  1  1  \\  \"  /  >  \"  ;", "xmlHighlighter . setText ( text )  ;", "iterator    =    xmlHighlighter . createIterator (  6  )  ;", "assertEquals ( XmlTokenType . TAG _ WHITE _ SPACE ,    iterator . getTokenType (  )  )  ;", "iterator    =    xmlHighlighter . createIterator (  2  1  )  ;", "assertEquals ( XmlTokenType . TAG _ WHITE _ SPACE ,    iterator . getTokenType (  )  )  ;", "iterator    =    xmlHighlighter . createIterator (  2  3  )  ;", "assertEquals ( XmlTokenType . TAG _ WHITE _ SPACE ,    iterator . getTokenType (  )  )  ;", "iterator    =    xmlHighlighter . createIterator (  9  )  ;", "assertEquals ( XmlTokenType . XML _ REAL _ WHITE _ SPACE ,    iterator . getTokenType (  )  )  ;", "text    =     \"  <  ! DOCTYPE   schema    [     <  ! ENTITY   RelativeURL       \\  \"  [  ^  :  #  /  \\  \\  ?  ]  *  (  :  {  0  ,  0  }  |  [  #  /  \\  \\  ?  ]  .  *  )  \\  \"  >  \"  ;", "xmlHighlighter . setText ( text )  ;", "iterator    =    xmlHighlighter . createIterator (  5  3  )  ;", "assertSame (  \" Xml   attribute   value \"  ,    iterator . getTokenType (  )  ,    XmlTokenType . XML _ DATA _ CHARACTERS )  ;", "assertEquals ( iterator . getStart (  )  ,     4  1  )  ;", "assertEquals ( iterator . getEnd (  )  ,     7  0  )  ;", "text    =     \"  < a   name =  '  $  '  /  >  \"  ;", "xmlHighlighter . setText ( text )  ;", "iterator    =    xmlHighlighter . createIterator (  9  )  ;", "assertEquals (  \"  $    in   attr   value \"  ,    XmlTokenType . XML _ ATTRIBUTE _ VALUE _ TOKEN ,    iterator . getTokenType (  )  )  ;", "iterator    =    xmlHighlighter . createIterator (  1  0  )  ;", "assertEquals (  \"  '    after    $    in   attr   value \"  ,    XmlTokenType . XML _ ATTRIBUTE _ VALUE _ END _ DELIMITER ,    iterator . getTokenType (  )  )  ;", "text    =     \"  < project >  < jar   file =  \\  \"  $  {  \\  \"  >     <  / jar >  < jar   file =  \\  \"  $  {  }  \\  \"  /  >  <  / project >     \"  ;", "xmlHighlighter . setText ( text )  ;", "iterator    =    xmlHighlighter . createIterator (  2  2  )  ;", "assertEquals (  \"  $  {    in   attr   value \"  ,    XmlTokenType . XML _ ATTRIBUTE _ VALUE _ END _ DELIMITER ,    iterator . getTokenType (  )  )  ;", "text    =     \"  <  !  -  -  & nbsp ;     & aaa ;  -  -  >  \"  ;", "xmlHighlighter . setText ( text )  ;", "iterator    =    xmlHighlighter . createIterator (  5  )  ;", "assertEquals (  \" char   entity   in   comment \"  ,    XmlTokenType . XML _ COMMENT _ CHARACTERS ,    iterator . getTokenType (  )  )  ;", "iterator    =    xmlHighlighter . createIterator (  1  2  )  ;", "assertEquals (  \" entity   ref   in   comment \"  ,    XmlTokenType . XML _ COMMENT _ CHARACTERS ,    iterator . getTokenType (  )  )  ;", "text    =     \"  <  !  -  -     -  -     -  -  >  \"  ;", "xmlHighlighter . setText ( text )  ;", "iterator    =    xmlHighlighter . createIterator (  5  )  ;", "assertEquals (  \" double    -  -    in   xml   comment \"  ,    XmlTokenType . XML _ BAD _ CHARACTER ,    iterator . getTokenType (  )  )  ;", "}", "METHOD_END"], "methodName": ["testEditorHighlighting"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testEmptyNSRef"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( true )  ;", "}", "METHOD_END"], "methodName": ["testEncoding"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "final   XmlTag   rootTag    =     (  ( XmlFile )     ( myFile )  )  . getDocument (  )  . getRootTag (  )  ;", "final   List < XmlEntityRef >    refs    =    new   ArrayList <  >  (  )  ;", "XmlUtil . processXmlElements ( rootTag ,    new   PsiElementProcessor (  )     {", "@ Override", "public   boolean   execute (  @ NotNull", "final   PsiElement   element )     {", "if    ( element   instanceof   XmlEntityRef )     {", "refs . add (  (  ( XmlEntityRef )     ( element )  )  )  ;", "}", "return   true ;", "}", "}  ,    true )  ;", "assertEquals (  \" Should   be    2    entity   refs \"  ,     2  ,    refs . size (  )  )  ;", "PsiReference [  ]    entityRefs    =    refs . get (  0  )  . getReferences (  )  ;", "assertTrue (  (  (  ( entityRefs . length )     =  =     1  )     &  &     (  ( entityRefs [  0  ]  . resolve (  )  )     =  =    null )  )  )  ;", "entityRefs    =    refs . get (  1  )  . getReferences (  )  ;", "assertTrue (  (  (  ( entityRefs . length )     =  =     1  )     &  &     (  ( entityRefs [  0  ]  . resolve (  )  )     !  =    null )  )  )  ;", "doTest ( getFullRelativeTestName (  \"  2  . xml \"  )  ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testEntityHighlighting"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testEntityRefBadFormat"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testEntityRefWithEmptyDtd"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testEntityRefWithNoDtd"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  (  (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  . xsd \"  )  ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testEnumeratedAttributesValidation"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFiles ( null ,     (  ( XmlHighlightingTest . BASE _ PATH )     +     \" EnumeratedBoolean . xml \"  )  ,     (  ( XmlHighlightingTest . BASE _ PATH )     +     \" EnumeratedBoolean . xsd \"  )  )  ;", "doDoTest ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testEnumeratedBoolean"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "String   location    =     \" def _ xslt . dtd \"  ;", "String   url    =     \" http :  /  / www . w 3  . org /  1  9  9  9  / XSL / Transform \"  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily ( url ,    location ,    getTestRootDisposable (  )  )  ;", "doTest ( new   VirtualFile [  ]  {    getVirtualFile ( getFullRelativeTestName (  )  )  ,    getVirtualFile (  (  (  . BASE _ PATH )     +    location )  )     }  ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testErrorInDtd"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "List < String >    list    =    new   ArrayList <  >  (  )  ;", "list . add (  \" http :  /  / xml . apache . org / axis / wsdd 2  /  \"  )  ;", "list . add (  \" http :  /  / xml . apache . org / axis / wsdd 2  / providers / java \"  )  ;", "list . add (  \" http :  /  / soaprop . org / xsd 2  \"  )  ;", "ExternalResourceManagerEx . getInstanceEx (  )  . addIgnoredResources ( list ,    getTestRootDisposable (  )  )  ;", "doTest ( getFullRelativeTestName (  \"  . xml \"  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testExternalValidatorOnValidXmlWithNamespacesNotSetup"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "ExternalResourceManagerEx . getInstanceEx (  )  . addIgnoredResources ( Collections . singletonList (  \"  \"  )  ,    getTestRootDisposable (  )  )  ;", "doTest ( getFullRelativeTestName (  \"  . xml \"  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testExternalValidatorOnValidXmlWithNamespacesNotSetup2"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "doTest ( new   VirtualFile [  ]  {    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  . xml \"  )  )  ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  . xsd \"  )  )     }  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testHighlightWhenNoNsSchemaLocation"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "configureByFiles ( null ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  . xml \"  )  )  ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  . dtd \"  )  )  )  ;", "doDoTest ( true ,    false )  ;", "configureByFiles ( null ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  2  . xml \"  )  )  ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  . dtd \"  )  )  )  ;", "doDoTest ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testHighlightingWithConditionalSectionsInDtd"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "ExternalResourceManagerEx . getInstanceEx (  )  . addIgnoredResources ( Collections . singletonList (  \" http :  /  / ignored / uri \"  )  ,    getTestRootDisposable (  )  )  ;", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testIgnoredNamespaceHighlighting"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "configureByFiles ( null ,     (  (  (  . BASE _ PATH )     +    testName )     +     \"  . xsd \"  )  ,     (  (  (  . BASE _ PATH )     +    testName )     +     \"  2  . xsd \"  )  )  ;", "doDoTest ( true ,    false ,    true )  ;", "}", "METHOD_END"], "methodName": ["testImportProblems"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testInvalidIdRefAttribute"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( getFullRelativeTestName (  )  ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testInvalidIdRefInXsl"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  (  (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  . xml \"  )  )  ;", "doDoTest ( true ,    false )  ;", "List < WebReference >    list    =    PlatformTestUtil . collectWebReferences ( myFile )  ;", "assertEquals (  2  ,    list . size (  )  )  ;", "Collections . sort ( list ,    Comparator . comparingInt (  (    o )     -  >    o . getCanonicalText (  )  . length (  )  )  )  ;", "assertEquals (  \" https :  /  / www . jetbrains . com / ruby / download \"  ,    list . get (  0  )  . getCanonicalText (  )  )  ;", "assertTrue (  (  ( list . get (  0  )  . getElement (  )  )    instanceof   XmlAttributeValue )  )  ;", "assertEquals (  \" http :  /  / blog . jetbrains . com / ruby /  2  0  1  2  /  0  4  / rubymine -  4  -  0  -  3  - update - is - available /  \"  ,    list . get (  1  )  . getCanonicalText (  )  )  ;", "assertTrue (  (  ( list . get (  1  )  . getElement (  )  )    instanceof   XmlComment )  )  ;", "}", "METHOD_END"], "methodName": ["testLinksInAttrValuesAndComments"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testManyRootTags"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestWithLocations ( new   String [  ]  [  ]  {    new   String [  ]  {     \" schemas / Forms . xsd \"  ,     \" Forms . xsd \"     }     }  ,     \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testMappedSchemaLocation"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( getFullRelativeTestName (  )  ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testMavenValidation"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFiles ( null ,     (  ( XmlHighlightingTest . BASE _ PATH )     +     \" MaxOccurLimit . xml \"  )  ,     (  ( XmlHighlightingTest . BASE _ PATH )     +     \" MaxOccurLimit . xsd \"  )  )  ;", "assertTrue ( doHighlighting (  )  . stream (  )  . anyMatch (  (    info )     -  >     ( info . getSeverity (  )  )     =  =    HighlightSeverity . ERROR )  )  ;", "configureByFiles ( null ,     (  ( XmlHighlightingTest . BASE _ PATH )     +     \" MaxOccurLimit . xml \"  )  ,     (  ( XmlHighlightingTest . BASE _ PATH )     +     \" MaxOccurLimit . xsd \"  )  )  ;", "System . setProperty ( ValidateXmlActionHandler . JDK _ XML _ MAX _ OCCUR _ LIMIT ,     \"  1  0  0  0  0  \"  )  ;", "assertFalse ( doHighlighting (  )  . stream (  )  . anyMatch (  (    info )     -  >     ( info . getSeverity (  )  )     =  =    HighlightSeverity . ERROR )  )  ;", "}", "METHOD_END"], "methodName": ["testMaxOccurLimitValidation"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestWithLocations ( null ,     \" xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testMinMaxOccursInSchema"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "enableInspectionTool ( new   HtmlUnknownTagInspection (  )  )  ;", "doTest ( getFullRelativeTestName (  \"  . html \"  )  ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["testMobileHtml"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String [  ]  [  ]    urls    =    new   String [  ]  [  ]  {    new   String [  ]  {     \" http :  /  / www . springframework . org / schema / beans / spring - beans -  2  .  0  . xsd \"  ,     \" spring - beans -  2  .  0  . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . springframework . org / schema / tool \"  ,     \" spring - tool -  2  .  5  . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . springframework . org / schema / context / spring - context -  2  .  5  . xsd \"  ,     \" spring - context -  2  .  5  . xsd \"     }  ,    new   String [  ]  {     \" urn : xxx \"  ,     \" mule . xsd \"     }  ,    new   String [  ]  {     \" urn : yyy \"  ,     \" mule - management . xsd \"     }     }  ;", "doWithLocations ( urls ,     \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testMuleConfigHighlighting"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "String   path    =     ( getTestName ( false )  )     +     ( File . separatorChar )  ;", "final   String [  ]  [  ]    urls    =    new   String [  ]  [  ]  {    new   String [  ]  {     \" http :  /  / www . springframework . org / schema / beans / spring - beans -  2  .  0  . xsd \"  ,     \" spring - beans -  2  .  0  . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . springframework . org / schema / tool \"  ,     \" spring - tool -  2  .  5  . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . springframework . org / schema / context / spring - context -  2  .  5  . xsd \"  ,     \" spring - context -  2  .  5  . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . mulesource . org / schema / mule / core /  2  .  2  \"  ,    path    +     \" mule 2  _  2  . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . mulesource . org / schema / mule / cxf /  2  .  2  \"  ,    path    +     \" mule 2  _  2  - cxf . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / cxf . apache . org / core \"  ,    path    +     \" cxf _ core . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / cxf . apache . org / configuration / beans \"  ,    path    +     \" cxf - beans . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . mulesource . org / schema / mule / schemadoc /  2  .  2  \"  ,    path    +     \" mule 2  _  2  - schemadoc . xsd \"     }     }  ;", "doTestWithLocations ( urls ,     \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testMuleConfigHighlighting2"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doSchemaTestWithManyFilesFromSeparateDir ( new   String [  ]  [  ]  {    new   String [  ]  {     \" http :  /  / www . springframework . org / schema / tool \"  ,     \" spring - tool -  2  .  5  . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . springframework . org / schema / beans / spring - beans -  2  .  5  . xsd \"  ,     \" spring - beans -  2  .  5  . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . mulesource . org / schema / mule / core /  2  .  2  / mule . xsd \"  ,     \" mule . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . mulesource . org / schema / mule / stdio /  2  .  2  / mule - stdio . xsd \"  ,     \" mule - stdio . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . springframework . org / schema / context / spring - context -  2  .  5  . xsd \"  ,     \" spring - context -  2  .  5  . xsd \"     }  ,    new   String [  ]  {     \" http :  /  / www . mulesource . org / schema / mule / schemadoc /  2  .  2  / mule - schemadoc . xsd \"  ,     \" mule - schemadoc . xsd \"     }     }  ,    null )  ;", "}", "METHOD_END"], "methodName": ["testMuleConfigValidation"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( new   VirtualFile [  ]  {    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" MultipleImports / agg . xsd \"  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" MultipleImports / toimport 1  . xsd \"  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" MultipleImports / toimport 2  . xsd \"  )  )     }  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testMultipleImports"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   baseName    =     ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  ;", "configureByFiles ( null ,    getVirtualFile (  ( baseName    +     \"  . xml \"  )  )  ,    getVirtualFile (  ( baseName    +     \"  . dtd \"  )  )  ,    getVirtualFile (  ( baseName    +     \"  . ent \"  )  )  )  ;", "doDoTest ( true ,    false )  ;", "final   List < PsiReference >    refs    =    new   ArrayList <  >  (  )  ;", "myFile . accept ( new   XmlRecursiveElementVisitor (  )     {", "@ Override", "public   void   visitXmlAttribute ( final   XmlAttribute   attribute )     {", "refs . add ( attribute . getReference (  )  )  ;", "}", "@ Override", "public   void   visitXmlTag ( final   XmlTag   tag )     {", "refs . add ( tag . getReference (  )  )  ;", "super . visitXmlTag ( tag )  ;", "}", "}  )  ;", "assertEquals (  2  ,    refs . size (  )  )  ;", "for    ( PsiReference   ref    :    refs )     {", "final   PsiElement   element    =    ref . resolve (  )  ;", "assertTrue (  ( element   instanceof   PsiNamedElement )  )  ;", "assertSame ( element . getNavigationElement (  )  ,    element )  ;", "assertTrue (  (  !  ( element . isPhysical (  )  )  )  )  ;", "final   PsiElement   original    =    element . getOriginalElement (  )  ;", "if    (  ( original    !  =    element )     &  &     (  !  ( element   instanceof   XmlAttlistDecl )  )  )     {", "assertNotNull ( original )  ;", "assertTrue ( original . isPhysical (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testNavigateToDeclDefinedWithEntity"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "doTest ( new   VirtualFile [  ]  {    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  . xml \"  )  )  ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  . xsd \"  )  )     }  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testNoNamespaceLocation"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testNoSpaceBeforeAttrAndNoCdataEnd"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   url    =     \" http :  /  / www . w 3  . org /  1  9  9  9  / XSL / Format \"  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily ( url ,     \" fop . xsd \"  ,    getTestRootDisposable (  )  )  ;", "configureByFiles ( null ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  . xml \"  )  )  ,    getVirtualFile (  (  (  . BASE _ PATH )     +     \" fop . xsd \"  )  )  )  ;", "doDoTest ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testNonEnumeratedValuesHighlighting"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doManyFilesFromSeparateDirTest (  \" concept . dtd \"  ,     \" concept . dtd \"  ,    null )  ;", "}", "METHOD_END"], "methodName": ["testOasisDocumentHighlighting"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( new   VirtualFile [  ]  {    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" Substitute / prefixed . xml \"  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" Substitute / schema - b . xsd \"  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" Substitute / schema - a . xsd \"  )  )     }  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testPrefixedSubstitution"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestWithLocations ( null ,     \" xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testProblemWithImportedNsReference"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestWithLocations ( null ,     \" xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testProblemWithMemberTypes"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFiles ( null ,     (  ( XmlHighlightingTest . BASE _ PATH )     +     \" qualified . xml \"  )  ,     (  ( XmlHighlightingTest . BASE _ PATH )     +     \" qualified . xsd \"  )  )  ;", "doDoTest ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testQualifiedAttributeReference"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( new   VirtualFile [  ]  {    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" Redefine / derived . xsd \"  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" Redefine / base . xsd \"  )  )     }  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testRedefine"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( new   VirtualFile [  ]  {    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" Redefine / sample . xml \"  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" Redefine / derived . xsd \"  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" Redefine / base . xsd \"  )  )     }  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testRedefine2"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "VirtualFile [  ]    files    =    new   VirtualFile [  ]  {    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  . xml \"  )  )  ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  . xsd \"  )  )  ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  _  2  . xsd \"  )  )     }  ;", "doTest ( files ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testRedefineBaseType"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "VirtualFile [  ]    files    =    new   VirtualFile [  ]  {    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  . xml \"  )  )  ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  . xsd \"  )  )  ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  _  2  . xsd \"  )  )     }  ;", "doTest ( files ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testRedefineQualifiedType"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testReferencingTargetNamespace"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( new   VirtualFile [  ]  {    getVirtualFile ( getFullRelativeTestName (  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" entities . dtd \"  )  )     }  ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testResolveEntityUrl"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  (  (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  . dtd \"  )  )  ;", "doDoTest ( true ,    false )  ;", "final   String   text    =    myEditor . getDocument (  )  . getText (  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >    myEditor . getSelectionModel (  )  . setSelection (  0  ,    myEditor . getDocument (  )  . getTextLength (  )  )  )  ;", "AnAction   action    =    ActionManager . getInstance (  )  . getAction ( ACTION _ COMMENT _ BLOCK )  ;", "action . actionPerformed ( AnActionEvent . createFromAnAction ( action ,    null ,     \"  \"  ,    DataManager . getInstance (  )  . getDataContext (  )  )  )  ;", "assertNotSame ( text ,    myEditor . getDocument (  )  . getText (  )  )  ;", "PsiDocumentManager . getInstance ( myProject )  . commitDocument ( myEditor . getDocument (  )  )  ;", "Collection < HighlightInfo >    infos    =    doHighlighting (  )  ;", "assertEquals (  0  ,    infos . size (  )  )  ;", "action . actionPerformed ( AnActionEvent . createFromAnAction ( action ,    null ,     \"  \"  ,    DataManager . getInstance (  )  . getDataContext (  )  )  )  ;", "assertEquals ( text ,    myEditor . getDocument (  )  . getText (  )  . trim (  )  )  ;", "PsiDocumentManager . getInstance ( myProject )  . commitDocument ( myEditor . getDocument (  )  )  ;", "infos    =    doHighlighting (  )  ;", "assertEquals (  0  ,    infos . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testResolvedDtdElementReferences"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFiles ( null ,    getVirtualFile (  (  (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  . xml \"  )  )  ,    getVirtualFile (  (  (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  / RatingandServiceSelectionRequest . dtd \"  )  )  ,    getVirtualFile (  (  (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  / XpciInterchange . dtd \"  )  )  ,    getVirtualFile (  (  (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  / Xpcivocabulary . dtd \"  )  )  )  ;", "doDoTest ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testResolvingEntitiesInDtd"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( new   VirtualFile [  ]  {    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" SchemaAutodetection / policy . xml \"  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" SchemaAutodetection / cs - xacml - schema - policy -  0  1  . xsd \"  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" SchemaAutodetection / cs - xacml - schema - context -  0  1  . xsd \"  )  )     }  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testSchemaAutodetection"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestWithLocations ( new   String [  ]  [  ]  {    new   String [  ]  {     \" http :  /  / www . springframework . org / schema / beans \"  ,     \" ComplexSchemaValidation 1  1  . xsd \"     }     }  ,     \" xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testSchemaImportHighlightingAndResolve"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( getFullRelativeTestName (  \"  . xsd \"  )  ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testSchemaReferencesValidation"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "String   location    =     ( getTestName ( false )  )     +     \"  . xsd \"  ;", "String   url    =     \" http :  /  / example . org / ns / books /  \"  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily ( url ,    location ,    getTestRootDisposable (  )  )  ;", "configureByFiles ( null ,    getVirtualFile ( getFullRelativeTestName (  )  )  ,    getVirtualFile (  (  (  . BASE _ PATH )     +    location )  )  )  ;", "doDoTest ( true ,    false )  ;", "Editor [  ]    allEditors    =    EditorFactory . getInstance (  )  . getAllEditors (  )  ;", "final   Editor   schemaEditor    =     (  ( allEditors [  0  ]  )     =  =     ( myEditor )  )     ?    allEditors [  1  ]     :    allEditors [  0  ]  ;", "final   String   text    =    schemaEditor . getDocument (  )  . getText (  )  ;", "final   String   newText    =    text . replaceAll (  \" xsd \"  ,     \" xs \"  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >    schemaEditor . getDocument (  )  . replaceString (  0  ,    text . length (  )  ,    newText )  )  ;", "doDoTest ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testSchemaUpdate"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testSchemaValidation"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFiles ( null ,    getVirtualFile (  (  (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  . xml \"  )  )  ,    getVirtualFile (  (  (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  . xsd \"  )  )  )  ;", "doDoTest ( true ,    false )  ;", "final   XmlTag   rootTag    =     (  ( XmlFile )     ( myFile )  )  . getDocument (  )  . getRootTag (  )  ;", "final   XmlAttributeValue   valueElement    =    rootTag . getAttribute (  \" noNamespaceSchemaLocation \"  ,    XmlUtil . XML _ SCHEMA _ INSTANCE _ URI )  . getValueElement (  )  ;", "final   PsiReference [  ]    references    =    valueElement . getReferences (  )  ;", "final   String   expectedFileName    =     ( getTestName ( false )  )     +     \"  . xsd \"  ;", "assertEquals (  1  ,    references . length )  ;", "final   PsiElement   schema    =    references [  0  ]  . resolve (  )  ;", "assertNotNull ( schema )  ;", "assertEquals ( expectedFileName ,    schema . getContainingFile (  )  . getName (  )  )  ;", "final   PsiReference   referenceAt    =    myFile . findReferenceAt ( myEditor . getCaretModel (  )  . getOffset (  )  )  ;", "assertNotNull ( referenceAt )  ;", "final   PsiElement   psiElement    =    referenceAt . resolve (  )  ;", "assertTrue (  (  (  ( psiElement   instanceof   XmlTag )     &  &     (  \" complexType \"  . equals (  (  ( XmlTag )     ( psiElement )  )  . getLocalName (  )  )  )  )     &  &     (  \" Y \"  . equals (  (  ( XmlTag )     ( psiElement )  )  . getAttributeValue (  \" name \"  )  )  )  )  )  ;", "assertEquals ( expectedFileName ,    psiElement . getContainingFile (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSchemaValidation2"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "String   location    =     ( getTestName ( false )  )     +     \"  . xsd \"  ;", "String   location 2     =     ( getTestName ( false )  )     +     \"  _  2  . xsd \"  ;", "String   url    =     \" parent \"  ;", "String   url 2     =     \" child \"  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily ( url ,    location ,    getTestRootDisposable (  )  )  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily ( url 2  ,    location 2  ,    getTestRootDisposable (  )  )  ;", "configureByFiles ( null ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  . xml \"  )  )  ,    getVirtualFile (  (  (  . BASE _ PATH )     +    location )  )  ,    getVirtualFile (  (  (  . BASE _ PATH )     +    location 2  )  )  )  ;", "doDoTest ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testSchemaValidation3"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "String   schemaLocation    =     ( getTestName ( false )  )     +     \"  . xsd \"  ;", "configureByFiles ( null ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  . xml \"  )  )  ,    getVirtualFile (  (  (  . BASE _ PATH )     +    schemaLocation )  )  )  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily ( schemaLocation ,    schemaLocation ,    getTestRootDisposable (  )  )  ;", "doDoTest ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testSchemaValidation4"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "String   schemaLocation    =     ( getTestName ( false )  )     +     \"  . xsd \"  ;", "configureByFile (  (  (  . BASE _ PATH )     +    schemaLocation )  )  ;", "doDoTest ( true ,    false )  ;", "final   List < PsiReference >    myTypeOrElementRefs    =    new   ArrayList <  >  (  1  )  ;", "final   List < XmlTag >    myTypesAndElementDecls    =    new   ArrayList <  >  (  1  )  ;", "myFile . accept ( new   XmlRecursiveElementVisitor (  )     {", "@ Override", "public   void   visitXmlAttributeValue ( XmlAttributeValue   value )     {", "final   PsiElement   parent    =    value . getParent (  )  ;", "if    (  !  ( parent   instanceof   XmlAttribute )  )", "return ;", "final   String   name    =     (  ( XmlAttribute )     ( parent )  )  . getName (  )  ;", "if    (  (  (  \" type \"  . equals ( name )  )     |  |     (  \" base \"  . equals ( name )  )  )     |  |     (  \" ref \"  . equals ( name )  )  )     {", "myTypeOrElementRefs . add ( value . getReferences (  )  [  0  ]  )  ;", "}", "}", "@ Override", "public   void   visitXmlTag ( XmlTag   tag )     {", "super . visitXmlTag ( tag )  ;", "final   String   localName    =    tag . getLocalName (  )  ;", "if    (  (  (  \" complexType \"  . equals ( localName )  )     |  |     (  \" simpleType \"  . equals ( localName )  )  )     |  |     (  \" element \"  . equals ( localName )  )  )     {", "if    (  ( tag . getAttributeValue (  \" name \"  )  )     !  =    null )", "myTypesAndElementDecls . add ( tag )  ;", "}", "}", "}  )  ;", "assertEquals (  9  ,    myTypesAndElementDecls . size (  )  )  ;", "assertEquals (  5  ,    myTypeOrElementRefs . size (  )  )  ;", "for    ( XmlTag   t    :    myTypesAndElementDecls )     {", "final   XmlAttribute   attribute    =    t . getAttribute (  \" name \"  ,    null )  ;", "final   XmlAttributeValue   valueElement    =    attribute . getValueElement (  )  ;", "final   PsiReference   nameReference    =    valueElement . getReferences (  )  [  0  ]  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "nameReference . handleElementRename (  \" zzz \"  )  ;", "}  )  ;", "}", "for    ( PsiReference   ref    :    myTypeOrElementRefs )     {", "assertNull ( ref . resolve (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSchemaValidation5"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "String   location    =     ( getTestName ( false )  )     +     \"  . xsd \"  ;", "String   url    =     \" aaa \"  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily ( url ,    location ,    getTestRootDisposable (  )  )  ;", "configureByFiles ( null ,    getVirtualFile ( getFullRelativeTestName (  )  )  ,    getVirtualFile (  (  (  . BASE _ PATH )     +    location )  )  )  ;", "doDoTest ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testSchemaValidation6"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFiles ( null ,     (  ( XmlHighlightingTest . BASE _ PATH )     +     \" Versioning . xsd \"  )  )  ;", "doDoTest ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testSchemaVersioning"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "doTest ( new   VirtualFile [  ]  {    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  . xml \"  )  )     }  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testSchemaWithXmlId"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( getFullRelativeTestName (  \"  . dtd \"  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testSgmlDTD"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" web - app _  2  _  4  . xsd \"  )  )  ;", "final   String   testName    =    getTestName ( false )  ;", "final   String   actionName    =    XmlBundle . message ( AddXsiSchemaLocationForExtResourceAction . KEY )  ;", "doTestWithQuickFix (  (  ( XmlHighlightingTest . BASE _ PATH )     +    testName )  ,    actionName ,    false )  ;", "doTestWithQuickFix (  (  (  ( XmlHighlightingTest . BASE _ PATH )     +    testName )     +     \"  2  \"  )  ,    actionName ,    false )  ;", "doTestWithQuickFix (  (  (  ( XmlHighlightingTest . BASE _ PATH )     +    testName )     +     \"  3  \"  )  ,    actionName ,    false )  ;", "doTestWithQuickFix (  (  (  ( XmlHighlightingTest . BASE _ PATH )     +    testName )     +     \"  4  \"  )  ,    actionName ,    false )  ;", "}", "METHOD_END"], "methodName": ["testSpecifyXsiSchemaLocationQuickFix"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "String   location    =     \" relaxng . xsd \"  ;", "String   url    =     \" http :  /  / relaxng . org / ns / structure / fake /  1  .  0  \"  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily ( url ,    location ,    getTestRootDisposable (  )  )  ;", "doTest ( new   VirtualFile [  ]  {    getVirtualFile ( getFullRelativeTestName (  )  )  ,    getVirtualFile (  (  (  . BASE _ PATH )     +    location )  )     }  ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testStackOverflow"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   url    =     \" urn : aaa \"  ;", "final   String   location    =     ( getName ( false )  )     +     \"  . xsd \"  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily ( url ,    location ,    getRootDisposable (  )  )  ;", "do ( getFullRelativeName (  \"  . xsd \"  )  ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testStackOverflow2"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFiles ( null ,     (  ( XmlHighlightingTest . BASE _ PATH )     +     \" XMLSchema _  1  _  1  . xsd \"  )  )  ;", "doHighlighting (  )  ;", "}", "METHOD_END"], "methodName": ["testStackOverflowInSchema"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( new   VirtualFile [  ]  {    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" Substitute / test . xml \"  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" Substitute / schema - b . xsd \"  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" Substitute / schema - a . xsd \"  )  )     }  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testSubstitution"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "ExternalResourceManagerExImpl . registerResourceTemporarily (  \" http :  /  / www . omg . org / spec / BPMN /  2  0  1  0  0  5  2  4  / MODEL \"  ,     \" BPMN 2  0  . xsd \"  ,    getTestRootDisposable (  )  )  ;", "doTest ( new   VirtualFile [  ]  {    getVirtualFile (  (  (  . BASE _ PATH )     +     \" FinancialReportProcess . bpmn 2  0  . xml \"  )  )  ,    getVirtualFile (  (  (  . BASE _ PATH )     +     \" BPMN 2  0  . xsd \"  )  )  ,    getVirtualFile (  (  (  . BASE _ PATH )     +     \" Semantic . xsd \"  )  )     }  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testSubstitutionFromInclude"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( getFullRelativeTestName (  \"  . svg \"  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testSvg"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( new   VirtualFile [  ]  {    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" TheSameElement / IntelliJPersonData . xml \"  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" TheSameElement / IntellijCalTech . xsd \"  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" TheSameElement / IntelliJMeldeamt . xsd \"  )  )     }  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testTheSameElement"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( new   VirtualFile [  ]  {    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" TheSameTypeName / test 2  . xml \"  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" TheSameTypeName / test - common - xsd 1  . xsd \"  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" TheSameTypeName / test - common - xsd 2  . xsd \"  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" TheSameTypeName / test - xsd 1  . xsd \"  )  )  ,    getVirtualFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" TheSameTypeName / test - xsd 2  . xsd \"  )  )     }  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testTheSameTypeName"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" web - app _  2  _  4  . xsd \"  )  )  ;", "final   String   testName    =    getTestName ( false )  ;", "doTest (  (  (  ( XmlHighlightingTest . BASE _ PATH )     +    testName )     +     \"  . xml \"  )  ,    true ,    false )  ;", "doTestWithUnboundNSQuickFix (  (  (  ( XmlHighlightingTest . BASE _ PATH )     +    testName )     +     \"  2  \"  )  )  ;", "configureByFiles ( null ,     (  (  ( XmlHighlightingTest . BASE _ PATH )     +    testName )     +     \"  4  . xml \"  )  ,     (  (  ( XmlHighlightingTest . BASE _ PATH )     +    testName )     +     \"  4  . dtd \"  )  )  ;", "doDoTest ( true ,    false )  ;", "doTestWithUnboundNSQuickFix (  (  (  ( XmlHighlightingTest . BASE _ PATH )     +    testName )     +     \"  5  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testUnboundNsHighlighting"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  (  ( XmlHighlightingTest . BASE _ PATH )     +     \" web - app _  2  _  4  . xsd \"  )  )  ;", "doTestWithQuickFix (  (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )  ,    XmlHighlightingTest . CREATE _ NAMESPACE _ DECLARATION _ INTENTION _ NAME ,    true )  ;", "}", "METHOD_END"], "methodName": ["testUnboundNsHighlighting6"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestWithLocations ( null ,     \" xml \"  )  ;", "final   List < XmlAttribute >    attrs    =    new   ArrayList <  >  (  2  )  ;", "myFile . acceptChildren ( new   XmlRecursiveElementVisitor (  )     {", "@ Override", "public   void   visitXmlAttribute ( final   XmlAttribute   attribute )     {", "if    (  !  ( attribute . isNamespaceDeclaration (  )  )  )", "attrs . add ( attribute )  ;", "}", "}  )  ;", "assertEquals (  4  ,    attrs . size (  )  )  ;", ". checkAttribute ( attrs . get (  0  )  ,     \"  \"  )  ;", ". checkAttribute ( attrs . get (  1  )  ,     \" foo 2  \"  )  ;", ". checkAttribute ( attrs . get (  2  )  ,     \"  \"  )  ;", ". checkAttribute ( attrs . get (  3  )  ,     \" foo 4  \"  )  ;", "}", "METHOD_END"], "methodName": ["testUnqualifiedAttributePsi"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doDtdRefsWithQuickFixTestSequence (  (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )  ,     \" dtd \"  )  ;", "}", "METHOD_END"], "methodName": ["testUnresolvedDtdElementReferences"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doDtdRefsWithQuickFixTestSequence (  (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )  ,     \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testUnresolvedDtdElementReferencesInXml"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   s    =     ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  ;", "doDtdEntityRefWithQuickFixTest ( s ,     \" xml \"  )  ;", "doDtdEntityRefWithQuickFixTest (  ( s    +     \"  _  2  \"  )  ,     \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testUnresolvedDtdElementReferencesInXml2"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doDtdEntityRefWithQuickFixTest (  (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )  ,     \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testUnresolvedDtdElementReferencesInXml3"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   s    =     ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  ;", "doDtdEntityRefWithQuickFixTest ( s ,     \" dtd \"  )  ;", "}", "METHOD_END"], "methodName": ["testUnresolvedDtdEntityReference"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testUnresolvedSymbolForForAttribute"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   baseName    =     ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  ;", "configureByFiles ( null ,    getVirtualFile (  ( baseName    +     \"  . xml \"  )  )  ,    getVirtualFile (  ( baseName    +     \"  . dtd \"  )  )  ,    getVirtualFile (  ( baseName    +     \"  2  . dtd \"  )  )  )  ;", "doDoTest ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testUsingDtdReference"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestWithLocations ( null ,     \" xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testUsingSchemaDtd"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( getFullRelativeTestName (  \"  . dtd \"  )  ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testValidationOfDtdFile"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testWebApp"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( getFullRelativeTestName (  \"  . xsd \"  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testWrongRegExpCategory"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( getFullRelativeTestName (  \"  . xsd \"  )  ,    true ,    false )  ;", "doTest ( getFullRelativeTestName (  \"  2  . xsd \"  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testWrongRegExpInSchema"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( getFullRelativeTestName (  \"  . wsdl \"  )  ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testWsdlValidation"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \"  < html >  <  / html >  \"  ;", "EditorHighlighter   xhter    =    HighlighterFactory . createHighlighter ( XHTML ,    EditorColorsManager . getInstance (  )  . getGlobalScheme (  )  ,    myProject )  ;", "xhter . setText ( text )  ;", "HighlighterIterator   iterator    =    xhter . createIterator (  1  )  ;", "assertSame (  \" Xml   tag   name \"  ,    iterator . getTokenType (  )  ,    XmlTokenType . XML _ TAG _ NAME )  ;", "iterator    =    xhter . createIterator (  8  )  ;", "assertSame (  \" Xml   tag   name   at   end   of   tag \"  ,    iterator . getTokenType (  )  ,    XmlTokenType . XML _ TAG _ NAME )  ;", "}", "METHOD_END"], "methodName": ["testXHtmlEditorHighlighting"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testXHtmlValidation"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile ( getFullRelativeTestName (  )  )  ;", "doDoTest ( true ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["testXHtmlValidation2"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doManyFilesFromSeparateDirTest (  \" http :  /  / www . w 3  . org / TR / xhtml - basic / xhtml - basic 1  1  . dtd \"  ,     \" xhtml - basic 1  1  . dtd \"  ,     (  )     -  >     {", "final   List < XmlAttribute >    attrs    =    new   ArrayList <  >  (  )  ;", "myFile . acceptChildren ( new   XmlRecursiveElementVisitor (  )     {", "@ Override", "public   void   visitXmlAttribute ( final   XmlAttribute   attribute )     {", "if    (  ( attribute . getDescriptor (  )  )     !  =    null )", "attrs . add ( attribute )  ;", "}", "}  )  ;", "assertEquals (  8  ,    attrs . size (  )  )  ;", "for    ( XmlAttribute   a    :    attrs )     {", "final   PsiElement   element    =    a . getDescriptor (  )  . getDeclaration (  )  ;", "assertTrue (  (  ( Navigatable )     ( element )  )  . canNavigate (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testXHtmlValidation3"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "configureByFiles ( null ,     (  (  (  . BASE _ PATH )     +    testName )     +     \"  . xml \"  )  ,     (  (  (  . BASE _ PATH )     +    testName )     +     \"  - inc . xml \"  )  ,     (  (  (  . BASE _ PATH )     +    testName )     +     \" TestSchema . xsd \"  )  )  ;", "ExternalResourceManagerEx . getInstanceEx (  )  . addIgnoredResources ( Collections . singletonList (  \" oxf :  / apps / somefile . xml \"  )  ,    getTestRootDisposable (  )  )  ;", "doDoTest ( true ,    false ,    true )  ;", "VirtualFile [  ]    includedFiles    =    FileIncludeManager . getManager ( getProject (  )  )  . getIncludedFiles ( getFile (  )  . getVirtualFile (  )  ,    true )  ;", "assertEquals (  1  ,    includedFiles . length )  ;", "}", "METHOD_END"], "methodName": ["testXInclude"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String [  ]  [  ]    resources    =    new   String [  ]  [  ]  {    new   String [  ]  {     \" http :  /  / www . test . com / test \"  ,     ( getTestName ( false )  )     +     \"  . dtd \"     }     }  ;", "doConfigureWithLocations ( resources ,     \" xml \"  )  ;", "try    {", "doDoTest ( true ,    true )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >    myEditor . getDocument (  )  . insertString (  (  ( myEditor . getDocument (  )  . getCharsSequence (  )  . toString (  )  . indexOf (  \"  ?  >  \"  )  )     +     2  )  ,     \"  \\ n \"  )  )  ;", "doDoTest ( true ,    true )  ;", "}    finally    {", ". unregisterResources ( resources )  ;", "}", "}", "METHOD_END"], "methodName": ["testXercesCachingProblem"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testXercesMessageOnDtd"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "try    {", "myJustJaxpValidation    =    true ;", "do (  )  ;", "}    finally    {", "myJustJaxpValidation    =    false ;", "}", "}", "METHOD_END"], "methodName": ["testXercesMessageOnPI"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( getFullRelativeTestName (  \"  . xml \"  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testXercesMessagesBinding"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   url    =     ( getTestName ( false )  )     +     \"  . xsd \"  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily ( url ,    url ,    getTestRootDisposable (  )  )  ;", "doTest ( new   VirtualFile [  ]  {    getVirtualFile ( getFullRelativeTestName (  \"  . xml \"  )  )  ,    getVirtualFile ( getFullRelativeTestName (  \"  . xsd \"  )  )     }  ,    true ,    false )  ;", "final   String   url 2     =     ( getTestName ( false )  )     +     \"  _  2  . xsd \"  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily ( url 2  ,    url 2  ,    getTestRootDisposable (  )  )  ;", "doTest ( new   VirtualFile [  ]  {    getVirtualFile ( getFullRelativeTestName (  \"  _  2  . xml \"  )  )  ,    getVirtualFile ( getFullRelativeTestName (  \"  _  2  . xsd \"  )  )     }  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testXercesMessagesBinding2"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( getFullRelativeTestName (  \"  . xml \"  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testXercesMessagesBinding3"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "String   url    =     \" antlib : ant \"  ;", "enablpectionTool ( new   AntResolvpection (  )  )  ;", "doTestWithLocations ( new   String [  ]  [  ]  {    new   String [  ]  {    url ,     ( getTestName ( false )  )     +     \"  . xsd \"     }     }  ,     \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testXercesMessagesBinding4"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "try    {", "myJustJaxpValidation    =    true ;", "do (  )  ;", "}    finally    {", "myJustJaxpValidation    =    false ;", "}", "}", "METHOD_END"], "methodName": ["testXercesMessagesBinding5"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "disableHtmlSupport (  )  ;", "try    {", "configureByFiles ( null ,    getVirtualFile (  (  (  . BASE _ PATH )     +     \" xhtml 1  - transitional . xsd \"  )  )  ,    getVirtualFile (  (  (  . BASE _ PATH )     +     \" xhtml - special . ent \"  )  )  ,    getVirtualFile (  (  (  . BASE _ PATH )     +     \" xhtml - symbol . ent \"  )  )  ,    getVirtualFile (  (  (  . BASE _ PATH )     +     \" xhtml - lat 1  . ent \"  )  )  )  ;", "doDoTest ( true ,    false )  ;", "}    finally    {", "enableHtmlSupport (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testXhtmlSchemaHighlighting"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile (  (  (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  . xml \"  )  )  ;", "final   XmlTag   root    =     (  ( XmlFile )     ( myFile )  )  . getDocument (  )  . getRootTag (  )  ;", "final   XmlTag   tag 1     =    root . getSubTags (  )  [  0  ]  ;", "assert   tag 1  . getLocalName (  )  . equals (  \" foo \"  )  ;", "assertEquals (  \" xxx \"  ,    tag 1  . getAttributeValue (  \" xxx \"  ,     \" abc \"  )  )  ;", "final   XmlTag   tag 2     =    root . getSubTags (  )  [  0  ]  . getSubTags (  )  [  0  ]  ;", "assert   tag 2  . getLocalName (  )  . equals (  \" bar \"  )  ;", "assertEquals (  \" yyy \"  ,    tag 2  . getAttributeValue (  \" yyy \"  ,     \" abc \"  )  )  ;", "assertEquals (  \" zzz \"  ,    tag 2  . getAttributeValue (  \" zzz \"  )  )  ;", "assertNull ( tag 2  . getAttributeValue (  \" zzz \"  ,     \" unknown \"  )  )  ;", "assertNull ( tag 2  . getAttributeValue (  \" zzz \"  ,     \" abc \"  )  )  ;", "final   XmlTag   tag 3     =    root . getSubTags (  )  [  0  ]  . getSubTags (  )  [  1  ]  ;", "assert   tag 3  . getLocalName (  )  . equals (  \" bar 2  \"  )  ;", "assertEquals (  \" zzz \"  ,    tag 3  . getAttributeValue (  \" zzz \"  ,     \" def \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testXmlPsi"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "doTest ( getFullRelativeTestName (  \"  _  2  . xml \"  )  ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testXsiSchemaLocation"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( new   VirtualFile [  ]  {    getVirtualFile ( getFullRelativeTestName (  )  )  ,    getVirtualFile (  (  (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  _  1  . xsd \"  )  )  ,    getVirtualFile (  (  (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  _  2  . xsd \"  )  )  ,    getVirtualFile (  (  (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  _  3  . xsd \"  )  )     }  ,    false ,    false )  ;", "XmlTag   rootTag    =     (  ( XmlFile )     ( myFile )  )  . getDocument (  )  . getRootTag (  )  ;", "XmlHighlightingTest . checkOneTagForSchemaAttribute ( rootTag ,     \" xmlns : test 2  \"  ,     (  ( getTestName ( false )  )     +     \"  _  2  . xsd \"  )  )  ;", "configureByFiles ( null ,    getVirtualFile (  (  (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  _  2  . xsd \"  )  )  ,    getVirtualFile (  (  (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  _  3  . xsd \"  )  )  )  ;", "rootTag    =     (  ( XmlFile )     ( myFile )  )  . getDocument (  )  . getRootTag (  )  ;", "final   List < XmlTag >    tags    =    new   ArrayList <  >  (  )  ;", "XmlUtil . processXmlElements ( rootTag ,    new   PsiElementProcessor (  )     {", "@ Override", "public   boolean   execute (  @ NotNull", "final   PsiElement   element )     {", "if    (  (  ( element   instanceof   XmlTag )     &  &     (  (  (  (  (  (  ( XmlTag )     ( element )  )  . getName (  )  . equals (  \" xs : element \"  )  )     |  |     (  (  ( XmlTag )     ( element )  )  . getName (  )  . equals (  \" xs : attribute \"  )  )  )     |  |     (  (  ( XmlTag )     ( element )  )  . getName (  )  . equals (  \" xs : restriction \"  )  )  )     |  |     (  (  ( XmlTag )     ( element )  )  . getName (  )  . equals (  \" xs : group \"  )  )  )     |  |     (  (  ( XmlTag )     ( element )  )  . getName (  )  . equals (  \" xs : attributeGroup \"  )  )  )  )     &  &     (  (  (  (  (  ( XmlTag )     ( element )  )  . getAttributeValue (  \" type \"  )  )     !  =    null )     |  |     (  (  (  ( XmlTag )     ( element )  )  . getAttributeValue (  \" ref \"  )  )     !  =    null )  )     |  |     (  (  (  ( XmlTag )     ( element )  )  . getAttributeValue (  \" base \"  )  )     !  =    null )  )  )     {", "tags . add (  (  ( XmlTag )     ( element )  )  )  ;", "}", "return   true ;", "}", "}  ,    true )  ;", "assertEquals (  \" Should   be   adequate   number   of   tags \"  ,     1  1  ,    tags . size (  )  )  ;", "final   String   resolveFileName    =     ( getTestName ( false )  )     +     \"  _  3  . xsd \"  ;", "XmlHighlightingTest . checkOneTagForSchemaAttribute ( tags . get (  1  )  ,     \" type \"  ,    resolveFileName )  ;", "XmlHighlightingTest . checkOneTagForSchemaAttribute ( tags . get (  0  )  ,     \" ref \"  ,    resolveFileName )  ;", "XmlHighlightingTest . checkOneTagForSchemaAttribute ( tags . get (  3  )  ,     \" type \"  ,    resolveFileName )  ;", "XmlHighlightingTest . checkOneTagForSchemaAttribute ( tags . get (  4  )  ,     \" base \"  ,    resolveFileName )  ;", "final   String   schemaFile    =     \" XMLSchema . xsd \"  ;", "XmlHighlightingTest . checkOneTagForSchemaAttribute ( tags . get (  5  )  ,     \" base \"  ,    schemaFile )  ;", "XmlHighlightingTest . checkOneTagForSchemaAttribute ( rootTag ,     \" xmlns : xs \"  ,    schemaFile )  ;", "XmlHighlightingTest . checkOneTagForSchemaAttribute ( tags . get (  6  )  ,     \" ref \"  ,    resolveFileName )  ;", "XmlHighlightingTest . checkOneTagForSchemaAttribute ( tags . get (  7  )  ,     \" ref \"  ,    resolveFileName )  ;", "XmlHighlightingTest . checkOneTagForSchemaAttribute ( rootTag ,     \" xmlns : test 2  \"  ,     (  ( getTestName ( false )  )     +     \"  _  2  . xsd \"  )  )  ;", "XmlHighlightingTest . checkOneTagForSchemaAttribute ( tags . get (  8  )  ,     \" type \"  ,    schemaFile )  ;", "XmlHighlightingTest . checkOneTagForSchemaAttribute ( tags . get (  9  )  ,     \" ref \"  ,    schemaFile )  ;", "XmlHighlightingTest . checkOneTagForSchemaAttribute ( tags . get (  1  0  )  ,     \" ref \"  ,    resolveFileName )  ;", "}", "METHOD_END"], "methodName": ["testXsiSchemaLocation2"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile ( getFullRelativeTestName (  \"  . xsd \"  )  ,    null )  ;", "doDoTest ( true ,    false )  ;", "final   List < XmlTag >    tags    =    new   ArrayList <  >  (  )  ;", "XmlUtil . processXmlElements (  (  ( XmlFile )     ( myFile )  )  . getDocument (  )  ,    new   PsiElementProcessor (  )     {", "@ Override", "public   boolean   execute (  @ NotNull", "final   PsiElement   element )     {", "if    (  ( element   instanceof   XmlTag )     &  &     (  (  ( XmlTag )     ( element )  )  . getName (  )  . equals (  \" xs : include \"  )  )  )     {", "tags . add (  (  ( XmlTag )     ( element )  )  )  ;", "}", "return   true ;", "}", "}  ,    true )  ;", "assertEquals (  \" Should   be   three   tags \"  ,     3  ,    tags . size (  )  )  ;", "String   location    =     \" xslt -  1  _  0  . xsd \"  ;", ". checkOneTagForSchemaAttribute ( tags . get (  2  )  ,     \" schemaLocation \"  ,    location )  ;", "}", "METHOD_END"], "methodName": ["testXsiSchemaLocation3"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "doTest ( new   VirtualFile [  ]  {    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  . xml \"  )  )  ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  _ Types . xsd \"  )  )  ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  _ Request . xsd \"  )  )  ,    getVirtualFile (  (  (  (  . BASE _ PATH )     +    testName )     +     \"  _ Generic . xsd \"  )  )     }  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testXsiType"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestWithLocations ( null ,     \" xsl \"  )  ;", "}", "METHOD_END"], "methodName": ["testXslt2"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( getFullRelativeTestName (  \"  . xsl \"  )  ,    true ,    false )  ;", "doTest ( getFullRelativeTestName (  \"  2  . xsl \"  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testXsltValidation"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( getFullRelativeTestName (  \"  . xsl \"  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testXsltValidation3"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testclosedTag1"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testduplicateAttribute"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "configureByFiles ( null ,     (  (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  . xml \"  )  ,     (  (  ( XmlHighlightingTest . BASE _ PATH )     +     ( getTestName ( false )  )  )     +     \"  . xsd \"  )  )  ;", "final   String   url    =     \" http :  /  / www . foo . org / schema \"  ;", "final   String   url 2     =     \" http :  /  / www . bar . org / foo \"  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily ( url ,     (  ( getTestName ( false )  )     +     \"  . xsd \"  )  ,    getTestRootDisposable (  )  )  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily ( url 2  ,     (  ( getTestName ( false )  )     +     \"  . xsd \"  )  ,    getTestRootDisposable (  )  )  ;", "final   Collection < HighlightInfo >    infoCollection    =    doDoTest ( true ,    false ,    true )  ;", "final   TextRange   startTagNameRange    =    XmlTagUtil . getStartTagNameElement (  (  ( XmlFile )     ( myFile )  )  . getDocument (  )  . getRootTag (  )  )  . getTextRange (  )  ;", "HighlightInfo   infoAtTagName    =    null ;", "for    ( HighlightInfo   info    :    infoCollection )     {", "if    (  (  ( info . startOffset )     =  =     ( startTagNameRange . getStartOffset (  )  )  )     &  &     (  ( info . endOffset )     =  =     ( startTagNameRange . getEndOffset (  )  )  )  )     {", "if    ( info . getDescription (  )  . equals (  \" Attribute    \\  \" foo \\  \"    bound   to   namespace    \\  \" http :  /  / www . w 3  . org /  2  0  0  0  / xmlns /  \\  \"    was   already   specified   for   element    \\  \" root \\  \"  .  \"  )  )     {", "infoAtTagName    =    info ;", "break ;", "}", "}", "}", "assertNotNull ( infoAtTagName )  ;", "}", "METHOD_END"], "methodName": ["testduplicateAttribute2"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testrootTag1"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testwrongRootTag1"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "if    ( resources    =  =    null )", "return ;", "}", "METHOD_END"], "methodName": ["unregisterResources"], "fileName": "com.intellij.codeInsight.daemon.XmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . enableInspections ( new   XmlDefaultAttributeValueInspection (  )  )  ;", "myFixture . configureByText ( HtmlFileType . INSTANCE ,     (  \"  <  ! DOCTYPE   html >  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"  < html   lang =  \\  \" en \\  \"  >  \\ n \"     +     \"  < head >  \\ n \"  )     +     \"              < meta   charset =  \\  \" UTF -  8  \\  \"  >  \\ n \"  )     +     \"              < title > Title <  / title >  \\ n \"  )     +     \"  <  / head >  \\ n \"  )     +     \"  < body >  \\ n \"  )     +     \"  < form   action =  \\  \" index . php \\  \"  >  \\ n \"  )     +     \"              < input   type =  \\  \" hidden \\  \"    name =  \\  \" name _  1  \\  \"    value =  \\  \" val _  1  \\  \"  >  \\ n \"  )     +     \"              < input   type =  \\  \" hidden \\  \"    name =  \\  \" name _  2  \\  \"    value =  \\  \" val _  2  \\  \"  >  \\ n \"  )     +     \"              < button   type =  \\  \" button \\  \"  > Proper   js   button <  / button >  \\ n \"  )     +     \"              < button   type =  < warning   descr =  \\  \" Redundant   default   attribute   value   assignment \\  \"  >  \\  \" submit \\  \"  <  / warning >  > Proper   submit   button <  / button >  \\ n \"  )     +     \"              < button > Behave   as   submit   when   missing   type =  \\  \" button \\  \"  <  / button >  \\ n \"  )     +     \"  <  / form >  \\ n \"  )     +     \"  <  / body >  \\ n \"  )     +     \"  <  / html >  \\ n \"  )  )  )  ;", "myFixture . checkHighlighting (  )  ;", "}", "METHOD_END"], "methodName": ["_testHtmlFromRncSchema"], "fileName": "com.intellij.codeInsight.daemon.XmlInspectionsTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . enableInspections ( new   XmlDefaultAttributeValueInspection (  )  )  ;", "myFixture . configureByText ( HtmlFileType . INSTANCE ,     \"  < input   type =  \\  \" text \\  \"  /  >  \"  )  ;", "myFixture . checkHighlighting (  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultAttributeInHtml"], "fileName": "com.intellij.codeInsight.daemon.XmlInspectionsTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . enableInspections ( new   XmlDefaultAttributeValueInspection (  )  )  ;", "myFixture . configureByText ( XmlFileType . INSTANCE ,     (  \"  < schema   xmlns =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"    elementFormDefault =  < warning   descr =  \\  \" Redundant   default   attribute   value   assignment \\  \"  >  \\  \" unqua < caret > lified \\  \"  <  / warning >  >  \\ n \"     +     \"  <  / schema >  \"  )  )  ;", "myFixture . checkHighlighting (  )  ;", "IntentionAction   action    =    myFixture . findSingleIntention ( XmlErrorMessages . message (  \" remove . attribute . quickfix . family \"  )  )  ;", "myFixture . launchAction ( action )  ;", "myFixture . checkResult (  (  \"  < schema   xmlns =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \\ n \"     +     \"  <  / schema >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultAttributeValue"], "fileName": "com.intellij.codeInsight.daemon.XmlInspectionsTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . enableInspections ( new   XmlDefaultAttributeValueInspection (  )  )  ;", "myFixture . testHighlighting (  \" def . xml \"  ,     \" def . xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testRequiredFixedAttribute"], "fileName": "com.intellij.codeInsight.daemon.XmlInspectionsTest"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     1  0  0  ;    i +  +  )     {", "do (  \" xml / WsdlValidation . wsdl \"  ,    false ,    false )  ;", "System . out . println ( i )  ;", "}", "}", "METHOD_END"], "methodName": ["testSchemaValidator"], "fileName": "com.intellij.codeInsight.daemon.XmlStressTest"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   parent    =    element . getParent (  )  ;", "if    ( parent   instanceof   XmlTag )     {", "XmlTag   tag    =     (  ( XmlTag )     ( parent )  )  ;", "if    ( tag . getNamespace (  )  . isEmpty (  )  )     {", "while    ( tag    !  =    null )     {", "final   XmlAttribute   attr    =    tag . getAttribute (  \" xmlns \"  )  ;", "if    ( attr    !  =    null )", "return   attr ;", "tag    =    tag . getParentTag (  )  ;", "}", "}", "} else", "if    (  ( parent   instanceof   XmlAttribute )     &  &     (  (  ( XmlAttribute )     ( parent )  )  . getName (  )  . equals (  \" xmlns \"  )  )  )     {", "return    (  ( XmlAttribute )     ( parent )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getXmlnsDeclaration"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.AddSchemaPrefixIntention"}, {"methodBody": ["METHOD_START", "{", "final   int   localNameIndex    =     ( ns . length (  )  )     +     1  ;", "final   int   totalCount    =     ( tags . size (  )  )     +     ( attrs . size (  )  )  ;", "final   SequentialModalProgressTask   progressTask    =    new   SequentialModalProgressTask ( project ,     \" Changing   to   d   namespace \"  ,    true )  ;", "progressTask . setTask ( new   SequentialTask (  )     {", "int   tagIndex    =     0  ;", "int   attrIndex    =     0  ;", "@ Override", "public   void   prepare (  )     {", "}", "@ Override", "public   boolean   isDone (  )     {", "return    (  ( tagIndex )     +     ( attrIndex )  )     >  =    totalCount ;", "}", "@ Override", "public   boolean   iteration (  )     {", "progressTask . getIndicator (  )  . setFraction (  (  (  ( double )     (  ( tagIndex )     +     ( attrIndex )  )  )     /    totalCount )  )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >     {", "if    (  ( tagIndex )     <     ( tags . size (  )  )  )     {", "XmlTag   tag    =    tags . get (  (  ( tagIndex )  +  +  )  )  ;", "final   String   s    =    tag . getName (  )  . substring ( localNameIndex )  ;", "if    (  !  ( s . isEmpty (  )  )  )     {", "tag . setName ( s )  ;", "}", "} else", "if    (  ( attrIndex )     <     ( attrs . size (  )  )  )     {", "XmlAttribute   attr    =    attrs . get (  (  ( attrIndex )  +  +  )  )  ;", "attr . setValue ( attr . getValue (  )  . substring ( localNameIndex )  )  ;", "}", "}  )  ;", "return   isDone (  )  ;", "}", "@ Override", "public   void   stop (  )     {", "}", "}  )  ;", "ProgressManager . getInstance (  )  . run ( progressTask )  ;", "}", "METHOD_END"], "methodName": ["convertTagsAndAttributes"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.ConvertSchemaPrefixToDefaultIntention"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   parent    =    element . getParent (  )  ;", "if    (  !  ( parent   instanceof   XmlElement )  )", "return   null ;", "for    ( PsiReference   ref    :    parent . getReferences (  )  )     {", "if    ( ref   instanceof   Reference )     {", "final   PsiElement   elem    =    ref . resolve (  )  ;", "if    ( elem    !  =    null )     {", "final   PsiElement   attr    =    elem . getParent (  )  ;", "if    ( attr   instanceof   XmlAttribute )     {", "final   PsiElement   tag    =    attr . getParent (  )  ;", "if    (  ( tag   instanceof   XmlTag )     &  &     (  (  (  ( XmlTag )     ( tag )  )  . getAttribute (  \" xmlns \"  )  )     =  =    null )  )     {", "return    (  ( XmlAttribute )     ( attr )  )  ;", "}", "}", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getXmlnsDeclaration"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.ConvertSchemaPrefixToDefaultIntention"}, {"methodBody": ["METHOD_START", "{", "if    (  ( name    =  =    null )     |  |     ( name . isEmpty (  )  )  )", "return   true ;", "final   List < String >    list    =    StringUtil . getWordsIn ( name )  ;", "final   String [  ]    words    =    ArrayUtil . toStringArray ( list )  ;", "final   boolean [  ]    wordsFound    =    new   boolean [ words . length ]  ;", "final   int [  ]    wordsFoundCount    =    new   int [  1  ]  ;", "IdTableBuilding . ScanWordProcessor   wordProcessor    =    new   IdTableBuilding . ScanWordProcessor (  )     {", "@ Override", "public   void   run ( final   CharSequence   chars ,     @ Nullable", "char [  ]    charsArray ,    int   start ,    int   end )     {", "if    (  ( wordsFoundCount [  0  ]  )     =  =     ( words . length )  )", "return ;", "final   int   foundWordLen    =    end    -    start ;", "Next    :    for    ( int   i    =     0  ;    i    <     ( words . length )  ;     +  + i )     {", "final   String   localName    =    words [ i ]  ;", "if    (  ( wordsFound [ i ]  )     |  |     (  ( localName . length (  )  )     !  =    foundWordLen )  )", "continue ;", "for    ( int   j    =     0  ;    j    <     ( localName . length (  )  )  ;     +  + j )     {", "if    (  ( chars . charAt (  ( start    +    j )  )  )     !  =     ( localName . charAt ( j )  )  )", "continue   Next ;", "}", "wordsFound [ i ]     =    true ;", "( wordsFoundCount [  0  ]  )  +  +  ;", "break ;", "}", "}", "}  ;", "final   CharSequence   cos    =    tldFileByUri . getViewProvider (  )  . getCos (  )  ;", "IdTableBuilding . scanWords ( wordProcessor ,    cos ,     0  ,    cos . length (  )  )  ;", "return    ( wordsFoundCount [  0  ]  )     =  =     ( words . length )  ;", "}", "METHOD_END"], "methodName": ["checkIfGivenXmlHasTheseWords"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.CreateNSDeclarationIntentionFix"}, {"methodBody": ["METHOD_START", "{", "PsiFile   file    =    element . getContainingFile (  )  ;", "return   file   instanceof   XmlFile    ?    new    ( element ,    namespacePrefix )     :    null ;", "}", "METHOD_END"], "methodName": ["createFix"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.CreateNSDeclarationIntentionFix"}, {"methodBody": ["METHOD_START", "{", "return    (  ( XmlFile )     ( myElement . getFile (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.CreateNSDeclarationIntentionFix"}, {"methodBody": ["METHOD_START", "{", "if    ( element   instanceof   XmlAttribute )     {", "element    =    element . getParent (  )  ;", "}", "Set < String >    set    =    getXmlNamespaceHelper (  )  . guessUnboundNamespaces ( element ,    xmlFile )  ;", "final   String   match    =     . getUnboundNamespaceForPrefix ( myNamespacePrefix ,    xmlFile ,    set )  ;", "if    ( match    !  =    null )     {", "return   Collections . singletonList ( match )  ;", "}", "List < String >    namespaces    =    new   ArrayList <  >  ( set )  ;", "Collections . sort ( namespaces )  ;", "return   namespaces ;", "}", "METHOD_END"], "methodName": ["getNamespaces"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.CreateNSDeclarationIntentionFix"}, {"methodBody": ["METHOD_START", "{", "return   XmlErrorMessages . message (  \" select . namespace . title \"  ,    StringUtil . capitalize ( getXmlNamespaceHelper (  )  . getNamespaceAlias ( getFile (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getTitle"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.CreateNSDeclarationIntentionFix"}, {"methodBody": ["METHOD_START", "{", "final   List < XmlSchemaProvider >    providers    =    XmlSchemaProvider . getAvailableProviders ( xmlFile )  ;", "for    ( XmlSchemaProvider   provider    :    providers )     {", "for    ( String   namespace    :    namespaces )     {", "if    ( prefix . equals ( provider . getDefaultPrefix ( namespace ,    xmlFile )  )  )     {", "return   namespace ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getUnboundNamespaceForPrefix"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.CreateNSDeclarationIntentionFix"}, {"methodBody": ["METHOD_START", "{", "return   XmlNamespaceHelper . getHelper ( getFile (  )  )  ;", "}", "METHOD_END"], "methodName": ["getXmlNamespaceHelper"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.CreateNSDeclarationIntentionFix"}, {"methodBody": ["METHOD_START", "{", "ProgressManager . getInstance (  )  . runProcessWithProgressSynchronously (  (  )     -  >    ReadAction . run (  (  )     -  >    processExternalUrisImpl ( metaHandler ,    file ,    processor )  )  ,    XmlErrorMessages . message (  \" finding . acceptable . uri \"  )  ,    false ,    file . getProject (  )  )  ;", "}", "METHOD_END"], "methodName": ["processExternalUris"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.CreateNSDeclarationIntentionFix"}, {"methodBody": ["METHOD_START", "{", "final   ProgressIndicator   pi    =    ProgressManager . getInstance (  )  . getProgressIndicator (  )  ;", "final   String   searchFor    =    metaHandler . searchFor (  )  ;", "if    ( pi    !  =    null )", "pi . setText ( XmlErrorMessages . message (  \" looking . in . schemas \"  )  )  ;", "final   ExternalResourceManager   instanceEx    =    ExternalResourceManager . getInstance (  )  ;", "final   String [  ]    availableUrls    =    instanceEx . getResourceUrls ( null ,    true )  ;", "int   i    =     0  ;", "for    ( String   url    :    availableUrls )     {", "if    ( pi    !  =    null )     {", "pi . setFraction (  (  (  ( double )     ( i )  )     /     ( availableUrls . length )  )  )  ;", "pi . setText 2  ( url )  ;", "+  + i ;", "}", "final   XmlFile   xmlFile    =    XmlUtil . findNamespace ( file ,    url )  ;", "if    ( xmlFile    !  =    null )     {", "final   boolean   wordFound    =    CreateNSDeclarationIntentionFix . checkIfGivenXmlHasTheseWords ( searchFor ,    xmlFile )  ;", "if    (  ! wordFound )", "continue ;", "final   XmlDocument   document    =    xmlFile . getDocument (  )  ;", "assert   document    !  =    null ;", "final   PsiMetaData   metaData    =    document . getMetaData (  )  ;", "if    ( metaHandler . isAcceptableMetaData ( metaData ,    url )  )     {", "final   XmlNSDescriptorImpl   descriptor    =     ( metaData   instanceof   XmlNSDescriptorImpl )     ?     (  ( XmlNSDescriptorImpl )     ( metaData )  )     :    null ;", "final   String   defaultNamespace    =     ( descriptor    !  =    null )     ?    descriptor . getDefaultNamespace (  )     :    url ;", "if    (  (  !  ( XmlUtil . XML _ SCHEMA _ URI 2  . equals ( defaultNamespace )  )  )     &  &     (  !  ( XmlUtil . XML _ SCHEMA _ URI 3  . equals ( defaultNamespace )  )  )  )     {", "processor . process ( defaultNamespace ,    url )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processExternalUrisImpl"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.CreateNSDeclarationIntentionFix"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( namespacesToChooseFrom . length )     >     1  )     &  &     (  !  ( ApplicationManager . getApplication (  )  . isUnitTestMode (  )  )  )  )     {", "JBPopupFactory . getInstance (  )  . createPopupChooserBuilder ( ContainerUtil . newArrayList ( namespacesToChooseFrom )  )  . setRenderer ( XmlNSRenderer . INSTANCE )  . setTitle ( title )  . setItemChosenCallback (  (    selectedValue )     -  >     {", "PsiDocumentManager . getInstance ( project )  . commitAllDocuments (  )  ;", "CommandProcessor . getInstance (  )  . executeCommand ( project ,     (  )     -  >    ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >     {", "try    {", "onSelection . doSomethingWithGivenStringToProduceXmlAttributeNowPlease ( selectedValue )  ;", "}    catch    (    ex )     {", "throw   new    < ex > RuntimeException (  )  ;", "}", "}  )  ,    requestor . getText (  )  ,    requestor . getFamilyName (  )  )  ;", "}  )  . createPopup (  )  . showInBestPositionFor ( editor )  ;", "} else    {", "WriteAction . run (  (  )     -  >     {", "String   attrName    =     ( namespacesToChooseFrom . length    =  =     0  )     ?     \"  \"     :    namespacesToChooseFrom [  0  ]  ;", "onSelection . doSomethingWithGivenStringToProduceXmlAttributeNowPlease ( attrName )  ;", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["runActionOverSeveralAttributeValuesAfterLettingUserSelectTheNeededOne"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.CreateNSDeclarationIntentionFix"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . asList ( ModuleRootManager . getInstance ( module )  . getContentRoots (  )  )  ;", "}", "METHOD_END"], "methodName": ["getBaseRoots"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.HtmlFileReferenceHelper"}, {"methodBody": ["METHOD_START", "{", "final   PsiFile   file    =    reference . getElement (  )  . getContainingFile (  )  ;", "final   String   basePath    =     ( file   instanceof   XmlFile )     ?    til . getHrefBase (  (  ( XmlFile )     ( file )  )  )     :    null ;", "return    ( basePath    =  =    null )     |  |     (  !  ( til . hasHtmlPrefix ( basePath )  )  )  ;", "}", "METHOD_END"], "methodName": ["notRemoteBase"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.HtmlUnknownTargetInspection"}, {"methodBody": ["METHOD_START", "{", "PsiElement   nextSibling    =    attribute . getNextSibling (  )  ;", "while    ( nextSibling    !  =    null )     {", "if    ( nextSibling   instanceof   Xml )", "return   nextSibling ;", "nextSibling    =    nextSibling . getNextSibling (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findNextAttribute"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.RemoveAttributeIntentionFix"}, {"methodBody": ["METHOD_START", "{", "return   new   LocalQuickFix (  )     {", "@ Nls", "@ NotNull", "@ Override", "public   String   getFamilyName (  )     {", "return   XmlErrorMessages . message (  \" remove . attribute . quickfix . family \"  )  ;", "}", "@ Override", "public   void   applyFix (  @ NotNull", "Project   project ,     @ NotNull", "ProblemDescriptor   descriptor )     {", "Xml   attribute    =    PsiTreeUtil . getParentOfType ( descriptor . getPsiElement (  )  ,    Xml . class )  ;", "if    ( attribute    !  =    null )     {", "attribute . delete (  )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createDeleteFix"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlDefaultAttributeValueInspection"}, {"methodBody": ["METHOD_START", "{", "final   String   text    =    element . getErrorDescription (  )  ;", "if    (  ( text    !  =    null )     &  &     ( text . startsWith ( XmlErrorMessages . message (  \" unescaped . ampersand \"  )  )  )  )     {", "QuickFixAction . registerQuickFixAction ( highlightInfo ,    new   IntentionAction (  )     {", "@ Override", "@ NotNull", "public   String   getText (  )     {", "return   XmlErrorMessages . message (  \" escape . ampersand . quickfix \"  )  ;", "}", "@ Override", "@ NotNull", "public   String   getFamilyName (  )     {", "return   getText (  )  ;", "}", "@ Override", "public   boolean   isAvailable (  @ NotNull", "Project   project ,    Editor   editor ,    PsiFile   file )     {", "return   true ;", "}", "@ Override", "public   void   invoke (  @ NotNull", "Project   project ,    Editor   editor ,    PsiFile   file )     {", "final   int   textOffset    =    element . getTextOffset (  )  ;", "editor . getDocument (  )  . replaceString ( textOffset ,     ( textOffset    +     1  )  ,     . AMP _ ENTITY )  ;", "}", "@ Override", "public   boolean   startInWriteAction (  )     {", "return   true ;", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["registerXmlErrorQuickFix"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlErrorQuickFixProvider"}, {"methodBody": ["METHOD_START", "{", "addElementsForTagWithManyQuickFixes ( tag ,    localizedMessage ,    type ,     (  ( IntentionAction )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["addElementsForTag"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlHighlightVisitor"}, {"methodBody": ["METHOD_START", "{", "bindMessageToTag ( tag ,    type ,     (  -  1  )  ,    localizedMessage ,    quickFixActions )  ;", "}", "METHOD_END"], "methodName": ["addElementsForTagWithManyQuickFixes"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlHighlightVisitor"}, {"methodBody": ["METHOD_START", "{", "myHolder . add ( info )  ;", "}", "METHOD_END"], "methodName": ["addToResults"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlHighlightVisitor"}, {"methodBody": ["METHOD_START", "{", "if    ( childByRole    !  =    null )     {", "final   TextRange   textRange    =    childByRole . getTextRange (  )  ;", "if    ( length    =  =     (  -  1  )  )", "length    =    textRange . getLength (  )  ;", "final   int   startOffset    =    textRange . getStartOffset (  )  ;", "HighlightInfo   highlightInfo    =    HighlightInfo . newHighlightInfo ( warning )  . range ( childByRole ,    startOffset ,     ( startOffset    +    length )  )  . descriptionAndTooltip ( localizedMessage )  . create (  )  ;", "if    ( highlightInfo    =  =    null )     {", "highlightInfo    =    HighlightInfo . newHighlightInfo ( warning )  . range ( new   TextRange ( startOffset ,     ( startOffset    +    length )  )  )  . textAttributes (  . NONEMPTY _ TEXT _ ATTRIBUTES )  . descriptionAndTooltip ( localizedMessage )  . create (  )  ;", "}", "for    ( final   IntentionAction   quickFixAction    :    quickFixActions )     {", "if    ( quickFixAction    =  =    null )", "continue ;", "QuickFixAction . registerQuickFixAction ( highlightInfo ,    textRange ,    quickFixAction )  ;", "}", "addToResults ( highlightInfo )  ;", "}", "}", "METHOD_END"], "methodName": ["bindMessageToAstNode"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlHighlightVisitor"}, {"methodBody": ["METHOD_START", "{", "XmlToken   childByRole    =    XmlTagUtil . getStartTagNameElement ( tag )  ;", "bindMessageToAstNode ( childByRole ,    warning ,    messageLength ,    localizedMessage ,    quickFixActions )  ;", "childByRole    =    XmlTagUtil . getEndTagNameElement ( tag )  ;", "bindMessageToAstNode ( childByRole ,    warning ,    messageLength ,    localizedMessage ,    quickFixActions )  ;", "}", "METHOD_END"], "methodName": ["bindMessageToTag"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlHighlightVisitor"}, {"methodBody": ["METHOD_START", "{", "XmlTag   tag    =    attribute . getParent (  )  ;", "if    ( tag    =  =    null )", "return ;", "final   String   name    =    attribute . getName (  )  ;", "PsiElement   prevLeaf    =    PsiTreeUtil . prevLeaf ( attribute )  ;", "if    (  !  ( prevLeaf   instanceof   PsiWhiteSpace )  )     {", "TextRange   textRange    =    attribute . getTextRange (  )  ;", "HighlightInfoType   type    =     ( tag   instanceof   HtmlTag )     ?    HighlightInfoType . WARNING    :    HighlightInfoType . ERROR ;", "String   description    =    XmlErrorMessages . message (  \" attribute . should . be . preceded . with . space \"  )  ;", "HighlightInfo   info    =    HighlightInfo . newHighlightInfo ( type )  . range ( textRange . getStartOffset (  )  ,    textRange . getStartOffset (  )  )  . descriptionAndTooltip ( description )  . create (  )  ;", "addToResults ( info )  ;", "}", "if    (  ( attribute . isNamespaceDeclaration (  )  )     |  |     ( XmlUtil . XML _ SCHEMA _ INSTANCE _ URI . equals ( attribute . getNamespace (  )  )  )  )     {", "return ;", "}", "XmlElementDescriptor   elementDescriptor    =    tag . getDescriptor (  )  ;", "if    (  (  ( elementDescriptor    =  =    null )     |  |     ( elementDescriptor   instanceof   AnyXmlElementDescriptor )  )     |  |     (  . ourDoJaxpTesting )  )     {", "return ;", "}", "XmlAttributeDescriptor   attributeDescriptor    =    elementDescriptor . getAttributeDescriptor ( attribute )  ;", "if    ( attributeDescriptor    =  =    null )     {", "if    (  !  ( XmlUtil . attributeFromTemplateFramework ( name ,    tag )  )  )     {", "final   String   localizedMessage    =    XmlErrorMessages . message (  \" attribute . is . not . allowed . here \"  ,    name )  ;", "final   HighlightInfo   highlightInfo    =    reportAttributeProblem ( tag ,    name ,    attribute ,    localizedMessage )  ;", "if    ( highlightInfo    !  =    null )     {", "PsiFile   file    =    tag . getContainingFile (  )  ;", "if    ( file    !  =    null )     {", "for    ( XmlUndefinedElementFixProvider   fixProvider    :    Extensions . getExtensions ( XmlUndefinedElementFixProvider . EP _ NAME )  )     {", "IntentionAction [  ]    fixes    =    fixProvider . createFixes ( attribute )  ;", "if    ( fixes    !  =    null )     {", "for    ( IntentionAction   action    :    fixes )     {", "QuickFixAction . registerQuickFixAction ( highlightInfo ,    action )  ;", "}", "break ;", "}", "}", "}", "}", "}", "} else    {", "checkDuplicateAttribute ( tag ,    attribute )  ;", "PsiReference [  ]    attrRefs    =    attribute . getReferences (  )  ;", "doCheckRefs ( attribute ,    attrRefs ,     (  !  ( attribute . getNamespacePrefix (  )  . isEmpty (  )  )     ?     2     :     1  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkAttribute"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlHighlightVisitor"}, {"methodBody": ["METHOD_START", "{", "if    ( XmlHighlightVisitor . skipValidation ( tag )  )     {", "return ;", "}", "final   XmlAttribute [  ]    attributes    =    tag . getAttributes (  )  ;", "final   PsiFile   containingFile    =    tag . getContainingFile (  )  ;", "final   XmlExtension   extension    =     ( containingFile   instanceof   XmlFile )     ?    XmlExtension . getExtension ( containingFile )     :    DefaultXmlExtension . DEFAULT _ EXTENSION ;", "for    ( XmlAttribute   tagAttribute    :    attributes )     {", "ProgressManager . checkCanceled (  )  ;", "if    (  ( attribute    !  =    tagAttribute )     &  &     ( Comparing . strEqual ( attribute . getName (  )  ,    tagAttribute . getName (  )  )  )  )     {", "final   String   localName    =    attribute . getLocalName (  )  ;", "if    ( extension . canBeDuplicated ( tagAttribute )  )", "continue ;", "final   ASTNode   attributeNode    =    SourceTreeToPsiMap . psiElementToTree ( attribute )  ;", "assert   attributeNode    !  =    null ;", "final   ASTNode   attributeNameNode    =    XmlChildRole . ATTRIBUTE _ NAME _ FINDER . findChild ( attributeNode )  ;", "assert   attributeNameNode    !  =    null ;", "HighlightInfo   highlightInfo    =    HighlightInfo . newHighlightInfo ( XmlHighlightVisitor . getTagProblemInfoType ( tag )  )  . range ( attributeNameNode )  . descriptionAndTooltip ( XmlErrorMessages . message (  \" duplicate . attribute \"  ,    localName )  )  . create (  )  ;", "addToResults ( highlightInfo )  ;", "IntentionAction   intentionAction    =    new   RemoveAttributeIntentionFix ( localName ,    attribute )  ;", "QuickFixAction . registerQuickFixAction ( highlightInfo ,    intentionAction )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkDuplicateAttribute"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlHighlightVisitor"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )", "return ;", "doCheckRefs ( value ,    value . getReferences (  )  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["checkReferences"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlHighlightVisitor"}, {"methodBody": ["METHOD_START", "{", "if    ( XmlHighlightVisitor . ourDoJaxpTesting )", "return ;", "if    (  !  ( myHolder . hasErrorResults (  )  )  )     {", "checkTagByDescriptor ( tag )  ;", "}", "if    (  !  ( myHolder . hasErrorResults (  )  )  )     {", "if    (  !  ( XmlHighlightVisitor . skipValidation ( tag )  )  )     {", "final   XmlElementDescriptor   descriptor    =    tag . getDescriptor (  )  ;", "if    (  ( tag   instanceof   HtmlTag )     &  &     (  ( descriptor   instanceof   AnyXmlElementDescriptor )     |  |     ( descriptor    =  =    null )  )  )     {", "return ;", "}", "checkReferences ( tag )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkTag"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlHighlightVisitor"}, {"methodBody": ["METHOD_START", "{", "String   name    =    tag . getName (  )  ;", "XmlElementDescriptor   elementDescriptor ;", "final   PsiElement   parent    =    tag . getParent (  )  ;", "if    ( parent   instanceof   XmlTag )     {", "XmlTag   parentTag    =     (  ( XmlTag )     ( parent )  )  ;", "elementDescriptor    =    XmlUtil . getDescriptorFromContext ( tag )  ;", "final   XmlElementDescriptor   parentDescriptor    =    parentTag . getDescriptor (  )  ;", "if    (  (  ( parentDescriptor    !  =    null )     &  &     ( elementDescriptor    =  =    null )  )     &  &     (  . shouldBeValidated ( tag )  )  )     {", "if    ( tag   instanceof   HtmlTag )     {", "return ;", "}", "addElementsForTag ( tag ,    XmlErrorMessages . message (  \" element . is . not . allowed . here \"  ,    name )  ,     . getTagProblemInfoType ( tag )  )  ;", "return ;", "}", "if    (  ( elementDescriptor   instanceof   AnyXmlElementDescriptor )     |  |     ( elementDescriptor    =  =    null )  )     {", "elementDescriptor    =    tag . getDescriptor (  )  ;", "}", "if    ( elementDescriptor    =  =    null )", "return ;", "} else    {", "elementDescriptor    =    tag . getDescriptor (  )  ;", "if    ( elementDescriptor    =  =    null )     {", "addElementsForTag ( tag ,    XmlErrorMessages . message (  \" element . must . be . declared \"  ,    name )  ,    WRONG _ REF )  ;", "return ;", "}", "}", "if    ( elementDescriptor   instanceof   Validator )     {", "(  ( Validator < XmlTag >  )     ( elementDescriptor )  )  . validate ( tag ,    this )  ;", "}", "}", "METHOD_END"], "methodName": ["checkTagByDescriptor"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlHighlightVisitor"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =    start ;    i    <     ( references . length )  ;     +  + i )     {", "PsiReference   reference    =    references [ i ]  ;", "ProgressManager . checkCanceled (  )  ;", "if    ( XmlHighlightVisitor . isUrlReference ( reference )  )", "continue ;", "if    (  !  ( XmlHighlightVisitor . hasBadResolve ( reference ,    false )  )  )     {", "continue ;", "}", "String   description    =    XmlHighlightVisitor . getErrorDescription ( reference )  ;", "final   int   startOffset    =    reference . getElement (  )  . getTextRange (  )  . getStartOffset (  )  ;", "final   TextRange   referenceRange    =    reference . getRangeInElement (  )  ;", "if    (  ( referenceRange . getStartOffset (  )  )     >     ( referenceRange . getEndOffset (  )  )  )     {", "XmlHighlightVisitor . LOG . error (  (  (  (  (  (  \" Reference   range   start   offset    >    end   offset :        \"     +    reference )     +     \"  ,    start   offset :     \"  )     +     ( referenceRange . getStartOffset (  )  )  )     +     \"  ,    end   offset :     \"  )     +     ( referenceRange . getEndOffset (  )  )  )  )  ;", "}", "HighlightInfoType   type    =    XmlHighlightVisitor . getTagProblemInfoType ( PsiTreeUtil . getParentOfType ( value ,    XmlTag . class )  )  ;", "if    ( value   instanceof   XmlAttributeValue )     {", "PsiElement   parent    =    value . getParent (  )  ;", "if    ( parent   instanceof   XmlAttribute )     {", "String   name    =     (  ( XmlAttribute )     ( parent )  )  . getName (  )  . toLowerCase (  )  ;", "if    (  (  ( type . getSeverity ( null )  . compareTo ( WARNING . getSeverity ( null )  )  )     >     0  )     &  &     ( name . endsWith (  \" stylename \"  )  )  )     {", "type    =    HighlightInfoType . WARNING ;", "}", "}", "}", "HighlightInfo   info    =    HighlightInfo . newHighlightInfo ( type )  . range (  ( startOffset    +     ( referenceRange . getStartOffset (  )  )  )  ,     ( startOffset    +     ( referenceRange . getEndOffset (  )  )  )  )  . descriptionAndTooltip ( description )  . create (  )  ;", "addToResults ( info )  ;", "if    ( reference   instanceof   LocalQuickFixProvider )     {", "LocalQuickFix [  ]    fixes    =     (  ( LocalQuickFixProvider )     ( reference )  )  . getQuickFixes (  )  ;", "if    ( fixes    !  =    null )     {", "InspectionManager   manager    =    InspectionManager . getInstance ( reference . getElement (  )  . getProject (  )  )  ;", "for    ( LocalQuickFix   fix    :    fixes )     {", "ProblemDescriptor   descriptor    =    manager . createProblemDescriptor ( value ,    description ,    fix ,    GENERIC _ ERROR _ OR _ WARNING ,    true )  ;", "QuickFixAction . registerQuickFixAction ( info ,    new   LocalQuickFixAsIntentionAdapter ( fix ,    descriptor )  )  ;", "}", "}", "}", "UnresolvedReferenceQuickFixProvider . registerReferenceFixes ( reference ,    new   quickfix . QuickFixActionRegistrarImpl ( info )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doCheckRefs"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlHighlightVisitor"}, {"methodBody": ["METHOD_START", "{", "String   message ;", "if    ( reference   instanceof   EmptyResolveMessageProvider )     {", "message    =     (  ( EmptyResolveMessageProvider )     ( reference )  )  . getUnresolvedMessagePattern (  )  ;", "} else    {", "message    =    PsiBundle . message (  \" cannot . resolve . symbol \"  )  ;", "}", "String   description ;", "try    {", "description    =    BundleBase . format ( message ,    reference . getCanonicalText (  )  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "description    =    message ;", "}", "return   description ;", "}", "METHOD_END"], "methodName": ["getErrorDescription"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlHighlightVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( tag   instanceof   HtmlTag )     &  &     ( XmlUtil . HTML _ URI . equals ( tag . getNamespace (  )  )  )  )     {", "if    (  . isInjectedWithoutValidation ( tag )  )", "return   HighlightInfoType . INFORMATION ;", "return   HighlightInfoType . WARNING ;", "}", "return   HighlightInfoType . WRONG _ REF ;", "}", "METHOD_END"], "methodName": ["getTagProblemInfoType"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlHighlightVisitor"}, {"methodBody": ["METHOD_START", "{", "String   unquotedValue    =    value . getValue (  )  ;", "if    ( tag   instanceof   HtmlTag )     {", "unquotedValue    =    unquotedValue . toLowerCase (  )  ;", "}", "return   unquotedValue ;", "}", "METHOD_END"], "methodName": ["getUnquotedValue"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlHighlightVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ! checkSoft )     &  &     ( reference . isSoft (  )  )  )", "return   false ;", "if    ( reference   instanceof   PsiPolyVariantReference )     {", "return    (  (  ( PsiPolyVariantReference )     ( reference )  )  . multiResolve ( false )  . length )     =  =     0  ;", "}", "return    ( reference . resolve (  )  )     =  =    null ;", "}", "METHOD_END"], "methodName": ["hasBadResolve"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlHighlightVisitor"}, {"methodBody": ["METHOD_START", "{", "return    ( FRANKENSTEIN _ INJECTION . get ( element . getContainingFile (  )  )  )     =  =     ( Boolean . TRUE )  ;", "}", "METHOD_END"], "methodName": ["isInjectedWithoutValidation"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlHighlightVisitor"}, {"methodBody": ["METHOD_START", "{", "return    ( reference   instanceof   FileReferenceOwner )     |  |     ( reference   instanceof   AnchorReference )  ;", "}", "METHOD_END"], "methodName": ["isUrlReference"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlHighlightVisitor"}, {"methodBody": ["METHOD_START", "{", "final   RemoveAttributeIntentionFix   removeAttributeIntention    =    new   RemoveAttributeIntentionFix ( localName ,    attribute )  ;", "if    (  !  ( tag   instanceof   HtmlTag )  )     {", "final   InfoType   tagProblemInfoType    =    InfoType . WRONG _ REF ;", "final   ASTNode   node    =    SourceTreeToPsiMap . psiElementToTree ( attribute )  ;", "assert   node    !  =    null ;", "final   ASTNode   child    =    XmlChildRole . ATTRIBUTE _ NAME _ FINDER . findChild ( node )  ;", "assert   child    !  =    null ;", "final   Info   highlightInfo    =    Info . newInfo ( tagProblemInfoType )  . range ( child )  . descriptionAndTooltip ( localizedMessage )  . create (  )  ;", "addToResults ( highlightInfo )  ;", "QuickFixAction . registerQuickFixAction ( highlightInfo ,    removeAttributeIntention )  ;", "return   highlightInfo ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["reportAttributeProblem"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlHighlightVisitor"}, {"methodBody": ["METHOD_START", "{", "XmlHighlightVisitor . ourDoJaxpTesting    =    doJaxpTesting ;", "}", "METHOD_END"], "methodName": ["setDoJaxpTesting"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlHighlightVisitor"}, {"methodBody": ["METHOD_START", "{", "element . putUserData ( XmlElement . DO _ NOT _ VALIDATE ,    Boolean . TRUE )  ;", "}", "METHOD_END"], "methodName": ["setSkipValidation"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlHighlightVisitor"}, {"methodBody": ["METHOD_START", "{", "PsiElement   parent    =    tag . getParent (  )  ;", "if    ( parent   instanceof   XmlTag )     {", "return    (  !  (  . skipValidation ( parent )  )  )     &  &     (  !  ( XmlUtil . tagFromTemplateFramework ( tag )  )  )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["shouldBeValidated"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlHighlightVisitor"}, {"methodBody": ["METHOD_START", "{", "return    ( context   instanceof   XmlElement )     &  &     (  (  ( XmlElement )     ( context )  )  . skipValidation (  )  )  ;", "}", "METHOD_END"], "methodName": ["skipValidation"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlHighlightVisitor"}, {"methodBody": ["METHOD_START", "{", "PsiReference [  ]    references    =    element . getReferences (  )  ;", "for    ( PsiReference   reference    :    references )     {", "if    (  !  ( XmlHighlightVisitor . isUrlReference ( reference )  )  )     {", "continue ;", "}", "if    ( XmlHighlightVisitor . isInjectedWithoutValidation ( element )  )     {", "continue ;", "}", "if    (  !  ( needToCheckRef ( reference )  )  )     {", "continue ;", "}", "boolean   isHtml    =    HtmlUtil . isHtmlTagContainingFile ( element )  ;", "if    ( isHtml    ^     ( isForHtml (  )  )  )     {", "continue ;", "}", "if    (  (  ! isHtml )     &  &     ( XmlHighlightVisitor . skipValidation ( element )  )  )     {", "continue ;", "}", "final   TextRange   range    =     (  ( reference . getElement (  )  )     =  =    null )     ?    null    :    reference . getElement (  )  . getTextRange (  )  ;", "if    (  (  ( range    !  =    null )     &  &     (  !  ( range . isEmpty (  )  )  )  )     &  &     ( XmlHighlightVisitor . hasBadResolve ( reference ,    false )  )  )     {", "holder . registerProblem ( reference ,    ProblemsHolder . unresolvedReferenceMessage ( reference )  ,     ( isHtml    ?    ProblemHighlightType . GENERIC _ ERROR _ OR _ WARNING    :    ProblemHighlightType . LIKE _ UNKNOWN _ SYMBOL )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkRefs"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlPathReferenceInspection"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isForHtml"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlPathReferenceInspection"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["needToCheckRef"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlPathReferenceInspection"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( namespacePrefix . isEmpty (  )  )     &  &     (  (  !  ( element   instanceof   XmlTag )  )     |  |     (  !  (  ( element . getParent (  )  )    instanceof   XmlDocument )  )  )  )     |  |     ( XmlUnboundNsPrefixInspection . XML . equals ( namespacePrefix )  )  )     {", "return ;", "}", "final   String   namespaceByPrefix    =    context . getNamespaceByPrefix ( namespacePrefix )  ;", "if    (  !  ( namespaceByPrefix . isEmpty (  )  )  )     {", "return ;", "}", "PsiFile   psiFile    =    context . getContainingFile (  )  ;", "if    (  !  ( psiFile   instanceof   XmlFile )  )", "return ;", "final   XmlFile   containingFile    =     (  ( XmlFile )     ( psiFile )  )  ;", "if    (  !  ( HighlightingLevelManager . getInstance ( containingFile . getProject (  )  )  . shouldInspect ( containingFile )  )  )", "return ;", "final   XmlExtension   extension    =    XmlExtension . getExtension ( containingFile )  ;", "if    (  ( extension . getPrefixDeclaration ( context ,    namespacePrefix )  )     !  =    null )     {", "return ;", "}", "final   String   localizedMessage    =     ( isOnTheFly )     ?    XmlErrorMessages . message (  \" unbound . namespace \"  ,    namespacePrefix )     :    XmlErrorMessages . message (  \" unbound . namespace . no . param \"  )  ;", "if    ( namespacePrefix . isEmpty (  )  )     {", "final   XmlTag   tag    =     (  ( XmlTag )     ( element )  )  ;", "if    (  (  !  ( XmlUtil . JSP _ URI . equals ( tag . getNamespace (  )  )  )  )     &  &    isOnTheFly )     {", "LocalQuickFix   fix    =    XmlQuickFixFactory . getInstance (  )  . createNSDeclarationIntentionFix ( context ,    namespacePrefix ,    token )  ;", "XmlUnboundNsPrefixInspection . reportTagProblem ( tag ,    localizedMessage ,    null ,    INFORMATION ,    fix ,    holder )  ;", "}", "return ;", "}", "final   int   prefixLength    =    namespacePrefix . length (  )  ;", "final   TextRange   range    =    new   TextRange (  0  ,    prefixLength )  ;", "final   HighlightInfoType   infoType    =    extension . getHighlightInfoType ( containingFile )  ;", "final   ProblemHighlightType   highlightType    =     ( infoType    =  =     ( HighlightInfoType . ERROR )  )     ?    ProblemHighlightType . ERROR    :    ProblemHighlightType . LIKE _ UNKNOWN _ SYMBOL ;", "if    ( element   instanceof   XmlTag )     {", "LocalQuickFix   fix    =     ( isOnTheFly )     ?    XmlQuickFixFactory . getInstance (  )  . createNSDeclarationIntentionFix ( context ,    namespacePrefix ,    token )     :    null ;", "XmlUnboundNsPrefixInspection . reportTagProblem ( element ,    localizedMessage ,    range ,    highlightType ,    fix ,    holder )  ;", "} else", "if    ( element   instanceof   com . intellij . psi . xml . XmlAttribute )     {", "LocalQuickFix   fix    =     ( isOnTheFly )     ?    XmlQuickFixFactory . getInstance (  )  . createNSDeclarationIntentionFix ( element ,    namespacePrefix ,    token )     :    null ;", "com . intellij . psi . xml . XmlAttribute   attribute    =     (  ( com . intellij . psi . xml . XmlAttribute )     ( element )  )  ;", "holder . registerProblem ( attribute . getNameElement (  )  ,    localizedMessage ,    highlightType ,    range ,    fix )  ;", "} else    {", "holder . registerProblem ( element ,    localizedMessage ,    highlightType ,    range )  ;", "}", "}", "METHOD_END"], "methodName": ["checkUnboundNamespacePrefix"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlUnboundNsPrefixInspection"}, {"methodBody": ["METHOD_START", "{", "XmlToken   nameToken    =    XmlTagUtil . getStartTagNameElement (  (  ( XmlTag )     ( element )  )  )  ;", "if    ( nameToken    !  =    null )     {", "holder . registerProblem ( nameToken ,    localizedMessage ,    highlType ,    range ,    fix )  ;", "}", "nameToken    =    XmlTagUtil . getEndTagNameElement (  (  ( XmlTag )     ( element )  )  )  ;", "if    ( nameToken    !  =    null )     {", "holder . registerProblem ( nameToken ,    localizedMessage ,    highlType ,    range ,    fix )  ;", "}", "}", "METHOD_END"], "methodName": ["reportTagProblem"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlUnboundNsPrefixInspection"}, {"methodBody": ["METHOD_START", "{", "if    ( XmlUtil . XML _ SCHEMA _ INSTANCE _ URI . equals ( attribute . getNamespace (  )  )  )     {", "if    ( XmlUtil . NO _ NAMESPACE _ SCHEMA _ LOCATION _ ATT . equals ( attribute . getLocalName (  )  )  )     {", "if    ( refCountHolder . isInUse (  \"  \"  )  )", "return ;", "holder . registerProblem ( attribute ,    XmlBundle . message (  \" xml . inspections . unused . schema . location \"  )  ,    LIKE _ UNUSED _ SYMBOL ,    new    . RemoveNamespaceLocationFix (  \"  \"  )  )  ;", "} else", "if    ( XmlUtil . SCHEMA _ LOCATION _ ATT . equals ( attribute . getLocalName (  )  )  )     {", "com . intellij . psi . xml . XmlAttributeValue   value    =    attribute . getValueElement (  )  ;", "if    ( value    =  =    null )", "return ;", "PsiReference [  ]    references    =    value . getReferences (  )  ;", "for    ( int   i    =     0  ,    referencesLength    =    references . length ;    i    <    referencesLength ;    i +  +  )     {", "PsiReference   reference    =    references [ i ]  ;", "if    ( reference   instanceof   com . intellij . psi . impl . source . resolve . reference . impl . providers . URLReference )     {", "String   ns    =     . getNamespaceFromReference ( reference )  ;", "if    (  (  ( com . intellij . util . ArrayUtil . indexOf ( attribute . getParent (  )  . knownNamespaces (  )  ,    ns )  )     =  =     (  -  1  )  )     &  &     (  !  ( refCountHolder . isUsedNamespace ( ns )  )  )  )     {", "if    (  !  ( XmlHighlightVisitor . hasBadResolve ( reference ,    false )  )  )     {", "holder . registerProblemForReference ( reference ,    LIKE _ UNUSED _ SYMBOL ,    XmlBundle . message (  \" xml . inspections . unused . schema . location \"  )  ,    new    . RemoveNamespaceLocationFix ( ns )  )  ;", "}", "for    ( int   j    =    i    +     1  ;    j    <    referencesLength ;    j +  +  )     {", "PsiReference   nextRef    =    references [ j ]  ;", "if    ( nextRef   instanceof   com . intellij . psi . impl . source . resolve . reference . impl . providers . URLReference )", "break ;", "if    (  !  ( XmlHighlightVisitor . hasBadResolve ( nextRef ,    false )  )  )     {", "holder . registerProblemForReference ( nextRef ,    LIKE _ UNUSED _ SYMBOL ,    XmlBundle . message (  \" xml . inspections . unused . schema . location \"  )  ,    new    . RemoveNamespaceLocationFix ( ns )  )  ;", "}", "}", "}", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["checkUnusedLocations"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlUnusedNamespaceInspection"}, {"methodBody": ["METHOD_START", "{", "return   attribute . getName (  )  . contains (  \"  :  \"  )     ?    attribute . getLocalName (  )     :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["getDeclaredPrefix"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlUnusedNamespaceInspection"}, {"methodBody": ["METHOD_START", "{", "return   parent . getAttribute ( XmlUtil . NO _ NAMESPACE _ SCHEMA _ LOCATION _ ATT ,    XmlUtil . XML _ SCHEMA _ INSTANCE _ URI )  ;", "}", "METHOD_END"], "methodName": ["getDefaultLocation"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlUnusedNamespaceInspection"}, {"methodBody": ["METHOD_START", "{", "PsiReference [  ]    references    =    value . getReferences (  )  ;", "for    ( int   i    =     0  ,    referencesLength    =    references . length ;    i    <    referencesLength ;    i    +  =     2  )     {", "PsiReference   reference    =    references [ i ]  ;", "if    ( namespace . equals (  . getNamespaceFromReference ( reference )  )  )     {", "if    (  ( i    +     1  )     <    referencesLength )     {", "return   new   PsiReference [  ]  {    references [  ( i    +     1  )  ]  ,    reference    }  ;", "} else    {", "return   new   PsiReference [  ]  {    reference    }  ;", "}", "}", "}", "return   PsiReference . EMPTY _ ARRAY ;", "}", "METHOD_END"], "methodName": ["getLocationReferences"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlUnusedNamespaceInspection"}, {"methodBody": ["METHOD_START", "{", "XmlAttribute   locationAttr    =    tag . getAttribute ( XmlUtil . SCHEMA _ LOCATION _ ATT ,    XmlUtil . XML _ SCHEMA _ INSTANCE _ URI )  ;", "if    ( locationAttr    =  =    null )     {", "return   PsiReference . EMPTY _ ARRAY ;", "}", "XmlAttributeValue   value    =    locationAttr . getValueElement (  )  ;", "return   value    =  =    null    ?    PsiReference . EMPTY _ ARRAY    :     . getLocationReferences ( namespace ,    value )  ;", "}", "METHOD_END"], "methodName": ["getLocationReferences"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlUnusedNamespaceInspection"}, {"methodBody": ["METHOD_START", "{", "return   reference . getRangeInElement (  )  . substring ( reference . getElement (  )  . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["getNamespaceFromReference"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlUnusedNamespaceInspection"}, {"methodBody": ["METHOD_START", "{", "if    (  ( references . length )     =  =     0  )     {", "return ;", "}", "XmlAttributeValue   element    =     (  ( XmlAttributeValue )     ( references [  0  ]  . getElement (  )  )  )  ;", "XmlAttribute   attribute    =     (  ( XmlAttribute )     ( element . getParent (  )  )  )  ;", "if    (  ( element . getReferences (  )  . length )     =  =     ( references . length )  )     {", "attribute . delete (  )  ;", "return ;", "}", "PsiFile   file    =    element . getContainingFile (  )  ;", "Project   project    =    file . getProject (  )  ;", "SmartPsiElementPointer < XmlAttribute >    pointer    =    SmartPointerManager . getInstance ( project )  . createSmartPsiElementPointer ( attribute )  ;", "for    ( PsiReference   reference    :    references )     {", ". RemoveNamespaceDeclarationFix . removeReferenceText ( reference )  ;", "}", "PsiDocumentManager   documentManager    =    PsiDocumentManager . getInstance ( project )  ;", "Document   document    =    documentManager . getDocument ( file )  ;", "assert   document    !  =    null ;", "documentManager . commitDocument ( document )  ;", "String   trimmed    =    element . getValue (  )  . trim (  )  ;", "XmlAttribute   pointerElement    =    pointer . getElement (  )  ;", "assert   pointerElement    !  =    null ;", "pointerElement . setValue ( trimmed )  ;", "}", "METHOD_END"], "methodName": ["removeReferencesOrAttribute"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.XmlUnusedNamespaceInspection"}, {"methodBody": ["METHOD_START", "{", "String   text    =    value . getValue (  )  ;", "int   start    =    text . indexOf (  . CHARSET _ PREFIX )  ;", "if    ( start    !  =     (  -  1  )  )     {", "start    +  =     . CHARSET _ PREFIX . length (  )  ;", "int   end    =    text . indexOf (  '  ;  '  ,    start )  ;", "if    ( end    =  =     (  -  1  )  )", "end    =    text . length (  )  ;", "String   charsetName    =    text . substring ( start ,    end )  ;", "TextRange   textRange    =    new   TextRange ( start ,    end )  . shiftRight (  . xmlAttributeValueRange ( value )  . getStartOffset (  )  )  ;", "return   new   PsiReference [  ]  {    new   XmlEncodingReference ( value ,    charsetName ,    textRange ,     0  )     }  ;", "}", "return   PsiReference . EMPTY _ ARRAY ;", "}", "METHOD_END"], "methodName": ["extractFromContentAttribute"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.encoding.XmlEncodingReferenceProvider"}, {"methodBody": ["METHOD_START", "{", "ASTNode   valueNode    =    XmlChildRole . ATTRIBUTE _ VALUE _ VALUE _ FINDER . findChild ( xmlAttributeValue . getNode (  )  )  ;", "PsiElement   toHighl =     ( valueNode    =  =    null )     ?    xmlAttributeValue    :    valueNode . getPsi (  )  ;", "TextRange   childRange    =    toHighlgetTextRange (  )  ;", "TextRange   range    =    xmlAttributeValue . getTextRange (  )  ;", "return   childRange . shiftR (  -  ( range . getStartOffset (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["xmlAttributeValueRange"], "fileName": "com.intellij.codeInsight.daemon.impl.analysis.encoding.XmlEncodingReferenceProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( FileModificationService . getInstance (  )  . prepareFileForWrite ( file )  )  )", "return ;", "final   XmlElementFactory   elementFactory    =    XmlElementFactory . getInstance ( file . getProject (  )  )  ;", "if    (  ( tag . getAttributeValue (  . XMLNS _ XSI _ ATTR _ NAME )  )     =  =    null )     {", "tag . add ( elementFactory . createXmlAttribute (  . XMLNS _ XSI _ ATTR _ NAME ,    XmlUtil . XML _ SCHEMA _ INSTANCE _ URI )  )  ;", "}", "final   XmlAttribute   locationAttribute    =    tag . getAttribute (  . XSI _ SCHEMA _ LOCATION _ ATTR _ NAME )  ;", "final   String   toInsert    =     ( uri    +     \"     \"  )     +    s ;", "int   offset    =    s . length (  )  ;", "if    ( locationAttribute    =  =    null )     {", "tag . add ( elementFactory . createXmlAttribute (  . XSI _ SCHEMA _ LOCATION _ ATTR _ NAME ,    toInsert )  )  ;", "} else    {", "final   String   newValue    =     (  ( locationAttribute . getValue (  )  )     +     \"  \\ n \"  )     +    toInsert ;", "locationAttribute . setValue ( newValue )  ;", "}", "PsiDocumentManager . getInstance ( file . getProject (  )  )  . doPostponedOperationsAndUnblockDocument ( editor . getDocument (  )  )  ;", "CodeStyleManager . getInstance ( file . getProject (  )  )  . reformat ( tag )  ;", "@ SuppressWarnings (  \" ConstantConditions \"  )", "final   TextRange   range    =    tag . getAttribute (  . XSI _ SCHEMA _ LOCATION _ ATTR _ NAME )  . getValueElement (  )  . getTextRange (  )  ;", "final   TextRange   textRange    =    new   TextRange (  (  (  ( range . getEndOffset (  )  )     -    offset )     -     1  )  ,     (  ( range . getEndOffset (  )  )     -     1  )  )  ;", "editor . getCaretModel (  )  . moveToOffset ( textRange . getStartOffset (  )  )  ;", "}", "METHOD_END"], "methodName": ["doIt"], "fileName": "com.intellij.codeInsight.daemon.impl.quickfix.AddXsiSchemaLocationForExtResourceAction"}, {"methodBody": ["METHOD_START", "{", "PsiElement   element    =    file . findElementAt ( offset )  ;", "if    (  ( element    =  =    null )     |  |     ( element   instanceof   PsiWhiteSpace )  )     {", "return   null ;", "}", "PsiReference   currenf    =    file . getViewProvider (  )  . findReferenceAt ( offset ,    file . getLanguage (  )  )  ;", "if    ( currenf    =  =    null )", "currenf    =    file . getViewProvider (  )  . findReferenceAt ( offset )  ;", "if    (  ( currenf   instanceof   URLReference )     |  |     ( currenf   instanceof   DependentNSReference )  )     {", "return   currenf . getCanonicalText (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findUri"], "fileName": "com.intellij.codeInsight.daemon.impl.quickfix.BaseExtResourceAction"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isAcceptableUri"], "fileName": "com.intellij.codeInsight.daemon.impl.quickfix.BaseExtResourceAction"}, {"methodBody": ["METHOD_START", "{", "ApplicationManager . getApplication (  )  . invokeLater ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "ApplicationManager . getApplication (  )  . runWriteAction ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "for    ( String   resourcesUrl    :    resourceUrls )     {", "ExternalManager . getInstance (  )  . remove ( resourcesUrl )  ;", "}", "for    ( String   downloaded    :    downloadeds )     {", "VirtualFile   virtualFile    =    LocalFileSystem . getInstance (  )  . findFileByIoFile ( new   File ( downloaded )  )  ;", "if    ( virtualFile    !  =    null )     {", "try    {", "virtualFile . delete ( this )  ;", "}    catch    ( IOException   ignore )     {", "}", "}", "}", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["cleanup"], "fileName": "com.intellij.codeInsight.daemon.impl.quickfix.FetchExtResourceAction"}, {"methodBody": ["METHOD_START", "{", "return   ReadAction . compute (  (  )     -  >     {", "PsiFile   file    =    psiManager . findFile ( vFile )  ;", "if    ( file   instanceof   XmlFile )     {", "PsiFile   contextFile    =     ( contextVFile    !  =    null )     ?    psiManager . findFile ( contextVFile )     :    null ;", "return   extractEmbeddedFileReferences (  (  ( XmlFile )     ( file )  )  ,     ( contextFile   instanceof   XmlFile    ?     (  ( XmlFile )     ( contextFile )  )     :    null )  ,    url )  ;", "}", "return   Collections . emptySet (  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["extractEmbeddedFileReferences"], "fileName": "com.intellij.codeInsight.daemon.impl.quickfix.FetchExtResourceAction"}, {"methodBody": ["METHOD_START", "{", "final   Set < String >    result    =    new   LinkedHashSet <  >  (  )  ;", "if    ( context    !  =    null )     {", "XmlEntityCache . copyEntityCaches ( file ,    context )  ;", "}", "XmlUtil . processXmlElements ( file ,    new   PsiElementProcessor (  )     {", "@ Override", "public   boolean   execute (  @ NotNull", "PsiElement   element )     {", "if    ( element   instanceof   XmlEntityDecl )     {", "String   candidateName    =    null ;", "for    ( PsiElement   e    =    element . getLastChild (  )  ;    e    !  =    null ;    e    =    e . getPrevSibling (  )  )     {", "if    (  ( e   instanceof   XmlAttributeValue )     &  &     ( candidateName    =  =    null )  )     {", "candidateName    =    e . getText (  )  . substring (  1  ,     (  ( e . getTextLength (  )  )     -     1  )  )  ;", "} else", "if    (  (  ( e   instanceof   psi . xml . XmlToken )     &  &     ( candidateName    !  =    null )  )     &  &     (  (  (  (  ( psi . xml . XmlToken )     ( e )  )  . getTokenType (  )  )     =  =     ( psi . xml . XmlTokenType . XML _ DOCTYPE _ PUBLIC )  )     |  |     (  (  (  ( psi . xml . XmlToken )     ( e )  )  . getTokenType (  )  )     =  =     ( psi . xml . XmlTokenType . XML _ DOCTYPE _ SYSTEM )  )  )  )     {", "if    (  !  ( result . contains ( candidateName )  )  )     {", "result . add ( candidateName )  ;", "}", "break ;", "}", "}", "} else", "if    ( element   instanceof   psi . xml . XmlTag )     {", "final   psi . xml . XmlTag   tag    =     (  ( psi . xml . XmlTag )     ( element )  )  ;", "String   schemaLocation    =    tag . getAttributeValue ( XmlUtil . SCHEMA _ LOCATION _ ATT )  ;", "if    ( schemaLocation    !  =    null )     {", "final   psi . PsiReference [  ]    references    =    tag . getAttribute ( XmlUtil . SCHEMA _ LOCATION _ ATT )  . getValueElement (  )  . getReferences (  )  ;", "if    (  ( references . length )     >     0  )     {", "String   extension    =    openapi . util . io . FileUtilRt . getExtension ( new   File ( url )  . getName (  )  )  ;", "final   String   namespace    =    tag . getAttributeValue (  \" namespace \"  )  ;", "if    (  (  ( namespace    !  =    null )     &  &     (  ( schemaLocation . indexOf (  '  /  '  )  )     =  =     (  -  1  )  )  )     &  &     (  !  ( extension . equals ( openapi . util . io . FileUtilRt . getExtension ( schemaLocation )  )  )  )  )     {", "result . add (  (  ( namespace . substring (  0  ,     (  ( namespace . lastIndexOf (  '  /  '  )  )     +     1  )  )  )     +    schemaLocation )  )  ;", "} else    {", "result . add ( schemaLocation )  ;", "}", "}", "} else    {", "schemaLocation    =    tag . getAttributeValue ( XmlUtil . SCHEMA _ LOCATION _ ATT ,    XmlUtil . XML _ SCHEMA _ INSTANCE _ URI )  ;", "if    ( schemaLocation    !  =    null )     {", "final   StringTokenizer   tokenizer    =    new   StringTokenizer ( schemaLocation )  ;", "while    ( tokenizer . hasMoreTokens (  )  )     {", "tokenizer . nextToken (  )  ;", "if    (  !  ( tokenizer . hasMoreTokens (  )  )  )", "break ;", "String   location    =    tokenizer . nextToken (  )  ;", "result . add ( location )  ;", "}", "}", "}", "}", "return   true ;", "}", "}  ,    true ,    true )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["extractEmbeddedFileReferences"], "fileName": "com.intellij.codeInsight.daemon.impl.quickfix.FetchExtResourceAction"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   HttpRequests . request ( dtdUrl )  . accept (  \" text / xml , application / xml , text / html ,  *  /  *  \"  )  . connect ( new   HttpRequests . RequestProcessor <  . FetchResult >  (  )     {", "@ Override", "public   FetchResult   process (  @ NotNull", "HttpRequests . Request   request )    throws   IOException    {", "FetchResult   result    =    new   FetchResult (  )  ;", "result . bytes    =    request . readBytes ( indicator )  ;", "result . contentType    =    request . getConnection (  )  . getContentType (  )  ;", "return   result ;", "}", "}  )  ;", "}    catch    ( MalformedURLException   e )     {", "if    (  !  ( ApplicationManager . getApplication (  )  . isUnitTestMode (  )  )  )     {", "ApplicationManager . getApplication (  )  . invokeLater (  (  )     -  >    Messages . showMessageDialog ( project ,    XmlBundle . message (  \" invalid . url . message \"  ,    dtdUrl )  ,    XmlBundle . message (  \" invalid . url . title \"  )  ,    Messages . getErrorIcon (  )  )  ,    indicator . getModalityState (  )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["fetchData"], "fileName": "com.intellij.codeInsight.daemon.impl.quickfix.FetchExtResourceAction"}, {"methodBody": ["METHOD_START", "{", "final   String   extResourcesPath    =    FetchExtResourceAction . getExternalResourcesPath (  )  ;", "final   File   extResources    =    new   File ( extResourcesPath )  ;", "FetchExtResourceAction . LOG . assertTrue (  (  ( extResources . mkdirs (  )  )     |  |     ( extResources . exists (  )  )  )  ,    extResources )  ;", "final   PsiManager   psiManager    =    PsiManager . getInstance ( project )  ;", "ApplicationManager . getApplication (  )  . invokeAndWait (  (  )     -  >     {", "WriteAction . run (  (  )     -  >     {", "final   String   path    =    FileUtil . toSystemIndependentName ( extResources . getAbsolutePath (  )  )  ;", "final   VirtualFile   vFile    =    LocalFileSystem . getInstance (  )  . refreshAndFindFileByPath ( path )  ;", "FetchExtResourceAction . LOG . assertTrue (  ( vFile    !  =    null )  ,    path )  ;", "}  )  ;", "}  )  ;", "final   List < String >    downloadedResources    =    new   LinkedList <  >  (  )  ;", "final   List < String >    resourceUrls    =    new   LinkedList <  >  (  )  ;", "final   IOException [  ]    nestedException    =    new   IOException [  1  ]  ;", "try    {", "final   String   resPath    =    fetchOneFile ( indicator ,    url ,    project ,    extResourcesPath ,    null )  ;", "if    ( resPath    =  =    null )", "return ;", "resourceUrls . add ( dtdUrl )  ;", "downloadedResources . add ( resPath )  ;", "VirtualFile   virtualFile    =    FetchExtResourceAction . findFileByPath ( resPath ,    dtdUrl )  ;", "Set < String >    processedLinks    =    new   HashSet <  >  (  )  ;", "Map < String ,    String >    baseUrls    =    new   HashMap <  >  (  )  ;", "VirtualFile   contextFile    =    virtualFile ;", "Set < String >    linksToProcess    =    new   HashSet ( FetchExtResourceAction . extractEmbeddedFileReferences ( virtualFile ,    null ,    psiManager ,    url )  )  ;", "while    (  !  ( linksToProcess . isEmpty (  )  )  )     {", "String   s    =    linksToProcess . iterator (  )  . next (  )  ;", "linksToProcess . remove ( s )  ;", "processedLinks . add ( s )  ;", "final   boolean   absoluteUrl    =    s . startsWith ( FetchExtResourceAction . HTTP _ PROTOCOL )  ;", "String   resourceUrl ;", "if    ( absoluteUrl )     {", "resourceUrl    =    s ;", "} else    {", "String   baseUrl    =    baseUrls . get ( s )  ;", "if    ( baseUrl    =  =    null )", "baseUrl    =    url ;", "resourceUrl    =     ( baseUrl . substring (  0  ,     (  ( baseUrl . lastIndexOf (  '  /  '  )  )     +     1  )  )  )     +    s ;", "}", "String   resourcePath ;", "String   refname    =    s . substring (  (  ( s . lastIndexOf (  '  /  '  )  )     +     1  )  )  ;", "if    ( absoluteUrl )", "refname    =     (  ( Integer . toHexString ( s . hashCode (  )  )  )     +     \"  _  \"  )     +    refname ;", "try    {", "resourcePath    =    fetchOneFile ( indicator ,    resourceUrl ,    project ,    extResourcesPath ,    refname )  ;", "}    catch    ( IOException   e )     {", "nestedException [  0  ]     =    new   FetchExtResourceAction . FetchingResourceIOException ( e ,    resourceUrl )  ;", "break ;", "}", "if    ( resourcePath    =  =    null )", "break ;", "virtualFile    =    FetchExtResourceAction . findFileByPath ( resourcePath ,     ( absoluteUrl    ?    s    :    null )  )  ;", "downloadedResources . add ( resourcePath )  ;", "if    ( absoluteUrl )     {", "resourceUrls . add ( s )  ;", "}", "final   Set < String >    newLinks    =    FetchExtResourceAction . extractEmbeddedFileReferences ( virtualFile ,    contextFile ,    psiManager ,    resourceUrl )  ;", "for    ( String   u    :    newLinks )     {", "baseUrls . put ( u ,    resourceUrl )  ;", "if    (  !  ( processedLinks . contains ( u )  )  )", "linksToProcess . add ( u )  ;", "}", "}", "}    catch    ( IOException   ex )     {", "nestedException [  0  ]     =    ex ;", "}", "if    (  ( nestedException [  0  ]  )     !  =    null )     {", "cleanup ( resourceUrls ,    downloadedResources )  ;", "throw   nestedException [  0  ]  ;", "}", "}", "METHOD_END"], "methodName": ["fetchDtd"], "fileName": "com.intellij.codeInsight.daemon.impl.quickfix.FetchExtResourceAction"}, {"methodBody": ["METHOD_START", "{", "SwingUtilities . invokeLater (  (  )     -  >    indicator . setText ( XmlBundle . message (  \" fetching . progress . indicator \"  ,    resourceUrl )  )  )  ;", ". FetchResult   result    =     . fetchData ( project ,    resourceUrl ,    indicator )  ;", "if    ( result    =  =    null )", "return   null ;", "if    (  !  ( resultIsValid ( project ,    indicator ,    resourceUrl ,    result )  )  )     {", "return   null ;", "}", "int   slashIndex    =    resourceUrl . lastIndexOf (  '  /  '  )  ;", "String   resPath    =    extResourcesPath    +     ( File . separatorChar )  ;", "if    ( refname    !  =    null )     {", "resPath    +  =    refname ;", "int   refNameSlashIndex    =    resPath . lastIndexOf (  '  /  '  )  ;", "if    ( refNameSlashIndex    !  =     (  -  1  )  )     {", "final   File   parent    =    new   File ( resPath . substring (  0  ,    refNameSlashIndex )  )  ;", "if    (  (  !  ( parent . mkdirs (  )  )  )     |  |     (  !  ( parent . exists (  )  )  )  )     {", ". LOG . warn (  (  \" Unable   to   create :     \"     +    parent )  )  ;", "}", "}", "} else    {", "resPath    +  =     (  ( Integer . toHexString ( resourceUrl . hashCode (  )  )  )     +     \"  _  \"  )     +     ( resourceUrl . substring (  ( slashIndex    +     1  )  )  )  ;", "}", "final   int   lastDoPosInResourceUrl    =    resourceUrl . lastIndexOf (  '  .  '  ,    slashIndex )  ;", "if    (  ( lastDoPosInResourceUrl    =  =     (  -  1  )  )     |  |     (  ( FileTypeManager . getInstance (  )  . getFileTypeByExtension ( resourceUrl . substring (  ( lastDoPosInResourceUrl    +     1  )  )  )  )     =  =     ( FileTypes . UNKNOWN )  )  )     {", "final   String   extension    =     (  (  ( result . contentType )     !  =    null )     &  &     ( result . contentType . contains (  . HTML _ MIME )  )  )     ?    HTML . getDefaultExtension (  )     :    XML . getDefaultExtension (  )  ;", "resPath    +  =     \"  .  \"     +    extension ;", "}", "File   res    =    new   File ( resPath )  ;", "FileUtil . writeToFile ( res ,    result . bytes )  ;", "return   resPath ;", "}", "METHOD_END"], "methodName": ["fetchOneFile"], "fileName": "com.intellij.codeInsight.daemon.impl.quickfix.FetchExtResourceAction"}, {"methodBody": ["METHOD_START", "{", "final   Ref < VirtualFile >    ref    =    new   Ref (  )  ;", "ApplicationManager . getApplication (  )  . invokeAndWait (  (  )     -  >    ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >     {", "ref . set ( LocalFileSystem . getInstance (  )  . refreshAndFindFileByPath ( resPath . replace ( File . separatorChar ,     '  /  '  )  )  )  ;", "if    ( dtdUrl    !  =    null )     {", "ExternalManager . getInstance (  )  . add ( dtdUrl ,    resPath )  ;", "}", "}  )  )  ;", "return   ref . get (  )  ;", "}", "METHOD_END"], "methodName": ["findFileByPath"], "fileName": "com.intellij.codeInsight.daemon.impl.quickfix.FetchExtResourceAction"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   currentElement    =    file . findElementAt ( offset )  ;", "final   XmlAttribute   attribute    =    PsiTreeUtil . getParentOfType ( currentElement ,    XmlAttribute . class )  ;", "if    ( attribute    !  =    null )     {", "final   XmlTag   tag    =    PsiTreeUtil . getParentOfType ( currentElement ,    XmlTag . class )  ;", "if    ( tag    !  =    null )     {", "final   String   prefix    =    tag . getPrefixByNamespace ( XmlUtil . XML _ SCHEMA _ INSTANCE _ URI )  ;", "if    ( prefix    !  =    null )     {", "final   String   attrValue    =    tag . getAttributeValue ( XmlUtil . SCHEMA _ LOCATION _ ATT ,    XmlUtil . XML _ SCHEMA _ INSTANCE _ URI )  ;", "if    ( attrValue    !  =    null )     {", "final   StringTokenizer   tokenizer    =    new   StringTokenizer ( attrValue )  ;", "while    ( tokenizer . hasMoreElements (  )  )     {", "if    ( uri . equals ( tokenizer . nextToken (  )  )  )     {", "if    (  !  ( tokenizer . hasMoreElements (  )  )  )", "return   uri ;", "final   String   url    =    tokenizer . nextToken (  )  ;", "return   url . startsWith (  . HTTP _ PROTOCOL )     ?    url    :    uri ;", "}", "if    (  !  ( tokenizer . hasMoreElements (  )  )  )", "return   uri ;", "tokenizer . nextToken (  )  ;", "}", "}", "}", "}", "}", "return   uri ;", "}", "METHOD_END"], "methodName": ["findUrl"], "fileName": "com.intellij.codeInsight.daemon.impl.quickfix.FetchExtResourceAction"}, {"methodBody": ["METHOD_START", "{", "return    (  ( PathManager . getSystemPath (  )  )     +     ( File . separator )  )     +     ( FetchExtResourceAction . EXT _ RESOURCES _ FOLDER )  ;", "}", "METHOD_END"], "methodName": ["getExternalResourcesPath"], "fileName": "com.intellij.codeInsight.daemon.impl.quickfix.FetchExtResourceAction"}, {"methodBody": ["METHOD_START", "{", "if    ( myForceResultIsValid )     {", "return   true ;", "}", "if    (  (  (  (  !  ( ApplicationManager . getApplication (  )  . isUnitTestMode (  )  )  )     &  &     (  ( result . contentType )     !  =    null )  )     &  &     ( result . contentType . contains (  . HTML _ MIME )  )  )     &  &     ( new   String ( result . bytes )  . contains (  \"  < html \"  )  )  )     {", "ApplicationManager . getApplication (  )  . invokeLater (  (  )     -  >    Messages . showMessageDialog ( project ,    XmlBundle . message (  \" invalid . url . no . xml . file . at . location \"  ,    resourceUrl )  ,    XmlBundle . message (  \" invalid . url . title \"  )  ,    Messages . getErrorIcon (  )  )  ,    indicator . getModalityState (  )  )  ;", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["resultIsValid"], "fileName": "com.intellij.codeInsight.daemon.impl.quickfix.FetchExtResourceAction"}, {"methodBody": ["METHOD_START", "{", "final   PsiFile   file    =    deepestElement . getContainingFile (  )  ;", "if    (  ( file    =  =    null )     |  |     (  !  ( XmlTUtil . isTActive ( file )  )  )  )     {", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isMyContext"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeBreadcrumbsPresentationProvider"}, {"methodBody": ["METHOD_START", "{", "final   int   levelCount    =    WebEditorOptions . getInstance (  )  . getTagTreeHighlightingLevelCount (  )  ;", "if    (  (  (  . ourColorKeys )     =  =    null )     |  |     (  (  . ourColorKeys . length )     !  =    levelCount )  )     {", ". ourColorKeys    =    new   ColorKey [ levelCount ]  ;", "for    ( int   i    =     0  ;    i    <     (  . ourColorKeys . length )  ;    i +  +  )     {", ". ourColorKeys [ i ]     =    ColorKey . createColorKey (  (  \" HTML _ TAG _ TREE _ LEVEL \"     +    i )  ,     . DEFAULT _ COLORS [  ( i    %     (  . DEFAULT _ COLORS . length )  )  ]  )  ;", "}", "}", "return    . ourColorKeys ;", "}", "METHOD_END"], "methodName": ["getColorKeys"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeHighlightingColors"}, {"methodBody": ["METHOD_START", "{", "for    ( Project   project    :    ProjectManager . getInstance (  )  . getOpenProjects (  )  )     {", "for    ( FileEditor   fileEditor    :    FileEditorManager . getInstance ( project )  . getAllEditors (  )  )     {", "if    ( fileEditor   instanceof   TextEditor )     {", "final   Editor   editor    =     (  ( TextEditor )     ( fileEditor )  )  . getEditor (  )  ;", "Pass . clearHighlightingAndLineMarkers ( editor ,    project )  ;", "final   BreadcrumbsXmlWrapper   breadcrumbsXmlWrapper    =    BreadcrumbsXmlWrapper . getBreadcrumbsComponent ( editor )  ;", "if    ( breadcrumbsXmlWrapper    !  =    null )     {", "breadcrumbsXmlWrapper . queueUpdate (  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["clearTagTreeHighlighting"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeHighlightingConfigurable"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Integer )     ( myLevelsSpinner . getValue (  )  )  )  . intValue (  )  ;", "}", "METHOD_END"], "methodName": ["getLevelCount"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeHighlightingConfigurable"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     (  (  (  ( Double )     ( myOpacitySpinner . getValue (  )  )  )  . doubleValue (  )  )     *     1  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["getOpacity"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeHighlightingConfigurable"}, {"methodBody": ["METHOD_START", "{", "final   MarkupModel   markupModel    =    DocumentMarkupModel . forDocument ( editor . getDocument (  )  ,    project ,    true )  ;", "for    ( RangeHighlighter   highlighter    :    markupModel . getAllHighlighters (  )  )     {", "HighlightInfo   info    =    HighlightInfo . fromRangeHighlighter ( highlighter )  ;", "if    ( info    =  =    null )", "continue ;", "if    (  ( info . type )     =  =     (  . TYPE )  )     {", "highlighter . dispose (  )  ;", "}", "}", ". clearLineMarkers ( editor )  ;", "}", "METHOD_END"], "methodName": ["clearHighlightingAndLineMarkers"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeHighlightingPass"}, {"methodBody": ["METHOD_START", "{", "final   List < RangeHighlighter >    oldHighlighters    =    editor . getUserData ( XmlTagTreeHighlightingPass . TAG _ TREE _ HIGHLIGHTERS _ IN _ EDITOR _ KEY )  ;", "if    ( oldHighlighters    !  =    null )     {", "final   MarkupModelEx   markupModel    =     (  ( MarkupModelEx )     ( editor . getMarkupModel (  )  )  )  ;", "for    ( RangeHighlighter   highlighter    :    oldHighlighters )     {", "if    ( markupModel . containsHighlighter ( highlighter )  )     {", "highlighter . dispose (  )  ;", "}", "}", "editor . putUserData ( XmlTagTreeHighlightingPass . TAG _ TREE _ HIGHLIGHTERS _ IN _ EDITOR _ KEY ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["clearLineMarkers"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeHighlightingPass"}, {"methodBody": ["METHOD_START", "{", "TextAttributes   attributes    =    new   TextAttributes ( null ,    color ,    null ,    null ,    Font . PLAIN )  ;", "return   HighlightInfo . newHighlightInfo ( XmlTagTreeHighlightingPass . TYPE )  . range ( range )  . textAttributes ( attributes )  . severity ( INFORMATION )  . createUnconditionally (  )  ;", "}", "METHOD_END"], "methodName": ["createHighlightInfo"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeHighlightingPass"}, {"methodBody": ["METHOD_START", "{", "final   RangeHighlighter   highlighter    =    mm . addRangeHighlighter ( range . getStartOffset (  )  ,    range . getEndOffset (  )  ,     0  ,    null ,    LINES _ IN _ RANGE )  ;", "highlighter . setLineMarkerRenderer ( new   LineMarkerRenderer (  )     {", "@ Override", "public   void   paint ( Editor   editor ,    Graphics   g ,    Rectangle   r )     {", "g . setColor ( color )  ;", "g . fillRect (  (  ( r . x )     -     1  )  ,    r . y ,     2  ,    r . height )  ;", "}", "}  )  ;", "return   highlighter ;", "}", "METHOD_END"], "methodName": ["createHighlighter"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeHighlightingPass"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   endTagStart    =    XmlChildRole . CLOSING _ TAG _ START _ FINDER . findChild ( tagNode )  ;", "if    ( endTagStart    =  =    null )     {", "return   null ;", "}", "ASTNode   endTagEnd    =    endTagStart ;", "while    (  ( endTagEnd    !  =    null )     &  &     (  ( endTagEnd . getElementType (  )  )     !  =     ( XmlTokenType . XML _ TAG _ END )  )  )     {", "endTagEnd    =    endTagEnd . getTreeNext (  )  ;", "}", "if    ( endTagEnd    =  =    null )     {", "return   null ;", "}", "return   new   openapi . util . TextRange ( endTagStart . getStartOffset (  )  ,    endTagEnd . getTextRange (  )  . getEndOffset (  )  )  ;", "}", "METHOD_END"], "methodName": ["getEndTagRange"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeHighlightingPass"}, {"methodBody": ["METHOD_START", "{", "XmlTagTreeHighlightingPass . clearLineMarkers ( myEditor )  ;", "final   int   count    =    myPairsToHighlight . size (  )  ;", "final   List < HighlightInfo >    highlightInfos    =    new   ArrayList <  >  (  ( count    *     2  )  )  ;", "final   MarkupModel   markupModel    =    myEditor . getMarkupModel (  )  ;", "final   Color [  ]    baseColors    =    XmlTagTreeHighlightingUtil . getBaseColors (  )  ;", "final   Color [  ]    colorsForEditor    =     ( count    >     1  )     ?    toColorsForEditor ( baseColors )     :    new   Color [  ]  {    myEditor . getColorsScheme (  )  . getAttributes ( MATCHED _ BRACE _ ATTRIBUTES )  . getBackgroundColor (  )     }  ;", "final   Color [  ]    colorsForLineMarkers    =    XmlTagTreeHighlightingPass . toColorsForLineMarkers ( baseColors )  ;", "final   List < RangeHighlighter >    newHighlighters    =    new   ArrayList <  >  (  )  ;", "assert    ( colorsForEditor . length )     >     0  ;", "for    ( int   i    =     0  ;     ( i    <    count )     &  &     ( i    <     ( baseColors . length )  )  ;    i +  +  )     {", "Pair < TextRange ,    TextRange >    pair    =    myPairsToHighlight . get ( i )  ;", "if    (  (  ( pair . first )     =  =    null )     &  &     (  ( pair . second )     =  =    null )  )     {", "continue ;", "}", "Color   color    =    colorsForEditor [ i ]  ;", "if    ( color    =  =    null )     {", "continue ;", "}", "if    (  (  ( pair . first )     !  =    null )     &  &     (  !  ( pair . first . isEmpty (  )  )  )  )     {", "highlightInfos . add ( XmlTagTreeHighlightingPass . createHighlightInfo ( color ,    pair . first )  )  ;", "}", "if    (  (  ( pair . second )     !  =    null )     &  &     (  !  ( pair . second . isEmpty (  )  )  )  )     {", "highlightInfos . add ( XmlTagTreeHighlightingPass . createHighlightInfo ( color ,    pair . second )  )  ;", "}", "final   int   start    =     (  ( pair . first )     !  =    null )     ?    pair . first . getStartOffset (  )     :    pair . second . getStartOffset (  )  ;", "final   int   end    =     (  ( pair . second )     !  =    null )     ?    pair . second . getEndOffset (  )     :    pair . first . getEndOffset (  )  ;", "final   Color   lineMarkerColor    =    colorsForLineMarkers [ i ]  ;", "if    (  (  ( count    >     1  )     &  &     ( lineMarkerColor    !  =    null )  )     &  &     ( start    !  =    end )  )     {", "final   RangeHighlighter   highlighter    =    XmlTagTreeHighlightingPass . createHighlighter ( markupModel ,    new   TextRange ( start ,    end )  ,    lineMarkerColor )  ;", "newHighlighters . add ( highlighter )  ;", "}", "}", "myEditor . putUserData ( XmlTagTreeHighlightingPass . TAG _ TREE _ HIGHLIGHTERS _ IN _ EDITOR _ KEY ,    newHighlighters )  ;", "return   highlightInfos ;", "}", "METHOD_END"], "methodName": ["getHighlights"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeHighlightingPass"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   startTagStart    =    XmlChildRole . START _ TAG _ START _ FINDER . findChild ( tagNode )  ;", "if    ( startTagStart    =  =    null )     {", "return   null ;", "}", "ASTNode   tagName    =    startTagStart . getTreeNext (  )  ;", "if    (  ( tagName    =  =    null )     |  |     (  ( tagName . getElementType (  )  )     !  =     ( XmlTokenType . XML _ NAME )  )  )     {", "return   null ;", "}", "ASTNode   next    =    tagName . getTreeNext (  )  ;", "if    (  ( next    !  =    null )     &  &     (  ( next . getElementType (  )  )     =  =     ( XmlTokenType . XML _ TAG _ END )  )  )     {", "tagName    =    next ;", "}", "return   new   openapi . util . TextRange ( startTagStart . getStartOffset (  )  ,    tagName . getTextRange (  )  . getEndOffset (  )  )  ;", "}", "METHOD_END"], "methodName": ["getStartTagRange"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeHighlightingPass"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   tagNode    =    tag . getNode (  )  ;", "return   Pair . create (  . getStartTagRange ( tagNode )  ,     . getEndTagRange ( tagNode )  )  ;", "}", "METHOD_END"], "methodName": ["getTagRanges"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeHighlightingPass"}, {"methodBody": ["METHOD_START", "{", "if    ( element    =  =    null )", "return   false ;", "final   IElementType   type    =    element . getNode (  )  . getElementType (  )  ;", "if    ( type    =  =     ( XmlTokenType . XML _ NAME )  )", "return    (  . isTagStartOrEnd ( element . getNextSibling (  )  )  )     |  |     (  . isTagStartOrEnd ( element . getPrevSibling (  )  )  )  ;", "return    (  ( type    =  =     ( XmlTokenType . XML _ START _ TAG _ START )  )     |  |     ( type    =  =     ( XmlTokenType . XML _ END _ TAG _ START )  )  )     |  |     ( type    =  =     ( XmlTokenType . XML _ TAG _ END )  )  ;", "}", "METHOD_END"], "methodName": ["isTagStartOrEnd"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeHighlightingPass"}, {"methodBody": ["METHOD_START", "{", "final   Color   tagBackground    =    myEditor . getBackgroundColor (  )  ;", "if    ( tagBackground    =  =    null )     {", "return   baseColors ;", "}", "final   Color [  ]    resultColors    =    new   Color [ baseColors . length ]  ;", "final   double   transparency    =     ( WebEditorOptions . getInstance (  )  . getTagTreeHighlightingOpacity (  )  )     *     0  .  0  1  ;", "for    ( int   i    =     0  ;    i    <     ( resultColors . length )  ;    i +  +  )     {", "final   Color   color    =    baseColors [ i ]  ;", "final   Color   color 1     =     ( color    !  =    null )     ?    Util . makeTransparent ( color ,    tagBackground ,    transparency )     :    null ;", "resultColors [ i ]     =    color 1  ;", "}", "return   resultColors ;", "}", "METHOD_END"], "methodName": ["toColorsForEditor"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeHighlightingPass"}, {"methodBody": ["METHOD_START", "{", "final   Color [  ]    colors    =    new   Color [ baseColors . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( colors . length )  ;    i +  +  )     {", "colors [ i ]     =     . toLineMarkerColor (  2  3  9  ,    baseColors [ i ]  )  ;", "}", "return   colors ;", "}", "METHOD_END"], "methodName": ["toColorsForLineMarkers"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeHighlightingPass"}, {"methodBody": ["METHOD_START", "{", "int   value    =     (  ( int )     (  ( gray    *     0  .  6  )     +     (  0  .  3  2     *    color )  )  )  ;", "return   value    <     0     ?     0     :    value    >     2  5  5     ?     2  5  5     :    value ;", "}", "METHOD_END"], "methodName": ["toLineMarkerColor"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeHighlightingPass"}, {"methodBody": ["METHOD_START", "{", "return   color    =  =    null    ?    null    :    new   Color ( XmlTagTreeHighlightingPass . toLineMarkerColor ( gray ,    color . getRed (  )  )  ,    XmlTagTreeHighlightingPass . toLineMarkerColor ( gray ,    color . getGreen (  )  )  ,    XmlTagTreeHighlightingPass . toLineMarkerColor ( gray ,    color . getBlue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["toLineMarkerColor"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeHighlightingPass"}, {"methodBody": ["METHOD_START", "{", "final   Set < String >    names    =    new   HashSet <  >  (  )  ;", "for    ( PsiElement   element    :    elements )     {", "if    ( element   instanceof    )     {", "final   String   name    =     (  (  )     ( element )  )  . getName (  )  ;", "if    (  !  ( names . add ( name )  )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsTagsWithSameName"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeHighlightingUtil"}, {"methodBody": ["METHOD_START", "{", "final   ColorKey [  ]    colorKeys    =    XmlTagTreeHighlightingColors . getColorKeys (  )  ;", "final   Color [  ]    colors    =    new   Color [ colorKeys . length ]  ;", "final   EditorColorsScheme   colorsScheme    =    EditorColorsManager . getInstance (  )  . getGlobalScheme (  )  ;", "for    ( int   i    =     0  ;    i    <     ( colors . length )  ;    i +  +  )     {", "colors [ i ]     =    colorsScheme . getColor ( colorKeys [ i ]  )  ;", "}", "return   colors ;", "}", "METHOD_END"], "methodName": ["getBaseColors"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeHighlightingUtil"}, {"methodBody": ["METHOD_START", "{", "for    ( PsiFile   f    :    file . getViewProvider (  )  . getAllFiles (  )  )     {", "if    ( f   instanceof   File )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasXmlViewProvider"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeHighlightingUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( ApplicationManager . getApplication (  )  . isUnitTestMode (  )  )     {", "return   false ;", "}", "if    (  !  (  . hasXmlViewProvider ( file )  )  )     {", "return   false ;", "}", "if    (  !  ( WebEditorOptions . getInstance (  )  . isTagTreeHighlightingEnabled (  )  )  )     {", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isTagTreeHighlightingActive"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeHighlightingUtil"}, {"methodBody": ["METHOD_START", "{", "final   int   result    =     (  ( int )     (  ( backgroundChannel    *     (  1     -    transparency )  )     +     ( channel    *    transparency )  )  )  ;", "if    ( result    <     0  )     {", "return    0  ;", "}", "if    ( result    >     2  5  5  )     {", "return    2  5  5  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["makeTransparent"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeHighlightingUtil"}, {"methodBody": ["METHOD_START", "{", "int   r    =    XmlTagTreeHighlightingUtil . makeTransparent ( transparency ,    color . getRed (  )  ,    backgroundColor . getRed (  )  )  ;", "int   g    =    XmlTagTreeHighlightingUtil . makeTransparent ( transparency ,    color . getGreen (  )  ,    backgroundColor . getGreen (  )  )  ;", "int   b    =    XmlTagTreeHighlightingUtil . makeTransparent ( transparency ,    color . getBlue (  )  ,    backgroundColor . getBlue (  )  )  ;", "return   new   Color ( r ,    g ,    b )  ;", "}", "METHOD_END"], "methodName": ["makeTransparent"], "fileName": "com.intellij.codeInsight.daemon.impl.tagTreeHighlighting.XmlTagTreeHighlightingUtil"}, {"methodBody": ["METHOD_START", "{", "PsiFile   file    =    myFixture . configureByText ( XmlFileType . INSTANCE ,     \"  < a /  >  \"  )  ;", "assertFalse ( new   Intention (  )  . isAvailable ( getProject (  )  ,    myFixture . getEditor (  )  ,    file )  )  ;", "}", "METHOD_END"], "methodName": ["testAlreadyCollapsed"], "fileName": "com.intellij.codeInsight.daemon.quickFix.CollapseTagTest"}, {"methodBody": ["METHOD_START", "{", "PsiFile   file    =    myFixture . configureByText ( XmlFileType . INSTANCE ,     \"  < a >              < caret >           <  / a >  \"  )  ;", "assertTrue ( new   Intention (  )  . isAvailable ( getProject (  )  ,    myFixture . getEditor (  )  ,    file )  )  ;", "}", "METHOD_END"], "methodName": ["testAvailable"], "fileName": "com.intellij.codeInsight.daemon.quickFix.CollapseTagTest"}, {"methodBody": ["METHOD_START", "{", "PsiFile   file    =    myFixture . configureByText ( XmlFileType . INSTANCE ,     \"  < a >              < caret >           < b /  >     <  / a >  \"  )  ;", "assertFalse ( new   Intention (  )  . isAvailable ( getProject (  )  ,    myFixture . getEditor (  )  ,    file )  )  ;", "}", "METHOD_END"], "methodName": ["testNotAvailable"], "fileName": "com.intellij.codeInsight.daemon.quickFix.CollapseTagTest"}, {"methodBody": ["METHOD_START", "{", "doExtractionOfEmbeddedFiles ( new   String [  ]  {    shortFileName    }  ,    new   String [  ]  [  ]  {    expectedFileNames    }  )  ;", "}", "METHOD_END"], "methodName": ["doExtractionOfEmbeddedFiles"], "fileName": "com.intellij.codeInsight.daemon.quickFix.ExtractExternalResourceLinksTest"}, {"methodBody": ["METHOD_START", "{", "final   List < VirtualFile >    files    =    new   ArrayList <  >  ( shortFileName . length )  ;", "for    ( String   s    :    shortFileName )     {", "if    (  ( FileUtilRt . getExtension ( s )  . length (  )  )     <     3  )     {", "s    +  =     \"  . xsd \"  ;", "}", "files . add ( getVirtualFile (  (  (  (  . getBasePath (  )  )     +     \"  /  \"  )     +    s )  )  )  ;", "}", "int   fileIndex    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( expectedFileNames . length )  ;    i +  +  )     {", "String [  ]    expectedFileNameArray    =    expectedFileNames [ i ]  ;", "Set < String >    strings    =    FetchExtResourceAction . extractEmbeddedFileReferences ( files . get ( fileIndex )  ,     ( fileIndex    !  =     0     ?    files . get (  0  )     :    null )  ,    getPsiManager (  )  ,    shortFileName [ i ]  )  ;", "assertEquals ( expectedFileNameArray . length ,    strings . size (  )  )  ;", "int   index    =     0  ;", "for    ( final   String   string    :    strings )     {", "assertEquals ( expectedFileNameArray [ index ]  ,    string )  ;", "+  + index ;", "}", "fileIndex +  +  ;", "}", "}", "METHOD_END"], "methodName": ["doExtractionOfEmbeddedFiles"], "fileName": "com.intellij.codeInsight.daemon.quickFix.ExtractExternalResourceLinksTest"}, {"methodBody": ["METHOD_START", "{", "return    \"  / quickFix / fetchExternalResources \"  ;", "}", "METHOD_END"], "methodName": ["getBasePath"], "fileName": "com.intellij.codeInsight.daemon.quickFix.ExtractExternalResourceLinksTest"}, {"methodBody": ["METHOD_START", "{", "doExtractionOfEmbeddedFiles (  \" BPMN 2  0  . xsd \"  ,     \" BPMNDI . xsd \"  ,     \" Semantic . xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testBPMN"], "fileName": "com.intellij.codeInsight.daemon.quickFix.ExtractExternalResourceLinksTest"}, {"methodBody": ["METHOD_START", "{", "doExtractionOfEmbeddedFiles (  \"  1  . dtd \"  ,     \" xhtml - lat 1  . ent \"  ,     \" xhtml - symbol . ent \"  ,     \" xhtml - special . ent \"  )  ;", "doExtractionOfEmbeddedFiles (  \"  1  . xsd \"  ,     \" j 2 ee _  1  _  4  . xsd \"  ,     \" jsp _  2  _  0  . xsd \"  )  ;", "doExtractionOfEmbeddedFiles ( new   String [  ]  {     \"  2  . dtd \"  ,     \"  2  . mod \"     }  ,    new   String [  ]  [  ]  {    new   String [  ]  {     \" dbnotnx . mod \"  ,     \" dbcentx . mod \"  ,     \" dbpoolx . mod \"  ,     \" dbhierx . mod \"  ,     \" dbgenent . mod \"     }  ,    new   String [  ]  {     \" htmltblx . mod \"  ,     \" calstblx . dtd \"     }     }  )  ;", "doExtractionOfEmbeddedFiles ( new   String [  ]  {     \"  3  . dtd \"     }  ,    new   String [  ]  [  ]  {    new   String [  ]  {     \" onix - international . elt \"     }     }  )  ;", "doExtractionOfEmbeddedFiles (  \"  3  . xsd \"  ,     \" j 2 ee _  1  _  4  . xsd \"  ,     \" jsp _  2  _  0  . xsd \"  )  ;", "doExtractionOfEmbeddedFiles (  \"  4  . xml \"  ,     \" http :  /  / www . springframework . org / schema / beans / spring - beans . xsd \"  ,     \" http :  /  / www . springframework . org / schema / aop / spring - aop . xsd \"  ,     \" http :  /  / www . springframework . org / schema / tx / spring - tx . xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testExtractionOfEmbeddedFiles"], "fileName": "com.intellij.codeInsight.daemon.quickFix.ExtractExternalResourceLinksTest"}, {"methodBody": ["METHOD_START", "{", "doExtractionOfEmbeddedFiles (  \" web -  1  .  1  \"  ,     \" http :  /  / geronimo . apache . org / xml / ns / geronimo - naming -  1  .  1  . xsd \"  ,     \" http :  /  / geronimo . apache . org / xml / ns / geronimo - security -  1  .  1  . xsd \"  ,     \" http :  /  / geronimo . apache . org / xml / ns / geronimo - module -  1  .  1  . xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testGeronimo"], "fileName": "com.intellij.codeInsight.daemon.quickFix.ExtractExternalResourceLinksTest"}, {"methodBody": ["METHOD_START", "{", "doExtractionOfEmbeddedFiles (  \"  6  . xml \"  ,     \" http :  /  / jboss . com / products / seam / components -  1  .  2  . xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testSeamImport"], "fileName": "com.intellij.codeInsight.daemon.quickFix.ExtractExternalResourceLinksTest"}, {"methodBody": ["METHOD_START", "{", "doAllTests (  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "com.intellij.codeInsight.daemon.quickFix.FetchExternalResourcesFixTest"}, {"methodBody": ["METHOD_START", "{", "doAllTests (  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "com.intellij.codeInsight.daemon.quickFix.IgnoreExternalResourcesFixTest"}, {"methodBody": ["METHOD_START", "{", "doAllTests (  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "com.intellij.codeInsight.daemon.quickFix.ManuallySetupExternalResourcesFixTest"}, {"methodBody": ["METHOD_START", "{", "final   String   url    =     \" http :  /  / com / dtd / preferences . dtd \"  ;", "assertEquals ( url ,    ExternalResourceManager . getInstance (  )  . getResourceLocation ( url ,    getProject (  )  )  )  ;", "myFixture . configureByText ( XmlFileType . INSTANCE ,     \"  <  ! DOCTYPE   images   SYSTEM    \\  \" http :  /  / com / dtd / prefer < caret > ences . dtd \\  \"  >  \"  )  ;", "IntentionAction   ntion    =    myFixture . getAvailableIntention ( XmlBundle . message (  \" fetch . external . resource \"  )  )  ;", "assertNotNull ( ntion )  ;", "ntion . invoke ( getProject (  )  ,    myFixture . getEditor (  )  ,    myFixture . getFile (  )  )  ;", "assertNotSame ( url ,    ExternalResourceManager . getInstance (  )  . getResourceLocation ( url ,    getProject (  )  )  )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >    ExternalResourceManager . getInstance (  )  . removeResource ( url )  )  ;", "}", "METHOD_END"], "methodName": ["testFetchDtd"], "fileName": "com.intellij.codeInsight.daemon.quickFix.RealFetchTest"}, {"methodBody": ["METHOD_START", "{", "final   String   url    =     \" http :  /  / com / dtd / preferences . dtd \"  ;", "VirtualFile   virtualFile    =    myFixture . getTempDirFixture (  )  . createFile (  \" images . dtd \"  ,     \"  \"  )  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily ( url ,    virtualFile . getPath (  )  ,    getRootDisposable (  )  )  ;", "myFixture . configureByText ( XmlFileType . INSTANCE ,     \"  <  ! DOCTYPE   images   SYSTEM    \\  \"  < error   descr =  \\  \" Resource   registered   by   this   uri   is   not   recognized    ( Settings    |    Languages    &    Frameworks    |    Schemas   and   DTDs )  \\  \"  > http :  /  / com / dtd / prefer < caret > ences . dtd <  / error >  \\  \"  >  < images >     <  / images >  \"  )  ;", "myFixture . testHighlighting (  )  ;", "IntentionAction   intention    =    myFixture . getAvailableIntention ( XmlBundle . message (  \" fetch . external . resource \"  )  )  ;", "assertNotNull ( intention )  ;", "intention . invoke ( getProject (  )  ,    myFixture . getEditor (  )  ,    myFixture . getFile (  )  )  ;", "List < HighlightInfo >    infos    =    myFixture . doHighlighting (  )  ;", "assertEmpty ( infos )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >    ExternalResourceManager . getInstance (  )  . removeResource ( url )  )  ;", "}", "METHOD_END"], "methodName": ["testOverwriteFetchDtd"], "fileName": "com.intellij.codeInsight.daemon.quickFix.RealFetchTest"}, {"methodBody": ["METHOD_START", "{", "doAllTests (  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "com.intellij.codeInsight.daemon.quickFix.ReplaceTagEmptyBodyTest"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iterator . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ TAG _ END )  )     {", "return   false ;", "}", "PsiDocumentManager . getInstance ( project )  . commitDocument (  . getDocument (  )  )  ;", "final   PsiElement   element    =    file . findElementAt ( iterator . getStart (  )  )  ;", "if    ( element    =  =    null )     {", "return   false ;", "}", "final   PsiElement   parent    =    element . getParent (  )  ;", "return    ( parent   instanceof   XmlTag )     &  &     (  ( parent . getTextRange (  )  . getEndOffset (  )  )     =  =     ( iterator . getEnd (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAtTheEndOfEmptyTag"], "fileName": "com.intellij.codeInsight.editorActions.EnterBetweenXmlTagsHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( offset    =  =     0  )", "return   false ;", "CharSequence   chars    =    editor . getDocument (  )  . getCharsSequence (  )  ;", "if    (  ( chars . charAt (  ( offset    -     1  )  )  )     !  =     '  >  '  )", "return   false ;", "EditorHighlighter   highlighter    =     (  ( EditorEx )     ( editor )  )  . getHighlighter (  )  ;", "HighlighterIterator   iterator    =    highlighter . createIterator (  ( offset    -     1  )  )  ;", "if    (  ( iterator . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ TAG _ END )  )", "return   false ;", "if    (  . isAtTheEndOfEmptyTag ( project ,    editor ,    file ,    iterator )  )     {", "return   false ;", "}", "iterator . retreat (  )  ;", "int   retrieveCount    =     1  ;", "while    (  !  ( iterator . atEnd (  )  )  )     {", "final   IElementType   tokenType    =    iterator . getTokenType (  )  ;", "if    ( tokenType    =  =     ( XmlTokenType . XML _ END _ TAG _ START )  )", "return   false ;", "if    ( tokenType    =  =     ( XmlTokenType . XML _ START _ TAG _ START )  )", "break ;", "+  + retrieveCount ;", "iterator . retreat (  )  ;", "}", "for    ( int   i    =     0  ;    i    <    retrieveCount ;     +  + i )", "iterator . advance (  )  ;", "iterator . advance (  )  ;", "return    (  !  ( iterator . atEnd (  )  )  )     &  &     (  ( iterator . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ END _ TAG _ START )  )  ;", "}", "METHOD_END"], "methodName": ["isBetweenXmlTags"], "fileName": "com.intellij.codeInsight.editorActions.EnterBetweenXmlTagsHandler"}, {"methodBody": ["METHOD_START", "{", "String   finalText    =     (  !  ( text . contains (  \"  < selection >  \"  )  )  )     ?     (  \"  < selection >  \"     +    text )     +     \"  <  / selection >  \"     :    text ;", "PlatformTestUtil . withEncoding (  \" UTF 8  \"  ,     (  )     -  >     {", "myFixture . configureByText (  (  (  ( getTestName ( true )  )     +     \"  .  \"  )     +    extension )  ,    finalText )  ;", "myFixture . performEditorAction (  \"  \"  )  ;", "myFixture . checkResult ( expected )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.codeInsight.editorActions.EscapeEntitiesActionTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  (  (  \"  < a   alt =  '  \"     +     ( EscapeEntitiesActionTest . N _ DASH )  )     +     \"  '  >  <  / a >  \"  )  ,     \" html \"  ,     \"  < a   alt =  '  & ndash ;  '  >  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeValue"], "fileName": "com.intellij.codeInsight.editorActions.EscapeEntitiesActionTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  (  \"  <  ! DOCTYPE   html \\ n \"     +     (  \"                         PUBLIC    \\  \"  -  /  / W 3 C /  / DTD   XHTML    1  .  0    Transitional /  / EN \\  \"  \\ n \"     +     \"                          \\  \" http :  /  / www . w 3  . org / TR / xhtml 1  / DTD / xhtml 1  - transitional . dtd \\  \"  >  \"  )  )  ,     \" html \"  ,     (  \"  <  ! DOCTYPE   html \\ n \"     +     (  \"                         PUBLIC    \\  \"  -  /  / W 3 C /  / DTD   XHTML    1  .  0    Transitional /  / EN \\  \"  \\ n \"     +     \"                          \\  \" http :  /  / www . w 3  . org / TR / xhtml 1  / DTD / xhtml 1  - transitional . dtd \\  \"  >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testDoctypeSystemPublic"], "fileName": "com.intellij.codeInsight.editorActions.EscapeEntitiesActionTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  (  \"  < a >  < selection >  <  <  / selection >  <  / a >  \\ n \"     +     (  \"  < a >  < selection >  <  <  / selection >  <  / a >  \\ n \"     +     \"  < a >  < selection >  <  <  / selection >  <  / a >  \\ n \"  )  )  ,     \" html \"  ,     (  \"  < a >  & lt ;  <  / a >  \\ n \"     +     (  \"  < a >  & lt ;  <  / a >  \\ n \"     +     \"  < a >  & lt ;  <  / a >  \\ n \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultiCaret"], "fileName": "com.intellij.codeInsight.editorActions.EscapeEntitiesActionTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  <  <  <  \"  ,     \" html \"  ,     \"  & lt ;  & lt ;  & lt ;  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleHtml"], "fileName": "com.intellij.codeInsight.editorActions.EscapeEntitiesActionTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  >  >  >  \"  ,     \" xml \"  ,     \"  & gt ;  & gt ;  & gt ;  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleXml"], "fileName": "com.intellij.codeInsight.editorActions.EscapeEntitiesActionTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  < a >  <  <  / a >  \"  ,     \" html \"  ,     \"  < a >  & lt ;  <  / a >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTag"], "fileName": "com.intellij.codeInsight.editorActions.EscapeEntitiesActionTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( EscapeEntitiesActionTest . N _ DASH ,     \" html \"  ,     \"  & ndash ;  \"  )  ;", "}", "METHOD_END"], "methodName": ["testVeryWide"], "fileName": "com.intellij.codeInsight.editorActions.EscapeEntitiesActionTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( EscapeEntitiesActionTest . COPY ,     \" html \"  ,     \"  & reg ;  \"  )  ;", "}", "METHOD_END"], "methodName": ["testWide"], "fileName": "com.intellij.codeInsight.editorActions.EscapeEntitiesActionTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  (  \"  < component >  \\ n \"     +     (  \"       amp       &             U +  0  0  2  6     (  3  8  )    XML    1  .  0    ampersand \\ n \"     +     \"  <  / component >  \"  )  )  ,     \" xml \"  ,     (  \"  < component >  \\ n \"     +     (  \"       amp       & amp ;             U +  0  0  2  6     (  3  8  )    XML    1  .  0    ampersand \\ n \"     +     \"  <  / component >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testXmlAmp"], "fileName": "com.intellij.codeInsight.editorActions.EscapeEntitiesActionTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  (  \"  < component >  \\ n \"     +     (  \"       lt          <             U +  0  0  3 C    (  6  0  )    XML    1  .  0    less - than   sign \\ n \"     +     \"  <  / component >  \"  )  )  ,     \" xml \"  ,     (  \"  < component >  \\ n \"     +     (  \"       lt          & lt ;             U +  0  0  3 C    (  6  0  )    XML    1  .  0    less - than   sign \\ n \"     +     \"  <  / component >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testXmlLt"], "fileName": "com.intellij.codeInsight.editorActions.EscapeEntitiesActionTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  <  <  <  \"  ,     \" xml \"  ,     \"  & lt ;  & lt ;  & lt ;  \"  )  ;", "}", "METHOD_END"], "methodName": ["testXmlStart"], "fileName": "com.intellij.codeInsight.editorActions.EscapeEntitiesActionTest"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   DataFlavor ( flavor )  ;", "}    catch    ( ClassNotFoundExcep   e )     {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["buildDataFlavor"], "fileName": "com.intellij.codeInsight.editorActions.HtmlCopyPastePreProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DefaultStyledDocument   document    =    new   DefaultStyledDocument (  )  ;", "try    {", "new   RTFEditorKit (  )  . read ( stream ,    document ,     0  )  ;", "final   StringWriter   writer    =    new   StringWriter (  )  ;", "new   HTMLEditorKit (  )  . write ( writer ,    document ,     0  ,    document . getLength (  )  )  ;", "return   writer . toString (  )  ;", "}    catch    ( IOException    |    BadLocationException   e )     {", ". LOG . error ( e )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["convertFromRtfStream"], "fileName": "com.intellij.codeInsight.editorActions.HtmlCopyPastePreProcessor"}, {"methodBody": ["METHOD_START", "{", "CodeInsightTestUtil . doWordSelectionTestOnDirectory ( myFixture ,    getTestName ( true )  ,     \" html \"  )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.codeInsight.editorActions.HtmlSelectWordTest"}, {"methodBody": ["METHOD_START", "{", "WebEditorOptions . getInstance (  )  . setSelectWholeCssIdentifierOnDoubleClick ( true )  ;", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testSelectClassNames"], "fileName": "com.intellij.codeInsight.editorActions.HtmlSelectWordTest"}, {"methodBody": ["METHOD_START", "{", "WebEditorOptions . getInstance (  )  . setSelectWholeCssIdentifierOnDoubleClick ( false )  ;", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testSelectClassNamesWithDisabledSelectSelectorOption"], "fileName": "com.intellij.codeInsight.editorActions.HtmlSelectWordTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testSelectTag"], "fileName": "com.intellij.codeInsight.editorActions.HtmlSelectWordTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlAttribute   attribute    =    PsiTreeUtil . getParentOfType ( e ,    XmlAttribute . class )  ;", "if    ( attribute    !  =    null )     {", "result . add ( attribute . getTextRange (  )  )  ;", "final   XmlAttributeValue   value    =    attribute . getValueElement (  )  ;", "if    ( value    !  =    null )     {", "if    ( getClassAttributeName (  )  . equalsIgnoreCase ( attribute . getName (  )  )  )     {", ". addClassAttributeRanges ( result ,    editor ,    cursorOffset ,    editorText ,    value )  ;", "}", "final   TextRange   range    =    value . getTextRange (  )  ;", "result . add ( range )  ;", "if    (  (  ( value . getFirstChild (  )  )     !  =    null )     &  &     (  ( value . getFirstChild (  )  . getNode (  )  . getElementType (  )  )     =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ START _ DELIMITER )  )  )     {", "result . add ( new   TextRange (  (  ( range . getStartOffset (  )  )     +     1  )  ,     (  ( range . getEndOffset (  )  )     -     1  )  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["addAttributeSelection"], "fileName": "com.intellij.codeInsight.editorActions.HtmlSelectioner"}, {"methodBody": ["METHOD_START", "{", "final   TextRange   attributeValueTextRange    =    attributeValue . getTextRange (  )  ;", "final   LinkedList < TextRange >    wordRanges    =    ContainerUtil . newLinkedList (  )  ;", "SelectWordUtil . addWordSelection ( editor . getSettings (  )  . isCamelWords (  )  ,    editorText ,    cursorOffset ,    wordRanges ,     . JAVA _ IDENTIFIER _ AND _ HYPHEN _ CONDITION )  ;", "for    ( TextRange   range    :    wordRanges )     {", "if    ( attributeValueTextRange . contains ( range )  )     {", "result . add ( range )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addClassAttributeRanges"], "fileName": "com.intellij.codeInsight.editorActions.HtmlSelectioner"}, {"methodBody": ["METHOD_START", "{", "XmlTag   tag    =    PsiTreeUtil . getParentOfType ( e ,    XmlTag . class ,    true )  ;", "while    ( tag    !  =    null )     {", "result . add ( tag . getTextRange (  )  )  ;", "final   ASTNode   tagStartEnd    =    XmlChildRole . START _ TAG _ END _ FINDER . findChild ( tag . getNode (  )  )  ;", "final   ASTNode   tagEndStart    =    XmlChildRole . CLOSING _ TAG _ START _ FINDER . findChild ( tag . getNode (  )  )  ;", "if    (  ( tagStartEnd    !  =    null )     &  &     ( tagEndStart    !  =    null )  )     {", "result . add ( new   openapi . util . UnfairTextRange ( tagStartEnd . getTextRange (  )  . getEndOffset (  )  ,    tagEndStart . getTextRange (  )  . getStartOffset (  )  )  )  ;", "}", "if    ( tagStartEnd    !  =    null )     {", "result . add ( new   TextRange ( tag . getTextRange (  )  . getStartOffset (  )  ,    tagStartEnd . getTextRange (  )  . getEndOffset (  )  )  )  ;", "}", "if    ( tagEndStart    !  =    null )     {", "result . add ( new   TextRange ( tagEndStart . getTextRange (  )  . getStartOffset (  )  ,    tag . getTextRange (  )  . getEndOffset (  )  )  )  ;", "}", "tag    =    PsiTreeUtil . getParentOfType ( tag ,    XmlTag . class ,    true )  ;", "}", "}", "METHOD_END"], "methodName": ["addTagSelection2"], "fileName": "com.intellij.codeInsight.editorActions.HtmlSelectioner"}, {"methodBody": ["METHOD_START", "{", "if    ( e   instanceof   XmlToken )     {", "return    ( Util . has ( e . getContainingFile (  )  )  )     |  |     ( Util . supportsXmlTypedHandlers ( e . getContainingFile (  )  )  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["canSelectElement"], "fileName": "com.intellij.codeInsight.editorActions.HtmlSelectioner"}, {"methodBody": ["METHOD_START", "{", "return   HtmlUtil . CLASS _ ATTRIBUTE _ NAME ;", "}", "METHOD_END"], "methodName": ["getClassAttributeName"], "fileName": "com.intellij.codeInsight.editorActions.HtmlSelectioner"}, {"methodBody": ["METHOD_START", "{", "AutoPopupController . getInstance ( project )  . autoPopupMemberLookup ( editor ,     (    file )     -  >     {", "int   offset    =    editor . getCaretModel (  )  . getOffset (  )  ;", "PsiElement   lastElement    =    InjectedLanguageUtil . findElementAtNoCommit ( file ,     ( offset    -     1  )  )  ;", "if    ( lastElement   instanceof   PsiFile )     {", "lastElement    =    file . findElementAt (  ( offset    -     1  )  )  ;", "}", "if    (  ( lastElement    =  =    null )     |  |     (  !  ( lastElement . isValid (  )  )  )  )", "return   false ;", "if    ( doCompleteIfNeeded ( offset ,    file ,    lastElement )  )     {", "return   true ;", "}", "FileViewProvider   fileViewProvider    =    file . getViewProvider (  )  ;", "Language   templateDataLanguage ;", "final   PsiElement   parent    =    lastElement . getParent (  )  ;", "if    (  ( fileViewProvider   instanceof   TemplateLanguageFileViewProvider )     &  &     (  ( templateDataLanguage    =     (  ( TemplateLanguageFileViewProvider )     ( fileViewProvider )  )  . getTemplateDataLanguage (  )  )     !  =     ( parent . getLanguage (  )  )  )  )     {", "lastElement    =    fileViewProvider . findElementAt (  ( offset    -     1  )  ,    templateDataLanguage )  ;", "if    (  ( lastElement    =  =    null )     |  |     (  !  ( lastElement . isValid (  )  )  )  )", "return   false ;", "return   doCompleteIfNeeded ( offset ,    file ,    lastElement )  ;", "}", "return   false ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["autoPopupXmlLookup"], "fileName": "com.intellij.codeInsight.editorActions.XmlAutoPopupHandler"}, {"methodBody": ["METHOD_START", "{", "final   Ref < Boolean >    isRelevantLanguage    =    new   Ref (  )  ;", "final   Ref < Boolean >    isAnt    =    new   Ref (  )  ;", "String   text    =    lastElement . getText (  )  ;", "final   int   len    =    offset    -     ( lastElement . getTextRange (  )  . getStartOffset (  )  )  ;", "if    ( len    <     ( text . length (  )  )  )     {", "text    =    text . substring (  0  ,    len )  ;", "}", "if    (  (  (  (  (  ( text . equals (  \"  <  \"  )  )     &  &     (  . isLanguageRelevant ( lastElement ,    file ,    isRelevantLanguage ,    isAnt )  )  )     |  |     (  ( text . equals (  \"     \"  )  )     &  &     (  . isLanguageRelevant ( lastElement ,    file ,    isRelevantLanguage ,    isAnt )  )  )  )     |  |     (  (  ( text . endsWith (  \"  $  {  \"  )  )     &  &     (  . isLanguageRelevant ( lastElement ,    file ,    isRelevantLanguage ,    isAnt )  )  )     &  &     ( isAnt . get (  )  . booleanValue (  )  )  )  )     |  |     (  (  ( text . endsWith (  \"  @  {  \"  )  )     &  &     (  . isLanguageRelevant ( lastElement ,    file ,    isRelevantLanguage ,    isAnt )  )  )     &  &     ( isAnt . get (  )  . booleanValue (  )  )  )  )     |  |     (  ( text . endsWith (  \"  <  /  \"  )  )     &  &     (  . isLanguageRelevant ( lastElement ,    file ,    isRelevantLanguage ,    isAnt )  )  )  )     {", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["doCompleteIfNeeded"], "fileName": "com.intellij.codeInsight.editorActions.XmlAutoPopupHandler"}, {"methodBody": ["METHOD_START", "{", "Boolean   isAntFile    =    isAnt . get (  )  ;", "if    ( isAntFile    =  =    null )     {", "isAntFile    =    XmlUtil . isAntFile ( file )  ;", "isAnt . set ( isAntFile )  ;", "}", "Boolean   result    =    isRelevantLanguage . get (  )  ;", "if    ( result    =  =    null )     {", "Language   language    =    element . getLanguage (  )  ;", "PsiElement   parent    =    element . getParent (  )  ;", "if    (  ( element   instanceof   PsiWhiteSpace )     &  &     ( parent    !  =    null )  )     {", "language    =    parent . getLanguage (  )  ;", "}", "result    =     (  ( language   instanceof   XMLLanguage )     |  |     ( HtmlUtil . supportsXmlTypeds ( file )  )  )     |  |     ( isAntFile . booleanValue (  )  )  ;", "isRelevantLanguage . set ( result )  ;", "}", "return   result . booleanValue (  )  ;", "}", "METHOD_END"], "methodName": ["isLanguageRelevant"], "fileName": "com.intellij.codeInsight.editorActions.XmlAutoPopupHandler"}, {"methodBody": ["METHOD_START", "{", "ASTNode   astNode    =    XmlCopyPastePreProcessor . ENCODE _ EACH _ SYMBOL _ POLICY . encodeXmlTextContents ( text ,    element )  ;", "return   astNode . getTreeParent (  )  . getText (  )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "com.intellij.codeInsight.editorActions.XmlCopyPastePreProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( HtmlUtil . hasHtml ( file )  )     |  |     ( HtmlUtil . supportsXmlTypedHandlers ( file )  )  )     {", "return    . getQuoteStyleForFile ( file )  . quote ;", "}", "return    \"  \\  \"  \"  ;", "}", "METHOD_END"], "methodName": ["getAttributeQuote"], "fileName": "com.intellij.codeInsight.editorActions.XmlEditUtil"}, {"methodBody": ["METHOD_START", "{", "return   CodeStyle . getSettings ( file )  . getCustomSettings ( HtmlCodeStyleSettings . class )  . HTML _ QUOTE _ STYLE ;", "}", "METHOD_END"], "methodName": ["getQuoteStyleForFile"], "fileName": "com.intellij.codeInsight.editorActions.XmlEditUtil"}, {"methodBody": ["METHOD_START", "{", "PsiElement   context    =    file . getContext (  )  ;", "CodeStyleSettings . QuoteStyle   style    =     . getQuoteStyleForFile ( file )  ;", "if    (  (  ( context    !  =    null )     &  &     (  !  ( style . quote . isEmpty (  )  )  )  )     &  &     ( context . getText (  )  . startsWith ( style . quote )  )  )     {", "return   style    =  =     ( QuoteStyle . Double )     ?    QuoteStyle . Single    :    QuoteStyle . Double ;", "}", "return   style ;", "}", "METHOD_END"], "methodName": ["quoteStyle"], "fileName": "com.intellij.codeInsight.editorActions.XmlEditUtil"}, {"methodBody": ["METHOD_START", "{", "int   newOffset    =     ( editor . getCaretModel (  )  . getOffset (  )  )     -     ( typed    ?     2     :     1  )  ;", "if    ( newOffset    <     0  )", "return   null ;", "PsiElement   at    =    file . findElementAt ( newOffset )  ;", "return   at    !  =    null    ?    at . getParent (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getAttributeCandidate"], "fileName": "com.intellij.codeInsight.editorActions.XmlEqTypedHandler"}, {"methodBody": ["METHOD_START", "{", "return   XmlEditUtil . getAttributeQuote ( file )  ;", "}", "METHOD_END"], "methodName": ["getDefaultQuote"], "fileName": "com.intellij.codeInsight.editorActions.XmlEqTypedHandler"}, {"methodBody": ["METHOD_START", "{", "PsiElement   atParent    =    XmlEqTypedHandler . getAttributeCandidate ( editor ,    file ,    true )  ;", "XmlAttributeDescriptor   descriptor    =     ( atParent   instanceof   XmlAttribute )     ?     (  ( XmlAttribute )     ( atParent )  )  . getDescriptor (  )     :    null ;", "return   XmlExtension . getExtension ( file )  . getAttributeValuePresentation ( descriptor ,    quote )  ;", "}", "METHOD_END"], "methodName": ["getValuePresentation"], "fileName": "com.intellij.codeInsight.editorActions.XmlEqTypedHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( fileContext    !  =    null )     {", "if    ( fileContext . getText (  )  . startsWith (  \"  \\  \"  \"  )  )", "return    \"  '  '  \"  ;", "if    ( fileContext . getText (  )  . startsWith (  \"  \\  '  \"  )  )", "return    \"  \\  \"  \\  \"  \"  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["tryCompleteQuotes"], "fileName": "com.intellij.codeInsight.editorActions.XmlEqTypedHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( editedFile    =  =    null )", "return   false ;", "if    (  ( editedFile . getLanguage (  )  )    instanceof   XMLLanguage )     {", "return   true ;", "}", "if    ( HtmlUtil . supportsXmls ( editedFile )  )     {", "return   true ;", "}", "final   FileViewProvider   provider    =    editedFile . getViewProvider (  )  ;", "if    (  ( provider . getBaseLanguage (  )  )    instanceof   XMLLanguage )     {", "return   true ;", "}", "return    ( provider   instanceof   TemplateLanguageFileViewProvider )     &  &     (  (  (  ( TemplateLanguageFileViewProvider )     ( provider )  )  . getTemplateDataLanguage (  )  )    instanceof   XMLLanguage )  ;", "}", "METHOD_END"], "methodName": ["fileContainsXmlLanguage"], "fileName": "com.intellij.codeInsight.editorActions.XmlGtTypedHandler"}, {"methodBody": ["METHOD_START", "{", "Project   project    =    editor . getProject (  )  ;", "if    ( project    !  =    null )     {", "PsiDocumentManager   documentManager    =    PsiDocumentManager . getInstance ( project )  ;", "Document   document    =    editor . getDocument (  )  ;", "documentManager . commitDocument ( document )  ;", "int   lineOffset    =    document . getLineStartOffset ( document . getLineNumber ( editor . getCaretModel (  )  . getOffset (  )  )  )  ;", "CodeStyleManager . getInstance ( project )  . adjustLineIndent ( document ,    lineOffset )  ;", "}", "}", "METHOD_END"], "methodName": ["autoIndent"], "fileName": "com.intellij.codeInsight.editorActions.XmlSlashTypedHandler"}, {"methodBody": ["METHOD_START", "{", "String   name    =    tag . getName (  )  ;", "while    ( tag    !  =    null )     {", "if    (  (  (  ( XmlUtil . getTokenOf ( tag ,    XmlToken . XML _ EMPTY _ ELEMENT _ END )  )     =  =    null )     &  &     (  ( XmlTagUtil . getEndTagNameElement ( tag )  )     =  =    null )  )     &  &     ( name . equals ( tag . getName (  )  )  )  )     {", "return   true ;", "}", "tag    =    tag . getParentTag (  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasUnclosedParent"], "fileName": "com.intellij.codeInsight.editorActions.XmlSlashTypedHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( tag 1     =  =    null )     |  |     ( tag 1     =  =    tag )  )     |  |     (  ( tag 1  . getTextOffset (  )  )     <  =     ( tag . getTextOffset (  )  )  )  )", "return   false ;", "if    (  . hasUnclosedParent ( tag 1  )  )", "return   true ;", "if    (  ( XmlUtil . getTokenOfType ( tag 1  ,    XmlTokenType . XML _ EMPTY _ ELEMENT _ END )  )     !  =    null )", "return   false ;", "XmlToken   element    =    XmlTagUtil . getEndTagNameElement ( tag 1  )  ;", "return    ( element    !  =    null )     &  &     (  ( element . getTextOffset (  )  )     >    offset )  ;", "}", "METHOD_END"], "methodName": ["shouldReplace"], "fileName": "com.intellij.codeInsight.editorActions.XmlSlashTypedHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( WebEditorOptions . getInstance (  )  . isSyncTagEditing (  )  )  )     |  |     ( document    =  =    null )  )", "return    . TagNameSynchronizer . EMPTY ;", "final   Editor [  ]    editors    =    EditorFactory . getInstance (  )  . getEditors ( document )  ;", "return   ContainerUtil . mapNotNull ( editors ,     (    editor )     -  >    editor . getUserData (  . SYNCHRONIZER _ KEY )  ,     . TagNameSynchronizer . EMPTY )  ;", "}", "METHOD_END"], "methodName": ["findSynchronizers"], "fileName": "com.intellij.codeInsight.editorActions.XmlTagNameSynchronizer"}, {"methodBody": ["METHOD_START", "{", "final   PsiFile   psiFile    =     (  ( file    !  =    null )     &  &     ( file . isValid (  )  )  )     ?    PsiManager . getInstance ( project )  . findFile ( file )     :    null ;", "if    ( psiFile    !  =    null )     {", "for    ( Language   language    :    psiFile . getViewProvider (  )  . getLanguages (  )  )     {", "if    (  (  (  ( ContainerUtil . find (  . SUPPORTED _ LANGUAGES ,    language :  : isKindOf )  )     !  =    null )     |  |     ( HtmlUtil . supportsXmlTypedHandlers ( psiFile )  )  )     &  &     (  !  ( language   instanceof   TemplateLanguage )  )  )     {", "return   language ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findXmlLikeLanguage"], "fileName": "com.intellij.codeInsight.editorActions.XmlTagNameSynchronizer"}, {"methodBody": ["METHOD_START", "{", "final   Project   project    =    editor . getProject (  )  ;", "if    ( project    =  =    null )", "return ;", "final   Document   document    =    editor . getDocument (  )  ;", "final   VirtualFile   file    =    myFileDocumentManager . getFile ( document )  ;", "final   Language   language    =     . findXmlLikeLanguage ( project ,    file )  ;", "if    ( language    !  =    null )", "new    . TagNameSynchronizer ( editor ,    project ,    language )  ;", "}", "METHOD_END"], "methodName": ["installSynchronizer"], "fileName": "com.intellij.codeInsight.editorActions.XmlTagNameSynchronizer"}, {"methodBody": ["METHOD_START", "{", "PsiElement   first    =    null ;", "PsiElement   last    =    null ;", "for    ( PsiElement   child    :    children )     {", "if    ( child   instanceof   XmlToken )     {", "XmlToken   token    =     (  ( XmlToken )     ( child )  )  ;", "if    (  ( token . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ TAG _ END )  )     {", "first    =    token . getNextSibling (  )  ;", "}", "if    (  ( token . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ END _ TAG _ START )  )     {", "last    =    token . getPrevSibling (  )  ;", "break ;", "}", "}", "}", "if    (  ( first    !  =    null )     &  &     ( last    !  =    null )  )     {", "result . addAll ( expandToWholeLine ( Text ,    new   TextRange ( first . getTextRange (  )  . getStartOffset (  )  ,    last . getTextRange (  )  . getEndOffset (  )  )  ,    false )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addTagContentSelection"], "fileName": "com.intellij.codeInsight.editorActions.XmlTagSelectioner"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( token . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ DATA _ CHARACTERS )  )     &  &     (  ( token . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ START _ TAG _ START )  )  )     &  &     (  ( token . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ END _ TAG _ START )  )  )     &  &     (  ( token . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ EMPTY _ ELEMENT _ END )  )  )     &  &     (  ( token . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ TAG _ END )  )  ;", "}", "METHOD_END"], "methodName": ["shouldSelectToken"], "fileName": "com.intellij.codeInsight.editorActions.XmlTokenSelectioner"}, {"methodBody": ["METHOD_START", "{", "doTestFromLeftToRight (  \"  < tag   a 1  < caret >  =  \\  ' v 1  \\  '    a 2  =  \\  \" v 2  \\  \"  /  >  \"  ,     \"  < tag   a 2  =  \\  \" v 2  \\  \"    a 1  < caret >  =  \\  ' v 1  \\  '  /  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testMoveAttributes"], "fileName": "com.intellij.codeInsight.editorActions.moveLeftRight.XmlMoveLeftRightTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlText   text    =    PsiTreeUtil . getParentOfType ( movedStartElement ,    XmlText . class )  ;", "final   XmlText   text 2     =    PsiTreeUtil . getParentOfType ( movedEndElement ,    XmlText . class )  ;", "if    (  (  ( text    !  =    null )     &  &     (  ( InjectedLanguageManager . getInstance ( text . getProject (  )  )  . getInjectedPsiFiles ( text )  )     !  =    null )  )     |  |     (  ( text 2     !  =    null )     &  &     (  ( InjectedLanguageManager . getInstance ( text 2  . getProject (  )  )  . getInjectedPsiFiles ( text 2  )  )     !  =    null )  )  )     {", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["checkInjections"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMover"}, {"methodBody": ["METHOD_START", "{", "return   XmlMover . getMeaningfulElementAtOffset ( file ,    offset ,    forward ,     (    t )     -  >    sourceElement   instanceof   XmlAttribute    ?    t   instanceof   XmlAttribute    :    t   instanceof   XmlTag )  ;", "}", "METHOD_END"], "methodName": ["getDestinationElement"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMover"}, {"methodBody": ["METHOD_START", "{", "PsiElement   element    =    file . findElementAt ( offset )  ;", "if    ( element   instanceof   PsiWhiteSpace )     {", "element    =     ( forward )     ?    PsiTreeUtil . nextLeaf ( element )     :    PsiTreeUtil . prevLeaf ( element )  ;", "}", "return   ObjectUtils . tryCast ( PsiTreeUtil . findFirstParent ( element ,    false ,    condi )  ,    XmlElement . class )  ;", "}", "METHOD_END"], "methodName": ["getMeaningfulElementAtOffset"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMover"}, {"methodBody": ["METHOD_START", "{", "return   XmlMover . getMeaningfulElementAtOffset ( file ,    offset ,    forward ,     (    t )     -  >     ( t   instanceof   XmlTag )     |  |     ( t   instanceof   XmlAttribute )  )  ;", "}", "METHOD_END"], "methodName": ["getSourceElement"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMover"}, {"methodBody": ["METHOD_START", "{", "return   parent . getValue (  )  . getTextRange (  )  ;", "}", "METHOD_END"], "methodName": ["getTagContentRange"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMover"}, {"methodBody": ["METHOD_START", "{", "if    (  ( target . getParent (  )  )     =  =    moved )     {", "XmlTag   next    =     ( down )     ?    PsiTreeUtil . getNextSiblingOfType ( moved ,    XmlTag . class )     :    PsiTreeUtil . getPrevSiblingOfType ( moved ,    XmlTag . class )  ;", "if    ( next    =  =    null )", "return   info . prohibitMove (  )  ;", "info . toMove    =    new   LineRange ( moved )  ;", "info . toMove 2     =    new   LineRange ( next )  ;", "return   true ;", "} else", "if    (  ( moved . getParent (  )  )     =  =    target )     {", "return   false ;", "}", "LineRange   targetRange    =    new   LineRange ( target )  ;", "targetRange    =     (  ( XmlChildRole . CLOSING _ TAG _ START _ FINDER . findChild ( target . getNode (  )  )  )     =  =    null )     ?    new   LineRange ( targetRange . startLine ,     (  ( targetRange . endLine )     -     1  )  )     :    targetRange ;", "if    ( targetRange . contains ( info . toMove 2  )  )     {", "XmlElementDescriptor   descriptor    =    moved . getDescriptor (  )  ;", "if    ( descriptor    =  =    null )", "return   false ;", "XmlNSDescriptor   nsDescriptor    =    descriptor . getNSDescriptor (  )  ;", "if    ( nsDescriptor    =  =    null )", "return   false ;", "XmlFile   descriptorFile    =    nsDescriptor . getDescriptorFile (  )  ;", "if    (  ( descriptorFile    =  =    null )     |  |     ( XmlDocumentImpl . isAutoGeneratedSchema ( descriptorFile )  )  )", "return   false ;", "if    (  !  ( TagNameVariantCollector . couldContain ( target ,    moved )  )  )     {", "info . toMove    =    new   LineRange ( moved )  ;", "info . toMove 2     =    targetRange ;", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["moveTags"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMover"}, {"methodBody": ["METHOD_START", "{", "final   int   line    =    document . getLineNumber ( valueStart )  ;", "final   LineRange   to    =    info . to ;", "int   delta    =    line    -     ( to . endLine )  ;", "info . to    =    new   LineRange ( to . startLine ,    Math . max ( line ,    to . endLine )  )  ;", "if    (  ( delta    >     0  )     &  &    down )     {", "final   LineRange   to 2     =    info . to 2  ;", "info . to 2     =    new   LineRange (  (  ( to 2  . startLine )     +    delta )  ,    Math . min (  (  ( to 2  . endLine )     +    delta )  ,     (  ( document . getLineCount (  )  )     -     1  )  )  )  ;", "movedLineStart    =    document . getLineStartOffset ( to . startLine )  ;", "}", "return   movedLineStart ;", "}", "METHOD_END"], "methodName": ["updateMovedRegionEnd"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMover"}, {"methodBody": ["METHOD_START", "{", "final   int   line    =    document . getLineNumber ( offset )  ;", "final   LineRange   to    =    info . to ;", "int   delta    =     ( to . startLine )     -    line ;", "info . to    =    new   LineRange ( Math . min ( line ,    to . startLine )  ,    to . endLine )  ;", "if    (  ( delta    >     0  )     &  &     (  ! down )  )     {", "final   LineRange   to 2     =    info . to 2  ;", "info . to 2     =    new   LineRange (  (  ( to 2  . startLine )     -    delta )  ,     (  ( to 2  . endLine )     -    delta )  )  ;", "movedLineStart    =    document . getLineStartOffset ( to . startLine )  ;", "}", "return   movedLineStart ;", "}", "METHOD_END"], "methodName": ["updateMovedRegionStart"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMover"}, {"methodBody": ["METHOD_START", "{", "if    (  ( offset    +     1  )     <     ( document . getTextLength (  )  )  )     {", "final   int   line    =    document . getLineNumber (  ( offset    +     1  )  )  ;", "final   LineRange   to 2     =    info . to 2  ;", "if    ( to 2     =  =    null )", "return ;", "info . to 2     =    new   LineRange ( to 2  . startLine ,    Math . min ( Math . max ( line ,    to 2  . endLine )  ,     (  ( document . getLineCount (  )  )     -     1  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["updatedMovedIntoEnd"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMover"}, {"methodBody": ["METHOD_START", "{", "final   String   baseName    =     (  ( getBasePath (  )  )     +     '  /  '  )     +     ( getTestName ( true )  )  ;", "final   String   fileName    =     ( baseName    +     \"  .  \"  )     +    ext ;", "@ NonNls", "String   afterFileName    =     ( baseName    +     \"  _ afterUp .  \"  )     +    ext ;", "EHandler   handler    =    new   MoveStatementUpAction (  )  . getHandler (  )  ;", "performAction ( fileName ,    handler ,    afterFileName )  ;", "afterFileName    =     ( baseName    +     \"  _ afterDown .  \"  )     +    ext ;", "handler    =    new   MoveStatementDownAction (  )  . getHandler (  )  ;", "performAction ( fileName ,    handler ,    afterFileName )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "return    \"  / mover \"  ;", "}", "METHOD_END"], "methodName": ["getBasePath"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile ( fileName )  ;", "if    ( handler . isEnabled ( myEditor ,    null )  )     {", "WriteCommand . runWriteCommand ( null ,    new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "handler . execute ( myEditor ,    null )  ;", "}", "}  )  ;", "}", "checkResultByFile (  ( new   File ( getTestDataPath (  )  ,    afterFileName )  . exists (  )     ?    afterFileName    :    fileName )  )  ;", "}", "METHOD_END"], "methodName": ["performAction"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" html \"  )  ;", "}", "METHOD_END"], "methodName": ["test1"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" html \"  )  ;", "}", "METHOD_END"], "methodName": ["testHtmlScript"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" html \"  )  ;", "}", "METHOD_END"], "methodName": ["testHtmlStyle"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" html \"  )  ;", "}", "METHOD_END"], "methodName": ["testHtmlUnclosed"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testMoveTag"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testMoveTag1"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testMoveTagWithEmptyLines"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testMultiLineTag"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testRootTag"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testRootTag1"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testSingleTag"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testTag"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testTag10"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testTag11"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testTag2"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testTag3"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testTag4"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testTag5"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testTag6"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testTag7"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testTag8"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testTag9"], "fileName": "com.intellij.codeInsight.editorActions.moveUpDown.XmlMoverTest"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement [  ]    children    =    element . getChildren (  )  ;", "if    (  ( children . length )     >     0  )     {", "if    (  (  ( children [  0  ]  )    instanceof   XmlToken )     &  &     (  ( XmlTokenType . XML _ END _ TAG _ START )     =  =     (  (  ( XmlToken )     ( children [  0  ]  )  )  . getTokenType (  )  )  )  )     {", "if    ( XmlErrorMessages . message (  \" xml . parsing . c . tag . matches . nothing \"  )  . equals ( element . getErrorDescription (  )  )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["skip"], "fileName": "com.intellij.codeInsight.highlighting.HtmlClosingTagErrorFilter"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( errorDescription . contains (  \" is   not   closed \"  )  )     |  |     ( errorDescription . contains (  \" is   not   completed \"  )  )  )     |  |     ( errorDescription . contains (  \" expected \"  )  )  )     |  |     ( errorDescription . contains (  \" not   terminated \"  )  )  )     |  |     ( errorDescription . contains (  \" Unclosed   string \"  )  )  )     |  |     ( errorDescription . contains (  \" Unexpected   tokens \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isErrorToBeFiltered"], "fileName": "com.intellij.codeInsight.highlighting.InjectedHtmlErrorFilter"}, {"methodBody": ["METHOD_START", "{", "final   PsiFile   containingFile    =    element . getContainingFile (  )  ;", "if    (  (  ( containingFile . getLanguage (  )  )     =  =     ( HTMLLanguage . INSTANCE )  )     &  &     (  ( containingFile . getContext (  )  )     !  =    null )  )     {", "if    (  . isErrorToBeFiltered ( element . getErrorDescription (  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["shouldHighlightErrorElement"], "fileName": "com.intellij.codeInsight.highlighting.InjectedHtmlErrorFilter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( file   instanceof   XmlFile )  )", "return   null ;", "PsiElement   element    =    file . findElementAt ( offset )  ;", "if    ( element    =  =    null )", "return   null ;", "element    =    element . getParent (  )  ;", "while    ( element    !  =    null )     {", "if    ( element   instanceof   XmlTag )     {", "XmlTag   tag    =     (  ( XmlTag )     ( element )  )  ;", "final   PsiElement [  ]    children    =    tag . getChildren (  )  ;", "if    ( offset    <  =     ( children [  0  ]  . getTextRange (  )  . getStartOffset (  )  )  )", "return   null ;", "for    ( PsiElement   child    :    children )     {", "final   TextRange   range    =    child . getTextRange (  )  ;", "if    (  (  ( range . getStartOffset (  )  )     <  =    offset )     &  &     (  ( range . getEndOffset (  )  )     >    offset )  )", "return   tag ;", "if    ( child   instanceof   XmlToken )     {", "XmlToken   token    =     (  ( XmlToken )     ( child )  )  ;", "if    (  ( token . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ TAG _ END )  )", "return   null ;", "}", "}", "return   null ;", "}", "element    =    element . getParent (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findXmlTag"], "fileName": "com.intellij.codeInsight.hint.api.impls.XmlParameterInfoHandler"}, {"methodBody": ["METHOD_START", "{", "final   XmlAttributeDescriptor [  ]    xmlAttributeDescriptors    =    p . getAttributesDescriptors ( null )  ;", "Arrays . sort ( xmlAttributeDescriptors ,     . COMPARATOR )  ;", "return   xmlAttributeDescriptors ;", "}", "METHOD_END"], "methodName": ["getSortedDescriptors"], "fileName": "com.intellij.codeInsight.hint.api.impls.XmlParameterInfoHandler"}, {"methodBody": ["METHOD_START", "{", "final   XmlAttributeDescriptor [  ]    attributes    =     ( descriptor    !  =    null )     ?    XmlParameterInfoHandler . getSortedDescriptors ( descriptor )     :    XmlAttributeDescriptor . EMPTY ;", "StringBuilder   buffer    =    new   StringBuilder (  )  ;", "int   highlightStartOffset    =     -  1  ;", "int   highlightEndOffset    =     -  1  ;", "if    (  ( attributes . length )     =  =     0  )     {", "buffer . append ( CodeInsightBundle . message (  \" xml . tag . info . no . attributes \"  )  )  ;", "} else    {", "StringBuilder   text 1     =    new   StringBuilder (  \"     \"  )  ;", "StringBuilder   text 2     =    new   StringBuilder (  \"     \"  )  ;", "StringBuilder   text 3     =    new   StringBuilder (  \"     \"  )  ;", "for    ( XmlAttributeDescriptor   attribute    :    attributes )     {", "if    ( Boolean . TRUE . equals ( attributePresentFun . fun ( attribute . getName (  )  )  )  )     {", "if    (  !  ( text 1  . toString (  )  . equals (  \"     \"  )  )  )     {", "text 1  . append (  \"  ,     \"  )  ;", "}", "text 1  . append ( attribute . getName (  )  )  ;", "} else", "if    ( attribute . isRequired (  )  )     {", "if    (  !  ( text 2  . toString (  )  . equals (  \"     \"  )  )  )     {", "text 2  . append (  \"  ,     \"  )  ;", "}", "text 2  . append ( attribute . getName (  )  )  ;", "} else    {", "if    (  !  ( text 3  . toString (  )  . equals (  \"     \"  )  )  )     {", "text 3  . append (  \"  ,     \"  )  ;", "}", "text 3  . append ( attribute . getName (  )  )  ;", "}", "}", "if    (  (  !  ( text 1  . toString (  )  . equals (  \"     \"  )  )  )     &  &     (  !  ( text 2  . toString (  )  . equals (  \"     \"  )  )  )  )     {", "text 1  . append (  \"  ,     \"  )  ;", "}", "if    (  (  !  ( text 2  . toString (  )  . equals (  \"     \"  )  )  )     &  &     (  !  ( text 3  . toString (  )  . equals (  \"     \"  )  )  )  )     {", "text 2  . append (  \"  ,     \"  )  ;", "}", "if    (  (  (  !  ( text 1  . toString (  )  . equals (  \"     \"  )  )  )     &  &     (  !  ( text 3  . toString (  )  . equals (  \"     \"  )  )  )  )     &  &     ( text 2  . toString (  )  . equals (  \"     \"  )  )  )     {", "text 1  . append (  \"  ,     \"  )  ;", "}", "buffer . append ( text 1  )  ;", "highlightStartOffset    =    buffer . length (  )  ;", "buffer . append ( text 2  )  ;", "highlightEndOffset    =    buffer . length (  )  ;", "buffer . append ( text 3  )  ;", "}", "context . setupUIComponentPresentation ( buffer . toString (  )  ,    highlightStartOffset ,    highlightEndOffset ,    false ,    false ,    true ,    context . getDefaultParameterColor (  )  )  ;", "}", "METHOD_END"], "methodName": ["updateElementDescriptor"], "fileName": "com.intellij.codeInsight.hint.api.impls.XmlParameterInfoHandler"}, {"methodBody": ["METHOD_START", "{", "String   caption    =    CodeInsightBundle . message (  \" intention . color . chooser . dialog \"  )  ;", "final   XmlAttributeValue   literal    =    PsiTreeUtil . getParentOfType ( element ,    XmlAttributeValue . class ,    false )  ;", "if    ( literal    =  =    null )", "return ;", "final   String   text    =    StringUtil . unquoteString ( literal . getValue (  )  )  ;", "Color   oldColor ;", "try    {", "oldColor    =    Color . decode ( text )  ;", "}    catch    ( NumberFormatException   e )     {", "oldColor    =    JBColor . GRAY ;", "}", "Color   color    =    ColorChooser . chooseColor ( editorComponent ,    caption ,    oldColor ,    true )  ;", "if    ( color    =  =    null )", "return ;", "if    (  !  ( Comparing . equal ( color ,    oldColor )  )  )     {", "if    (  !  ( FileModificationService . getInstance (  )  . preparePsiElementForWrite ( element )  )  )", "return ;", "final   String   newText    =     \"  #  \"     +     ( ColorUtil . toHex ( color )  )  ;", "final   PsiManager   manager    =    literal . getManager (  )  ;", "final   XmlAttribute   newAttribute    =    XmlElementFactory . getInstance ( manager . getProject (  )  )  . createAttribute (  \" name \"  ,    newText ,    element )  ;", "final   Runnable   replaceRunnable    =     (  )     -  >     {", "final   XmlAttributeValue   valueElement    =    newAttribute . getValueElement (  )  ;", "assert   valueElement    !  =    null ;", "literal . replace ( valueElement )  ;", "}  ;", "WriteCommandAction . writeCommandAction ( element . getProject (  )  )  . withName ( caption )  . run (  (  )     -  >     {", "replaceRunnable . run (  )  ;", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["chooseColor"], "fileName": "com.intellij.codeInsight.intentions.XmlChooseColorIntentionAction"}, {"methodBody": ["METHOD_START", "{", "SmartPointerManager   manager    =    SmartPointerManager . getInstance ( project )  ;", "Set < PsiElement >    elements    =    new   gnu . trove . THashSet (  )  ;", "final   List < SmartPsiElementPointer >    list    =    new   ArrayList <  >  ( targets . size (  )  )  ;", "for    ( final   T   target    :    targets )     {", "for    ( final   PsiElement   psiElement    :    converter . fun ( target )  )     {", "if    (  ( elements . add ( psiElement )  )     &  &     ( psiElement . isValid (  )  )  )     {", "list . add ( manager . createSmartPsiElementPointer ( psiElement )  )  ;", "}", "}", "}", "return   list ;", "}", "METHOD_END"], "methodName": ["calcPsiTargets"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "assert    ( myTargets )     !  =    null    :     \" Must   have   called    . setTargets (  )    before   calling   create (  )  \"  ;", "}", "METHOD_END"], "methodName": ["checkBuilt"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "return   NavigationGutterIconBuilder . create ( icon ,    NavigationGutterIconBuilder . DEFAULT _ PSI _ CONVERTOR ,    NavigationGutterIconBuilder . PSI _ GOTO _ RELATED _ ITEM _ PROVIDER )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "return   NavigationGutterIconBuilder . create ( icon ,    converter ,    null )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   NavigationGutterIconBuilder ( icon ,    converter ,    gotoRelatedItemProvider )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( gotoRelatedItemProvider    =  =    null )     {", "return   NotNullLazyValue . createConstantValue ( Collecs . emptyList (  )  )  ;", "}", "if    ( lazy )     {", "return   new   NotNullLazyValue < Collec <  ?    extends   GotoRelatedItem >  >  (  )     {", "@ NotNull", "@ Override", "protected   Collec <  ?    extends   GotoRelatedItem >    compute (  )     {", "return   ContainerUtil . concat ( factory . create (  )  ,    gotoRelatedItemProvider )  ;", "}", "}  ;", "}", "Collec < GotoRelatedItem >    concat    =    ContainerUtil . concat ( factory . create (  )  ,    gotoRelatedItemProvider )  ;", "return   NotNullLazyValue . createConstantValue ( concat )  ;", "}", "METHOD_END"], "methodName": ["createGotoTargetsThunk"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "checkBuilt (  )  ;", "NotNullLazyValue < List < SmartPsiElementPointer >  >    pointers    =     . createPointersThunk ( myLazy ,    project ,     . evaluateAndForget ( myTargets )  ,    myConverter )  ;", "final   boolean   empty    =    isEmpty (  )  ;", "if    (  (  ( myTooltipText )     =  =    null )     &  &     (  !  ( myLazy )  )  )     {", "final   SortedSet < String >    names    =    new   TreeSet <  >  (  )  ;", "for    ( T   t    :    myTargets . getValue (  )  )     {", "final   String   text    =    myNamer . fun ( t )  ;", "if    ( text    !  =    null )     {", "names . add ( MessageFormat . format (  . PATTERN ,    text )  )  ;", "}", "}", "@ NonNls", "StringBuilder   sb    =    new   StringBuilder (  \"  < html >  < body >  \"  )  ;", "if    (  ( myTooltipTitle )     !  =    null )     {", "sb . append ( myTooltipTitle )  . append (  \"  < br >  \"  )  ;", "}", "for    ( String   name    :    names )     {", "sb . append ( name )  . append (  \"  < br >  \"  )  ;", "}", "sb . append (  \"  <  / body >  <  / html >  \"  )  ;", "myTooltipText    =    sb . toString (  )  ;", "}", "Computable < PsiElementListCellRenderer >    renderer    =     (  ( myCellRenderer )     =  =    null )     ?    DefaultPsiElementCellRenderer :  : new    :    myCellRenderer ;", "return   new    . MyNavigationGutterIconRenderer ( this ,    myAlignment ,    myIcon ,    myTooltipText ,    pointers ,    renderer ,    empty )  ;", "}", "METHOD_END"], "methodName": ["createGutterIconRenderer"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "final   NavigationGutterIconBuilder . MyNavigationGutterIconRenderer   renderer    =    createGutterIconRenderer ( element . getProject (  )  )  ;", "final   String   tooltip    =    renderer . getTooltipText (  )  ;", "NotNullLazyValue < Collection <  ?    extends   GotoRelatedItem >  >    gotoTargets    =    getGotoTargets (  )  ;", "return   new   com . intellij . codeInsight . daemon . RelatedItemLineMarkerInfo ( element ,    element . getTextRange (  )  ,    renderer . getIcon (  )  ,    Pass . LINE _ MARKERS ,     ( tooltip    =  =    null    ?    null    :    new   com . intellij . util . ConstantFunction ( tooltip )  )  ,     ( renderer . isNavigateAction (  )     ?    renderer    :    null )  ,    renderer . getAlignment (  )  ,    gotoTargets )  ;", "}", "METHOD_END"], "methodName": ["createLineMarkerInfo"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ! lazy )     {", "return   NotNullLazyValue . createConstantValue (  . calcPsiTargets ( project ,    targets . create (  )  ,    converter )  )  ;", "}", "return   new   NotNullLazyValue < List < SmartPsiElementPointer >  >  (  )     {", "@ Override", "@ NotNull", "public   List < SmartPsiElementPointer >    compute (  )     {", "return    . calcPsiTargets ( project ,    targets . create (  )  ,    converter )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createPointersThunk"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "final   NavigationGutterIconBuilder . MyNavigationGutterIconRenderer   renderer    =    createGutterIconRenderer ( project )  ;", "annotation . setGutterIconRenderer ( renderer )  ;", "annotation . setNeedsUpdateOnTyping ( false )  ;", "return   annotation ;", "}", "METHOD_END"], "methodName": ["doInstall"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "final   Ref < NotNullLazyValue < T >  >    ref    =    Ref . create ( lazyValue )  ;", "return   new   openapi . util . Factory < T >  (  )     {", "volatile   T   result ;", "@ Override", "public   T   create (  )     {", "if    (  ( result )     =  =    null )     {", "result    =    ref . get (  )  . getValue (  )  ;", "ref . set ( null )  ;", "}", "return   result ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["evaluateAndForget"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "return   NavigationGutterIconBuilder . createGotoTargetsThunk ( myLazy ,    myGotoRelatedItemProvider ,    NavigationGutterIconBuilder . evaluateAndForget ( myTargets )  )  ;", "}", "METHOD_END"], "methodName": ["getGotoTargets"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  !  ( myLazy )  )     &  &     ( myTargets . getValue (  )  . isEmpty (  )  )  )     |  |     ( element    =  =    null )  )", "return   null ;", "return   doInstall ( holder . createInfoAnnot ( element ,    null )  ,    element . getProject (  )  )  ;", "}", "METHOD_END"], "methodName": ["install"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  !  ( myLazy )  )     &  &     ( myTargets . getValue (  )  . isEmpty (  )  )  )     |  |     ( element    =  =    null )  )", "return   null ;", "return   doInstall ( holder . createAnnot ( element ,    INFORMATION ,    null )  ,    element . getManager (  )  . getProject (  )  )  ;", "}", "METHOD_END"], "methodName": ["install"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( myLazy )     {", "return   false ;", "}", "Set < PsiElement >    elements    =    new   gnu . trove . THashSet (  )  ;", "Collec <  ?    extends   T >    targets    =    myTargets . getValue (  )  ;", "for    ( final   T   target    :    targets )     {", "for    ( final   PsiElement   psiElement    :    myConverter . fun ( target )  )     {", "if    ( elements . add ( psiElement )  )     {", "return   false ;", "}", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "myAlignment    =    alignment ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setAlignment"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "myCellRenderer    =    new   Computable . PredefinedValueComputable <  >  ( cellRenderer )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setCellRenderer"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "myEmptyText    =    emptyText ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setEmptyPopupText"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "myNamer    =    namer ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setNamer"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "myPopupTitle    =    popupTitle ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setPopupTitle"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "return   setTargets ( ContainerUtil . createMaybeSingletonList ( target )  )  ;", "}", "METHOD_END"], "methodName": ["setTarget"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "return   setTargets ( Arrays . asList ( targets )  )  ;", "}", "METHOD_END"], "methodName": ["setTargets"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "myTargets    =     (  ( NotNullLazyValue )     ( targets )  )  ;", "myLazy    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTargets"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "myTargets    =    NotNullLazyValue . createConstantValue (  (  ( Collection < T >  )     ( targets )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTargets"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "myTooltipText    =    tooltipText ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTooltipText"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "myTooltipTitle    =    tooltipTitle ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTooltipTitle"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    o )", "return   true ;", "if    (  ( o    =  =    null )     |  |     (  ( getClass (  )  )     !  =     ( o . getClass (  )  )  )  )", "return   false ;", "final      renderer    =     (  (  )     ( o )  )  ;", "if    (  ( myEmptyText )     !  =    null    ?     !  ( myEmptyText . equals ( renderer . myEmptyText )  )     :     ( renderer . myEmptyText )     !  =    null )", "return   false ;", "if    (  !  ( myPointers . getValue (  )  . equals ( renderer . myPointers . getValue (  )  )  )  )", "return   false ;", "if    (  ( myPopupTitle )     !  =    null    ?     !  ( myPopupTitle . equals ( renderer . myPopupTitle )  )     :     ( renderer . myPopupTitle )     !  =    null )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconRenderer"}, {"methodBody": ["METHOD_START", "{", "return   ContainerUtil . mapNotNull ( myPointers . getValue (  )  ,     (  ( NullableFunction < SmartPsiElementPointer ,    PsiElement >  )     (  (    smartPsiElementPointer )     -  >    smartPsiElementPointer . getElement (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getTargetElements"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconRenderer"}, {"methodBody": ["METHOD_START", "{", "int   result ;", "result    =     (  ( myPopupTitle )     !  =    null )     ?    myPopupTitle . hashCode (  )     :     0  ;", "result    =     (  3  1     *    result )     +     (  ( myEmptyText )     !  =    null    ?    myEmptyText . hashCode (  )     :     0  )  ;", "result    =     (  3  1     *    result )     +     ( myPors . getValue (  )  . hashCode (  )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.intellij.codeInsight.navigation.NavigationGutterIconRenderer"}, {"methodBody": ["METHOD_START", "{", "PsiElement   parent    =     ( element   instanceof   XmlFile )     ?    element    :    element . getParent (  )  ;", "if    ( parent    !  =    null )     {", "PsiElement [  ]    children    =    parent . getChildren (  )  ;", "for    ( PsiElement   child    :    children )     {", "if    ( child   instanceof   XmlTag )     {", "array . add ( child )  ;", "}", "}", "}", "final   PsiElement   parentElement    =    element . getParent (  )  ;", "if    ( parentElement    !  =    null )     {", ". addNavigationElements ( array ,    parentElement )  ;", "}", "}", "METHOD_END"], "methodName": ["addNavigationElements"], "fileName": "com.intellij.codeInsight.navigation.XmlMethodNavigationOffsetProvider"}, {"methodBody": ["METHOD_START", "{", "return    ( language . isKindOf ( HTMLLanguage . INSTANCE )  )     |  |     ( language . isKindOf ( XHTMLLanguage . INSTANCE )  )  ;", "}", "METHOD_END"], "methodName": ["isMyLanguage"], "fileName": "com.intellij.codeInsight.template.HtmlContextType"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( PsiTreeUtil . getParentOfType ( element ,    XmlComment . class )  )     !  =    null )     &  &     (  ( element . getNode (  )  . getElementType (  )  )     !  =     ( XmlTokenType . XML _ COMMENT _ START )  )  )     {", "return   false ;", "}", "if    (  ( PsiTreeUtil . getParentOfType ( element ,    X . class )  )     !  =    null )     {", "return   true ;", "}", "if    (  ( element . getNode (  )  . getElementType (  )  )     =  =     ( XmlTokenType . XML _ START _ TAG _ START )  )     {", "return   true ;", "}", "PsiElement   parent    =    element . getParent (  )  ;", "if    ( parent   instanceof   PsiErrorElement )     {", "parent    =    parent . getParent (  )  ;", "}", "return   parent   instanceof   XmlDocument ;", "}", "METHOD_END"], "methodName": ["isInContext"], "fileName": "com.intellij.codeInsight.template.HtmlTextContextType"}, {"methodBody": ["METHOD_START", "{", "Language   languageAtOffset    =    PsiUtilCore . getLanguageAtOffset ( file ,    offset )  ;", "return    !  (  ( languageAtOffset . isKindOf ( XMLLanguage . INSTANCE )  )     |  |     ( languageAtOffset   instanceof   XMLLanguage )  )  ;", "}", "METHOD_END"], "methodName": ["isEmbeddedContent"], "fileName": "com.intellij.codeInsight.template.XmlContextType"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( file . getLanguage (  )  . isKindOf ( XMLLanguage . INSTANCE )  )     &  &     (  !  ( XmlContextType . isEmbeddedContent ( file ,    offset )  )  )  )     &  &     (  !  ( HtmlContextType . isMyLanguage ( PsiUtilCore . getLanguageAtOffset ( file ,    offset )  )  )  )  )     &  &     (  ( file . getFileType (  )  )     !  =     ( StdFileTypes . JSPX )  )  )     &  &     (  ( file . getFileType (  )  )     !  =     ( StdFileTypes . JSP )  )  ;", "}", "METHOD_END"], "methodName": ["isInXml"], "fileName": "com.intellij.codeInsight.template.XmlContextType"}, {"methodBody": ["METHOD_START", "{", "return    (  ( file    !  =    null )     &  &     (  ( file . getFileType (  )  )     =  =     ( StdFileTypes . XML )  )  )     &  &     (  ( FileUtilRt . extensionEquals ( file . getName (  )  ,     \" xsl \"  )  )     |  |     ( FileUtilRt . extensionEquals ( file . getName (  )  ,     \" xslt \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isXslOrXsltFile"], "fileName": "com.intellij.codeInsight.template.XslTextContextType"}, {"methodBody": ["METHOD_START", "{", "return   myTemplate ;", "}", "METHOD_END"], "methodName": ["getGeneratedTemplate"], "fileName": "com.intellij.codeInsight.template.emmet.CollectCustomTemplateCallback"}, {"methodBody": ["METHOD_START", "{", "return    !  ( callback . getEditor (  )  . isDisposed (  )  )  ;", "}", "METHOD_END"], "methodName": ["isValid"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetAbbreviationBalloon"}, {"methodBody": ["METHOD_START", "{", "EmmetAbbreviationBalloon . ourTestingAbbreviation    =    testingAbbreviation ;", "Disposer . register ( parentDisposable ,    new   Disposable (  )     {", "@ Override", "public   void   dispose (  )     {", "EmmetAbbreviationBalloon . ourTestingAbbreviation    =    null ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["setTestingAbbreviation"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetAbbreviationBalloon"}, {"methodBody": ["METHOD_START", "{", "if    ( ApplicationManager . getApplication (  )  . isUnitTestMode (  )  )     {", "if    (  (  . ourTestingAbbreviation )     =  =    null )     {", "throw   new   RuntimeException (  \" Testing   abbreviation   is   not   set .    See    # setTestingAbbreviation \"  )  ;", "}", "myCallback . onEnter (  . ourTestingAbbreviation )  ;", "return ;", "}", "JPanel   panel    =    new   JPanel ( new   BorderLayout (  )  )  ;", "final   TextFieldWithStoredHistory   field    =    new   TextFieldWithStoredHistory ( myAbbreviationsHistoryKey )  ;", "final   Dimension   fieldPreferredSize    =    field . getPreferredSize (  )  ;", "field . setPreferredSize ( new   Dimension ( Math . max (  2  2  0  ,    fieldPreferredSize . width )  ,    fieldPreferredSize . height )  )  ;", "field . setHistorySize (  1  0  )  ;", "ContextHelpLabel   label    =    myContextHelp . createHelpLabel (  )  ;", "label . setBorder ( Borders . empty (  0  ,     3  ,     0  ,     1  )  )  ;", "panel . add ( field ,    BorderLayout . CENTER )  ;", "panel . add ( label ,    BorderLayout . EAST )  ;", "final   JBPopupFactory   popupFactory    =    JBPopupFactory . getInstance (  )  ;", "final   BalloonImpl   balloon    =     (  ( BalloonImpl )     ( popupFactory . createBalloonBuilder ( panel )  . setCloseButtonEnabled ( false )  . setBlockClicksThroughBalloon ( true )  . setAnimationCycle (  0  )  . setHideOnKeyOutside ( true )  . setHideOnClickOutside ( true )  . setFillColor ( panel . getBackground (  )  )  . createBalloon (  )  )  )  ;", "final   DocumentAdapter   documentListener    =    new   DocumentAdapter (  )     {", "@ Override", "protected   void   textChanged ( DocumentEvent   e )     {", "if    (  !  (  . isValid ( customTemplateCallback )  )  )     {", "balloon . hide (  )  ;", "return ;", "}", ". validateTemplateKey ( field ,    balloon ,    field . getText (  )  ,    customTemplateCallback )  ;", "}", "}  ;", "field . addDocumentListener ( documentListener )  ;", "final   KeyAdapter   keyListener    =    new   KeyAdapter (  )     {", "@ Override", "public   void   keyPressed (  @ NotNull", "KeyEvent   e )     {", "if    (  !  ( field . isPopupVisible (  )  )  )     {", "if    (  !  (  . isValid ( customTemplateCallback )  )  )     {", "balloon . hide (  )  ;", "return ;", "}", "switch    ( e . getKeyCode (  )  )     {", "case   KeyEvent . VK _ ENTER    :", "final   String   abbreviation    =    field . getText (  )  ;", "if    (  . validateTemplateKey ( field ,    balloon ,    abbreviation ,    customTemplateCallback )  )     {", "myCallback . onEnter ( abbreviation )  ;", "PropertiesComponent . getInstance (  )  . setValue ( myLastAbbreviationKey ,    abbreviation )  ;", "field . addCurrentTextToHistory (  )  ;", "balloon . hide (  )  ;", "}", "break ;", "case   KeyEvent . VK _ ESCAPE    :", "balloon . hide ( false )  ;", "break ;", "}", "}", "}", "}  ;", "field . addKeyboardListener ( keyListener )  ;", "balloon . addListener ( new   JBPopupListener . Adapter (  )     {", "@ Override", "public   void   beforeShown ( LightweightWindowEvent   event )     {", "field . setText ( PropertiesComponent . getInstance (  )  . getValue ( myLastAbbreviationKey ,     \"  \"  )  )  ;", "}", "@ Override", "public   void   onClosed ( LightweightWindowEvent   event )     {", "field . removeKeyListener ( keyListener )  ;", "field . removeDocumentListener ( documentListener )  ;", "super . onClosed ( event )  ;", "}", "}  )  ;", "balloon . show ( popupFactory . guessBestPopupLocation ( customTemplateCallback . getEditor (  )  )  ,    below )  ;", "final   IdeFocusManager   focusManager    =    IdeFocusManager . getInstance ( customTemplateCallback . getProject (  )  )  ;", "focusManager . doWhenFocusSettlesDown (  (  )     -  >     {", "focusManager . requestFocus ( field ,    true )  ;", "field . selectText (  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["show"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetAbbreviationBalloon"}, {"methodBody": ["METHOD_START", "{", "final   boolean   correct    =    ZenCodingTemplate . checkTemplateKey ( abbreviation ,    callback )  ;", "field . getTextEditor (  )  . setBackground (  ( correct    ?    LightColors . SLIGHTLY _ GREEN    :    LightColors . RED )  )  ;", "if    (  ( balloon    !  =    null )     &  &     (  !  ( balloon . isDisposed (  )  )  )  )     {", "balloon . revalidate (  )  ;", "}", "return   correct ;", "}", "METHOD_END"], "methodName": ["validateTemplateKey"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetAbbreviationBalloon"}, {"methodBody": ["METHOD_START", "{", "text    +  =    ZenCodingTemplate . MARKER ;", "final   List < ZenCodingToken >    result    =    new   ArrayList <  >  (  )  ;", "boolean   inQuotes    =    false ;", "boolean   inApostrophes    =    false ;", "int   bracesStack    =     0  ;", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <     ( text . length (  )  )  ;    i +  +  )     {", "final   char   c    =    text . charAt ( i )  ;", "if    ( inQuotes )     {", "builder . append ( c )  ;", "if    ( c    =  =     '  \"  '  )     {", "inQuotes    =    false ;", "result . add ( new   StringLiteralToken ( builder . toString (  )  )  )  ;", "builder    =    new   StringBuilder (  )  ;", "}", "continue ;", "}", "if    ( inApostrophes )     {", "builder . append ( c )  ;", "if    ( c    =  =     '  \\  '  '  )     {", "inApostrophes    =    false ;", "result . add ( new   StringLiteralToken ( builder . toString (  )  )  )  ;", "builder    =    new   StringBuilder (  )  ;", "}", "continue ;", "}", "if    ( bracesStack    >     0  )     {", "builder . append ( c )  ;", "if    ( c    =  =     '  }  '  )     {", "bracesStack -  -  ;", "if    ( bracesStack    =  =     0  )     {", "result . add ( new   TextToken ( builder . toString (  )  )  )  ;", "builder    =    new   StringBuilder (  )  ;", "}", "} else", "if    ( c    =  =     '  {  '  )     {", "bracesStack +  +  ;", "}", "continue ;", "}", "if    (  ( EmmetLexer . DELIMS . indexOf ( c )  )     <     0  )     {", "builder . append ( c )  ;", "} else    {", "if    (  ( c    =  =     '  +  '  )     &  &     (  ( i    =  =     (  ( text . length (  )  )     -     2  )  )     |  |     (  ( text . charAt (  ( i    +     1  )  )  )     =  =     '  )  '  )  )  )     {", "builder . append ( c )  ;", "continue ;", "}", "if    (  ( builder . length (  )  )     >     0  )     {", "final   String   tokenText    =    builder . toString (  )  ;", "final   int   n    =    StringUtil . parseInt ( tokenText ,     (  -  1  )  )  ;", "if    (  (  !  ( StringUtil . startsWithChar ( tokenText ,     '  0  '  )  )  )     &  &     ( n    >  =     0  )  )     {", "result . add ( new   NumberToken ( n )  )  ;", "} else    {", "result . add ( new   IdentifierToken ( tokenText )  )  ;", "}", "builder    =    new   StringBuilder (  )  ;", "}", "if    ( c    =  =     '  \"  '  )     {", "inQuotes    =    true ;", "builder . append ( c )  ;", "} else", "if    ( c    =  =     '  \\  '  '  )     {", "inApostrophes    =    true ;", "builder . append ( c )  ;", "} else", "if    ( c    =  =     '  {  '  )     {", "bracesStack    =     1  ;", "builder . append ( c )  ;", "} else", "if    ( c    =  =     '  (  '  )     {", "result . add ( tokens . ZenCodingTokens . OPENING _ R _ BRACKET )  ;", "} else", "if    ( c    =  =     '  )  '  )     {", "result . add ( tokens . ZenCodingTokens . CLOSING _ R _ BRACKET )  ;", "} else", "if    ( c    =  =     '  [  '  )     {", "result . add ( tokens . ZenCodingTokens . OPENING _ SQ _ BRACKET )  ;", "} else", "if    ( c    =  =     '  ]  '  )     {", "result . add ( tokens . ZenCodingTokens . CLOSING _ SQ _ BRACKET )  ;", "} else", "if    ( c    =  =     '  =  '  )     {", "result . add ( tokens . ZenCodingTokens . EQ )  ;", "} else", "if    ( c    =  =     '  .  '  )     {", "result . add ( tokens . ZenCodingTokens . DOT )  ;", "} else", "if    ( c    =  =     '  #  '  )     {", "result . add ( tokens . ZenCodingTokens . SHARP )  ;", "} else", "if    ( c    =  =     '  ,  '  )     {", "result . add ( tokens . ZenCodingTokens . COMMA )  ;", "} else", "if    ( c    =  =     '     '  )     {", "result . add ( tokens . ZenCodingTokens . SPACE )  ;", "} else", "if    ( c    =  =     '  |  '  )     {", "result . add ( tokens . ZenCodingTokens . PIPE )  ;", "} else", "if    ( c    !  =     ( ZenCodingTemplate . MARKER )  )     {", "result . add ( new   tokens . OperationToken ( c )  )  ;", "}", "}", "}", "if    (  (  ( bracesStack    !  =     0  )     |  |    inQuotes )     |  |    inApostrophes )     {", "return   null ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["lex"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetLexer"}, {"methodBody": ["METHOD_START", "{", "return    ( myIndex )  +  +  ;", "}", "METHOD_END"], "methodName": ["advance"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetParser"}, {"methodBody": ["METHOD_START", "{", "return   myIndex ;", "}", "METHOD_END"], "methodName": ["getCurrentPosition"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetParser"}, {"methodBody": ["METHOD_START", "{", "return   myIndex ;", "}", "METHOD_END"], "methodName": ["getIndex"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetParser"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myIndex )     <     ( myTokens . size (  )  )  )     {", "return   myTokens . get ( myIndex )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getToken"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetParser"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( myIndex )     +    i )     <     ( myTokens . size (  )  )  )     {", "return   myTokens . get (  (  ( myIndex )     +    i )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["nextToken"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetParser"}, {"methodBody": ["METHOD_START", "{", "return   node    !  =    null    ?    node    :    ZenEmptyNode . INSTANCE ;", "}", "METHOD_END"], "methodName": ["notNullNode"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetParser"}, {"methodBody": ["METHOD_START", "{", "ZenCodingNode   add    =    parseAddOrMore (  )  ;", "if    ( add    =  =    null )     {", "return   null ;", "}", "ZenCodingNode   result    =    add ;", "while    ( true )     {", "ZenCodingToken   token    =    getToken (  )  ;", "if    ( token    !  =     ( ZenCodingTokens . PIPE )  )     {", "return   result ;", "}", "advance (  )  ;", "token    =    getToken (  )  ;", "if    (  !  ( token   instanceof   IdentifierToken )  )     {", "return   null ;", "}", "final   String   filterSuffix    =     (  ( IdentifierToken )     ( token )  )  . getText (  )  ;", "if    ( ZenCodingUtil . checkFilterSuffix ( filterSuffix )  )     {", "result    =    new   FilterNode ( result ,    filterSuffix )  ;", "}", "advance (  )  ;", "}", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetParser"}, {"methodBody": ["METHOD_START", "{", "ZenCodingNode   mul    =    parseMul ( parseExpression (  )  )  ;", "ZenCodingToken   operationToken    =    getToken (  )  ;", "if    ( operationToken    =  =     ( ZenCodingTokens . OPENING _ R _ BRACKET )  )     {", "mul    =    parseMul ( new   MoreOperationNode (  . notNullNode ( mul )  ,     . notNullNode ( parseExpression (  )  )  )  )  ;", "operationToken    =    getToken (  )  ;", "}", "if    (  !  ( operationToken   instanceof   OperationToken )  )     {", "return   mul ;", "}", "char   sign    =     (  ( OperationToken )     ( operationToken )  )  . getSign (  )  ;", "if    ( sign    =  =     '  ^  '  )     {", "return   parseClimbUpOperation ( mul )  ;", "}", "if    ( sign    =  =     '  +  '  )     {", "advance (  )  ;", "ZenCodingNode   add 2     =    parseAddOrMore (  )  ;", "if    ( add 2     =  =    null )     {", "return   mul ;", "}", "return   new   AddOperationNode (  . notNullNode ( mul )  ,    add 2  )  ;", "}", "if    ( sign    =  =     '  >  '  )     {", "return   parseMoreOperation ( mul )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["parseAddOrMore"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetParser"}, {"methodBody": ["METHOD_START", "{", "advance (  )  ;", "leftPart    =     . notNullNode ( leftPart )  ;", "ZenCodingNode   rightPart    =    parseAddOrMore (  )  ;", "if    ( rightPart    =  =    null )     {", "return   leftPart ;", "}", "return   new   ClimbUpOperationNode ( leftPart ,    rightPart )  ;", "}", "METHOD_END"], "methodName": ["parseClimbUpOperation"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetParser"}, {"methodBody": ["METHOD_START", "{", "ZenCodingToken   token    =    getToken (  )  ;", "if    ( token    =  =     ( ZenCodingTokens . OPENING _ R _ BRACKET )  )     {", "advance (  )  ;", "ZenCodingNode   add    =    parseAddOrMore (  )  ;", "if    ( add    =  =    null )     {", "return   null ;", "}", "ZenCodingToken   closingBrace    =    getToken (  )  ;", "if    ( closingBrace    !  =     ( ZenCodingTokens . CLOSING _ R _ BRACKET )  )     {", "return   null ;", "}", "advance (  )  ;", "return   add ;", "} else", "if    ( token   instanceof   TextToken )     {", "advance (  )  ;", "return   new   TextNode (  (  ( TextToken )     ( token )  )  )  ;", "}", "final   ZenCodingNode   Node    =    parseTemplate (  )  ;", "if    ( Node    =  =    null )     {", "return   null ;", "}", "token    =    getToken (  )  ;", "if    ( token   instanceof   TextToken )     {", "advance (  )  ;", "return   new   MoreOperationNode ( Node ,    new   TextNode (  (  ( TextToken )     ( token )  )  )  )  ;", "}", "return   Node ;", "}", "METHOD_END"], "methodName": ["parseExpression"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetParser"}, {"methodBody": ["METHOD_START", "{", "advance (  )  ;", "leftPart    =     . notNullNode ( leftPart )  ;", "ZenCodingNode   rightPart    =    parseAddOrMore (  )  ;", "if    ( rightPart    =  =    null )     {", "return   leftPart ;", "}", "return   new   MoreOperationNode ( leftPart ,    rightPart )  ;", "}", "METHOD_END"], "methodName": ["parseMoreOperation"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetParser"}, {"methodBody": ["METHOD_START", "{", "ZenCodingToken   operationToken    =    getToken (  )  ;", "if    (  (  ( expression    !  =    null )     &  &     ( operationToken   instanceof   OperationToken )  )     &  &     (  (  (  ( OperationToken )     ( operationToken )  )  . getSign (  )  )     =  =     '  *  '  )  )     {", "advance (  )  ;", "ZenCodingToken   numberToken    =    getToken (  )  ;", "if    ( numberToken   instanceof   NumberToken )     {", "advance (  )  ;", "return   new   MulOperationN ( expression ,     (  ( NumberToken )     ( numberToken )  )  . getNumber (  )  )  ;", "}", "return   new   UnaryMulOperationN ( expression )  ;", "}", "return   expression ;", "}", "METHOD_END"], "methodName": ["parseMul"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetParser"}, {"methodBody": ["METHOD_START", "{", "ZenCodingToken   token    =    getToken (  )  ;", "if    (  !  ( token   instanceof   IdentifierToken )  )     {", "return   null ;", "}", "String   Key    =     (  ( IdentifierToken )     ( token )  )  . getText (  )  ;", "advance (  )  ;", "TemplateImpl       =    myCallback . findApplicableTemplate ( Key )  ;", "if    (  (     =  =    null )     &  &     (  !  ( ZenCodingUtil . isXML 1  1 ValidQName ( Key )  )  )  )     {", "return   null ;", "}", "final   TemplateToken   Token    =    new   TemplateToken ( Key )  ;", "if    (  !  ( setTemplate ( Token ,     )  )  )     {", "return   null ;", "}", "return   new   TemplateNode ( Token )  ;", "}", "METHOD_END"], "methodName": ["parseTemplate"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetParser"}, {"methodBody": ["METHOD_START", "{", "myIndex    =    position ;", "}", "METHOD_END"], "methodName": ["restorePosition"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetParser"}, {"methodBody": ["METHOD_START", "{", "if    ( template    =  =    null )     {", "template    =    myGenerator . createTemplateByKey ( token . getKey (  )  ,    token . isForceSingleTag (  )  )  ;", "}", "if    ( template    =  =    null )     {", "return   false ;", "}", "token . setTemplate ( template ,    myCallback )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["setTemplate"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetParser"}, {"methodBody": ["METHOD_START", "{", "EditorFactory   editorFactory    =    EditorFactory . getInstance (  )  ;", "Document   document    =    editorFactory . createDocument ( templateText )  ;", "final   EditorEx   previewEditor    =     (  ( EditorEx )     ( editorFactory . createEditor ( document ,    parentEditor . getProject (  )  ,    fileType ,    true )  )  )  ;", "MarkupModelEx   model    =    previewEditor . getMarkupModel (  )  ;", "if    ( model   instanceof   EditorMarkupModel )     {", "(  ( EditorMarkupModel )     ( model )  )  . setErrorStripeVisible ( true )  ;", "}", "final   EditorSettings   settings    =    previewEditor . getSettings (  )  ;", "settings . setLineNumbersShown ( false )  ;", "settings . setAdditionalLinesCount (  1  )  ;", "settings . setAdditionalColumnsCount (  1  )  ;", "settings . setRightMarginShown ( false )  ;", "settings . setFoldingOutlineShown ( false )  ;", "settings . setLineMarkerAreaShown ( false )  ;", "settings . setIndentGuidesShown ( false )  ;", "settings . setVirtualSpace ( false )  ;", "settings . setWheelFontChangeEnabled ( false )  ;", "settings . setAdditionalPageAtBottom ( false )  ;", "settings . setCaretRowShown ( false )  ;", "previewEditor . setCaretEnabled ( false )  ;", "previewEditor . setBorder ( Borders . empty (  )  )  ;", "JBPanel   panel    =    new   JBPanel ( new   BorderLayout (  )  )     {", "@ NotNull", "@ Override", "public   Dimension   getPreferredSize (  )     {", "Dimension   size    =    super . getPreferredSize (  )  ;", "Dimension   parentEditorSize    =    parentEditor . getScrollPane (  )  . getSize (  )  ;", "int   maxWidth    =     (  ( int )     ( parentEditorSize . getWidth (  )  )  )     /     3  ;", "int   maxHeight    =     (  ( int )     ( parentEditorSize . getHeight (  )  )  )     /     2  ;", "final   int   width    =     ( settings . isUseSoftWraps (  )  )     ?    maxWidth    :    Math . min (  (  ( int )     ( size . getWidth (  )  )  )  ,    maxWidth )  ;", "final   int   height    =    Math . min (  (  ( int )     ( size . getHeight (  )  )  )  ,    maxHeight )  ;", "return   new   Dimension ( width ,    height )  ;", "}", "@ NotNull", "@ Override", "public   Insets   getInsets (  )     {", "return   JBUI . insets (  1  ,     2  ,     0  ,     0  )  ;", "}", "}  ;", "panel . setBackground ( previewEditor . getBackgroundColor (  )  )  ;", "panel . add ( previewEditor . getComponent (  )  ,    BorderLayout . CENTER )  ;", "return   new    ( panel ,    previewEditor ,    parentEditor )  ;", "}", "METHOD_END"], "methodName": ["createHint"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetPreviewHint"}, {"methodBody": ["METHOD_START", "{", "return   myEditor . getDocument (  )  . getText (  )  ;", "}", "METHOD_END"], "methodName": ["getContent"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetPreviewHint"}, {"methodBody": ["METHOD_START", "{", "EmmetPreviewHint   emmetPreviewHint    =    EmmetPreviewHint . KEY . get ( parentEditor )  ;", "if    ( emmetPreviewHint    !  =    null )     {", "if    (  !  ( emmetPreviewHint . isDisposed )  )     {", "return   emmetPreviewHint ;", "}", "emmetPreviewHint . hide (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getExistingHint"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetPreviewHint"}, {"methodBody": ["METHOD_START", "{", "JRootPane   rootPane    =    myParentEditor . getContentComponent (  )  . getRootPane (  )  ;", "JComponent   layeredPane    =     ( rootPane    !  =    null )     ?    rootPane . getLayeredPane (  )     :    myParentEditor . getComponent (  )  ;", "LogicalPosition   logicalPosition    =    myParentEditor . getCaretModel (  )  . getLogicalPosition (  )  ;", "LogicalPosition   pos    =    new   LogicalPosition ( logicalPosition . line ,    logicalPosition . column )  ;", "Point   p 1     =    HintManagerImpl . getHintPosition ( this ,    myParentEditor ,    pos ,    UNDER )  ;", "Point   p 2     =    HintManagerImpl . getHintPosition ( this ,    myParentEditor ,    pos ,    ABOVE )  ;", "boolean   p 1 Ok    =     (  ( p 1  . y )     +     ( getComponent (  )  . getPreferredSize (  )  . height )  )     <     ( layeredPane . getHeight (  )  )  ;", "boolean   p 2 Ok    =     ( p 2  . y )     >  =     0  ;", "if    ( p 1 Ok )", "return   new   openapi . util . Pair ( p 1  ,    HintManager . UNDER )  ;", "if    ( p 2 Ok )", "return   new   openapi . util . Pair ( p 2  ,    HintManager . ABOVE )  ;", "int   underSpace    =     ( layeredPane . getHeight (  )  )     -     ( p 1  . y )  ;", "int   aboveSpace    =    p 2  . y ;", "return   aboveSpace    >    underSpace    ?    new   openapi . util . Pair ( new   Point ( p 2  . x ,     0  )  ,    HintManager . UNDER )     :    new   openapi . util . Pair ( p 1  ,    HintManager . ABOVE )  ;", "}", "METHOD_END"], "methodName": ["guessPosition"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetPreviewHint"}, {"methodBody": ["METHOD_START", "{", "myParentEditor . putUserData ( EmmetPreviewHint . KEY ,    this )  ;", "Pair < Point ,    Short >    position    =    guessPosition (  )  ;", "JRootPane   pane    =    myParentEditor . getComponent (  )  . getRootPane (  )  ;", "JComponent   layeredPane    =     ( pane    !  =    null )     ?    pane . getLayeredPane (  )     :    myParentEditor . getComponent (  )  ;", "HintHint   hintHint    =    new   HintHint ( layeredPane ,    position . first )  . setAwtTooltip ( true )  . setContentActive ( true )  . setExplicitClose ( true )  . setShowImmediately ( true )  . setPreferredPosition (  (  ( position . second )     =  =     ( HintManager . ABOVE )     ?    Position . above    :    Position . below )  )  . setTextBg ( myParentEditor . getColorsScheme (  )  . getDefaultBackground (  )  )  . setBorderInsets ( JBUI . insets (  1  )  )  ;", "int   hintFlags    =     (  ( HintManager . HIDE _ BY _ OTHER _ HINT )     |     ( HintManager . HIDE _ BY _ ESCAPE )  )     |     ( HintManager . UPDATE _ BY _ SCROLLING )  ;", "HintManagerImpl . getInstanceImpl (  )  . showEditorHint ( this ,    myParentEditor ,    position . first ,    hintFlags ,     0  ,    false ,    hintHint )  ;", "}", "METHOD_END"], "methodName": ["showHint"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetPreviewHint"}, {"methodBody": ["METHOD_START", "{", "myAlarm . cancelAllRequests (  )  ;", "myAlarm . addRequest (  (  )     -  >     {", "if    (  !  ( isDisposed )  )     {", "final   String   newText    =    contentProducer . produce (  )  ;", "if    ( StringUtil . isEmpty ( newText )  )     {", "hide (  )  ;", "} else", "if    (  !  ( myEditor . getDocument (  )  . getText (  )  . equals ( newText )  )  )     {", "util . DocumentUtil . writeInRunUndoTransparentAction (  (  )     -  >    myEditor . getDocument (  )  . setText ( newText )  )  ;", "}", "}", "}  ,     1  0  0  )  ;", "}", "METHOD_END"], "methodName": ["updateText"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetPreviewHint"}, {"methodBody": ["METHOD_START", "{", "editor . getDocument (  )  . addDocumentListener ( new   DocumentListener (  )     {", "@ Override", "public   void   documentChanged (  @ NotNull", "DocumentEvent   e )     {", "EmmetPreviewHint   existingHint    =    EmmetPreviewHint . getExistingHint ( editor )  ;", "if    ( existingHint    !  =    null )     {", "existingHint . updateText ( new    . TemplateTextProducer ( editor ,    file ,    expandPrimitiveAbbreviations )  )  ;", "} else    {", "e . getDocument (  )  . removeDocumentListener ( this )  ;", "}", "}", "}  )  ;", "editor . getCaretModel (  )  . addCaretListener ( new   CaretListener (  )     {", "@ Override", "public   void   caretPositionChanged (  @ NotNull", "CaretEvent   e )     {", "EmmetPreviewHint   existingHint    =    EmmetPreviewHint . getExistingHint ( e . getEditor (  )  )  ;", "if    ( existingHint    !  =    null )     {", "existingHint . updateText ( new    . TemplateTextProducer ( editor ,    file ,    expandPrimitiveAbbreviations )  )  ;", "} else    {", "e . getEditor (  )  . getCaretModel (  )  . removeCaretListener ( this )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addEmmetPreviewListeners"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetPreviewUtil"}, {"methodBody": ["METHOD_START", "{", "PsiDocumentManager . getInstance ( file . getProject (  )  )  . commitDocument ( editor . getDocument (  )  )  ;", "CollectCustomTemplateCallback   callback    =    new   CollectCustomTemplateCallback ( editor ,    file )  ;", "ZenCodingGenerator   generator    =    ZenCodingTemplate . findApplicableDefaultGenerator ( callback ,    false )  ;", "if    ( generator   instanceof   XmlZenCodingGenerator )     {", "final   String   templatePrefix    =    new   ZenCodingTemplate (  )  . computeTemplateKeyWithoutContextChecking ( callback )  ;", "if    ( templatePrefix    !  =    null )     {", "try    {", "ZenCodingTemplate . expand ( templatePrefix ,    callback ,    generator ,    Collections . emptyList (  )  ,    expandPrimitiveAbbreviations ,     0  )  ;", "TemplateImpl   template    =    callback . getGeneratedTemplate (  )  ;", "String   templateText    =     ( template    !  =    null )     ?    template . getTemplateText (  )     :    null ;", "if    (  !  ( StringUtil . isEmpty ( templateText )  )  )     {", "return   template . isToReformat (  )     ?     . reformatTemplateText ( file ,    templateText )     :    templateText ;", "}", "}    catch    ( EmmetException   e )     {", "return   e . getMessage (  )  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["calculateTemplateText"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetPreviewUtil"}, {"methodBody": ["METHOD_START", "{", "final   PsiFile   copy    =    PsiFileFactory . getInstance ( file . getProject (  )  )  . createFileFromText ( file . getName (  )  ,    file . getFileType (  )  ,    templateText )  ;", "VirtualFile   vFile    =    copy . getVirtualFile (  )  ;", "if    ( vFile    !  =    null )     {", "vFile . putUserData ( DONT _ RECORD _ UNDO ,    Boolean . TRUE )  ;", "}", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >    CommandProcessor . getInstance (  )  . runUndoTransparentAction (  (  )     -  >    CodeStyleManager . getInstance ( file . getProject (  )  )  . reformat ( copy )  )  )  ;", "return   copy . getText (  )  ;", "}", "METHOD_END"], "methodName": ["reformatTemplateText"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetPreviewUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( tag . isValid (  )  )     {", "String   templateText    =     . expandTemplate ( abbreviation ,    file ,    editor )  ;", "final   Collection < String >    classNames    =    ContainerUtil . newLinkedHashSet (  )  ;", "ContainerUtil . addAll ( classNames ,    HtmlUtil . splitClassNames ( tag . getAttributeValue ( HtmlUtil . CLASS _ ATTRIBUTE _ NAME )  )  )  ;", "final   Map < String ,    String >    attributes    =    ContainerUtil . newLinkedHashMap (  )  ;", "final   Ref < String >    newTagName    =    Ref . create (  )  ;", ". processTags ( file . getProject (  )  ,    templateText ,     (    tag 1  ,    firstTag )     -  >     {", "if    (  ( firstTag    &  &     (  !  ( abbreviation . isEmpty (  )  )  )  )     &  &     ( StringUtil . isJavaIdentifierPart ( abbreviation . charAt (  0  )  )  )  )     {", "newTagName . set ( tag 1  . getName (  )  )  ;", "}", "for    ( String   clazz    :    HtmlUtil . splitClassNames ( tag 1  . getAttributeValue ( HtmlUtil . CLASS _ ATTRIBUTE _ NAME )  )  )     {", "if    ( StringUtil . startsWithChar ( clazz ,     '  +  '  )  )     {", "classNames . add ( clazz . substring (  1  )  )  ;", "} else", "if    ( StringUtil . startsWithChar ( clazz ,     '  -  '  )  )     {", "classNames . remove ( clazz . substring (  1  )  )  ;", "} else    {", "classNames . clear (  )  ;", "classNames . add ( clazz )  ;", "}", "}", "if    (  ! firstTag )     {", "classNames . add ( tag 1  . getName (  )  )  ;", "}", "for    ( XmlAttribute   xmlAttribute    :    tag 1  . getAttributes (  )  )     {", "if    (  !  ( HtmlUtil . CLASS _ ATTRIBUTE _ NAME . equalsIgnoreCase ( xmlAttribute . getName (  )  )  )  )     {", "attributes . put ( xmlAttribute . getName (  )  ,    StringUtil . notNullize ( xmlAttribute . getValue (  )  )  )  ;", "}", "}", "return   true ;", "}  )  ;", "WriteCommandAction . writeCommandAction ( file . getProject (  )  ,    file )  . run (  . doUpdateTagAttributes ( tag ,    file ,    newTagName . get (  )  ,    classNames ,    attributes )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doUpdateTag"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetUpdateTagAction"}, {"methodBody": ["METHOD_START", "{", "return    (  )     -  >     {", "if    ( tag . isValid (  )  )     {", "if    (  !  ( ReadonlyStatusHandler . gettance ( file . getProject (  )  )  . ensureFilesWritable ( file . getVirtualFile (  )  )  . hasReadonlyFiles (  )  )  )     {", "tag . setAttribute ( HtmlUtil . CLASS _ ATTRIBUTE _ NAME ,    StringUtil . join ( classes ,     \"     \"  )  . trim (  )  )  ;", "for    ( Entry < String ,    String >    attribute    :    attributes . entrySet (  )  )     {", "final   String   attributeName    =    attribute . getKey (  )  ;", "if    ( StringUtil . startsWithChar ( attributeName ,     '  +  '  )  )     {", "final   XmlAttribute   existingAttribute    =    tag . getAttribute ( attributeName . substring (  1  )  )  ;", "if    ( existingAttribute    !  =    null )     {", "existingAttribute . setValue ( StringUtil . notNullize (  (  ( existingAttribute . getValue (  )  )     +     ( attribute . getValue (  )  )  )  )  )  ;", "} else    {", "tag . setAttribute ( attributeName . substring (  1  )  ,    attribute . getValue (  )  )  ;", "}", "} else", "if    ( StringUtil . startsWithChar ( attributeName ,     '  -  '  )  )     {", "final   XmlAttribute   existingAttribute    =    tag . getAttribute ( attributeName . substring (  1  )  )  ;", "if    ( existingAttribute    !  =    null )     {", "existingAttribute . delete (  )  ;", "}", "} else    {", "tag . setAttribute ( attributeName ,    attribute . getValue (  )  )  ;", "}", "}", "if    ( newTagName    !  =    null )     {", "tag . setName ( newTagName )  ;", "}", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["doUpdateTagAttributes"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetUpdateTagAction"}, {"methodBody": ["METHOD_START", "{", "final   CollectCustomTemplateCallback   callback    =    new   CollectCustomTemplateCallback ( editor ,    file )  ;", "ZenCodingTxpand ( abbreviation ,    callback ,    XmlZenCodingGeneratorImpl . INSTANCE ,    Collections . emptyList (  )  ,    true ,    Registry . intValue (  \" emmet . segments . limit \"  )  )  ;", "TemplateImpl   template    =    callback . getGeneratedTemplate (  )  ;", "return   template    !  =    null    ?    template . getTxt (  )     :    null ;", "}", "METHOD_END"], "methodName": ["expandTemplate"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetUpdateTagAction"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    PsiTreeUtil . getNonStrictParentOfType ( file . findElementAt ( editor . getCaretModel (  )  . getOffset (  )  )  ,    XmlTag . class )  ;", "return    ( tag    !  =    null )     &  &     ( HtmlUtil . isHtmlTag ( tag )  )     ?    tag    :    null ;", "}", "METHOD_END"], "methodName": ["findTag"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetUpdateTagAction"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtil . isNotEmpty ( templateText )  )     {", "final   PsiFileFactory   psiFileFactory    =    PsiFileFactory . getInstance ( project )  ;", "XmlFile   xmlFile    =     (  ( XmlFile )     ( psiFileFactory . createFileFromText (  \" dummy . xml \"  ,    HTML ,    templateText )  )  )  ;", "XmlTag   tag    =    xmlFile . getRootTag (  )  ;", "boolean   firstTag    =    true ;", "while    ( tag    !  =    null )     {", "processor . process ( tag ,    firstTag )  ;", "firstTag    =    false ;", "tag    =    PsiTreeUtil . getNextSiblingOfType ( tag ,    XmlTag . class )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processTags"], "fileName": "com.intellij.codeInsight.template.emmet.EmmetUpdateTagAction"}, {"methodBody": ["METHOD_START", "{", "if    ( token    =  =    null )     {", "return    \"  \"  ;", "}", "if    ( token   instanceof   StringLiteralToken )     {", "final   String   text    =     (  ( StringLiteralToken )     ( token )  )  . getText (  )  ;", "return   text . substring (  1  ,     (  ( text . length (  )  )     -     1  )  )  ;", "} else", "if    ( token   instanceof   tokens . TextToken )     {", "return    (  ( tokens . TextToken )     ( token )  )  . getText (  )  ;", "} else", "if    ( token   instanceof   tokens . IdentifierToken )     {", "return    (  ( tokens . IdentifierToken )     ( token )  )  . getText (  )  ;", "} else", "if    ( token   instanceof   tokens . NumberToken )     {", "return   Integer . toString (  (  ( tokens . NumberToken )     ( token )  )  . getNumber (  )  )  ;", "} else", "if    ( allowOperations    &  &     ( token   instanceof   tokens . OperationToken )  )     {", "return   String . valueOf (  (  ( tokens . OperationToken )     ( token )  )  . getSign (  )  )  ;", "} else", "if    (  ( token    =  =     ( tokens . ZenCodingTokens . DOT )  )     |  |     ( token    =  =     ( tokens . ZenCodingTokens . SHARP )  )  )     {", "return   token . toString (  )  ;", "}", "return    \"  \"  ;", "}", "METHOD_END"], "methodName": ["getAttributeValueByToken"], "fileName": "com.intellij.codeInsight.template.emmet.XmlEmmetParser"}, {"methodBody": ["METHOD_START", "{", "return   HtmlUtil . CLASS _ ATTRIBUTE _ NAME ;", "}", "METHOD_END"], "methodName": ["getClassAttributeName"], "fileName": "com.intellij.codeInsight.template.emmet.XmlEmmetParser"}, {"methodBody": ["METHOD_START", "{", "return   isHtml    ?    suggestTagName (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getDefaultTemplateKey"], "fileName": "com.intellij.codeInsight.template.emmet.XmlEmmetParser"}, {"methodBody": ["METHOD_START", "{", "if    ( node   instanceof   TemplateNode )     {", "return    (  ( TemplateNode )     ( node )  )  . getTemplateToken (  )  . getKey (  )  ;", "} else", "if    ( node   instanceof   nodes . MulOperationNode )     {", "ZenCodingNode   leftOperand    =     (  ( nodes . MulOperationNode )     ( node )  )  . getLeftOperand (  )  ;", "if    ( leftOperand   instanceof   TemplateNode )     {", "return    (  ( TemplateNode )     ( leftOperand )  )  . getTemplateToken (  )  . getKey (  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getParentTag"], "fileName": "com.intellij.codeInsight.template.emmet.XmlEmmetParser"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( nextToken    =  =    null )     |  |     ( nextToken    =  =     ( ZenCodingTokens . SPACE )  )  )     |  |     ( nextToken    =  =     ( ZenCodingTokens . CLOSING _ SQ _ BRACKET )  )  )     |  |     ( nextToken    =  =     ( ZenCodingTokens . COMMA )  )  ;", "}", "METHOD_END"], "methodName": ["isEndOfAttribute"], "fileName": "com.intellij.codeInsight.template.emmet.XmlEmmetParser"}, {"methodBody": ["METHOD_START", "{", "final   int   position    =    getCurrentPosition (  )  ;", "String   attributeName    =    parseAttributeName (  )  ;", "if    (  ( attributeName    !  =    null )     &  &     (  !  ( attributeName . isEmpty (  )  )  )  )     {", "if    (  ( getToken (  )  )     =  =     ( ZenCodingTokens . DOT )  )     {", "if    (  . isEndOfAttribute ( nextToken (  1  )  )  )     {", "advance (  )  ;", "return   Couple . of ( attributeName ,     . BOOLEAN _ ATTRIBUTE _ VALUE )  ;", "}", "} else    {", "if    (  ( getToken (  )  )     =  =     ( ZenCodingTokens . EQ )  )     {", "advance (  )  ;", "return   Couple . of ( attributeName ,    parseAttributeValue (  )  )  ;", "} else    {", "return   Couple . of ( attributeName ,     \"  \"  )  ;", "}", "}", "}", "restorePosition ( position )  ;", "final   String   impliedValue    =    parseAttributeValue (  )  ;", "if    (  !  ( impliedValue . isEmpty (  )  )  )     {", "return   Couple . of (  . DEFAULT _ ATTRIBUTE _ NAME ,    impliedValue )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["parseAttribute"], "fileName": "com.intellij.codeInsight.template.emmet.XmlEmmetParser"}, {"methodBody": ["METHOD_START", "{", "final   List < Couple < String >  >    result    =    new   ArrayList <  >  (  )  ;", "while    ( true )     {", "final   Couple < String >    attribute    =    pAttribute (  )  ;", "if    ( attribute    =  =    null )     {", "return   result ;", "}", "result . add ( attribute )  ;", "final   ZenCodingToken   token    =    getToken (  )  ;", "if    (  ( token    !  =     ( ZenCodingTokens . COMMA )  )     &  &     ( token    !  =     ( ZenCodingTokens . SPACE )  )  )     {", "return   result ;", "}", "advance (  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseAttributeList"], "fileName": "com.intellij.codeInsight.template.emmet.XmlEmmetParser"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   name    =    new   StringBuilder (  )  ;", "ZenCodingToken   token    =    getToken (  )  ;", "while    ( token    !  =    null )     {", "if    ( token   instanceof   IdentifierToken )     {", "name . append (  (  ( IdentifierToken )     ( token )  )  . getText (  )  )  ;", "} else", "if    (  ( token   instanceof   tokens . OperationToken )     &  &     (  (  (  (  ( tokens . OperationToken )     ( token )  )  . getSign (  )  )     =  =     '  +  '  )     |  |     (  (  (  ( tokens . OperationToken )     ( token )  )  . getSign (  )  )     =  =     '  -  '  )  )  )     {", "name . append (  (  ( tokens . OperationToken )     ( token )  )  . getSign (  )  )  ;", "} else    {", "break ;", "}", "advance (  )  ;", "token    =    getToken (  )  ;", "}", "if    (  ( name . length (  )  )     =  =     0  )     {", "return   null ;", "}", "final   XmlTag   tag    =    XmlElementFactory . getInstance ( myCallback . getProject (  )  )  . createTagFromText (  (  (  \"  < tag    \"     +    name )     +     \"  =  '  '  /  >  \"  )  ,    HTML )  ;", "XmlAttribute [  ]    attributes    =    tag . getAttributes (  )  ;", "if    (  ( attributes . length )     =  =     1  )     {", "return   attributes [  0  ]  . getName (  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["parseAttributeName"], "fileName": "com.intellij.codeInsight.template.emmet.XmlEmmetParser"}, {"methodBody": ["METHOD_START", "{", "ZenCodingToken   token ;", "final   StringBuilder   attrValueBuilder    =    new   StringBuilder (  )  ;", "String   value ;", "do    {", "token    =    getToken (  )  ;", "value    =     . getAttributeValueByToken ( token ,    true )  ;", "attrValueBuilder . append ( value )  ;", "if    (  !  (  . isEndOfAttribute ( token )  )  )     {", "advance (  )  ;", "}", "}    while    (  !  (  . isEndOfAttribute ( token )  )     )  ;", "return   attrValueBuilder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["parseAttributeValue"], "fileName": "com.intellij.codeInsight.template.emmet.XmlEmmetParser"}, {"methodBody": ["METHOD_START", "{", "Matcher   matcher    =    XmlEmmetParser . LOREM _ PATTERN . matcher ( templateKey )  ;", "if    ( matcher . matches (  )  )     {", "int   loremWordsCount    =    XmlEmmetParser . DEFAULT _ LOREM _ LENGTH ;", "if    (  ( matcher . groupCount (  )  )     >     1  )     {", "String   group    =    matcher . group (  2  )  ;", "loremWordsCount    =     (  ( group    =  =    null )     |  |     ( group . isEmpty (  )  )  )     ?    XmlEmmetParser . DEFAULT _ LOREM _ LENGTH    :    Integer . parseInt ( group )  ;", "}", "final   Map < String ,    String >    attributes    =    parseSelectors (  )  ;", "ZenCodingToken   token    =    getToken (  )  ;", "boolean   isRepeating    =     ( token   instanceof   OperationToken )     &  &     (  (  (  ( OperationToken )     ( token )  )  . getSign (  )  )     =  =     '  *  '  )  ;", "if    (  (  !  ( attributes . isEmpty (  )  )  )     |  |    isRepeating )     {", "String   wrapTag    =    suggestTagName (  )  ;", "TemplateImpl   template    =    myCallback . findApplicableTemplate ( templateKey )  ;", "if    (  ( template    =  =    null )     &  &     (  !  ( ZenCodingUtil . isXML 1  1 ValidQName ( templateKey )  )  )  )     {", "return   null ;", "}", "final   TemplateToken   templateToken    =    new   TemplateToken ( wrapTag ,    attributes )  ;", "if    (  !  ( setTemplate ( templateToken ,    template )  )  )     {", "return   null ;", "}", "return   new   MoreOperationNode ( new   TemplateNode ( templateToken )  ,    new   LoremNode ( loremWordsCount )  )  ;", "} else    {", "return   new   LoremNode ( loremWordsCount )  ;", "}", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["parseLorem"], "fileName": "com.intellij.codeInsight.template.emmet.XmlEmmetParser"}, {"methodBody": ["METHOD_START", "{", "ZenCodingToken   token    =    getToken (  )  ;", "if    ( token    =  =     ( ZenCodingTokens . OPENING _ SQ _ BRACKET )  )     {", "advance (  )  ;", "final   List < Couple < String >  >    attrList    =    parseAttributeList (  )  ;", "if    (  ( getToken (  )  )     !  =     ( ZenCodingTokens . CLOSING _ SQ _ BRACKET )  )     {", "return   null ;", "}", "advance (  )  ;", "return   attrList ;", "}", "if    (  ( token    =  =     ( ZenCodingTokens . DOT )  )     |  |     ( token    =  =     ( ZenCodingTokens . SHARP )  )  )     {", "final   String   name    =     ( token    =  =     ( ZenCodingTokens . DOT )  )     ?    getClassAttributeName (  )     :    HtmlUtil . ID _ ATTRIBUTE _ NAME ;", "advance (  )  ;", "token    =    getToken (  )  ;", "final   String   value    =     . getAttributeValueByToken ( token ,    false )  ;", "if    (  !  ( value . isEmpty (  )  )  )     {", "advance (  )  ;", "}", "return   Collections . singletonList ( Couple . of ( name ,    value )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["parseSelector"], "fileName": "com.intellij.codeInsight.template.emmet.XmlEmmetParser"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    String >    result    =    ContainerUtil . newLinkedHashMap (  )  ;", "List < Couple < String >  >    attrList    =    parseSelector (  )  ;", "while    ( attrList    !  =    null )     {", "for    ( Couple < String >    attr    :    attrList )     {", "if    ( getClassAttributeName (  )  . equals ( attr . first )  )     {", "result . put ( getClassAttributeName (  )  ,     (  (  ( StringUtil . notNullize ( result . get ( getClassAttributeName (  )  )  )  )     +     \"     \"  )     +     ( attr . second )  )  . trim (  )  )  ;", "} else", "if    ( xml . util . HtmlUtil . ID _ ATTRIBUTE _ NAME . equals ( attr . first )  )     {", "result . put ( xml . util . HtmlUtil . ID _ ATTRIBUTE _ NAME ,     (  (  ( StringUtil . notNullize ( result . get ( xml . util . HtmlUtil . ID _ ATTRIBUTE _ NAME )  )  )     +     \"     \"  )     +     ( attr . second )  )  . trim (  )  )  ;", "} else    {", "result . put ( attr . first ,    attr . second )  ;", "}", "}", "attrList    =    parseSelector (  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["parseSelectors"], "fileName": "com.intellij.codeInsight.template.emmet.XmlEmmetParser"}, {"methodBody": ["METHOD_START", "{", "if    (  ( tagLevel . size (  )  )     >     ( hasTagContext    ?     1     :     0  )  )     {", "tagLevel . pop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["popTagLevel"], "fileName": "com.intellij.codeInsight.template.emmet.XmlEmmetParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( tagLevel . empty (  )  )  )     {", "String   parentTag    =    tagLevel . peek (  )  ;", "if    (  . parentChildTagMapping . containsKey ( parentTag )  )     {", "return    . parentChildTagMapping . get ( parentTag )  ;", "}", "if    ( HtmlUtil . isPossiblyInlineTag ( parentTag )  )     {", "return    . DEFAULT _ INLINE _ TAG ;", "}", "}", "return    . DEFAULT _ TAG ;", "}", "METHOD_END"], "methodName": ["suggestTagName"], "fileName": "com.intellij.codeInsight.template.emmet.XmlEmmetParser"}, {"methodBody": ["METHOD_START", "{", "ZenCodingGenerator   generator    =    ZenCodingTemplate . findApplicableDefaultGenerator ( callback ,    true )  ;", "if    ( generator    =  =    null )     {", "int   offset    =    callback . getEditor (  )  . getCaretModel (  )  . getOffset (  )  ;", "ZenCodingTemplate . LOG . error (  (  (  (  \" Emmet   is   disabled   for   context   for   file    \"     +     ( callback . getFileType (  )  . getName (  )  )  )     +     \"    in   offset :     \"  )     +    offset )  ,    AttachmentFactory . createAttachment ( callback . getEditor (  )  . getDocument (  )  )  )  ;", "return   false ;", "}", "return   ZenCodingTemplate . checkTemplateKey ( inputString ,    callback ,    generator )  ;", "}", "METHOD_END"], "methodName": ["checkTemplateKey"], "fileName": "com.intellij.codeInsight.template.emmet.ZenCodingTemplate"}, {"methodBody": ["METHOD_START", "{", "return    ( ZenCodingTemplate . parse ( key ,    callback ,    generator ,    null )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["checkTemplateKey"], "fileName": "com.intellij.codeInsight.template.emmet.ZenCodingTemplate"}, {"methodBody": ["METHOD_START", "{", "int   predictedOutputLength    =    node . getApproximateOutputLength ( callback )  ;", "if    ( predictedOutputLength    >     (  1  5     *     1  0  2  4  )  )     {", "throw   new   EException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkTemplateOutputLength"], "fileName": "com.intellij.codeInsight.template.emmet.ZenCodingTemplate"}, {"methodBody": ["METHOD_START", "{", "final   ZenCodingGenerator   defaultGenerator    =    ZenCodingTemplate . findApplicableDefaultGenerator ( callback ,    true )  ;", "assert   defaultGenerator    !  =    null ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >    CommandProcessor . getInstance (  )  . executeCommand ( callback . getProject (  )  ,     (  )     -  >    callback . getEditor (  )  . getCaretModel (  )  . runForEachCaret ( new   CaretAction (  )     {", "@ Override", "public   void   perform ( Caret   caret )     {", "String   selectedText    =    callback . getEditor (  )  . getSelectionModel (  )  . getSelectedText (  )  ;", "if    ( selectedText    !  =    null )     {", "ZenCodingNode   node    =    parse ( abbreviation ,    callback ,    defaultGenerator ,    selectedText )  ;", "assert   node    !  =    null ;", "PsiElement   context    =    callback . getContext (  )  ;", "ZenCodingGenerator   generator    =    findApplicableGenerator ( node ,    callback ,    true )  ;", "List < ZenCodingFilter >    filters    =    getFilters ( node ,    context )  ;", "EditorModificationUtil . deleteSelectedText ( callback . getEditor (  )  )  ;", "PsiDocumentManager . getInstance ( callback . getProject (  )  )  . commitAllDocuments (  )  ;", "try    {", "expand ( node ,    generator ,    filters ,    selectedText ,    callback ,    true ,    Registry . intValue (  \" emmet . segments . limit \"  )  )  ;", "}    catch    (    e )     {", "CommonRefactoringUtil . showErrorHint ( callback . getProject (  )  ,    callback . getEditor (  )  ,    e . getMessage (  )  ,     \" Emmet   error \"  ,     \"  \"  )  ;", "}", "}", "}", "}  )  ,    CodeInsightBundle . message (  \" insert . code . template . command \"  )  ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["doWrap"], "fileName": "com.intellij.codeInsight.template.emmet.ZenCodingTemplate"}, {"methodBody": ["METHOD_START", "{", "ZenCodingTemplate . checkTemplateOutputLength ( node ,    callback )  ;", "GenerationNode   fakeParentNode    =    new   GenerationNode ( TemplateToken . EMPTY _ TEMPLATE _ TOKEN ,     (  -  1  )  ,     1  ,    surroundedText ,    true ,    null )  ;", "node . expand (  (  -  1  )  ,     1  ,    surroundedText ,    callback ,    true ,    fakeParentNode )  ;", "if    (  ! expandPrimitiveAbbreviations )     {", "if    ( ZenCodingTemplate . isPrimitiveNode ( node )  )     {", "return ;", "}", "}", "List < GenerationNode >    genNodes    =    fakeParentNode . getChildren (  )  ;", "LiveTemplateBuilder   builder    =    new   LiveTemplateBuilder ( EmmetOptions . getInstance (  )  . isAddEditPointAtTheEndOfTemplate (  )  ,    segmentsLimit )  ;", "int   end    =     -  1  ;", "for    ( int   i    =     0  ,    genNodesSize    =    genNodes . size (  )  ;    i    <    genNodesSize ;    i +  +  )     {", "GenerationNode   genNode    =    genNodes . get ( i )  ;", "TemplateImpl   template    =    genNode . generate ( callback ,    generator ,    filters ,    true ,    segmentsLimit )  ;", "int   e    =    builder . insertTemplate ( builder . length (  )  ,    template ,    null )  ;", "if    (  ( i    <     ( genNodesSize    -     1  )  )     &  &     ( genNode . isInsertNewLineBetweenNodes (  )  )  )     {", "builder . insertText ( e ,     \"  \\ n \"  ,    false )  ;", "e +  +  ;", "}", "if    (  ( end    =  =     (  -  1  )  )     &  &     ( end    <     ( builder . length (  )  )  )  )     {", "end    =    e ;", "}", "}", "for    ( ZenCodingFilter   filter    :    filters )     {", "if    ( filter   instanceof   SingleLineEmmetFilter )     {", "builder . setIsToReformat ( false )  ;", "break ;", "}", "}", "callback . startTemplate ( builder . buildTemplate (  )  ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["expand"], "fileName": "com.intellij.codeInsight.template.emmet.ZenCodingTemplate"}, {"methodBody": ["METHOD_START", "{", "final   ZenCodingNode   node    =    ZenCodingTemplate . parse ( key ,    callback ,    defaultGenerator ,    null )  ;", "if    ( node    =  =    null )     {", "return ;", "}", "if    ( node   instanceof   TemplateNode )     {", "if    (  ( key . equals (  (  ( TemplateNode )     ( node )  )  . getTemplateToken (  )  . getKey (  )  )  )     &  &     (  ( callback . findApplicableTemplates ( key )  . size (  )  )     >     1  )  )     {", "TemplateManagerImpl   templateManager    =     (  ( TemplateManagerImpl )     ( callback . getTemplateManager (  )  )  )  ;", "Map < TemplateImpl ,    String >    template 2 Argument    =    templateManager . findMatchingTemplates ( callback . getFile (  )  ,    callback . getEditor (  )  ,    null ,    TemplateSettings . getInstance (  )  )  ;", "Runnable   runnable    =    templateManager . startNonCustomTemplates ( template 2 Argument ,    callback . getEditor (  )  ,    null )  ;", "if    ( runnable    !  =    null )     {", "runnable . run (  )  ;", "}", "return ;", "}", "}", "PsiElement   context    =    callback . getContext (  )  ;", "ZenCodingGenerator   generator    =    ObjectUtils . notNull ( ZenCodingTemplate . findApplicableGenerator ( node ,    callback ,    false )  ,    defaultGenerator )  ;", "List < ZenCodingFilter >    filters    =    ZenCodingTemplate . getFilters ( node ,    context )  ;", "filters . addAll ( extraFilters )  ;", "ZenCodingTemplate . checkTemplateOutputLength ( node ,    callback )  ;", "callback . deleteTemplateKey ( key )  ;", "ZenCodingTemplate . expand ( node ,    generator ,    filters ,    null ,    callback ,    expandPrimitiveAbbreviations ,    segmentsLimit )  ;", "}", "METHOD_END"], "methodName": ["expand"], "fileName": "com.intellij.codeInsight.template.emmet.ZenCodingTemplate"}, {"methodBody": ["METHOD_START", "{", "PsiElement   context    =    callback . getContext (  )  ;", "if    (  !  ( context . isValid (  )  )  )     {", "return   null ;", "}", "for    ( Generator   generator    :    Generator . getInstances (  )  )     {", "if    (  ( generator . isMyContext ( callback ,    wrapping )  )     &  &     ( generator . isAppliedByDefault ( callback . getContext (  )  )  )  )     {", "return   generator ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findApplicableDefaultGenerator"], "fileName": "com.intellij.codeInsight.template.emmet.ZenCodingTemplate"}, {"methodBody": ["METHOD_START", "{", "ZenCodingGenerator   defaultGenerator    =    null ;", "ZenCodingGenerator [  ]    generators    =    ZenCodingGenerator . getInstances (  )  ;", "PsiElement   context    =    callback . getContext (  )  ;", "for    ( ZenCodingGenerator   generator    :    generators )     {", "if    (  ( generator . isMyContext ( callback ,    wrapping )  )     &  &     ( generator . isAppliedByDefault ( context )  )  )     {", "defaultGenerator    =    generator ;", "break ;", "}", "}", "while    ( node   instanceof   FilterNode )     {", "FilterNode   filterNode    =     (  ( FilterNode )     ( node )  )  ;", "String   suffix    =    filterNode . getFilter (  )  ;", "for    ( ZenCodingGenerator   generator    :    generators )     {", "if    ( generator . isMyContext ( callback ,    wrapping )  )     {", "if    (  ( suffix    !  =    null )     &  &     ( suffix . equals ( generator . getSuffix (  )  )  )  )     {", "return   generator ;", "}", "}", "}", "node    =    filterNode . getNode (  )  ;", "}", "return   defaultGenerator ;", "}", "METHOD_END"], "methodName": ["findApplicableGenerator"], "fileName": "com.intellij.codeInsight.template.emmet.ZenCodingTemplate"}, {"methodBody": ["METHOD_START", "{", "List < ZenCodingFilter >    result    =    new   ArrayList <  >  (  )  ;", "while    ( node   instanceof   FilterNode )     {", "FilterNode   filterNode    =     (  ( FilterNode )     ( node )  )  ;", "String   filterSuffix    =    filterNode . getFilter (  )  ;", "for    ( ZenCodingFilter   filter    :    ZenCodingFilter . getInstances (  )  )     {", "if    (  ( filter . isMyContext ( context )  )     &  &     ( filter . getSuffix (  )  . equals ( filterSuffix )  )  )     {", "result . add ( filter )  ;", "}", "}", "node    =    filterNode . getNode (  )  ;", "}", "for    ( ZenCodingFilter   filter    :    ZenCodingFilter . getInstances (  )  )     {", "if    (  ( filter . isMyContext ( context )  )     &  &     ( filter . isAppliedByDefault ( context )  )  )     {", "result . add ( filter )  ;", "}", "}", "Collections . reverse ( result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getFilters"], "fileName": "com.intellij.codeInsight.template.emmet.ZenCodingTemplate"}, {"methodBody": ["METHOD_START", "{", "if    ( node   instanceof   TemplateNode )     {", "final   TemplateToken   token    =     (  ( TemplateNode )     ( node )  )  . getTemplateToken (  )  ;", "if    ( token    !  =    null )     {", "final   Map < String ,    String >    attributes    =    token . getAttributes (  )  ;", "return    ( attributes . isEmpty (  )  )     |  |     (  ( attributes . containsKey ( HtmlUtil . CLASS _ ATTRIBUTE _ NAME )  )     &  &     ( StringUtil . isEmpty ( attributes . get ( HtmlUtil . CLASS _ ATTRIBUTE _ NAME )  )  )  )  ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isPrimitiveNode"], "fileName": "com.intellij.codeInsight.template.emmet.ZenCodingTemplate"}, {"methodBody": ["METHOD_START", "{", "List < ZenCodingToken >    tokens    =    new   EmmetLexer (  )  . lex ( text )  ;", "if    ( tokens    =  =    null )     {", "return   null ;", "}", "if    (  !  (  . validate ( tokens ,    generator )  )  )     {", "return   null ;", "}", "EmmetParser   parser    =    generator . createParser ( tokens ,    callback ,    generator ,     ( surroundedText    !  =    null )  )  ;", "ZenCodingNode   node    =    parser . parse (  )  ;", "if    (  (  ( parser . getIndex (  )  )     !  =     ( tokens . size (  )  )  )     |  |     ( node   instanceof   TextNode )  )     {", "return   null ;", "}", "return   node ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "com.intellij.codeInsight.template.emmet.ZenCodingTemplate"}, {"methodBody": ["METHOD_START", "{", "for    ( ZenCodingToken   token    :    tokens )     {", "if    (  ( token   instanceof   TextToken )     &  &     (  !  ( generator   instanceof   XmlZenCodingGenerator )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "com.intellij.codeInsight.template.emmet.ZenCodingTemplate"}, {"methodBody": ["METHOD_START", "{", "for    ( ZenCodingGenerator   generator    :    ZenCodingGenerator . getInstances (  )  )     {", "if    ( suffix . equals ( generator . getSuffix (  )  )  )     {", "return   true ;", "}", "}", "for    ( ZenCodingFilter   filter    :    ZenCodingFilter . getInstances (  )  )     {", "if    ( suffix . equals ( filter . getSuffix (  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["checkFilterSuffix"], "fileName": "com.intellij.codeInsight.template.emmet.ZenCodingUtil"}, {"methodBody": ["METHOD_START", "{", "return   s . contains ( ZenCodingUtil . SURROUNDED _ TEXT _ MARKER )  ;", "}", "METHOD_END"], "methodName": ["containsSurroundedTextMarker"], "fileName": "com.intellij.codeInsight.template.emmet.ZenCodingUtil"}, {"methodBody": ["METHOD_START", "{", "String   s    =    ZenCodingUtil . replaceMarkers ( value ,    numberInIteration ,    totalIterations ,    surroundedText )  ;", "return   s . replace (  \"  \\  \"  \"  ,     \"  & quot ;  \"  )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.intellij.codeInsight.template.emmet.ZenCodingUtil"}, {"methodBody": ["METHOD_START", "{", "FileType   type    =    callback . getFileType (  )  ;", "if    (  ( type    =  =     ( StdFileTypes . HTML )  )     |  |     ( type    =  =     ( StdFileTypes . XHTML )  )  )     {", "return   true ;", "}", "return    ( type   instanceof   LanguageFileType )     &  &     (  (  ( LanguageFileType )     ( type )  )  . getLanguage (  )  . isKindOf ( HTMLLanguage . INSTANCE )  )  ;", "}", "METHOD_END"], "methodName": ["isHtml"], "fileName": "com.intellij.codeInsight.template.emmet.ZenCodingUtil"}, {"methodBody": ["METHOD_START", "{", "final   int   colon    =    str . indexOf (  '  :  '  )  ;", "if    (  ( colon    =  =     0  )     |  |     ( colon    =  =     (  ( str . length (  )  )     -     1  )  )  )     {", "return   false ;", "}", "if    ( colon    >     0  )     {", "final   String   prefix    =    str . substring (  0  ,    colon )  ;", "final   String   localPart    =    str . substring (  ( colon    +     1  )  )  ;", "return    ( XML 1  1 Char . isXML 1  1 ValidNCName ( prefix )  )     &  &     ( XML 1  1 Char . isXML 1  1 ValidNCName ( localPart )  )  ;", "}", "return   XML 1  1 Char . isXML 1  1 ValidNCName ( str )  ;", "}", "METHOD_END"], "methodName": ["isXML11ValidQName"], "fileName": "com.intellij.codeInsight.template.emmet.ZenCodingUtil"}, {"methodBody": ["METHOD_START", "{", "String   by    =    Integer . toString (  ( numberInIteration    +     1  )  )  ;", "StringBuilder   builder    =    new   StringBuilder ( s . length (  )  )  ;", "int   markerStartIndex    =     -  1  ;", "int   i    =     0  ;", "int   n    =    s . length (  )  ;", "while    ( i    <  =    n )     {", "char   c    =     ( i    <    n )     ?    s . charAt ( i )     :     0  ;", "if    (  ( c    =  =     '  \\  \\  '  )     &  &     ( i    <     ( n    -     1  )  )  )     {", "i +  +  ;", "builder . append ( s . charAt ( i )  )  ;", "} else", "if    (  ( c    =  =     (  . NUMBER _ IN _ ITERATION _ PLACE _ HOLDER )  )     &  &     (  ( i    =  =     ( n    -     1  )  )     |  |     (  ( s . charAt (  ( i    +     1  )  )  )     !  =     '  #  '  )  )  )     {", "if    ( markerStartIndex    =  =     (  -  1  )  )     {", "markerStartIndex    =    i ;", "}", "} else    {", "int   markersCount    =    i    -    markerStartIndex ;", "if    ( markerStartIndex    !  =     (  -  1  )  )     {", "boolean   decrement    =    false ;", "if    (  ( i    <    n )     &  &     (  ( s . charAt ( i )  )     =  =     '  @  '  )  )     {", "i +  +  ;", "if    (  ( i    <    n )     &  &     (  ( s . charAt ( i )  )     =  =     '  -  '  )  )     {", "decrement    =    true ;", "i +  +  ;", "}", "StringBuilder   base    =    new   StringBuilder (  )  ;", "while    (  ( i    <    n )     &  &     ( Character . isDigit ( s . charAt ( i )  )  )  )     {", "base . append ( s . charAt ( i )  )  ;", "i +  +  ;", "}", "int   baseInt    =     ( com . intellij . openapi . util . text . StringUtil . parseInt ( base . toString (  )  ,     0  )  )     -     1  ;", "baseInt    =     ( baseInt    >  =     0  )     ?    baseInt    :     0  ;", "if    ( baseInt    >  =     0  )     {", "int   byInt    =     ( decrement )     ?    totalIterations    -    numberInIteration    :    numberInIteration    +     1  ;", "byInt    +  =    baseInt ;", "by    =    Integer . toString ( byInt )  ;", "}", "}", "for    ( int   k    =     0  ,    m    =    markersCount    -     ( by . length (  )  )  ;    k    <    m ;    k +  +  )     {", "builder . append (  '  0  '  )  ;", "}", "builder . append ( by )  ;", "markerStartIndex    =     -  1  ;", "c    =     ( i    <    n )     ?    s . charAt ( i )     :     0  ;", "}", "if    ( i    <    n )     {", "if    (  ( c    =  =     (  . NUMBER _ IN _ ITERATION _ PLACE _ HOLDER )  )     &  &     ( surroundedText    !  =    null )  )     {", "builder . append ( surroundedText )  ;", "i +  +  ;", "} else    {", "builder . append ( c )  ;", "}", "}", "}", "i +  +  ;", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["replaceMarkers"], "fileName": "com.intellij.codeInsight.template.emmet.ZenCodingUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( current    =  =    null )", "return   false ;", "if    (  ( current . getParent (  )  )    instanceof   XmlText )     {", "final   int   line    =    doc . getLineNumber ( offset )  ;", "final   int   lineStart    =    doc . getLineStartOffset ( line )  ;", "final   int   lineEnd    =    doc . getLineEndOffset ( line )  ;", "final   CharSequence   text    =    doc . getCharsSequence (  )  . subSequence ( lineStart ,    lineEnd )  ;", "if    (  ( StringUtil . isEmptyOrSpaces ( text )  )     &  &     (  . moveCaret ( editor ,    current ,    lineEnd )  )  )     {", "return   true ;", "}", "} else", "if    (  (  . isEmptyEditPoint ( current )  )     &  &     (  . moveCaret ( editor ,    current ,    current . getTextRange (  )  . getStartOffset (  )  )  )  )     {", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["checkAndMove"], "fileName": "com.intellij.codeInsight.template.emmet.actions.EmmetEditPointUtil"}, {"methodBody": ["METHOD_START", "{", "final   IElementType   type    =    element . getNode (  )  . getElementType (  )  ;", "if    ( type    =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ END _ DELIMITER )  )     {", "final   PsiElement   prev    =    PsiTree . prevLeaf ( element )  ;", "return    ( prev    !  =    null )     &  &     (  ( prev . getNode (  )  . getElementType (  )  )     =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ START _ DELIMITER )  )  ;", "}", "if    (  ( type    =  =     ( XmlTokenType . XML _ END _ TAG _ START )  )     |  |     ( type    =  =     ( XmlTokenType . XML _ START _ TAG _ START )  )  )     {", "final   PsiElement   prev    =    PsiTree . prevLeaf ( element )  ;", "return    ( prev    !  =    null )     &  &     (  ( prev . getNode (  )  . getElementType (  )  )     =  =     ( XmlTokenType . XML _ TAG _ END )  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isEmptyEditPoint"], "fileName": "com.intellij.codeInsight.template.emmet.actions.EmmetEditPointUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( XmlGtTypedHandler . fileContainsXmlLanguage ( file )  )  )", "return ;", ". moveToNextPoint ( editor ,    file ,    editor . getCaretModel (  )  . getOffset (  )  ,     (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["moveBackward"], "fileName": "com.intellij.codeInsight.template.emmet.actions.EmmetEditPointUtil"}, {"methodBody": ["METHOD_START", "{", "editor    =    InjectedLanguageUtil . getInjectedEditorForInjectedFile ( editor ,    current . getContainingFile (  )  )  ;", "final   CaretModel   caretModel    =    editor . getCaretModel (  )  ;", "if    (  ( caretModel . getOffset (  )  )     =  =    offset )", "return   false ;", "caretModel . moveToOffset ( offset )  ;", "final   Caret   caret    =    caretModel . getCurrentCaret (  )  ;", "ScrollingModel   scrollingModel    =    editor . getScrollingModel (  )  ;", "if    ( caret    =  =     ( caretModel . getPrimaryCaret (  )  )  )     {", "scrollingModel . scrollToCaret ( RELATIVE )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["moveCaret"], "fileName": "com.intellij.codeInsight.template.emmet.actions.EmmetEditPointUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( XmlGtTypedHandler . fileContainsXmlLanguage ( file )  )  )", "return ;", ". moveToNextPoint ( editor ,    file ,    editor . getCaretModel (  )  . getOffset (  )  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["moveForward"], "fileName": "com.intellij.codeInsight.template.emmet.actions.EmmetEditPointUtil"}, {"methodBody": ["METHOD_START", "{", "final   Document   doc    =    editor . getDocument (  )  ;", "final   TemplateLanguageFileViewProvider   provider    =    ObjectUtils . tryCast ( file . getViewProvider (  )  ,    TemplateLanguageFileViewProvider . class )  ;", "final   Language   additionalLanguage    =     ( provider    !  =    null )     ?    provider . getTemplateDataLanguage (  )     :    null ;", "PsiDocumentManager . getInstance ( file . getProject (  )  )  . commitDocument ( doc )  ;", "for    ( int   i    =    offset    +    inc ;     ( i    <     ( doc . getTextLength (  )  )  )     &  &     ( i    >  =     0  )  ;    i    +  =    inc )     {", "PsiElement   current    =    InjectedLanguageUtil . findElementAtNoCommit ( file ,    i )  ;", "if    (  . checkAndMove ( editor ,    doc ,    i ,    current )  )", "return ;", "if    ( additionalLanguage    !  =    null )     {", "current    =    provider . findElementAt ( i ,    additionalLanguage )  ;", "if    (  . checkAndMove ( editor ,    doc ,    i ,    current )  )", "return ;", "}", "}", "}", "METHOD_END"], "methodName": ["moveToNextPoint"], "fileName": "com.intellij.codeInsight.template.emmet.actions.EmmetEditPointUtil"}, {"methodBody": ["METHOD_START", "{", "return   PSI _ FILE . getData ( context )  ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "com.intellij.codeInsight.template.emmet.actions.GoToEditPointAction"}, {"methodBody": ["METHOD_START", "{", "final   BemEmmetFilter . BemState   result    =    new   BemEmmetFilter . BemState (  )  ;", "int   indexOfElementSeparator    =    className . indexOf ( elementSeparator )  ;", "if    ( indexOfElementSeparator    >  =     0  )     {", "result . setBlock ( className . substring (  0  ,    indexOfElementSeparator )  )  ;", "result . setElement ( className . substring (  ( indexOfElementSeparator    +     ( elementSeparator . length (  )  )  )  )  )  ;", "int   lastIndexOfElementSeparator    =    className . lastIndexOf ( elementSeparator )  ;", "assert   lastIndexOfElementSeparator    >  =     0  ;", "int   indexOfModifierSeparator    =    className . indexOf ( modifierSeparator ,     ( lastIndexOfElementSeparator    +     ( elementSeparator . length (  )  )  )  )  ;", "if    ( indexOfModifierSeparator    >  =     0  )     {", "result . setModifier ( className . substring (  ( indexOfModifierSeparator    +     ( modifierSeparator . length (  )  )  )  )  )  ;", "result . setElement ( className . substring (  ( indexOfElementSeparator    +     ( elementSeparator . length (  )  )  )  ,    indexOfModifierSeparator )  )  ;", "}", "} else    {", "int   indexOfModifierSeparator    =    className . indexOf ( modifierSeparator )  ;", "if    ( indexOfModifierSeparator    >  =     0  )     {", "result . setBlock ( className . substring (  0  ,    indexOfModifierSeparator )  )  ;", "result . setModifier ( className . substring (  ( indexOfModifierSeparator    +     ( modifierSeparator . length (  )  )  )  )  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["extractBemStateFromClassName"], "fileName": "com.intellij.codeInsight.template.emmet.filters.BemEmmetFilter"}, {"methodBody": ["METHOD_START", "{", "return   BemEmmetFilter . transformClassNameToBemFormat ( className ,    separator ,    node ,    false )  ;", "}", "METHOD_END"], "methodName": ["fillWithBemElements"], "fileName": "com.intellij.codeInsight.template.emmet.filters.BemEmmetFilter"}, {"methodBody": ["METHOD_START", "{", "return   BemEmmetFilter . transformClassNameToBemFormat ( className ,    separator ,    node ,    true )  ;", "}", "METHOD_END"], "methodName": ["fillWithBemModifiers"], "fileName": "com.intellij.codeInsight.template.emmet.filters.BemEmmetFilter"}, {"methodBody": ["METHOD_START", "{", "int   result    =     0  ;", "while    (  (  !  ( separator . isEmpty (  )  )  )     &  &     ( name . startsWith ( separator )  )  )     {", "result +  +  ;", "name    =    name . substring ( separator . length (  )  )  ;", "}", "return   Pair . create ( name ,    result )  ;", "}", "METHOD_END"], "methodName": ["getCleanStringAndDepth"], "fileName": "com.intellij.codeInsight.template.emmet.filters.BemEmmetFilter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( shortElementPrefix . isEmpty (  )  )     |  |     (  !  ( className . startsWith ( shortElementPrefix )  )  )  )     {", "return   className ;", "}", "StringBuilder   result    =    new   StringBuilder (  )  ;", "while    ( className . startsWith ( shortElementPrefix )  )     {", "className    =    className . substring ( shortElementPrefix . length (  )  )  ;", "result . append ( elementSeparator )  ;", "}", "return   result . append ( className )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["normalizeClassName"], "fileName": "com.intellij.codeInsight.template.emmet.filters.BemEmmetFilter"}, {"methodBody": ["METHOD_START", "{", "className    =    BemEmmetFilter . fillWithBemElements ( className ,    node ,    elementSeparator )  ;", "className    =    BemEmmetFilter . fillWithBemModifiers ( className ,    node ,    modifierSeparator )  ;", "BemEmmetFilter . BemState   nodeBemState    =    BemEmmetFilter . BEM _ STATE . get ( node )  ;", "BemEmmetFilter . BemState   bemState    =    BemEmmetFilter . extractBemStateFromClassName ( className ,    elementSeparator ,    modifierSeparator )  ;", "List < String >    result    =    ContainerUtil . newArrayList (  )  ;", "if    (  !  ( bemState . isEmpty (  )  )  )     {", "String   nodeBlockValue    =     ( nodeBemState    !  =    null )     ?    nodeBemState . getBlock (  )     :    null ;", "String   block    =    bemState . getBlock (  )  ;", "if    ( StringUtil . isEmpty ( block )  )     {", "block    =    StringUtil . notNullize ( nodeBlockValue )  ;", "bemState . setBlock ( block )  ;", "}", "String   prefix    =    block ;", "String   element    =    bemState . getElement (  )  ;", "if    ( StringUtil . isNotEmpty ( element )  )     {", "prefix    +  =    elementSeparator    +    element ;", "}", "result . add ( prefix )  ;", "String   modifier    =    bemState . getModifier (  )  ;", "if    ( StringUtil . isNotEmpty ( modifier )  )     {", "result . add (  (  ( prefix    +    modifierSeparator )     +    modifier )  )  ;", "}", "BemEmmetFilter . BemState   newNodeBemState    =    bemState . copy (  )  ;", "if    (  ( StringUtil . isNotEmpty ( nodeBlockValue )  )     &  &     ( StringUtil . isEmpty ( modifier )  )  )     {", "newNodeBemState . setBlock ( nodeBlockValue )  ;", "}", "BemEmmetFilter . BEM _ STATE . set ( node ,    newNodeBemState )  ;", "} else    {", "result . add ( className )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["processClassName"], "fileName": "com.intellij.codeInsight.template.emmet.filters.BemEmmetFilter"}, {"methodBody": ["METHOD_START", "{", "String   result    =    ContainerUtil . find ( classNames ,     (    className )     -  >    BemEmmetFilter . BLOCK _ NAME _ PATTERN . matcher ( className )  . matches (  )  )  ;", "if    ( result    =  =    null )     {", "result    =    ContainerUtil . find ( classNames ,     (    s )     -  >     (  ( s    !  =    null )     &  &     (  !  ( s . isEmpty (  )  )  )  )     &  &     ( Character . isLetter ( s . charAt (  0  )  )  )  )  ;", "}", "return   StringUtil . notNullize ( result )  ;", "}", "METHOD_END"], "methodName": ["suggestBlockName"], "fileName": "com.intellij.codeInsight.template.emmet.filters.BemEmmetFilter"}, {"methodBody": ["METHOD_START", "{", "Pair < String ,    Integer >    cleanStringAndDepth    =    BemEmmetFilter . getCleanStringAndDepth ( className ,    separator )  ;", "Integer   depth    =    cleanStringAndDepth . second ;", "if    ( depth    >     0  )     {", "GenerationNode   donor    =    node ;", "while    (  (  ( donor . getParent (  )  )     !  =    null )     &  &     ( depth    >     0  )  )     {", "donor    =    donor . getParent (  )  ;", "depth -  -  ;", "}", "BemEmmetFilter . BemState   bemState    =    BemEmmetFilter . BEM _ STATE . get ( donor )  ;", "if    ( bemState    !  =    null )     {", "String   prefix    =    bemState . getBlock (  )  ;", "if    (  !  ( StringUtil . isEmpty ( prefix )  )  )     {", "String   element    =    bemState . getElement (  )  ;", "if    ( isModifierSeparator    &  &     (  !  ( StringUtil . isEmpty ( element )  )  )  )     {", "prefix    =     ( prefix    +    separator )     +    element ;", "}", "return    ( prefix    +    separator )     +     ( cleanStringAndDepth . first )  ;", "}", "}", "}", "return   className ;", "}", "METHOD_END"], "methodName": ["transformClassNameToBemFormat"], "fileName": "com.intellij.codeInsight.template.emmet.filters.BemEmmetFilter"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "if    (  !  ( isNullOrEmpty ( idAttr )  )  )     {", "builder . append (  '  #  '  )  . append ( idAttr )  ;", "}", "if    (  !  ( isNullOrEmpty ( classAttr )  )  )     {", "builder . append (  '  .  '  )  . append ( classAttr )  ;", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["buildCommentString"], "fileName": "com.intellij.codeInsight.template.emmet.filters.CommentZenCodingFilter"}, {"methodBody": ["METHOD_START", "{", "final   String   surroundedText    =    node . getSurroundedText (  )  ;", "if    ( surroundedText    !  =    null )     {", "node . setSurroundedText (  . PATTERN . matcher ( surroundedText )  . replaceAll (  \"  \"  )  )  ;", "}", "for    ( GenerationNode   child    :    node . getChildren (  )  )     {", ". doFilter ( child )  ;", "}", "}", "METHOD_END"], "methodName": ["doFilter"], "fileName": "com.intellij.codeInsight.template.emmet.filters.TrimZenCodingFilter"}, {"methodBody": ["METHOD_START", "{", "if    ( hasChildren )     {", "Str   name    =    tag . getLocalName (  )  ;", "return    ( name . equals (  \" with - param \"  )  )     |  |     ( name . equals (  \" variable \"  )  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isOurTag"], "fileName": "com.intellij.codeInsight.template.emmet.filters.XslZenCodingFilter"}, {"methodBody": ["METHOD_START", "{", "return   node ;", "}", "METHOD_END"], "methodName": ["filterNode"], "fileName": "com.intellij.codeInsight.template.emmet.filters.ZenCodingFilter"}, {"methodBody": ["METHOD_START", "{", "return   text ;", "}", "METHOD_END"], "methodName": ["filterText"], "fileName": "com.intellij.codeInsight.template.emmet.filters.ZenCodingFilter"}, {"methodBody": ["METHOD_START", "{", "List < ZenCodingFilter >    generators    =    new   ArrayList <  >  (  )  ;", "Collections . addAll ( generators ,    ZenCodingFilter . OUR _ STANDARD _ FILTERS )  ;", "Collections . addAll ( generators ,    ZenCodingFilter . EP _ NAME . getExtensions (  )  )  ;", "return   generators ;", "}", "METHOD_END"], "methodName": ["getInstances"], "fileName": "com.intellij.codeInsight.template.emmet.filters.ZenCodingFilter"}, {"methodBody": ["METHOD_START", "{", "return   EmmetOptions . getInstance (  )  . isFilterEnabledByDefault ( this )  ;", "}", "METHOD_END"], "methodName": ["isAppliedByDefault"], "fileName": "com.intellij.codeInsight.template.emmet.filters.ZenCodingFilter"}, {"methodBody": ["METHOD_START", "{", "return   values . charAt ( rand (  0  ,     (  ( values . length (  )  )     -     1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["choice"], "fileName": "com.intellij.codeInsight.template.emmet.generators.LoremGenerator"}, {"methodBody": ["METHOD_START", "{", "Collection < String >    sentences    =    new   LinkedList <  >  (  )  ;", "int   totalWords    =     0  ;", "String [  ]    words ;", "if    ( startWithCommon )     {", "words    =    Arrays . copyOfRange (  . COMMON _ P ,     0  ,    Math . min ( wordsCount ,     . COMMON _ P . length )  )  ;", "if    (  ( words . length )     >     5  )     {", "words [  4  ]     +  =     '  ,  '  ;", "}", "totalWords    +  =    words . length ;", "sentences . add (  . sentence ( words ,     '  .  '  )  )  ;", "}", "while    ( totalWords    <    wordsCount )     {", "words    =    sample (  . WORDS ,    Math . min (  (  ( rand (  3  ,     1  2  )  )     *     ( rand (  1  ,     5  )  )  )  ,     ( wordsCount    -    totalWords )  )  )  ;", "totalWords    +  =    words . length ;", "insertCommas ( words )  ;", "sentences . add ( sentence ( words )  )  ;", "}", "return   StringUtil . join ( sentences ,     \"     \"  )  ;", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "com.intellij.codeInsight.template.emmet.generators.LoremGenerator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( words . length )     <  =     1  )     {", "return ;", "}", "len    =    words . length ;", "totalCommas ;", "if    (  ( len    >     3  )     &  &     ( len    <  =     6  )  )     {", "totalCommas    =    rand (  0  ,     1  )  ;", "} else", "if    (  ( len    >     6  )     &  &     ( len    <  =     1  2  )  )     {", "totalCommas    =    rand (  0  ,     2  )  ;", "} else    {", "totalCommas    =    rand (  1  ,     4  )  ;", "}", "while    ( totalCommas    >     0  )     {", "i    =    rand (  0  ,     (  ( words . length )     -     1  )  )  ;", "String   word    =    words [ i ]  ;", "if    (  !  ( StringUtil . endsWithChar ( word ,     '  ,  '  )  )  )     {", "words [ i ]     =    word    +     \"  ,  \"  ;", "}", "totalCommas -  -  ;", "}", "}", "METHOD_END"], "methodName": ["insertCommas"], "fileName": "com.intellij.codeInsight.template.emmet.generators.LoremGenerator"}, {"methodBody": ["METHOD_START", "{", "return    ( random . nextInt (  ( to    -    from )  )  )     +    from ;", "}", "METHOD_END"], "methodName": ["rand"], "fileName": "com.intellij.codeInsight.template.emmet.generators.LoremGenerator"}, {"methodBody": ["METHOD_START", "{", "int   len    =    words . length ;", "int   itions    =    Math . min ( len ,    wordsCount )  ;", "Set < String >    result    =    new   TreeSet <  >  (  )  ;", "while    (  ( result . size (  )  )     <    itions )     {", "int   i    =    rand (  0  ,     ( len    -     1  )  )  ;", "result . add ( words [ i ]  )  ;", "}", "return   ArrayUtil . toStringArray ( result )  ;", "}", "METHOD_END"], "methodName": ["sample"], "fileName": "com.intellij.codeInsight.template.emmet.generators.LoremGenerator"}, {"methodBody": ["METHOD_START", "{", "return   LoremGenerator . sentence ( words ,    choice (  \"  ?  !  .  .  .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["sentence"], "fileName": "com.intellij.codeInsight.template.emmet.generators.LoremGenerator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( words . length )     >     0  )     {", "words [  0  ]     =    StringUtil . capitalize ( words [  0  ]  )  ;", "}", "return    ( StringUtil . join ( words ,     \"     \"  )  )     +    endChar ;", "}", "METHOD_END"], "methodName": ["sentence"], "fileName": "com.intellij.codeInsight.template.emmet.generators.LoremGenerator"}, {"methodBody": ["METHOD_START", "{", "PsiElement   context    =    file . getContext (  )  ;", "if    ( context    !  =    null )     {", "String   contextText    =    contextText (  )  ;", "if    ( StringUtil . startsWithChar ( contextText ,     '  \"  '  )  )     {", "return   StringUtil . escapeChar ( text ,     '  \"  '  )  ;", "} else", "if    ( StringUtil . startsWithChar ( contextText ,     '  \\  '  '  )  )     {", "return   StringUtil . escapeChar ( text ,     '  \\  '  '  )  ;", "}", "}", "return   text ;", "}", "METHOD_END"], "methodName": ["replaceQuotesIfNeeded"], "fileName": "com.intellij.codeInsight.template.emmet.generators.XmlZenCodingGenerator"}, {"methodBody": ["METHOD_START", "{", "CodeStyleSettings . QuoteStyle   quoteStyle    =    XmlEditUtil . quoteStyle ( context . getContainingFile (  )  )  ;", "XmlTag   tag    =    token . getXmlTag (  )  ;", "if    ( tag    !  =    null )     {", "if    ( quoteStyle    !  =     ( QuoteStyle . None )  )     {", "DocumentUtil . writeInRunUndoTransparentAction (  (  )     -  >    HtmlQuotesFormatPreprocessor . HtmlQuotesConverter . runOnElement ( quoteStyle ,    tag )  )  ;", "}", "return    . replaceQuotesIfNeeded ( toString ( tag ,    token . getAttributes (  )  ,    hasChildren ,    context )  ,    context . getContainingFile (  )  )  ;", "}", "PsiFile   file    =    token . getFile (  )  ;", "if    ( quoteStyle    !  =     ( QuoteStyle . None )  )     {", "DocumentUtil . writeInRunUndoTransparentAction (  (  )     -  >    HtmlQuotesFormatPreprocessor . HtmlQuotesConverter . runOnElement ( quoteStyle ,    file )  )  ;", "}", "return    . replaceQuotesIfNeeded ( file . getText (  )  ,    context . getContainingFile (  )  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.codeInsight.template.emmet.generators.XmlZenCodingGenerator"}, {"methodBody": ["METHOD_START", "{", "final   List < SmartPsiElementPointer < XmlTag >  >    tagToClose    =    new   ArrayList <  >  (  )  ;", "Project   project    =    root . getProject (  )  ;", "final   SmartPointerManager   pointerManager    =    SmartPointerManager . getInstance ( project )  ;", "root . accept ( new   XmlRecursiveElementVisitor (  )     {", "@ Override", "public   void   visitXmlTag ( final   XmlTag   tag )     {", "if    (  !  (  . isTagClosed ( tag )  )  )     {", "tagToClose . add ( pointerManager . createSmartPsiElementPointer ( tag )  )  ;", "}", "}", "}  )  ;", "final   PsiDocumentManager   documentManager    =    PsiDocumentManager . getInstance ( project )  ;", "for    ( final   SmartPsiElementPointer < XmlTag >    pointer    :    tagToClose )     {", "final   XmlTag   tag    =    pointer . getElement (  )  ;", "if    ( tag    !  =    null )     {", "final   ASTNode   child    =    XmlChildRole . START _ TAG _ END _ FINDER . findChild ( tag . getNode (  )  )  ;", "if    ( child    !  =    null )     {", "final   int   offset    =    child . getTextRange (  )  . getStartOffset (  )  ;", "VirtualFile   file    =    tag . getContainingFile (  )  . getVirtualFile (  )  ;", "if    ( file    !  =    null )     {", "final   Document   document    =    FileDocumentManager . getInstance (  )  . getDocument ( file )  ;", "if    ( document    !  =    null )     {", "documentManager . doPostponedOperationsAndUnblockDocument ( document )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >     {", "document . replaceString ( offset ,    tag . getTextRange (  )  . getEndOffset (  )  ,     \"  /  >  \"  )  ;", "documentManager . commitDocument ( document )  ;", "}  )  ;", "}", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["closeUnclosingTags"], "fileName": "com.intellij.codeInsight.template.emmet.generators.XmlZenCodingGeneratorImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( name    +     \"  =  \\  \"  \"  )     +    value )     +     '  \"  '  ;", "}", "METHOD_END"], "methodName": ["getAttributeString"], "fileName": "com.intellij.codeInsight.template.emmet.generators.XmlZenCodingGeneratorImpl"}, {"methodBody": ["METHOD_START", "{", "return    ( isMyLanguage ( context . getLanguage (  )  )  )     &  &     ( wrapping    |  |     ( HtmlTextContextType . isInContext ( context )  )  )  ;", "}", "METHOD_END"], "methodName": ["isMyContext"], "fileName": "com.intellij.codeInsight.template.emmet.generators.XmlZenCodingGeneratorImpl"}, {"methodBody": ["METHOD_START", "{", "return   language   instanceof   XMLLanguage ;", "}", "METHOD_END"], "methodName": ["isMyLanguage"], "fileName": "com.intellij.codeInsight.template.emmet.generators.XmlZenCodingGeneratorImpl"}, {"methodBody": ["METHOD_START", "{", "ASTNode   node    =    tag . getNode (  )  ;", "assert   node    !  =    null ;", "final   ASTNode   emptyTagEnd    =    XmlChildRole . EMPTY _ TAG _ END _ FINDER . findChild ( node )  ;", "final   ASTNode   endTagEnd    =    XmlChildRole . CLOSING _ TAG _ START _ FINDER . findChild ( node )  ;", "return    ( emptyTagEnd    !  =    null )     |  |     ( endTagEnd    !  =    null )  ;", "}", "METHOD_END"], "methodName": ["isTagClosed"], "fileName": "com.intellij.codeInsight.template.emmet.generators.XmlZenCodingGeneratorImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( type    =  =     ( StdFileTypes . XHTML )  )     |  |     ( type    =  =     ( StdFileTypes . JSPX )  )  )     |  |     ( type    =  =     ( StdFileTypes . XML )  )  ;", "}", "METHOD_END"], "methodName": ["isTrueXml"], "fileName": "com.intellij.codeInsight.template.emmet.generators.XmlZenCodingGeneratorImpl"}, {"methodBody": ["METHOD_START", "{", "int   currentOffset    =    text . length (  )  ;", "int   groupCount    =     0  ;", "int   bracketCount    =     0  ;", "int   textCount    =     0  ;", "while    ( currentOffset    >     0  )     {", "currentOffset -  -  ;", "char   c    =    text . charAt ( currentOffset )  ;", "if    ( c    =  =     '  ]  '  )     {", "bracketCount +  +  ;", "} else", "if    ( c    =  =     '  [  '  )     {", "if    ( bracketCount    =  =     0  )     {", "currentOffset +  +  ;", "break ;", "}", "bracketCount -  -  ;", "} else", "if    ( c    =  =     '  }  '  )     {", "textCount +  +  ;", "} else", "if    ( c    =  =     '  {  '  )     {", "if    ( textCount    =  =     0  )     {", "currentOffset +  +  ;", "break ;", "}", "textCount -  -  ;", "} else", "if    ( c    =  =     '  )  '  )     {", "groupCount +  +  ;", "} else", "if    ( c    =  =     '  (  '  )     {", "if    ( groupCount    =  =     0  )     {", "currentOffset +  +  ;", "break ;", "}", "groupCount -  -  ;", "} else    {", "if    (  ( bracketCount    >     0  )     |  |     ( textCount    >     0  )  )     {", "continue ;", "}", "if    (  !  ( isAllowedChar ( c )  )  )     {", "currentOffset +  +  ;", "break ;", "}", "}", "}", "return    (  (  (  ( groupCount    =  =     0  )     &  &     ( textCount    =  =     0  )  )     &  &     ( bracketCount    =  =     0  )  )     &  &     ( currentOffset    >  =     0  )  )     &  &     ( currentOffset    <     ( text . length (  )  )  )     ?    text . subSequence ( currentOffset ,    text . length (  )  )  . toString (  )  . replaceFirst (  \"  ^  [  *  +  >  ^  ]  +  \"  ,     \"  \"  )     :    null ;", "}", "METHOD_END"], "methodName": ["computeKey"], "fileName": "com.intellij.codeInsight.template.emmet.generators.ZenCodingGenerator"}, {"methodBody": ["METHOD_START", "{", "Editor   editor    =    callback . getEditor (  )  ;", "int   currentOffset    =    editor . getCaretModel (  )  . getOffset (  )  ;", "int   startOffset    =    editor . getDocument (  )  . getLineStartOffset ( editor . getCaretModel (  )  . getLogicalPosition (  )  . line )  ;", "String   key    =    computeKey ( editor . getDocument (  )  . getCharsSequence (  )  . subSequence ( startOffset ,    currentOffset )  )  ;", "return    (  !  ( StringUtil . isEmpty ( key )  )  )     &  &     ( Template . checkTemplateKey ( key ,    callback ,    this )  )     ?    key    :    null ;", "}", "METHOD_END"], "methodName": ["computeTemplateKey"], "fileName": "com.intellij.codeInsight.template.emmet.generators.ZenCodingGenerator"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["createConfigurable"], "fileName": "com.intellij.codeInsight.template.emmet.generators.ZenCodingGenerator"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlEmmetParser ( tokens ,    callback ,    generator ,    surroundWithTemplate )  ;", "}", "METHOD_END"], "methodName": ["createParser"], "fileName": "com.intellij.codeInsight.template.emmet.generators.ZenCodingGenerator"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["createTemplateByKey"], "fileName": "com.intellij.codeInsight.template.emmet.generators.ZenCodingGenerator"}, {"methodBody": ["METHOD_START", "{", "return   ZenCodingGenerator . EP _ NAME . getExtensions (  )  ;", "}", "METHOD_END"], "methodName": ["getInstances"], "fileName": "com.intellij.codeInsight.template.emmet.generators.ZenCodingGenerator"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getSuffix"], "fileName": "com.intellij.codeInsight.template.emmet.generators.ZenCodingGenerator"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["hasCompletionItem"], "fileName": "com.intellij.codeInsight.template.emmet.generators.ZenCodingGenerator"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Character . isDigit ( c )  )     |  |     ( Character . isLetter ( c )  )  )     |  |     ( StringUtil . containsChar (  \"  /  >  +  ^  [  ]  (  )  {  }  #  .  *  :  $  -  _  !  @  |  %  \"  ,    c )  )  ;", "}", "METHOD_END"], "methodName": ["isAllowedChar"], "fileName": "com.intellij.codeInsight.template.emmet.generators.ZenCodingGenerator"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isHtml"], "fileName": "com.intellij.codeInsight.template.emmet.generators.ZenCodingGenerator"}, {"methodBody": ["METHOD_START", "{", "return   myLeftOperand ;", "}", "METHOD_END"], "methodName": ["getLeftOperand"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.AddOperationNode"}, {"methodBody": ["METHOD_START", "{", "return   myRightOperand ;", "}", "METHOD_END"], "methodName": ["getRightOperand"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.AddOperationNode"}, {"methodBody": ["METHOD_START", "{", "return   myLeftOperand ;", "}", "METHOD_END"], "methodName": ["getLeftOperand"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.ClimbUpOperationNode"}, {"methodBody": ["METHOD_START", "{", "return   myRightOperand ;", "}", "METHOD_END"], "methodName": ["getRightOperand"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.ClimbUpOperationNode"}, {"methodBody": ["METHOD_START", "{", "return   myFilter ;", "}", "METHOD_END"], "methodName": ["getFilter"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.FilterNode"}, {"methodBody": ["METHOD_START", "{", "return   myNode ;", "}", "METHOD_END"], "methodName": ["getNode"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.FilterNode"}, {"methodBody": ["METHOD_START", "{", "child . setParent ( this )  ;", "myChildren . add ( child )  ;", "}", "METHOD_END"], "methodName": ["addChild"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "for    ( GenerationNode   child    :    children )     {", "addChild ( child )  ;", "}", "}", "METHOD_END"], "methodName": ["addChildren"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "if    ( generator    =  =    null )     {", "return   Collections . emptyMap (  )  ;", "}", "for    ( String   value    :    attributes . values (  )  )     {", "if    ( ZenCodingUtil . containsSurroundedTextMarker ( value )  )     {", "myContainsSurroundedTextMarker    =    true ;", "break ;", "}", "}", "String   attributesString    =    generator . buildAttributesString ( attributes ,    hasChildren ,    myNumberInIt ,    myTotalIts ,    mySurroundedText )  ;", "attributesString    =     (  ( attributesString . length (  )  )     >     0  )     ?     '     '     +    attributesString    :    null ;", "Map < String ,    String >    predefinedValues    =    null ;", "if    ( attributesString    !  =    null )     {", "predefinedValues    =    new   HashMap <  >  (  )  ;", "predefinedValues . put ( TemplateToken . ATTRS ,    attributesString )  ;", "}", "return   predefinedValues ;", "}", "METHOD_END"], "methodName": ["buildPredefinedValues"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "boolean   flag    =    false ;", "for    ( PsiElement   child    :    tag . getChildren (  )  )     {", "if    (  ( child   instanceof   XmlToken )     &  &     ( XmlTokenType . XML _ EMPTY _ ELEMENT _ END . equals (  (  ( XmlToken )     ( child )  )  . getTokenType (  )  )  )  )     {", "flag    =    true ;", "break ;", "}", "builder . append ( child . getText (  )  )  ;", "}", "if    ( flag )     {", "builder . append (  \"  >  <  /  \"  )  . append ( tag . getName (  )  )  . append (  '  >  '  )  ;", "return   XmlElementFactory . gettance ( tag . getProject (  )  )  . createTagFromText ( builder . toString (  )  ,    XMLLanguage . INSTANCE )  ;", "}", "return   tag ;", "}", "METHOD_END"], "methodName": ["expandEmptyTagIfNecessary"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "LiveTemplateBuilder   builder    =    new   LiveTemplateBuilder ( EmmetOptions . getInstance (  )  . isAddEditPointAtTheEndOfTemplate (  )  ,    segmentsLimit )  ;", "if    (  ( predefinedVarValues    =  =    null )     &  &     ( surroundedText    =  =    null )  )     {", "return    ;", "}", "int   offset    =    builder . insertTemplate (  0  ,     ,    predefinedVarValues )  ;", "if    ( surroundedText    !  =    null )     {", "builder . insertText ( offset ,    surroundedText ,    true )  ;", "builder . setIsToReformat ( true )  ;", "}", "return   builder . buildTemplate (  )  ;", "}", "METHOD_END"], "methodName": ["expandTemplate"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "for    ( XmlAttribute   attribute    :    attributes )     {", "final   String   attributeValue    =    attribute . getValue (  )  ;", "if    (  . isEmptyValue ( attributeValue )  )     {", "return   attribute ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findEmptyAttribute"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "for    ( XmlAttribute   attribute    :    attributes )     {", "if    (  (  ( attribute . getValueElement (  )  )     !  =    null )     &  &     (  . isImpliedAttribute ( attribute . getLocalName (  )  )  )  )     {", "return   attribute ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findImpliedAttribute"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "myContainsSurroundedTextMarker    =     !  ( insertSurroundedText    &  &     ( myInsertSurroundedTextAtTheEnd )  )  ;", "generationNode    =    this ;", "if    ( generationNode    !  =     ( this )  )     {", "return   generationNode . generate ( callback ,    generator ,    Collections . emptyList (  )  ,    insertSurroundedText ,    segmentsLimit )  ;", "}", "boolean   shouldNotReformatTemplate    =    false ;", "boolean   oneLineTemplateExpanding    =    false ;", "for    ( ZenCodingFilter   filter    :    filters )     {", "generationNode    =    filter . filterNode ( generationNode )  ;", "if    ( filter   instanceof   SingleLineEmmetFilter )     {", "shouldNotReformatTemplate    =    true ;", "oneLineTemplateExpanding    =    true ;", "}", "}", "CodeStyleSettings   settings    =    CodeStyleSettingsManager . getSettings ( callback . getProject (  )  )  ;", "String   indentStr ;", "if    ( callback . isInInjectedFragment (  )  )     {", "Editor   editor    =    callback . getEditor (  )  ;", "Document   document    =    editor . getDocument (  )  ;", "if    (  ( document   instanceof   DocumentWindow )     &  &     (  (  ( DocumentWindow )     ( document )  )  . isOneLine (  )  )  )     {", "oneLineTemplateExpanding    =    true ;", "filters . add ( new   SingleLineEmmetFilter (  )  )  ;", "}", "indentStr    =     \"  \"  ;", "} else", "if    ( settings . useTabCharacter ( callback . getFileType (  )  )  )     {", "indentStr    =     \"  \\ t \"  ;", "} else    {", "int   tabSize    =    settings . getTabSize ( callback . getFileType (  )  )  ;", "indentStr    =    com . intellij . openapi . util . text . StringUtil . repeatSymbol (  '     '  ,    tabSize )  ;", "}", "LiveTemplateBuilder   builder    =    new   LiveTemplateBuilder ( EmmetOptions . getInstance (  )  . isAddEditPointAtTheEndOfTemplate (  )  ,    segmentsLimit )  ;", "int   end    =     -  1  ;", "boolean   hasChildren    =     ( myChildren . size (  )  )     >     0  ;", "TemplateImpl   parentTemplate ;", "Map < String ,    String >    predefinedValues ;", "if    ( generator   instanceof   XmlZenCodingGenerator )     {", "TemplateToken   xmlTemplateToken    =    myTemplateToken ;", "parentTemplate    =    invokeXmlTemplate ( xmlTemplateToken ,    callback ,    generator ,    hasChildren )  ;", "predefinedValues    =    buildPredefinedValues ( xmlTemplateToken . getAttributes (  )  ,     (  ( XmlZenCodingGenerator )     ( generator )  )  ,    hasChildren )  ;", "} else    {", "parentTemplate    =     . invokeTemplate ( myTemplateToken ,    hasChildren ,    callback ,    generator )  ;", "predefinedValues    =    null ;", "}", "String   s    =    parentTemplate . getString (  )  ;", "for    ( ZenCodingFilter   filter    :    filters )     {", "s    =    filter . filterText ( s ,    myTemplateToken )  ;", "}", "parentTemplate    =    parentTemplate . copy (  )  ;", "parentTemplate . setString ( s )  ;", "final   String   txt    =     ( hasChildren    |  |     ( myContainsSurroundedTextMarker )  )     ?    null    :    mySurroundedText ;", "parentTemplate    =     . expandTemplate ( parentTemplate ,    predefinedValues ,    txt ,    segmentsLimit )  ;", "int   offset    =    builder . insertTemplate (  0  ,    parentTemplate ,    null )  ;", "int   newOffset    =     . gotoChild ( callback . getProject (  )  ,    builder . getText (  )  ,    offset ,     0  ,    builder . length (  )  )  ;", "if    (  ( offset    <     ( builder . length (  )  )  )     &  &     ( newOffset    !  =    offset )  )     {", "end    =    offset ;", "}", "offset    =    newOffset ;", "if    (  (  ( end    =  =     (  -  1  )  )     &  &     ( offset    <     ( builder . length (  )  )  )  )     &  &     (  ( myChildren . size (  )  )     =  =     0  )  )     {", "end    =    offset ;", "}", "LiveTemplateBuilder . Marker   marker    =     ( offset    <     ( builder . length (  )  )  )     ?    builder . createMarker ( offset )     :    null ;", "for    ( int   i    =     0  ,    myChildrenSize    =    myChildren . size (  )  ;    i    <    myChildrenSize ;    i +  +  )     {", "child    =    myChildren . get ( i )  ;", "TemplateImpl   childTemplate    =    child . generate ( callback ,    generator ,    filters ,     (  !  ( myContainsSurroundedTextMarker )  )  ,    segmentsLimit )  ;", "boolean   blockTag    =    child . isBlockTag (  )  ;", "if    (  (  (  ! oneLineTemplateExpanding )     &  &    blockTag )     &  &     (  !  (  . isNewLineBefore ( builder . getText (  )  ,    offset )  )  )  )     {", "builder . insertText ( offset ,     (  \"  \\ n \"     +    indentStr )  ,    false )  ;", "offset    +  =     ( indentStr . length (  )  )     +     1  ;", "}", "int   e    =    builder . insertTemplate ( offset ,    childTemplate ,    null )  ;", "offset    =     ( marker    !  =    null )     ?    marker . getEndOffset (  )     :    builder . length (  )  ;", "if    (  (  ! oneLineTemplateExpanding )     &  &     (  ( blockTag    &  &     (  !  (  . isNewLineAfter ( builder . getText (  )  ,    offset )  )  )  )     |  |     ( myInsertNewLineBetweenNodes )  )  )     {", "builder . insertText ( offset ,     (  \"  \\ n \"     +    indentStr )  ,    false )  ;", "offset    +  =     ( indentStr . length (  )  )     +     1  ;", "}", "if    (  ( end    =  =     (  -  1  )  )     &  &     ( e    <    offset )  )     {", "end    =    e ;", "}", "}", "if    ( shouldNotReformatTemplate )     {", "builder . setIsToReformat ( false )  ;", "}", "return   builder . buildTemplate (  )  ;", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "return   myChildren ;", "}", "METHOD_END"], "methodName": ["getChildren"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "return   myParent ;", "}", "METHOD_END"], "methodName": ["getParent"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "return   mySurroundedText ;", "}", "METHOD_END"], "methodName": ["getSurroundedText"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "return   myTemplateToken ;", "}", "METHOD_END"], "methodName": ["getTemplateToken"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "PsiFile   file    =    PsiFileFactory . getInstance ( project )  . createFileFromText (  \" dummy . xml \"  ,    XML ,    text ,    LocalTimeCounter . currentTime (  )  ,    false )  ;", "PsiElement   element    =    file . findElementAt ( offset )  ;", "if    (  (  ( offset    <    end )     &  &     ( element   instanceof   XmlToken )  )     &  &     (  (  (  ( XmlToken )     ( element )  )  . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ END _ TAG _ START )  )  )     {", "return   offset ;", "}", "int   newOffset    =     -  1  ;", "XmlTag   tag    =    PsiTreeUtil . findElementOfClassAtRange ( file ,    start ,    end ,    XmlTag . class )  ;", "if    ( tag    !  =    null )     {", "for    ( PsiElement   child    :    tag . getChildren (  )  )     {", "if    (  ( child   instanceof   XmlToken )     &  &     (  (  (  ( XmlToken )     ( child )  )  . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ END _ TAG _ START )  )  )     {", "newOffset    =    child . getTextOffset (  )  ;", "}", "}", "}", "if    ( newOffset    >  =     0  )     {", "return   newOffset ;", "}", "return   offset ;", "}", "METHOD_END"], "methodName": ["gotoChild"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "TemplateImpl   template    =    token . getTemplate (  )  ;", "if    ( generator    !  =    null )     {", "assert   template    !  =    null ;", "template    =    generator . generateTemplate ( token ,    hasChildren ,    callback . getContext (  )  )  ;", ". removeVariablesWhichHasNoSegment ( template )  ;", "}", "return   template ;", "}", "METHOD_END"], "methodName": ["invokeTemplate"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "ZenCodingGenerator   zenCodingGenerator    =    ObjectUtils . notNull ( generator ,    XmlZenCodingGeneratorImpl . INSTANCE )  ;", "Map < String ,    String >    attributes    =    token . getAttributes (  )  ;", "TemplateImpl   template    =    token . getTemplate (  )  ;", "assert   template    !  =    null ;", "PsiFileFactory   fileFactory    =    PsiFileFactory . getInstance ( callback . getProject (  )  )  ;", "PsiFile   dummyFile    =    fileFactory . createFileFromText (  \" dummy . html \"  ,    callback . getFile (  )  . getLanguage (  )  ,    token . getTemplateText (  )  ,    false ,    true )  ;", "XmlTag   tag    =    PsiTreeUtil . findChildOfType ( dummyFile ,    XmlTag . class )  ;", "if    ( tag    !  =    null )     {", "if    (  ( EmmetOptions . getInstance (  )  . isHrefAutoDetectEnabled (  )  )     &  &     ( StringUtil . isNotEmpty ( mySurroundedText )  )  )     {", "final   boolean   isEmptyLinkTag    =     (  \" a \"  . equalsIgnoreCase ( tag . getName (  )  )  )     &  &     (  . isEmptyValue ( tag . getAttributeValue (  \" href \"  )  )  )  ;", "if    (  (  ! hasChildren )     &  &    isEmptyLinkTag )     {", "if    (  . HREF _ PATTERN . matcher ( mySurroundedText )  . matches (  )  )     {", "attributes . put (  \" href \"  ,     (  . PROTOCOL _ PATTERN . matcher ( mySurroundedText )  . find (  )     ?    mySurroundedText . trim (  )     :     \" http :  /  /  \"     +     ( mySurroundedText . trim (  )  )  )  )  ;", "} else", "if    (  . EMAIL _ PATTERN . matcher ( mySurroundedText )  . matches (  )  )     {", "attributes . put (  \" href \"  ,     (  \" mailto :  \"     +     ( mySurroundedText . trim (  )  )  )  )  ;", "}", "}", "}", "for    ( Map . Entry < String ,    String >    attribute    :    attributes . entrySet (  )  )     {", "if    ( Strings . isNullOrEmpty ( attribute . getValue (  )  )  )     {", "template . addVariable (  . prepareVariableName ( attribute . getKey (  )  )  ,     \"  \"  ,     \"  \"  ,    true )  ;", "}", "}", "XmlTag   tag 1     =     ( hasChildren )     ?     . expandEmptyTagIfNecessary ( tag )     :    tag ;", "setAttributeValues ( tag 1  ,    attributes ,    callback ,    zenCodingGenerator . isHtml ( callback )  )  ;", "token . setTemplateText ( tag 1  . getContainingFile (  )  . getText (  )  ,    callback )  ;", "}", "template    =    zenCodingGenerator . generateTemplate ( token ,    hasChildren ,    callback . getContext (  )  )  ;", ". removeVariablesWhichHasNoSegment ( template )  ;", "return   template ;", "}", "METHOD_END"], "methodName": ["invokeXmlTemplate"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myTemplateToken )     !  =    null )     {", "XmlTag   tag    =    myTemplateToken . getXmlTag (  )  ;", "if    ( tag    !  =    null )     {", "return   HtmlUtil . isHtmlBlockTagL ( tag . getName (  )  )  ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isBlockTag"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "if    ( XmlEmmetParser . BOOLEAN _ ATTRIBUTE _ VALUE . equals ( attributeValue )  )     {", "return   true ;", "}", "if    ( StringUtil . isEmpty ( attributeValue )  )     {", "final   XmlAttributeDescriptor   descriptor    =    xmlAttribute . getDescriptor (  )  ;", "return    ( descriptor    !  =    null )     &  &     ( HtmlUtil . isBooleanAttribute ( descriptor ,    callback . getContext (  )  )  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isBooleanAttribute"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "return    ( attributeValue    !  =    null )     &  &     (  ( attributeValue . isEmpty (  )  )     |  |     ( GenerationNode . ATTRIBUTE _ VARIABLE _ PATTERN . matcher ( attributeValue )  . matches (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isEmptyValue"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "return   StringUtil . startsWithChar ( xmlAttributeLocalName ,     '  !  '  )  ;", "}", "METHOD_END"], "methodName": ["isImpliedAttribute"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "return   myInsertNewLineBetweenNodes ;", "}", "METHOD_END"], "methodName": ["isInsertNewLineBetweenNodes"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "return    ( myChildren . size (  )  )     =  =     0  ;", "}", "METHOD_END"], "methodName": ["isLeaf"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "int   i    =    offset ;", "while    (  ( i    <     ( text . length (  )  )  )     &  &     ( Character . isWhitespace ( text . charAt ( i )  )  )  )     {", "if    (  ( text . charAt ( i )  )     =  =     '  \\ n '  )     {", "return   true ;", "}", "i +  +  ;", "}", "return   i    =  =     ( text . length (  )  )  ;", "}", "METHOD_END"], "methodName": ["isNewLineAfter"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "int   i    =    offset    -     1  ;", "while    (  ( i    >  =     0  )     &  &     ( Character . isWhitespace ( text . charAt ( i )  )  )  )     {", "if    (  ( text . charAt ( i )  )     =  =     '  \\ n '  )     {", "return   true ;", "}", "i -  -  ;", "}", "return   i    <     0  ;", "}", "METHOD_END"], "methodName": ["isNewLineBefore"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "char [  ]    toReplace    =    new   char [  ]  {     '  $  '  ,     '  -  '  ,     '  +  '  ,     '  :  '     }  ;", "StringBuilder   builder    =    new   StringBuilder ( attributeName . length (  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( attributeName . length (  )  )  ;    i +  +  )     {", "char   c    =    attributeName . charAt ( i )  ;", "boolean   replaced    =    false ;", "for    ( char   aToReplace    :    toReplace )     {", "if    ( c    =  =    aToReplace )     {", "builder . append (  '  _  '  )  ;", "replaced    =    true ;", "break ;", "}", "}", "if    (  ! replaced )     {", "builder . append ( c )  ;", "}", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["prepareVariableName"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "Set < String >    segments    =    new   HashSet <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <     ( getSegmentsCount (  )  )  ;    i +  +  )     {", "segments . add ( getSegmentName ( i )  )  ;", "}", "for    ( int   i    =     ( getVariableCount (  )  )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "String   varName    =    getVariableNameAt ( i )  ;", "if    (  !  ( segments . contains ( varName )  )  )     {", "removeVariable ( i )  ;", "} else    {", "segments . remove ( varName )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["removeVariablesWhichHasNoSegment"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "final   String   defaultAttributeValue    =    attributes . get ( XmlEmmetParser . DEFAULT _ ATTRIBUTE _ NAME )  ;", "if    ( defaultAttributeValue    !  =    null )     {", "attributes . remove ( XmlEmmetParser . DEFAULT _ ATTRIBUTE _ NAME )  ;", "final   List < XmlAttribute >    xmlAttributes    =    ContainerUtil . filter ( tag . getAttributes (  )  ,     (    attribute )     -  >     !  ( attributes . containsKey ( attribute . getLocalName (  )  )  )  )  ;", "XmlAttribute   defaultAttribute    =     . findImpliedAttribute ( xmlAttributes )  ;", "if    ( defaultAttribute    =  =    null )     {", "defaultAttribute    =     . findEmptyAttribute ( xmlAttributes )  ;", "}", "if    ( defaultAttribute    !  =    null )     {", "String   attributeName    =    defaultAttribute . getName (  )  ;", "if    (  ( attributeName . length (  )  )     >     1  )     {", "if    (  . isImpliedAttribute ( attributeName )  )     {", "defaultAttribute    =     (  ( XmlAttribute )     ( defaultAttribute . setName ( attributeName . substring (  1  )  )  )  )  ;", "}", "final   String   oldValue    =    defaultAttribute . getValue (  )  ;", "if    (  ( oldValue    !  =    null )     &  &     ( StringUtil . containsChar ( oldValue ,     '  |  '  )  )  )     {", "defaultAttribute . setValue ( StringUtil . replace ( oldValue ,     \"  |  \"  ,    defaultAttributeValue )  )  ;", "} else    {", "defaultAttribute . setValue ( defaultAttributeValue )  ;", "}", "}", "}", "}", "for    ( XmlAttribute   xmlAttribute    :    tag . getAttributes (  )  )     {", "final   String   attributeName    =    xmlAttribute . getName (  )  ;", "final   XmlAttributeValue   xmlAttributeValueElement    =    xmlAttribute . getValueElement (  )  ;", "if    (  (  ( xmlAttributeValueElement    !  =    null )     &  &     (  !  ( attributes . containsKey ( attributeName )  )  )  )     |  |     (  !  ( ZenCodingUtil . isXML 1  1 ValidQName ( attributeName )  )  )  )     {", "continue ;", "}", "String   attributeValue    =    StringUtil . notNullize ( attributes . get ( attributeName )  ,    StringUtil . notNullize ( xmlAttribute . getValue (  )  )  )  ;", "if    ( ZenCodingUtil . containsSurroundedTextMarker ( attributeValue )  )     {", "myContainsSurroundedTextMarker    =    true ;", "}", "if    ( isHtml    &  &     (  . isBooleanAttribute ( attributeValue ,    xmlAttribute ,    callback )  )  )     {", "if    ( HtmlUtil . isShortNotationOfBooleanAttributePreferred (  )  )     {", "if    ( xmlAttributeValueElement    !  =    null )     {", "final   PsiElement   prevSibling    =    xmlAttributeValueElement . getPrevSibling (  )  ;", "if    (  ( prevSibling    !  =    null )     &  &     ( prevSibling . textMatches (  \"  =  \"  )  )  )     {", "xmlAttribute . deleteChildRange ( prevSibling ,    xmlAttributeValueElement )  ;", "}", "}", "} else    {", "if    ( xmlAttributeValueElement    =  =    null )     {", "xmlAttribute . delete (  )  ;", "}", "tag . setAttribute ( attributeName ,    attributeName )  ;", "}", "} else    {", "if    ( xmlAttributeValueElement    =  =    null )     {", "xmlAttribute . delete (  )  ;", "}", "tag . setAttribute ( attributeName ,     ( StringUtil . isEmpty ( attributeValue )     ?     (  \"  $  \"     +     (  . prepareVariableName ( attributeName )  )  )     +     \"  $  \"     :    ZenCodingUtil . getValue ( attributeValue ,    myNumberInIteration ,    myTotalIterations ,    mySurroundedText )  )  )  ;", "}", "}", "for    ( XmlAttribute   xmlAttribute    :    tag . getAttributes (  )  )     {", "final   String   xmlAttributeLocalName    =    xmlAttribute . getLocalName (  )  ;", "if    (  (  ( xmlAttribute . getValue (  )  )     !  =    null )     &  &     (  . isImpliedAttribute ( xmlAttributeLocalName )  )  )     {", "xmlAttribute . delete (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setAttributeValues"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "myParent    =    parent ;", "}", "METHOD_END"], "methodName": ["setParent"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "mySurroundedText    =    surroundedText ;", "}", "METHOD_END"], "methodName": ["setSurroundedText"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.GenerationNode"}, {"methodBody": ["METHOD_START", "{", "return   myLeftOperand ;", "}", "METHOD_END"], "methodName": ["getLeftOperand"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.MoreOperationNode"}, {"methodBody": ["METHOD_START", "{", "return   myRightOperand ;", "}", "METHOD_END"], "methodName": ["getRightOperand"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.MoreOperationNode"}, {"methodBody": ["METHOD_START", "{", "return   myLeftOperand ;", "}", "METHOD_END"], "methodName": ["getLeftOperand"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.MulOperationNode"}, {"methodBody": ["METHOD_START", "{", "return   myRightOperand ;", "}", "METHOD_END"], "methodName": ["getRightOperand"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.MulOperationNode"}, {"methodBody": ["METHOD_START", "{", "return   myTemplateToken ;", "}", "METHOD_END"], "methodName": ["getTemplateToken"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.TemplateNode"}, {"methodBody": ["METHOD_START", "{", "return   myText ;", "}", "METHOD_END"], "methodName": ["getText"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.TextNode"}, {"methodBody": ["METHOD_START", "{", "return   myOperand ;", "}", "METHOD_END"], "methodName": ["getOperand"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.UnaryMulOperationNode"}, {"methodBody": ["METHOD_START", "{", "return   Collections . emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["getChildren"], "fileName": "com.intellij.codeInsight.template.emmet.nodes.ZenCodingNode"}, {"methodBody": ["METHOD_START", "{", "return   mySuffix ;", "}", "METHOD_END"], "methodName": ["getSuffix"], "fileName": "com.intellij.codeInsight.template.emmet.tokens.FilterToken"}, {"methodBody": ["METHOD_START", "{", "return   myText ;", "}", "METHOD_END"], "methodName": ["getText"], "fileName": "com.intellij.codeInsight.template.emmet.tokens.IdentifierToken"}, {"methodBody": ["METHOD_START", "{", "return   myNumber ;", "}", "METHOD_END"], "methodName": ["getNumber"], "fileName": "com.intellij.codeInsight.template.emmet.tokens.NumberToken"}, {"methodBody": ["METHOD_START", "{", "return   mySign ;", "}", "METHOD_END"], "methodName": ["getSign"], "fileName": "com.intellij.codeInsight.template.emmet.tokens.OperationToken"}, {"methodBody": ["METHOD_START", "{", "return   myText ;", "}", "METHOD_END"], "methodName": ["getText"], "fileName": "com.intellij.codeInsight.template.emmet.tokens.StringLiteralToken"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < String ,    String >    attribute    :    attributes . entrySet (  )  )     {", "if    (  (  !  ( XmlEParser . DEFAULT _ ATTRIBUTE _ NAME . equals ( attribute . getKey (  )  )  )  )     &  &     (  ( tag . getAttribute ( attribute . getKey (  )  )  )     =  =    null )  )     {", "XmlTag   htmlTag    =    XmlElementFactory . getInstance ( tag . getProject (  )  )  . createHTMLTagFromText (  (  (  \"  < dummy    \"     +     ( attribute . getKey (  )  )  )     +     \"  =  \\  \"  \\  \"  /  >  \"  )  )  ;", "final   XmlAttribute   newAttribute    =    ArrayUtil . getFirstElement ( htmlTag . getAttributes (  )  )  ;", "if    ( newAttribute    !  =    null )     {", "tag . add ( newAttribute )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["addMissingAttributes"], "fileName": "com.intellij.codeInsight.template.emmet.tokens.TemplateToken"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( template . getVariableCount (  )  )  ;    i +  +  )     {", "String   varName    =    template . getVariableNameAt ( i )  ;", "if    (  . ATTRS . equals ( varName )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsAttrsVar"], "fileName": "com.intellij.codeInsight.template.emmet.tokens.TemplateToken"}, {"methodBody": ["METHOD_START", "{", "XmlTag   dummyRootTag    =    null ;", "String   templateString    =    template . getString (  )  ;", "if    (  !  (  . containsAttrsVar ( template )  )  )     {", "PsiFile   dummyFile    =    PsiFileFactory . getInstance ( callback . getProject (  )  )  . createFileFromText (  \" dummy . html \"  ,    callback . getFile (  )  . getLanguage (  )  ,    templateString ,    false ,    true )  ;", "dummyRootTag    =    PsiTreeUtil . findChildOfType ( dummyFile ,    XmlTag . class )  ;", "if    (  ( dummyRootTag    !  =    null )     &  &     (  !  ( attributes . isEmpty (  )  )  )  )     {", ". addMissingAttributes ( dummyRootTag ,    attributes )  ;", "}", "}", "return   dummyRootTag    !  =    null    ?    dummyRootTag . getContainingFile (  )  . getText (  )     :    templateString ;", "}", "METHOD_END"], "methodName": ["createTemplateText"], "fileName": "com.intellij.codeInsight.template.emmet.tokens.TemplateToken"}, {"methodBody": ["METHOD_START", "{", "return   myAttributes ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "com.intellij.codeInsight.template.emmet.tokens.TemplateToken"}, {"methodBody": ["METHOD_START", "{", "return   myFile ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "com.intellij.codeInsight.template.emmet.tokens.TemplateToken"}, {"methodBody": ["METHOD_START", "{", "return   myKey ;", "}", "METHOD_END"], "methodName": ["getKey"], "fileName": "com.intellij.codeInsight.template.emmet.tokens.TemplateToken"}, {"methodBody": ["METHOD_START", "{", "return   myTemplate ;", "}", "METHOD_END"], "methodName": ["getTemplate"], "fileName": "com.intellij.codeInsight.template.emmet.tokens.TemplateToken"}, {"methodBody": ["METHOD_START", "{", "return   myFile . getText (  )  ;", "}", "METHOD_END"], "methodName": ["getTemplateText"], "fileName": "com.intellij.codeInsight.template.emmet.tokens.TemplateToken"}, {"methodBody": ["METHOD_START", "{", "return   PsiTreeUtil . findChildOfType ( myFile ,    XmlTag . class )  ;", "}", "METHOD_END"], "methodName": ["getXmlTag"], "fileName": "com.intellij.codeInsight.template.emmet.tokens.TemplateToken"}, {"methodBody": ["METHOD_START", "{", "return   myForceSingleTag ;", "}", "METHOD_END"], "methodName": ["isForceSingleTag"], "fileName": "com.intellij.codeInsight.template.emmet.tokens.TemplateToken"}, {"methodBody": ["METHOD_START", "{", "myFile    =    file ;", "}", "METHOD_END"], "methodName": ["setFile"], "fileName": "com.intellij.codeInsight.template.emmet.tokens.TemplateToken"}, {"methodBody": ["METHOD_START", "{", "myTemplate    =    template ;", "setTemplateText (  . createTemplateText ( template ,    callback ,    getAttributes (  )  )  ,    callback )  ;", "}", "METHOD_END"], "methodName": ["setTemplate"], "fileName": "com.intellij.codeInsight.template.emmet.tokens.TemplateToken"}, {"methodBody": ["METHOD_START", "{", "PsiFile   file    =    PsiFileFactory . getInstance ( callback . getProject (  )  )  . createFileFromText (  \" dummy . html \"  ,    callback . getFile (  )  . getLanguage (  )  ,    templateText ,    true ,    true )  ;", "VirtualFile   vFile    =    file . getVirtualFile (  )  ;", "if    ( vFile    !  =    null )     {", "vFile . putUserData ( DONT _ RECORD _ UNDO ,    Boolean . TRUE )  ;", "}", "setFile ( file )  ;", "}", "METHOD_END"], "methodName": ["setTemplateText"], "fileName": "com.intellij.codeInsight.template.emmet.tokens.TemplateToken"}, {"methodBody": ["METHOD_START", "{", "return    \" TEMPLATE \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.codeInsight.template.emmet.tokens.TemplateToken"}, {"methodBody": ["METHOD_START", "{", "return   myText ;", "}", "METHOD_END"], "methodName": ["getText"], "fileName": "com.intellij.codeInsight.template.emmet.tokens.TextToken"}, {"methodBody": ["METHOD_START", "{", "final   PsiFile   file    =    anchor . getContainingFile (  )  ;", "if    ( file   instanceof   XmlFile )     {", "final   XmlDocument   document    =     (  ( XmlFile )     ( file )  )  . getDocument (  )  ;", "final   XmlTag   rootTag    =     ( document    !  =    null )     ?    document . getRootTag (  )     :    null ;", "PsiElement   leaf    =     ( rootTag    !  =    null )     ?    rootTag . getPrevSibling (  )     :    file . findElementAt (  0  )  ;", "return   findLeaf ( leaf ,    id ,     0  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findFileSuppression"], "fileName": "com.intellij.codeInspection.DefaultXmlSuppressionProvider"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   element    =    findSuppressionLeaf ( anchor ,    id ,     0  )  ;", "if    ( element    !  =    null )", "return   element ;", "return   findFileSuppression ( anchor ,    id ,    originalElement )  ;", "}", "METHOD_END"], "methodName": ["findSuppression"], "fileName": "com.intellij.codeInspection.DefaultXmlSuppressionProvider"}, {"methodBody": ["METHOD_START", "{", "while    (  ( leaf    !  =    null )     &  &     (  ( leaf . getTextOffset (  )  )     >  =    offset )  )     {", "if    (  (  ( leaf   instanceof   PsiComment )     |  |     ( leaf   instanceof   XmlProlog )  )     |  |     ( leaf   instanceof   XmlText )  )     {", "@ NonNls", "String   text    =    leaf . getText (  )  ;", "if    ( isedFor ( text ,    id )  )", "return   leaf ;", "}", "leaf    =    leaf . getPrevSibling (  )  ;", "if    ( leaf   instanceof   XmlTag )     {", "return   null ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findSuppressionLeaf"], "fileName": "com.intellij.codeInspection.DefaultXmlSuppressionProvider"}, {"methodBody": ["METHOD_START", "{", "return    (  \"  <  !  -  -  \"     +     ( DefaultXmlSuppressionProvider . SUPPRESS _ MARK )  )     +     \"     \"  ;", "}", "METHOD_END"], "methodName": ["getPrefix"], "fileName": "com.intellij.codeInspection.DefaultXmlSuppressionProvider"}, {"methodBody": ["METHOD_START", "{", "return    \"     -  -  >  \"  ;", "}", "METHOD_END"], "methodName": ["getSuffix"], "fileName": "com.intellij.codeInspection.DefaultXmlSuppressionProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( originalText    =  =    null )     {", "return    (  (  ( getPrefix (  )  )     +    inspectionId )     +     ( getSuffix (  )  )  )     +     \"  \\ n \"  ;", "} else", "if    ( inspectionId . equals ( XmlSuppressablTool . ALL )  )     {", "final   int   pos    =    originalText . indexOf ( getPrefix (  )  )  ;", "return    (  (  (  ( originalText . substring (  0  ,    pos )  )     +     ( getPrefix (  )  )  )     +    inspectionId )     +     ( getSuffix (  )  )  )     +     \"  \\ n \"  ;", "}", "return   StringUtil . replace ( originalText ,    getSuffix (  )  ,     (  (  \"  ,     \"     +    inspectionId )     +     ( getSuffix (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSuppressionText"], "fileName": "com.intellij.codeInspection.DefaultXmlSuppressionProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( text . contains ( getPrefix (  )  )  )  )     {", "return   false ;", "}", "if    ( id    =  =    null )     {", "return   true ;", "}", "@ NonNls", "final   HashSet < String >    parts    =    ContainerUtil . newHashSet ( StringUtil . getWordsIn ( text )  )  ;", "return    ( parts . contains ( id )  )     |  |     ( parts . contains ( XmlSuppressablTool . ALL )  )  ;", "}", "METHOD_END"], "methodName": ["isSuppressedFor"], "fileName": "com.intellij.codeInspection.DefaultXmlSuppressionProvider"}, {"methodBody": ["METHOD_START", "{", "final   Project   project    =    file . getProject (  )  ;", "final   Document   doc    =    PsiDocumentManager . getInstance ( project )  . getDocument ( file )  ;", "assert   doc    !  =    null ;", "if    ( suppressionElement    !  =    null )     {", "final   TextRange   textRange    =    suppressionElement . getTextRange (  )  ;", "String   text    =    suppressionElement . getText (  )  ;", "final   String   suppressionText    =    getText ( inspectionId ,    text )  ;", "doc . replaceString ( textRange . getStartOffset (  )  ,    textRange . getEndOffset (  )  ,    suppressionText )  ;", "} else    {", "final   String   suppressionText    =    getText ( inspectionId ,    null )  ;", "doc . insertString ( offset ,    suppressionText )  ;", "CodeStyleManager . getInstance ( project )  . adjustLineIndent ( doc ,     ( offset    +     ( suppressionText . length (  )  )  )  )  ;", "UndoUtil . markPsiFileForUndo ( file )  ;", "}", "}", "METHOD_END"], "methodName": ["suppress"], "fileName": "com.intellij.codeInspection.DefaultXmlSuppressionProvider"}, {"methodBody": ["METHOD_START", "{", "return   ServiceManager . getService ( XmlQuickFixFactory . class )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "com.intellij.codeInspection.XmlQuickFixFactory"}, {"methodBody": ["METHOD_START", "{", "return   XmlSuppressableInspectionTool . getSuppressFixes ( toolId ,    new   DefaultXmlSuppressionProvider (  )  )  ;", "}", "METHOD_END"], "methodName": ["getSuppressFixes"], "fileName": "com.intellij.codeInspection.XmlSuppressableInspectionTool"}, {"methodBody": ["METHOD_START", "{", "return   new   SuppressQuickFix [  ]  {    new   XmlSuppressableInspectionTool . SuppressTagStatic ( toolId ,    provider )  ,    new   XmlSuppressableInspectionTool . SuppressForFile ( toolId ,    provider )  ,    new   XmlSuppressableInspectionTool . SuppressAllForFile ( provider )     }  ;", "}", "METHOD_END"], "methodName": ["getSuppressFixes"], "fileName": "com.intellij.codeInspection.XmlSuppressableInspectionTool"}, {"methodBody": ["METHOD_START", "{", "for    ( XmlSuppressionProvider   provider    :    Extensions . getExtensions ( XmlSuppressionProvider . EP _ NAME )  )     {", "if    (  ( provider . isProviderAvailable ( element . getContainingFile (  )  )  )     &  &     ( provider . isSuppressedFor ( element ,    inspectionId )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isSuppressed"], "fileName": "com.intellij.codeInspection.XmlSuppressionProvider"}, {"methodBody": ["METHOD_START", "{", "final   List < IntentionA   allIntentions    =    myFixture . getAvailableIntentions (  )  ;", "final   List < IntentionA   intentions    =    allIntentions . stream (  )  . filter (  (    a    -  >    agetText (  )  . startsWith ( hint )  )  . limit (  2  )  . collect ( Collectors . toList (  )  )  ;", "Assert . assertFalse (  (  (  (  \"  \\  \"  \"     +    hint )     +     \"  \\  \"    not   in    \"  )     +    intentions )  ,    intentions . isEmpty (  )  )  ;", "Assert . assertFalse (  (  (  (  (  \" Too   many   quickfixes   found   for    \\  \"  \"     +    hint )     +     \"  \\  \"  :     \"  )     +    intentions )     +     \"  ]  \"  )  ,     (  ( intentions . size (  )  )     >     1  )  )  ;", "return   intentions . get (  0  )  ;", "}", "METHOD_END"], "methodName": ["findIntention"], "fileName": "com.intellij.codeInspection.htmlInspections.HtmlMissingClosingTagInspectionTest"}, {"methodBody": ["METHOD_START", "{", "return   new   HtmlMissingClosingTagInspection (  )  ;", "}", "METHOD_END"], "methodName": ["getInspection"], "fileName": "com.intellij.codeInspection.htmlInspections.HtmlMissingClosingTagInspectionTest"}, {"methodBody": ["METHOD_START", "{", "final   LocalInspectionTool   inspection    =    getInspection (  )  ;", "myFixture . enableInspections ( inspection )  ;", "final   HighlightDisplayKey   displayKey    =    HighlightDisplayKey . find ( inspection . getShortName (  )  )  ;", "final   Project   project    =    myFixture . getProject (  )  ;", "final   InspectionProfileImpl   currentProfile    =    ProjectInspectionProfileManager . getInstance ( project )  . getCurrentProfile (  )  ;", "final   HighlightDisplayLevel   errorLevel    =    currentProfile . getErrorLevel ( displayKey ,    null )  ;", "if    ( errorLevel    =  =     ( HighlightDisplayLevel . DO _ NOT _ SHOW )  )     {", "currentProfile . setErrorLevel ( displayKey ,    WARNING ,    project )  ;", "}", "myFixture . configureByText ( HtmlFileType . INSTANCE ,    code )  ;", "myFixture . testHighlighting (  )  ;", "}", "METHOD_END"], "methodName": ["highlightTest"], "fileName": "com.intellij.codeInspection.htmlInspections.HtmlMissingClosingTagInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest ( before )  ;", "final   IntentionA   intention    =    findIntention ( hint )  ;", "assertNotNull ( intention )  ;", "myFixture . launchA ( intention )  ;", "myFixture . checkResult ( after )  ;", "}", "METHOD_END"], "methodName": ["quickfixTest"], "fileName": "com.intellij.codeInspection.htmlInspections.HtmlMissingClosingTagInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \"  < html >  < body >  < img >  <  / body >  <  / html >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testImgElement"], "fileName": "com.intellij.codeInspection.htmlInspections.HtmlMissingClosingTagInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \"  < html >  < table >  < error   descr =  \\  \" Element   table   is   not   closed \\  \"  >  <  <  / error >  / html >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testIncompleteElement"], "fileName": "com.intellij.codeInspection.htmlInspections.HtmlMissingClosingTagInspectionTest"}, {"methodBody": ["METHOD_START", "{", "quickfixTest (  \"  < html >  <  < warning   descr =  \\  \" Element    < p >    is   missing   an   end   tag \\  \"  > p <  / warning >  < caret >  > Behold !  <  / html >  \"  ,     \"  < html >  < p > Behold !  <  / p >  <  / html >  \"  ,     \" Add    <  / p >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testPElement"], "fileName": "com.intellij.codeInspection.htmlInspections.HtmlMissingClosingTagInspectionTest"}, {"methodBody": ["METHOD_START", "{", "XmlElementDescriptor   descriptor    =    tag . getDescriptor (  )  ;", "if    ( descriptor    =  =    null )", "return ;", "XmlAttributeDescriptor [  ]    descriptors    =    descriptor . getAttributesDescriptors ( tag )  ;", "int   initialSize    =    quickfixes . size (  )  ;", "for    ( XmlAttributeDescriptor   attr    :    descriptors )     {", "if    (  ( EditDistance . optimalAlignment ( name ,    attr . getName (  )  ,    false )  )     <  =     1  )     {", "quickfixes . add ( new    . RenameAttributeFix ( attr )  )  ;", "}", "if    (  ( quickfixes . size (  )  )     >  =     ( initialSize    +     3  )  )", "break ;", "}", "}", "METHOD_END"], "methodName": ["addSimilarAttributesQuickFixes"], "fileName": "com.intellij.codeInspection.htmlInspections.HtmlUnknownAttributeInspectionBase"}, {"methodBody": ["METHOD_START", "{", "myCustomValuesEnabled    =    customValuesEnabled ;", "}", "METHOD_END"], "methodName": ["enableCustomValues"], "fileName": "com.intellij.codeInspection.htmlInspections.HtmlUnknownElementInspection"}, {"methodBody": ["METHOD_START", "{", "return   myValues . contains ( value . toLowerCase (  )  )  ;", "}", "METHOD_END"], "methodName": ["isCustomValue"], "fileName": "com.intellij.codeInspection.htmlInspections.HtmlUnknownElementInspection"}, {"methodBody": ["METHOD_START", "{", "return   myCustomValuesEnabled ;", "}", "METHOD_END"], "methodName": ["isCustomValuesEnabled"], "fileName": "com.intellij.codeInspection.htmlInspections.HtmlUnknownElementInspection"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   node    =    attribute . getNode (  )  ;", "assert   node    !  =    null ;", "final   ASTNode   nameNode    =    XmlChildRole . ATTRIBUTE _ NAME _ FINDER . findChild ( node )  ;", "if    ( nameNode    !  =    null )     {", "final   Psi   name    =    nameNode . getPsi (  )  ;", "if    (  ( name . getTextLength (  )  )     >     0  )     {", "holder . registerProblem ( name ,    message ,    GENERIC _ ERROR _ OR _ WARNING ,    quickfixes )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["registerProblemOnAttributeName"], "fileName": "com.intellij.codeInspection.htmlInspections.HtmlUnknownElementInspection"}, {"methodBody": ["METHOD_START", "{", "final   JDOMExternalizableStringList   result    =    new   JDOMExternalizableStringList (  )  ;", "final   StringTokenizer   tokenizer    =    new   StringTokenizer ( properties ,     \"  ,  \"  )  ;", "while    ( tokenizer . hasMoreTokens (  )  )     {", "result . add ( tokenizer . nextToken (  )  . toLowerCase (  )  . trim (  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["reparseProperties"], "fileName": "com.intellij.codeInspection.htmlInspections.HtmlUnknownElementInspection"}, {"methodBody": ["METHOD_START", "{", "myValues    =    HtmlUnknownElementInspection . reparseProperties ( values )  ;", "}", "METHOD_END"], "methodName": ["updateAdditionalEntries"], "fileName": "com.intellij.codeInspection.htmlInspections.HtmlUnknownElementInspection"}, {"methodBody": ["METHOD_START", "{", "final   JPanel   result    =    new   JPanel ( new   BorderLayout (  )  )  ;", "final   JPanel   internalPanel    =    new   JPanel ( new   BorderLayout (  )  )  ;", "result . add ( internalPanel ,    BorderLayout . NORTH )  ;", "final   Ref < FieldPanel >    panelRef    =    new   Ref (  )  ;", "final   FieldPanel   additionalAttributesPanel    =    new   FieldPanel ( null ,    null ,    new   ActionListener (  )     {", "@ Override", "public   void   actionPerformed ( ActionEvent   event )     {", "Messages . showTextAreaDialog ( panelRef . get (  )  . getTextField (  )  ,    StringUtil . wordsToBeginFromUpperCase ( igetPanelTitle (  )  )  ,    igetClass (  )  . getSimpleName (  )  ,     (    s )     -  >    reparseProperties ( s )  ,     (    strings )     -  >    StringUtil . join ( strings ,     \"  ,  \"  )  )  ;", "}", "}  ,    null )  ;", "(  ( JButton )     ( additionalAttributesPanel . getComponent (  1  )  )  )  . setIcon ( OPEN _ EDIT _ DIALOG _ ICON )  ;", "panelRef . set ( additionalAttributesPanel )  ;", "additionalAttributesPanel . getTextField (  )  . getDocument (  )  . addDocumentListener ( new   DocumentAdapter (  )     {", "@ Override", "protected   void   textChanged ( DocumentEvent   e )     {", "final   Document   document    =    e . getDocument (  )  ;", "try    {", "final   String   text    =    document . getText (  0  ,    document . getLength (  )  )  ;", "if    ( text    !  =    null )     {", "iupdateAdditionalEntries ( text . trim (  )  )  ;", "}", "}    catch    ( BadLocationException   e 1  )     {", "igetLogger (  )  . error ( e 1  )  ;", "}", "}", "}  )  ;", "final   JCheckBox   checkBox    =    new   JCheckBox ( igetCheckboxTitle (  )  )  ;", "checkBox . setSelected ( iisCustomValuesEnabled (  )  )  ;", "checkBox . addActionListener ( new   ActionListener (  )     {", "@ Override", "public   void   actionPerformed ( ActionEvent   e )     {", "final   boolean   b    =    checkBox . isSelected (  )  ;", "if    ( b    !  =     ( iisCustomValuesEnabled (  )  )  )     {", "ienableCustomValues ( b )  ;", "additionalAttributesPanel . setEnabled ( iisCustomValuesEnabled (  )  )  ;", "}", "}", "}  )  ;", "internalPanel . add ( checkBox ,    BorderLayout . NORTH )  ;", "internalPanel . add ( additionalAttributesPanel ,    BorderLayout . CENTER )  ;", "additionalAttributesPanel . setPreferredSize ( new   Dimension (  1  5  0  ,    additionalAttributesPanel . getPreferredSize (  )  . height )  )  ;", "additionalAttributesPanel . setEnabled ( iisCustomValuesEnabled (  )  )  ;", "additionalAttributesPanel . setText ( igetAdditionalEntries (  )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["createOptionsPanel"], "fileName": "com.intellij.codeInspection.htmlInspections.HtmlUnknownTagInspection"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["createChangeTemplateDataFix"], "fileName": "com.intellij.codeInspection.htmlInspections.HtmlUnknownTagInspectionBase"}, {"methodBody": ["METHOD_START", "{", "return    ( descriptor    =  =    null )     |  |     ( descriptor   instanceof   AnyXmlElementDescriptor )  ;", "}", "METHOD_END"], "methodName": ["isAbstractDescriptor"], "fileName": "com.intellij.codeInspection.htmlInspections.HtmlUnknownTagInspectionBase"}, {"methodBody": ["METHOD_START", "{", "if    ( tagElement   instanceof   PsiErrorElement )     {", "Collection < OuterLanguageElement >    outers    =    PsiTreeUtil . findChildrenOfType ( tagElement ,    OuterLanguageElement . class )  ;", "String   replacement    =    StringUtil . join ( outers ,    PsiElement :  : getText ,     \"  \"  )  ;", "Document   document    =     . getDocument ( tagElement )  ;", "if    (  ( document    !  =    null )     &  &     (  !  ( replacement . isEmpty (  )  )  )  )     {", "TextRange   range    =    tagElement . getTextRange (  )  ;", "document . replaceString ( range . getStartOffset (  )  ,    range . getEndOffset (  )  ,    replacement )  ;", "} else    {", "tagElement . delete (  )  ;", "}", "} else    {", "final   ASTNode   astNode    =    tagElement . getNode (  )  ;", "if    ( astNode    !  =    null )     {", "final   ASTNode   endTagStart    =    XmlChildRole . CLOSING _ TAG _ START _ FINDER . findChild ( astNode )  ;", "if    ( endTagStart    !  =    null )     {", "Document   document    =     . getDocument ( tagElement )  ;", "if    ( document    !  =    null )     {", "document . deleteString ( endTagStart . getStartOffset (  )  ,    tagElement . getLastChild (  )  . getTextRange (  )  . getEndOffset (  )  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["doFix"], "fileName": "com.intellij.codeInspection.htmlInspections.RemoveExtraClosingTagIntentionAction"}, {"methodBody": ["METHOD_START", "{", "return   PsiDocumentManager . getInstance ( tagElement . getProject (  )  )  . getDocument ( tagElement . getContainingFile (  )  )  ;", "}", "METHOD_END"], "methodName": ["getDocument"], "fileName": "com.intellij.codeInspection.htmlInspections.RemoveExtraClosingTagIntentionAction"}, {"methodBody": ["METHOD_START", "{", "PsiElement   target    =    null ;", "PsiElement   parent    =    psiElement . getParent (  )  ;", "if    ( parent   instanceof   PsiErrorElement )     {", "parent    =    parent . getParent (  )  ;", "}", "if    ( parent   instanceof   XmlTag )     {", "if    ( start )     {", "target    =    XmlTagUtil . getStartTagNameElement (  (  ( XmlTag )     ( parent )  )  )  ;", "} else    {", "target    =    XmlTagUtil . getEndTagNameElement (  (  ( XmlTag )     ( parent )  )  )  ;", "if    ( target    =  =    null )     {", "final   PsiErrorElement   errorElement    =    PsiTreeUtil . getChildOfType ( parent ,    PsiErrorElement . class )  ;", "target    =    XmlWrongClosingTagNamfindEndTagName ( errorElement )  ;", "}", "}", "}", "return   target ;", "}", "METHOD_END"], "methodName": ["findOtherSide"], "fileName": "com.intellij.codeInspection.htmlInspections.RenameTagBeginOrEndIntentionAction"}, {"methodBody": ["METHOD_START", "{", "return   myStart    ?    XmlErrorMessages . message (  \" rename . start . tag . name . intention \"  ,    mySourceName ,    myTargetName )     :    XmlErrorMessages . message (  \" rename . end . tag . name . intention \"  ,    mySourceName ,    myTargetName )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.intellij.codeInspection.htmlInspections.RenameTagBeginOrEndIntentionAction"}, {"methodBody": ["METHOD_START", "{", "RequiredAttributesInspectionBase . registerProblem ( message ,    error ,    holder ,    XmlTagUtil . getStartTagNameElement ( tag )  ,    fixes )  ;", "RequiredAttributesInspectionBase . registerProblem ( message ,    error ,    holder ,    XmlTagUtil . getEndTagNameElement ( tag )  ,    fixes )  ;", "}", "METHOD_END"], "methodName": ["addElementsForTag"], "fileName": "com.intellij.codeInspection.htmlInspections.RequiredAttributesInspectionBase"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( toAppend . isEmpty (  )  )  )     {", "toAppend    +  =     \"  ,  \"     +    text ;", "} else    {", "toAppend    =    text ;", "}", "return   toAppend ;", "}", "METHOD_END"], "methodName": ["appendName"], "fileName": "com.intellij.codeInspection.htmlInspections.RequiredAttributesInspectionBase"}, {"methodBody": ["METHOD_START", "{", "return   new   AddHtmlTagOrAttributeToCustomsIntention ( RequiredAttributesInspectionBase . SHORT _ NAME _ KEY ,    name ,    XmlBundle . message (  \" add . optional . html . attribute \"  ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["getIntentionAction"], "fileName": "com.intellij.codeInspection.htmlInspections.RequiredAttributesInspectionBase"}, {"methodBody": ["METHOD_START", "{", "final   XmlAttribute   attribute    =    tag . getAttribute ( attrName )  ;", "if    ( attribute    =  =    null )", "return   false ;", "if    (  ( attribute . getValueElement (  )  )     !  =    null )", "return   true ;", "if    (  !  ( tag   instanceof   HtmlTag )  )", "return   false ;", "final   XmlAttributeDescriptor   descriptor    =    attribute . getDescriptor (  )  ;", "return    ( descriptor    !  =    null )     &  &     ( HtmlUtil . isBooleanAttribute ( descriptor ,    tag )  )  ;", "}", "METHOD_END"], "methodName": ["hasAttribute"], "fileName": "com.intellij.codeInspection.htmlInspections.RequiredAttributesInspectionBase"}, {"methodBody": ["METHOD_START", "{", "name    =    name . toLowerCase (  )  ;", "if    (  !  ( addial . contains ( name )  )  )", "return   false ;", "StringTokenizer   tokenizer    =    new   StringTokenizer ( addial ,     \"  ,     \"  )  ;", "while    ( tokenizer . hasMoreTokens (  )  )     {", "if    ( name . equals ( tokenizer . nextToken (  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isAdditionallyDeclared"], "fileName": "com.intellij.codeInspection.htmlInspections.RequiredAttributesInspectionBase"}, {"methodBody": ["METHOD_START", "{", "if    ( start    !  =    null )     {", "holder . registerProblem ( start ,    message ,    error ,    fixes )  ;", "}", "}", "METHOD_END"], "methodName": ["registerProblem"], "fileName": "com.intellij.codeInspection.htmlInspections.RequiredAttributesInspectionBase"}, {"methodBody": ["METHOD_START", "{", "boolean   htmlTag    =    false ;", "if    ( tag   instanceof   HtmlTag )     {", "htmlTag    =    true ;", "if    (  . isAdditionallyDeclared ( getAdditionalEntries (  )  ,    name )  )", "return ;", "}", "LocalQuickFix [  ]    fixes ;", "ProblemHighlightType   highlightType ;", "if    ( htmlTag )     {", "fixes    =     ( basicIntention    =  =    null )     ?    new   LocalQuickFix [  ]  {    addAttributeFix    }     :    new   LocalQuickFix [  ]  {    addAttributeFix ,    basicIntention    }  ;", "highlightType    =     ( XmlHighlightVisitor . isInjectedWithoutValidation ( tag )  )     ?    ProblemHighlightType . INFORMATION    :    ProblemHighlightType . GENERIC _ ERROR _ OR _ WARNING ;", "} else    {", "fixes    =     ( basicIntention    =  =    null )     ?    LocalQuickFix . EMPTY _ ARRAY    :    new   LocalQuickFix [  ]  {    basicIntention    }  ;", "highlightType    =    ProblemHighlightType . ERROR ;", "}", ". addElementsForTag ( tag ,    localizedMessage ,    highlightType ,    holder ,    fixes )  ;", "}", "METHOD_END"], "methodName": ["reportOneTagProblem"], "fileName": "com.intellij.codeInspection.htmlInspections.RequiredAttributesInspectionBase"}, {"methodBody": ["METHOD_START", "{", "ExternalResourceManagerEx . getInstanceEx (  )  . setDefaultHtmlDoctype ( Html 5 SchemaProvider . getHtml 5 SchemaLocation (  )  ,    project )  ;", "DaemonCodeAnalyzer . getInstance ( project )  . restart (  )  ;", "}", "METHOD_END"], "methodName": ["applyFix"], "fileName": "com.intellij.codeInspection.htmlInspections.SwitchToHtml5Action"}, {"methodBody": ["METHOD_START", "{", "if    ( element    =  =    null )", "return   null ;", "final   ASTN   astN    =    element . getN (  )  ;", "if    ( astN    =  =    null )", "return   null ;", "ASTN   current    =    astN . getLastChildN (  )  ;", "ASTN   prev    =    current ;", "while    ( current    !  =    null )     {", "final   IElementType   elementType    =    prev . getElementType (  )  ;", "if    (  (  ( elementType    =  =     ( XmlTokenType . XML _ NAME )  )     |  |     ( elementType    =  =     ( XmlTokenType . XML _ TAG _ NAME )  )  )     &  &     (  ( current . getElementType (  )  )     =  =     ( XmlTokenType . XML _ END _ TAG _ START )  )  )     {", "return    (  ( XmlToken )     ( prev . getPsi (  )  )  )  ;", "}", "prev    =    current ;", "current    =    current . getTreePrev (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findEndTagName"], "fileName": "com.intellij.codeInspection.htmlInspections.XmlWrongClosingTagNameInspection"}, {"methodBody": ["METHOD_START", "{", "PsiElement   context    =    tag . getContainingFile (  )  . getContext (  )  ;", "if    ( context    !  =    null )     {", "ParserDefinition   parserDefinition    =    INSTANCE . forLanguage ( context . getLanguage (  )  )  ;", "if    ( parserDefinition    !  =    null )     {", "ASTNode   contextNode    =    context . getNode (  )  ;", "if    (  ( contextNode    !  =    null )     &  &     (  ( contextNode . getChildren ( parserDefinition . getStringLiteralElements (  )  )  )     !  =    null )  )     {", "return ;", "}", "}", "}", "final   String   tagName    =    tag . getName (  )  ;", "final   String   endTokenText    =    end . getText (  )  ;", "final   RenameTagBeginOrEndIntentionAction   renameEndAction    =    new   RenameTagBeginOrEndIntentionAction ( tagName ,    endTokenText ,    false )  ;", "final   RenameTagBeginOrEndIntentionAction   renameStartAction    =    new   RenameTagBeginOrEndIntentionAction ( endTokenText ,    tagName ,    true )  ;", "final   Annotation   annotation    =    holder . createErrorAnnotation ( end ,    XmlErrorMessages . message (  \" wrong . closing . tag . name \"  )  )  ;", "annotation . registerFix ( new   RemoveExtraIntentionAction (  )  )  ;", "annotation . registerFix ( renameEndAction )  ;", "annotation . registerFix ( renameStartAction )  ;", "}", "METHOD_END"], "methodName": ["registerProblemEnd"], "fileName": "com.intellij.codeInspection.htmlInspections.XmlWrongClosingTagNameInspection"}, {"methodBody": ["METHOD_START", "{", "PsiElement   context    =    tag . getContainingFile (  )  . getContext (  )  ;", "if    ( context    !  =    null )     {", "ParserDefinition   parserDefinition    =    INSTANCE . forLanguage ( context . getLanguage (  )  )  ;", "if    ( parserDefinition    !  =    null )     {", "ASTNode   contextNode    =    context . getNode (  )  ;", "if    (  ( contextNode    !  =    null )     &  &     (  ( contextNode . getChildren ( parserDefinition . getStringLiteralElements (  )  )  )     !  =    null )  )     {", "return ;", "}", "}", "}", "final   String   t    =    tag . getName (  )  ;", "final   String   endTokenText    =    end . getText (  )  ;", "final   RenameTagBeginOrEndIntentionAction   renameEndAction    =    new   RenameTagBeginOrEndIntentionAction ( t ,    endTokenText ,    false )  ;", "final   RenameTagBeginOrEndIntentionAction   renameStartAction    =    new   RenameTagBeginOrEndIntentionAction ( endTokenText ,    t ,    true )  ;", "final   Annotation   annotation    =    holder . createErrorAnnotation ( start ,    XmlErrorMessages . message (  \" tag . has . wrong . closing . tag . name \"  )  )  ;", "annotation . registerFix ( renameEndAction )  ;", "annotation . registerFix ( renameStartAction )  ;", "}", "METHOD_END"], "methodName": ["registerProblemStart"], "fileName": "com.intellij.codeInspection.htmlInspections.XmlWrongClosingTagNameInspection"}, {"methodBody": ["METHOD_START", "{", "return    (  \"  / xml / tests / testData / editor /  \"     +     ( getTestName ( true )  )  )     +     ( isOriginal    ?     \"  . xml \"     :     \"  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["getTestFilePath"], "fileName": "com.intellij.editor.XmlEditorTest"}, {"methodBody": ["METHOD_START", "{", "configureByFile ( getTestFilePath ( true )  )  ;", "for    ( int   i    =     0  ;    i    <     3  ;    i +  +  )     {", "Util . performTypingAction ( myEditor ,     '  \\ n '  )  ;", "}", "PlatformTestUtil . startPerformanceTest (  \" Xml   editor   enter \"  ,     5  0  0  0  ,     (  )     -  >     {", "for    ( int   i    =     0  ;    i    <     3  ;    i +  +  )     {", "Util . performTypingAction ( myEditor ,     '  \\ n '  )  ;", "}", "}  )  . attempts (  1  )  . assertTiming (  )  ;", "checkResultByFile ( getTestFilePath ( false )  )  ;", "}", "METHOD_END"], "methodName": ["testEnterPerformance"], "fileName": "com.intellij.editor.XmlEditorTest"}, {"methodBody": ["METHOD_START", "{", "configureFromFileText (  \" a . xml \"  ,     (  \"  <  ! DOCTYPE   svg   PUBLIC    \\  \"  -  /  / W 3 C /  / DTD   SVG    1  .  1  /  / EN \\  \"     \\  \" http :  /  / www . w 3  . org / Graphics / SVG /  1  .  1  / DTD / svg 1  1  . dtd \\  \"  >  \\ n \"     +     (  (  (  (  \"  < svg   version =  \\  \"  1  .  1  \\  \"    id =  \\  \" Layer _  1  \\  \"    xmlns =  \\  \" http :  /  / www . w 3  . org /  2  0  0  0  / svg \\  \"  >  \\ n \"     +     \"  < g >  \\ n \"  )     +     \"                          < path   clip - path =  \\  \" url (  # SVGID _  2  _  )  \\  \"    fill =  \\  \"  # ffffff \\  \"    stroke =  \\  \"  < selection >  #  0  0  0  0  0  0  <  / selection >  \\  \"    stroke - width =  \\  \"  2  \\  \"    stroke - linecap =  \\  \" round \\  \"    stroke - linejoin =  \\  \" round \\  \"    stroke - miterlimit =  \\  \"  1  0  \\  \"    d =  \\  \" M 1  9  .  3  3  3  ,  8  .  3  3  3 V 1  2 c 0  ,  1  .  5  1  9  -  7  .  3  3  3  ,  4  -  7  .  3  3  3  ,  4 s -  7  .  3  3  3  -  2  .  4  8  1  -  7  .  3  3  3  -  4 V 8  .  3  3  3  \\  \"  /  >  \\ n \"  )     +     \"  <  / g >  \\ n \"  )     +     \"  <  / svg >  \"  )  )  )  ;", "CodeStyleSettings   clone    =    CodeStyleSettingsManager . getInstance ( getProject (  )  )  . getCurrentSettings (  )  . clone (  )  ;", "clone . WRAP _ WHEN _ TYPING _ REACHES _ RIGHT _ MARGIN    =    true ;", "try    {", "CodeStyleSettingsManager . getInstance ( getProject (  )  )  . setTemporarySettings ( clone )  ;", "Util . performTypingAction ( getEditor (  )  ,     ' x '  )  ;", "}    finally    {", "CodeStyleSettingsManager . getInstance ( getProject (  )  )  . dropTemporarySettings (  )  ;", "}", "checkResultByText (  (  \"  <  ! DOCTYPE   svg   PUBLIC    \\  \"  -  /  / W 3 C /  / DTD   SVG    1  .  1  /  / EN \\  \"     \\  \" http :  /  / www . w 3  . org / Graphics / SVG /  1  .  1  / DTD / svg 1  1  . dtd \\  \"  >  \\ n \"     +     (  (  (  (  (  \"  < svg   version =  \\  \"  1  .  1  \\  \"    id =  \\  \" Layer _  1  \\  \"    xmlns =  \\  \" http :  /  / www . w 3  . org /  2  0  0  0  / svg \\  \"  >  \\ n \"     +     \"  < g >  \\ n \"  )     +     \"                          < path   clip - path =  \\  \" url (  # SVGID _  2  _  )  \\  \"    fill =  \\  \"  # ffffff \\  \"    stroke =  \\  \" x \\  \"    stroke - width =  \\  \"  2  \\  \"    stroke - linecap =  \\  \" round \\  \"     \\ n \"  )     +     \"                                           stroke - linejoin =  \\  \" round \\  \"    stroke - miterlimit =  \\  \"  1  0  \\  \"    d =  \\  \" M 1  9  .  3  3  3  ,  8  .  3  3  3 V 1  2 c 0  ,  1  .  5  1  9  -  7  .  3  3  3  ,  4  -  7  .  3  3  3  ,  4 s -  7  .  3  3  3  -  2  .  4  8  1  -  7  .  3  3  3  -  4 V 8  .  3  3  3  \\  \"  /  >  \\ n \"  )     +     \"  <  / g >  \\ n \"  )     +     \"  <  / svg >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testHardWrap"], "fileName": "com.intellij.editor.XmlEditorTest"}, {"methodBody": ["METHOD_START", "{", "configureFromFileText (  \" a . xml \"  ,     \"  <  !  -  -    Some   very   long   and   informative   xml   comment   to   trigger   hard   wrapping   indeed .    Too   short ?    Dave ,    let   me   ask   you   something .    Are   hard   wraps   working ?    What   do   we   live   for ?    What   ice - cream   do   you   like ?    Who   am   I ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  < caret >  -  -  >  \"  )  ;", "CodeStyleSettings   clone    =    CodeStyleSettingsManager . getInstance ( getProject (  )  )  . getCurrentSettings (  )  . clone (  )  ;", "clone . WRAP _ WHEN _ TYPING _ REACHES _ RIGHT _ MARGIN    =    true ;", "try    {", "CodeStyleSettingsManager . getInstance ( getProject (  )  )  . setTemporarySettings ( clone )  ;", "Util . performTypingAction ( getEditor (  )  ,     '  ?  '  )  ;", "}    finally    {", "CodeStyleSettingsManager . getInstance ( getProject (  )  )  . dropTemporarySettings (  )  ;", "}", "checkResultByText (  (  \"  <  !  -  -    Some   very   long   and   informative   xml   comment   to   trigger   hard   wrapping   indeed .    Too   short ?    Dave ,    let   me   ask   you    \\ n \"     +     \" something .    Are   hard   wraps   working ?    What   do   we   live   for ?    What   ice - cream   do   you   like ?    Who   am   I ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?  -  -  >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testHardWrapInComment"], "fileName": "com.intellij.editor.XmlEditorTest"}, {"methodBody": ["METHOD_START", "{", "configureFromFileText (  (  ( getTestName ( true )  )     +     \"  . xml \"  )  ,     (  \"  < body >  \\ n \"     +     (  (  \"    a < caret > b \\ n \"     +     \"    cd \\ n \"  )     +     \"  <  / body >  \"  )  )  )  ;", "executeAction ( ACTION _ EDITOR _ JOIN _ LINES )  ;", "checkResultByText (  (  \"  < body >  \\ n \"     +     (  \"    ab   cd \\ n \"     +     \"  <  / body >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testJoiningText"], "fileName": "com.intellij.editor.XmlJoinLinesTest"}, {"methodBody": ["METHOD_START", "{", "final   Language   language    =    chameleon . getElementType (  )  . getLanguage (  )  ;", "final   ParserDefinition   parserDefinition    =    INSTANCE . forLanguage ( language )  ;", "return   parserDefinition . createLexer ( project )  ;", "}", "METHOD_END"], "methodName": ["createLexer"], "fileName": "com.intellij.embedding.EmbeddedLazyParseableElementType"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder   builder ;", "if    ( lexer   instanceof   MasqueradingLexer )     {", "builder    =    new   MasqueradingPsiBuilderAdapter ( project ,    parserDefinition ,     (  ( MasqueradingLexer )     ( lexer )  )  ,    chameleon ,    chameleon . getChars (  )  )  ;", "} else    {", "builder    =    new   lang . impl . PsiBuilderImpl ( project ,    parserDefinition ,    lexer ,    chameleon ,    chameleon . getChars (  )  )  ;", "}", "return   builder ;", "}", "METHOD_END"], "methodName": ["getBuilder"], "fileName": "com.intellij.embedding.EmbeddedLazyParseableElementType"}, {"methodBody": ["METHOD_START", "{", "return   INSTANCE . forLanguage ( getLanguage (  )  )  . createParser ( builder . getProject (  )  )  ;", "}", "METHOD_END"], "methodName": ["getParser"], "fileName": "com.intellij.embedding.EmbeddedLazyParseableElementType"}, {"methodBody": ["METHOD_START", "{", "final   PsiParser   parser    =    getParser ( builder )  ;", "return   parser . parse ( this ,    builder )  ;", "}", "METHOD_END"], "methodName": ["parseAndGetTree"], "fileName": "com.intellij.embedding.EmbeddedLazyParseableElementType"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   prevLeaf    =    TreeUtil . prevLeaf ( chameleon ,    true )  ;", "if    ( prevLeaf    =  =    null )     {", "return    0  ;", "}", "final   CharSequence   text    =    prevLeaf . getChars (  )  ;", "int   offset    =    text . length (  )  ;", "int   answer    =     0  ;", "while    (  (  -  - offset )     >  =     0  )     {", "final   char   c    =    text . charAt ( offset )  ;", "if    ( c    =  =     '  \\ n '  )     {", "break ;", "}", "if    (  ( c    !  =     '     '  )     &  &     ( c    !  =     '  \\ t '  )  )     {", "answer    =     0  ;", "break ;", "}", "answer +  +  ;", "}", "return   answer ;", "}", "METHOD_END"], "methodName": ["calcBaseIndent"], "fileName": "com.intellij.embedding.EmbeddingUtil"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   result    =    new   StringBuilder (  )  ;", "int   offset    =    startOffset ;", "for    (  . DeletedIndentInfo   deletion    :    myDeletions )     {", "result . append ( buffer . subSequence ( offset ,    deletion . getRealPos (  )  )  )  ;", "deletion . setShrunkPos ( result . length (  )  )  ;", "offset    =     ( deletion . getRealPos (  )  )     +     ( deletion . getLength (  )  )  ;", "}", "result . append ( buffer . subSequence ( offset ,    endOffset )  )  ;", "return   result . toString (  )  ;", "}", "METHOD_END"], "methodName": ["deleteIndents"], "fileName": "com.intellij.embedding.IndentEatingLexer"}, {"methodBody": ["METHOD_START", "{", "List < IndentEatingLexer . DeletedIndentInfo >    result    =    new   ArrayList <  >  (  )  ;", "int   offset    =    startOffset ;", "while    ( offset    <    endOffset )     {", "final   int   newline    =    StringUtil . indexOf ( buffer ,     '  \\ n '  ,    offset ,    endOffset )  ;", "if    ( newline    <     0  )     {", "break ;", "}", "int   charsToDelete    =     0  ;", "char   c ;", "while    (  (  (  ( charsToDelete    <     ( myIndent )  )     &  &     (  (  ( newline    +    charsToDelete )     +     1  )     <    endOffset )  )     &  &     (  ( c    =    buffer . charAt (  (  ( newline    +    charsToDelete )     +     1  )  )  )     !  =     '  \\ n '  )  )     &  &     ( Character . isWhitespace ( c )  )  )     {", "charsToDelete +  +  ;", "}", "if    ( charsToDelete    >     0  )     {", "result . add ( new   IndentEatingLexer . DeletedIndentInfo (  ( newline    +     1  )  ,    charsToDelete )  )  ;", "}", "offset    =     ( newline    +    charsToDelete )     +     1  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["findAllDeletions"], "fileName": "com.intellij.embedding.IndentEatingLexer"}, {"methodBody": ["METHOD_START", "{", "myTotalDelta    +  =    myCurrentDelta ;", "myCurrentDelta    =     0  ;", "while    (  ( myCurrentDelIndex )     <     ( myDeletions . size (  )  )  )     {", "final    . DeletedIndentInfo   info    =    myDeletions . get ( myCurrentDelIndex )  ;", "if    (  (  ( info . getShrunkPos (  )  )     >  =     ( super . getTokenStart (  )  )  )     &  &     (  ( info . getShrunkPos (  )  )     <  =     ( super . getTokenEnd (  )  )  )  )     {", "myCurrentDelta    +  =    info . getLength (  )  ;", "( myCurrentDelIndex )  +  +  ;", "} else    {", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["updateDeltas"], "fileName": "com.intellij.embedding.IndentEatingLexer"}, {"methodBody": ["METHOD_START", "{", "if    ( exact )     {", "return   myShrunkSence . get ( myLexPosition )  . realStart ;", "}", "int   lexPosition    =    myLexPosition ;", "while    (  ( lexPosition    >     0  )     &  &     (  (  ( myShrunkSence . get (  ( lexPosition    -     1  )  )  . shrunkStart )     =  =     ( myShrunkSence . get ( lexPosition )  . shrunkStart )  )     |  |     ( isWhiteSpaceOnPos (  ( lexPosition    -     1  )  )  )  )  )     {", "lexPosition -  -  ;", "}", "if    ( lexPosition    =  =     0  )     {", "return   myShrunkSence . get ( lexPosition )  . realStart ;", "}", "return    ( myShrunkSence . get (  ( lexPosition    -     1  )  )  . realStart )     +     1  ;", "}", "METHOD_END"], "methodName": ["getKeepUpPosition"], "fileName": "com.intellij.embedding.MasqueradingPsiBuilderAdapter"}, {"methodBody": ["METHOD_START", "{", "initTokenListAndCharSequence ( myLexer )  ;", "myLexPosition    =     0  ;", "}", "METHOD_END"], "methodName": ["initShrunkSequence"], "fileName": "com.intellij.embedding.MasqueradingPsiBuilderAdapter"}, {"methodBody": ["METHOD_START", "{", "lexer . start ( getDelegate (  )  . getOriginalText (  )  )  ;", "myShrunkSequence    =    new   ArrayList <  >  (  )  ;", "StringBuilder   charSequenceBuilder    =    new   StringBuilder (  )  ;", "int   realPos    =     0  ;", "int   shrunkPos    =     0  ;", "while    (  ( lexer . getTokenType (  )  )     !  =    null )     {", "final   IElementType   masqueTokenType    =    lexer . getMasqueTokenType (  )  ;", "final   String   masqueTokenText    =    lexer . getMasqueTokenText (  )  ;", "final   int   realLength    =     ( lexer . getTokenEnd (  )  )     -     ( lexer . getTokenStart (  )  )  ;", "if    ( masqueTokenType    !  =    null )     {", "assert   masqueTokenText    !  =    null ;", "final   int   masqueLength    =    masqueTokenText . length (  )  ;", "myShrunkSequence . add ( new    . MyShiftedToken ( masqueTokenType ,    realPos ,     ( realPos    +    realLength )  ,    shrunkPos ,     ( shrunkPos    +    masqueLength )  )  )  ;", "charSequenceBuilder . append ( masqueTokenText )  ;", "shrunkPos    +  =    masqueLength ;", "}", "realPos    +  =    realLength ;", "lexer . advance (  )  ;", "}", "myShrunkCharSequence    =    charSequenceBuilder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["initTokenListAndCharSequence"], "fileName": "com.intellij.embedding.MasqueradingPsiBuilderAdapter"}, {"methodBody": ["METHOD_START", "{", "return   myBuilderDelegate . whitespaceOrComment ( myShrunkSequence . get ( pos )  . elementType )  ;", "}", "METHOD_END"], "methodName": ["isWhiteSpaceOnPos"], "fileName": "com.intellij.embedding.MasqueradingPsiBuilderAdapter"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "sb . append (  (  (  (  \"  \\ nmyLexPosition =  \"     +     ( myLexPosition )  )     +     \"  /  \"  )     +     ( myShrunkSequence . size (  )  )  )  )  ;", "if    (  ( myLexPosition )     <     ( myShrunkSequence . size (  )  )  )     {", "final    . MyShiftedToken   token    =    myShrunkSequence . get ( myLexPosition )  ;", "sb . append (  (  (  (  \"  \\ nshrunk :  \"     +     ( token . shrunkStart )  )     +     \"  ,  \"  )     +     ( token . shrunkEnd )  )  )  ;", "sb . append (  (  (  (  \"  \\ nreal :  \"     +     ( token . realStart )  )     +     \"  ,  \"  )     +     ( token . realEnd )  )  )  ;", "sb . append (  (  \"  \\ nTT :  \"     +     ( getTokenText (  )  )  )  )  ;", "}", "sb . append (  \"  \\ ndelegate :  \"  )  ;", "sb . append (  (  \" eof =  \"     +     ( myDelegate . eof (  )  )  )  )  ;", "if    (  !  ( myDelegate . eof (  )  )  )     {", "sb . append (  (  (  (  \"  \\ nposition :  \"     +     ( myDelegate . getCurrentOffset (  )  )  )     +     \"  ,  \"  )     +     (  ( myDelegate . getCurrentOffset (  )  )     +     ( myDelegate . getTokenText (  )  . length (  )  )  )  )  )  ;", "sb . append (  (  \"  \\ nTT :  \"     +     ( myDelegate . getTokenText (  )  )  )  )  ;", "}", ". LOG . info ( sb . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["logPos"], "fileName": "com.intellij.embedding.MasqueradingPsiBuilderAdapter"}, {"methodBody": ["METHOD_START", "{", "while    (  (  ( myLexPosition )     <     ( myShrunkSequence . size (  )  )  )     &  &     ( isWhiteSpaceOnPos ( myLexPosition )  )  )     {", "( myLexPosition )  +  +  ;", "}", "}", "METHOD_END"], "methodName": ["skipWhitespace"], "fileName": "com.intellij.embedding.MasqueradingPsiBuilderAdapter"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder   delegate    =    getDelegate (  )  ;", "if    (  (  ( myLexPosition )     >  =     ( myShrunkSequence . size (  )  )  )     |  |     ( delegate . eof (  )  )  )     {", "myLexPosition    =    myShrunkSequence . size (  )  ;", "while    (  !  ( delegate . eof (  )  )  )     {", "delegate . advanceLexer (  )  ;", "}", "return ;", "}", "if    (  ( delegate . getCurrentOffset (  )  )     >     ( myShrunkSequence . get ( myLexPosition )  . realStart )  )     {", ". LOG . error (  \" delegate   is   ahead   of   my   builder !  \"  ,    new   Attachment (  (  \" offset    =     \"     +     ( delegate . getCurrentOffset (  )  )  )  ,    getOriginalText (  )  . toString (  )  )  ,    new   Attachment (  \" myShrunkSequence \"  ,    myShrunkSequence . toString (  )  )  )  ;", "return ;", "}", "final   int   keepUpPosition    =    getKeepUpPosition ( exact )  ;", "while    (  !  ( delegate . eof (  )  )  )     {", "final   int   delegatePosition    =    delegate . getCurrentOffset (  )  ;", "if    ( delegatePosition    <    keepUpPosition )     {", "delegate . advanceLexer (  )  ;", "} else    {", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["synchronizePositions"], "fileName": "com.intellij.embedding.MasqueradingPsiBuilderAdapter"}, {"methodBody": ["METHOD_START", "{", "configureFromFileText (  \" test . html \"  ,    text )  ;", "PsiElement   originalElement    =    getFile (  )  . findElementAt ( myEditor . getCaretModel (  )  . getOffset (  )  )  ;", "PsiElement   element    =    Manager . getInstance ( getProject (  )  )  . findTargetElement ( getEditor (  )  ,    getFile (  )  )  ;", "Provider   documentationProvider    =    Manager . getProviderFromElement ( originalElement )  ;", "assertNotNull (  \" inline   help   is   null \"  ,    documentationProvider . generateDoc ( element ,    originalElement )  )  ;", "assertNotNull (  \" external   help   is   null \"  ,    documentationProvider . getUrlFor ( element ,    originalElement )  )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.html.HtmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "HtmlDocumentationTest . doTest (  (  \"  <  ! DOCTYPE   HTML   PUBLIC    \\  \"  -  /  / W 3 C /  / DTD   HTML    4  .  0  1    Transitional /  / EN \\  \"  \\ n \"     +     (  (  (  (  \"           \\  \" http :  /  / www . w 3  . org / TR / html 4  / loose . dtd \\  \"  >  \\ n \"     +     \"  < html >  \\ n \"  )     +     \"  < body   on < caret > load =  \\  \"  \\  \"  >  \\ n \"  )     +     \"  <  / body >  \\ n \"  )     +     \"  <  / html >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testQuickDocumentationHtml4Attr"], "fileName": "com.intellij.html.HtmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "HtmlDocumentationTest . doTest (  (  \"  <  ! DOCTYPE   HTML   PUBLIC    \\  \"  -  /  / W 3 C /  / DTD   HTML    4  .  0  1    Transitional /  / EN \\  \"  \\ n \"     +     (  (  (  (  \"           \\  \" http :  /  / www . w 3  . org / TR / html 4  / loose . dtd \\  \"  >  \\ n \"     +     \"  < html >  \\ n \"  )     +     \"  < bo < caret > dy   onload =  \\  \"  \\  \"  >  \\ n \"  )     +     \"  <  / body >  \\ n \"  )     +     \"  <  / html >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testQuickDocumentationHtml4Tag"], "fileName": "com.intellij.html.HtmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "HtmlDocumentationTest . doTest (  (  \"  <  ! DOCTYPE   html >  \\ n \"     +     (  (  (  \"  < html >  \\ n \"     +     \"  < body   on < caret > load =  \\  \"  \\  \"  >  \\ n \"  )     +     \"  <  / body >  \\ n \"  )     +     \"  <  / html >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testQuickDocumentationHtml5Attr"], "fileName": "com.intellij.html.HtmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "HtmlDocumentationTest . doTest (  (  \"  <  ! DOCTYPE   html >  \\ n \"     +     (  (  (  \"  < html >  \\ n \"     +     \"  < bo < caret > dy   onload =  \\  \"  \\  \"  >  \\ n \"  )     +     \"  <  / body >  \\ n \"  )     +     \"  <  / html >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testQuickDocumentationHtml5Tag"], "fileName": "com.intellij.html.HtmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "HtmlDocumentationTest . doTest (  (  \"  <  ! DOCTYPE   html >  \\ n \"     +     (  (  (  (  \"  < html >  \\ n \"     +     \"  < body   onload =  \\  \"  \\  \"  >  \\ n \"  )     +     \"  < dia < caret > log >  <  / dialog \\ n \"  )     +     \"  <  / body >  \\ n \"  )     +     \"  <  / html >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testQuickDocumentationHtml5TagDialog"], "fileName": "com.intellij.html.HtmlDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "List < LineMarkerProvider >    markerProviders    =    embeddedLanguagesLineMarkerProviders . get ( language )  ;", "if    ( markerProviders    =  =    null )     {", "markerProviders    =    INSTANCE . allForLanguage ( language )  ;", "embeddedLanguagesLineMarkerProviders . put ( language ,    markerProviders )  ;", "}", "return   markerProviders ;", "}", "METHOD_END"], "methodName": ["getAllLineMarkerProvidersForLanguage"], "fileName": "com.intellij.html.HtmlLineMarkerProvider"}, {"methodBody": ["METHOD_START", "{", "doFailTestInHtml (  \"  < section >  < div    < caret >  >  <  / div >  <  / section >  \"  ,     \" itemprop \"  )  ;", "}", "METHOD_END"], "methodName": ["_testPropWithinScope"], "fileName": "com.intellij.html.MicrodataCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doFailTestInHtml (  \"  < a    < caret >  >  <  / a >  \"  ,     \" itemtype \"  ,     \" itemid \"  )  ;", "}", "METHOD_END"], "methodName": ["_testTypeInATag"], "fileName": "com.intellij.html.MicrodataCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doFailTestInHtml (  \"  < section    < caret >  >  < div >  <  / div >  <  / section >  \"  ,     \" itemtype \"  ,     \" itemid \"  )  ;", "}", "METHOD_END"], "methodName": ["_testTypeWithinScope"], "fileName": "com.intellij.html.MicrodataCompletionTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText ( HTML ,    text )  ;", "myFixture . ce ( BASIC )  ;", "}", "METHOD_END"], "methodName": ["configureAndComplete"], "fileName": "com.intellij.html.MicrodataCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureAndComplete ( text )  ;", "final   List < String >    lookups    =    myFixture . getLookupElementStrings (  )  ;", "assertNotNull ( lookups )  ;", "for    ( String   item    :    items )     {", "assertFalse (  (  \" Should   not   contain :     \"     +    item )  ,    lookups . contains ( item )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doFailTestInHtml"], "fileName": "com.intellij.html.MicrodataCompletionTest"}, {"methodBody": ["METHOD_START", "{", "configureAndComplete ( text )  ;", "assertContainsElements ( myFixture . getLookupElementStrings (  )  ,    Arrays . asList ( items )  )  ;", "}", "METHOD_END"], "methodName": ["doTestInHtml"], "fileName": "com.intellij.html.MicrodataCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestInHtml (  \"  < section   itemscope >  < div    < caret >  >  <  / div >  <  / section >  \"  ,     \" itemprop \"  )  ;", "}", "METHOD_END"], "methodName": ["testPropInScope"], "fileName": "com.intellij.html.MicrodataCompletionTest"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   virtualFile    =    myFixture . copyFileToProject (  \" Person . html \"  )  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily (  \" http :  /  / data - vocabulary . org / Person \"  ,    virtualFile . getPath (  )  ,    getTestRootDisposable (  )  )  ;", "doTestInHtml (  \"  < section   itemscope   itemtype =  \\  \" http :  /  / data - vocabulary . org / Person \\  \"  >  < div   itemprop =  \\  \"  < caret >  \\  \"  >  <  / div >  <  / section >  \"  ,     \" name \"  ,     \" nickname \"  ,     \" photo \"  ,     \" title \"  ,     \" role \"  ,     \" url \"  ,     \" affiliation \"  ,     \" friend \"  ,     \" acquaintance \"  ,     \" address \"  )  ;", "}", "METHOD_END"], "methodName": ["testPropValue"], "fileName": "com.intellij.html.MicrodataCompletionTest"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   virtualFile    =    myFixture . copyFileToProject (  \" Person . html \"  )  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily (  \" http :  /  / data - vocabulary . org / Person \"  ,    virtualFile . getPath (  )  ,    getTestRootDisposable (  )  )  ;", "doTestInHtml (  (  \"  < body >  \"     +     (  (  \"  < section   itemscope   itemtype =  \\  \" http :  /  / data - vocabulary . org / Person \\  \"    itemref =  \\  \" foo \\  \"  >  <  / section >  \"     +     \"  < section   id =  \\  \" foo \\  \"  >  < div   itemprop =  \\  \"  < caret >  \\  \"  >  <  / div >  <  / section >  \"  )     +     \"  <  / body >  \"  )  )  ,     \" name \"  ,     \" nickname \"  ,     \" photo \"  ,     \" title \"  ,     \" role \"  ,     \" url \"  ,     \" affiliation \"  ,     \" friend \"  ,     \" acquaintance \"  ,     \" address \"  )  ;", "}", "METHOD_END"], "methodName": ["testPropValueFromRef"], "fileName": "com.intellij.html.MicrodataCompletionTest"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   personFile    =    myFixture . copyFileToProject (  \" Person . html \"  )  ;", "final   VirtualFile   addressFile    =    myFixture . copyFileToProject (  \" Address . html \"  )  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily (  \" http :  /  / data - vocabulary . org / Person \"  ,    personFile . getPath (  )  ,    getTestRootDisposable (  )  )  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily (  \" http :  /  / data - vocabulary . org / Address \"  ,    addressFile . getPath (  )  ,    getTestRootDisposable (  )  )  ;", "doTestInHtml (  \"  < section   itemscope   itemtype =  \\  \" http :  /  / data - vocabulary . org / Person   http :  /  / data - vocabulary . org / Address \\  \"  >  < div   itemprop =  \\  \"  < caret >  \\  \"  >  <  / div >  <  / section >  \"  ,     \" name \"  ,     \" nickname \"  ,     \" photo \"  ,     \" title \"  ,     \" role \"  ,     \" url \"  ,     \" affiliation \"  ,     \" friend \"  ,     \" acquaintance \"  ,     \" address \"  ,     \" street - address \"  ,     \" locality \"  ,     \" region \"  ,     \" postal - code \"  ,     \" country - name \"  )  ;", "}", "METHOD_END"], "methodName": ["testPropValueFromTwoTypes"], "fileName": "com.intellij.html.MicrodataCompletionTest"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   personFile    =    myFixture . copyFileToProject (  \" Person . html \"  )  ;", "final   VirtualFile   addressFile    =    myFixture . copyFileToProject (  \" Address . html \"  )  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily (  \" http :  /  / data - vocabulary . org / Person \"  ,    personFile . getPath (  )  ,    getTestRootDisposable (  )  )  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily (  \" http :  /  / data - vocabulary . org / Address \"  ,    addressFile . getPath (  )  ,    getTestRootDisposable (  )  )  ;", "doTestInHtml (  (  \"  < div   itemscope   itemtype =  \\  \" http :  /  / data - vocabulary . org / Person \\  \"  >  \\ n \"     +     (  (  (  (  (  \"             My   name   is    < span   itemprop =  \\  \" name \\  \"  > Smith <  / span >  \\ n \"     +     \"              < span   itemprop =  \\  \"  < caret >  \\  \"    itemscope   itemtype =  \\  \" http :  /  / data - vocabulary . org / Address \\  \"  >  \\ n \"  )     +     \"                          < span   itemprop =  \\  \" locality \\  \"  > Albuquerque <  / span >  \\ n \"  )     +     \"                          < span   itemprop =  \\  \" region \\  \"  > NM <  / span >  \\ n \"  )     +     \"              <  / span >  \\ n \"  )     +     \"  <  / div >  \"  )  )  ,     \" name \"  ,     \" nickname \"  ,     \" photo \"  ,     \" title \"  ,     \" role \"  ,     \" url \"  ,     \" affiliation \"  ,     \" friend \"  ,     \" acquaintance \"  ,     \" address \"  )  ;", "}", "METHOD_END"], "methodName": ["testPropValueNestedScopes"], "fileName": "com.intellij.html.MicrodataCompletionTest"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   personFile    =    myFixture . copyFileToProject (  \" Person . html \"  )  ;", "final   VirtualFile   addressFile    =    myFixture . copyFileToProject (  \" Address . html \"  )  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily (  \" http :  /  / data - vocabulary . org / Person \"  ,    personFile . getPath (  )  ,    getTestRootDisposable (  )  )  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily (  \" http :  /  / data - vocabulary . org / Address \"  ,    addressFile . getPath (  )  ,    getTestRootDisposable (  )  )  ;", "doTestInHtml (  (  \"  < div   itemscope   itemtype =  \\  \" http :  /  / data - vocabulary . org / Person \\  \"     >  \\ n \"     +     (  (  (  (  (  (  (  (  (  \"             name   is    < span   itemprop =  \\  \" name \\  \"  > ann <  / span >  \\ n \"     +     \"             role   is    < span   itemprop =  \\  \" role \\  \"  > smth <  / span >  \\ n \"  )     +     \"           < span   itemprop =  \\  \" address \\  \"    itemscope \\ n \"  )     +     \"                            itemtype =  \\  \" http :  /  / data - vocabulary . org / Address \\  \"    itemref =  \\  \" qq \\  \"  >  \\ n \"  )     +     \"                    < span   itemprop =  \\  \" locality \\  \"  > spb <  / span >  \\ n \"  )     +     \"           <  / span >  \\ n \"  )     +     \"  <  / div >  \\ n \"  )     +     \"  < div >  \\ n \"  )     +     \"              < span   id =  \\  \" qq \\  \"    itemprop =  \\  \"  < caret >  \\  \"  > russia <  / span >  \\ n \"  )     +     \"  <  / div >  \"  )  )  ,     \" street - address \"  ,     \" locality \"  ,     \" region \"  ,     \" postal - code \"  ,     \" country - name \"  )  ;", "}", "METHOD_END"], "methodName": ["testPropValueNestedScopesDifferentTrees"], "fileName": "com.intellij.html.MicrodataCompletionTest"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   virtualFile    =    myFixture . copyFileToProject (  \" Product . html \"  )  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily (  \" http :  /  / schema . org / Product \"  ,    virtualFile . getPath (  )  ,    getTestRootDisposable (  )  )  ;", "doTestInHtml (  \"  < section   itemscope   itemtype =  \\  \" http :  /  / schema . org / Product \\  \"  >  < div   itemprop =  \\  \"  < caret >  \\  \"  >  <  / div >  <  / section >  \"  ,     \" additionalType \"  ,     \" aggregateRating \"  ,     \" brand \"  ,     \" color \"  ,     \" depth \"  ,     \" description \"  ,     \" gtin 1  3  \"  ,     \" gtin 1  4  \"  ,     \" gtin 8  \"  ,     \" height \"  ,     \" image \"  ,     \" isAccessoryOrSparePartFor \"  ,     \" isConsumableFor \"  ,     \" isRelatedTo \"  ,     \" isSimilarTo \"  ,     \" itemCondition \"  ,     \" logo \"  ,     \" manufacturer \"  ,     \" model \"  ,     \" mpn \"  ,     \" name \"  ,     \" offers \"  ,     \" productID \"  ,     \" releaseDate \"  ,     \" review \"  ,     \" reviews \"  ,     \" sku \"  ,     \" url \"  ,     \" weight \"  ,     \" width \"  )  ;", "}", "METHOD_END"], "methodName": ["testPropValueSchemaOrgFormat"], "fileName": "com.intellij.html.MicrodataCompletionTest"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   virtualFile    =    myFixture . copyFileToProject (  \" Rating . html \"  )  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily (  \" http :  /  / schema . org / Rating \"  ,    virtualFile . getPath (  )  ,    getTestRootDisposable (  )  )  ;", "doTestInHtml (  \"  < section   itemscope   itemtype =  \\  \" http :  /  / schema . org / Rating \\  \"  >  < div   itemprop =  \\  \"  < caret >  \\  \"  >  <  / div >  <  / section >  \"  ,     \" alternateName \"  ,     \" bestRating \"  ,     \" description \"  ,     \" image \"  ,     \" name \"  ,     \" potentialAction \"  ,     \" ratingValue \"  ,     \" reviewRating \"  ,     \" sameAs \"  ,     \" url \"  ,     \" worstRating \"  )  ;", "}", "METHOD_END"], "methodName": ["testPropValueSchemaOrgFormatWithLinks"], "fileName": "com.intellij.html.MicrodataCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestInHtml (  (  \"  < body >  \"     +     (  (  \"  < section   itemscope   itemref =  \\  \" bar   foo \\  \"  >  <  / section >  \"     +     \"  < section   id =  \\  \" foo \\  \"  >  < div    < caret >  >  <  / div >  <  / section >  \"  )     +     \"  <  / body >  \"  )  )  ,     \" itemprop \"  )  ;", "}", "METHOD_END"], "methodName": ["testPropWithinScopeWithRef"], "fileName": "com.intellij.html.MicrodataCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestInHtml (  \"  < section   itemscope   itemref =  \\  \" b < caret >  \\  \"  >  <  / section >  < p   id =  \\  \" bar \\  \"  >  <  / p >  < p   id =  \\  \" baz \\  \"  >  <  / p >  \"  ,     \" bar \"  ,     \" baz \"  )  ;", "}", "METHOD_END"], "methodName": ["testRefInScope"], "fileName": "com.intellij.html.MicrodataCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestInHtml (  \"  < a    < caret >  >  <  / a >  \"  ,     \" itemscope \"  )  ;", "}", "METHOD_END"], "methodName": ["testScopeInATag"], "fileName": "com.intellij.html.MicrodataCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestInHtml (  \"  < div    < caret >  >  <  / div >  \"  ,     \" itemscope \"  )  ;", "}", "METHOD_END"], "methodName": ["testScopeInDivTag"], "fileName": "com.intellij.html.MicrodataCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestInHtml (  \"  < span    < caret >  >  <  / span >  \"  ,     \" itemscope \"  )  ;", "}", "METHOD_END"], "methodName": ["testScopeInSpanTag"], "fileName": "com.intellij.html.MicrodataCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestInHtml (  \"  < section    < caret >  >  <  / section >  \"  ,     \" itemscope \"  )  ;", "}", "METHOD_END"], "methodName": ["testScopeType"], "fileName": "com.intellij.html.MicrodataCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestInHtml (  \"  < section   itemscope    < caret >  >  < div >  <  / div >  <  / section >  \"  ,     \" itemtype \"  ,     \" itemid \"  )  ;", "}", "METHOD_END"], "methodName": ["testTypeInScope"], "fileName": "com.intellij.html.MicrodataCompletionTest"}, {"methodBody": ["METHOD_START", "{", "if    ( context    =  =    null )     {", "return   descriptors ;", "}", "for    ( XmlAttributesProvider   provider    :    Extensions . getExtensions ( XmlAttributesProvider . EP _ NAME )  )     {", "descriptors    =    ArrayUtil . mergeArrays ( descriptors ,    provider . getAttributes ( context )  ,    XmlAttribute . ARRAY _ FACTORY )  ;", "}", "return   descriptors ;", "}", "METHOD_END"], "methodName": ["addAttrDescriptorsForFacelets"], "fileName": "com.intellij.html.impl.RelaxedHtmlFromSchemaElementDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    ( context    =  =    null )     {", "return   null ;", "}", "for    ( XmlAttributesProvider   provider    :    Extensions . getExtensions ( XmlAttributesProvider . EP _ NAME )  )     {", "final   XmlAttribute   descriptor    =    provider . getAttribute ( attributeName ,    context )  ;", "if    ( descriptor    !  =    null )     {", "return   descriptor ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAttributeDescriptorFromFacelets"], "fileName": "com.intellij.html.impl.RelaxedHtmlFromSchemaElementDescriptor"}, {"methodBody": ["METHOD_START", "{", "final   String   namespace    =    childTag . getNamespace (  )  ;", "final   XmlExtension   extension    =    XmlExtension . getExtensionByElement ( childTag )  ;", "if    (  (  !  ( XmlUtil . XHTML _ URI . equals ( namespace )  )  )     &  &     (  (  ( base . getContentType (  )  )     !  =     ( Xml . CONTENT _ TYPE _ EMPTY )  )     |  |     (  ( extension    !  =    null )     &  &     ( extension . isCustomTagAllowed ( childTag )  )  )  )  )     {", "return   new   AnyXml ( base ,    childTag . getNSDescriptor ( namespace ,    true )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getRelaxedDescriptor"], "fileName": "com.intellij.html.impl.RelaxedHtmlFromSchemaElementDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getCustomAttributeValues"], "fileName": "com.intellij.html.impl.providers.HtmlAttributeValueProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( file   instanceof   XmlFile )     {", "final    . CollectNamesVisitor   collectNamesVisitor    =     . getVisitorByType ( type )  ;", "file . accept ( collectNamesVisitor )  ;", "return   collectNamesVisitor . getValues (  )  ;", "}", "return   Collections . emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["collectNames"], "fileName": "com.intellij.html.impl.util.MicrodataUtil"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   virtualFile    =    file . getVirtualFile (  )  ;", "List < String >    result    =     ( virtualFile    !  =    null )     ?    virtualFile . getUserData (  . ITEM _ PROP _ KEYS )     :    null ;", "if    (  ( virtualFile    !  =    null )     &  &     ( result    =  =    null )  )     {", "result    =     . collectNames ( file ,    type )  ;", "virtualFile . putUserData (  . ITEM _ PROP _ KEYS ,    result )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["extractProperties"], "fileName": "com.intellij.html.impl.util.MicrodataUtil"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    XmlTag >    id 2 tag    =    MicrodataUtil . findScopesWithItemRef (  ( context    !  =    null    ?    context . getContainingFile (  )     :    null )  )  ;", "XmlTag   tag    =    context ;", "while    ( tag    !  =    null )     {", "if    (  ( tag    !  =    context )     &  &     (  ( tag . getAttribute ( MicrodataUtil . ITEM _ SCOPE )  )     !  =    null )  )", "return   tag ;", "final   String   id    =    MicrodataUtil . getStripedAttributeValue ( tag ,    HtmlUtil . ID _ ATTRIBUTE _ NAME )  ;", "if    (  ( id    !  =    null )     &  &     ( id 2 tag . containsKey ( id )  )  )", "return   id 2 tag . get ( id )  ;", "tag    =    tag . getParentTag (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findScopeTag"], "fileName": "com.intellij.html.impl.util.MicrodataUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( file   instanceof   XmlFile )  )", "return   emptyMap (  )  ;", "return   CachedValuesManager . getCachedValue ( file ,    new   psi . util . CachedValueProvider < Map < String ,    XmlTag >  >  (  )     {", "@ Nullable", "@ Override", "public   Result < Map < String ,    XmlTag >  >    compute (  )     {", "final   Map < String ,    XmlTag >    result    =    new   gnu . trove . THashMap (  )  ;", "file . accept ( new   XmlRecursiveElementVisitor (  )     {", "@ Override", "public   void   visitXmlTag ( final   XmlTag   tag )     {", "super . visitXmlTag ( tag )  ;", "XmlAttribute   refAttr    =    tag . getAttribute ( MicrodataUtil . ITEM _ REF )  ;", "if    (  ( refAttr    !  =    null )     &  &     (  ( tag . getAttribute ( MicrodataUtil . ITEM _ SCOPE )  )     !  =    null )  )     {", "MicrodataUtil . getReferencesForAttributeValue ( refAttr . getValueElement (  )  ,     (    t ,    v )     -  >     {", "result . put ( t ,    tag )  ;", "return   null ;", "}  )  ;", "}", "}", "}  )  ;", "return   Result . create ( result ,    file )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["findScopesWithItemRef"], "fileName": "com.intellij.html.impl.util.MicrodataUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( element    =  =    null )     {", "return   PsiReference . EMPTY _ ARRAY ;", "}", "String   text    =    element . getText (  )  ;", "String   urls    =    StringUunquoteString ( text )  ;", "StringTokenizer   tokenizer    =    new   StringTokenizer ( urls )  ;", "List < PsiReference >    result    =    new   ArrayList <  >  (  )  ;", "while    ( tokenizer . hasMoreTokens (  )  )     {", "String   token    =    tokenizer . nextToken (  )  ;", "int   index    =    text . indexOf ( token )  ;", "PsiReference   ref    =    refFun . fun ( token ,    index )  ;", "if    ( ref    !  =    null )     {", "result . add ( ref )  ;", "}", "}", "return   result . toArray ( EMPTY _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["getReferencesForAttributeValue"], "fileName": "com.intellij.html.impl.util.MicrodataUtil"}, {"methodBody": ["METHOD_START", "{", "String   value    =     ( tag    !  =    null )     ?    tag . getAttributeValue ( attributeName )     :    null ;", "return   value    !  =    null    ?    StringUunquoteString ( value )     :    null ;", "}", "METHOD_END"], "methodName": ["getStripedAttributeValue"], "fileName": "com.intellij.html.impl.util.MicrodataUtil"}, {"methodBody": ["METHOD_START", "{", "return   MicrodataUtil . getReferencesForAttributeValue ( element ,     (    token ,    offset )     -  >     {", "if    ( HtmlUtil . hasHtmlPrefix ( token )  )     {", "final   TextRange   range    =    TextRange . from ( offset ,    token . length (  )  )  ;", "final   URLReference   urlReference    =    new   URLReference ( element ,    range ,    true )  ;", "return   new   DependentNSReference ( element ,    range ,    urlReference ,    true )  ;", "}", "return   null ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["getUrlReferencesForAttributeValue"], "fileName": "com.intellij.html.impl.util.MicrodataUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( type . contains (  \" schema . org \"  )  )     {", "return   new    . CollectNamesFromSchemaOrgVisitor (  )  ;", "}", "return   new    . CollectNamesByMicrodataVisitor ( type )  ;", "}", "METHOD_END"], "methodName": ["getVisitorByType"], "fileName": "com.intellij.html.impl.util.MicrodataUtil"}, {"methodBody": ["METHOD_START", "{", "return    ( MicrodataUtil . findScopeTag ( tag )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasScopeTag"], "fileName": "com.intellij.html.impl.util.MicrodataUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( myModel . contains ( browser )  )     {", "return   false ;", "}", "myModel . addItem ( browser )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["addAndSelect"], "fileName": "com.intellij.ide.browsers.BrowserSelector"}, {"methodBody": ["METHOD_START", "{", "List < WebBrowser >    list    =    new   ArrayList <  >  (  )  ;", "if    ( browserCondition . value ( null )  )     {", "list . add ( null )  ;", "}", "list . addAll ( WebBrowserManager . getInstance (  )  . getBrowsers ( browserCondition )  )  ;", "return   new   ui . MutableCollectionComboBoxModel ( list )  ;", "}", "METHOD_END"], "methodName": ["createBrowsersComboModel"], "fileName": "com.intellij.ide.browsers.BrowserSelector"}, {"methodBody": ["METHOD_START", "{", "return   myBrowserComboWithBrowse ;", "}", "METHOD_END"], "methodName": ["getMainComponent"], "fileName": "com.intellij.ide.browsers.BrowserSelector"}, {"methodBody": ["METHOD_START", "{", "return   myModel . getSelected (  )  ;", "}", "METHOD_END"], "methodName": ["getSelected"], "fileName": "com.intellij.ide.browsers.BrowserSelector"}, {"methodBody": ["METHOD_START", "{", "WebBrowser   browser    =    getSelected (  )  ;", "return   browser    !  =    null    ?    browser . getId (  )  . toString (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getSelectedBrowserId"], "fileName": "com.intellij.ide.browsers.BrowserSelector"}, {"methodBody": ["METHOD_START", "{", "return   myModel . getSize (  )  ;", "}", "METHOD_END"], "methodName": ["getSize"], "fileName": "com.intellij.ide.browsers.BrowserSelector"}, {"methodBody": ["METHOD_START", "{", "myBrowserComboWithBrowse . getComboBox (  )  . setSelectedItem ( selectedItem )  ;", "}", "METHOD_END"], "methodName": ["setSelected"], "fileName": "com.intellij.ide.browsers.BrowserSelector"}, {"methodBody": ["METHOD_START", "{", "createComponent (  )  ;", "myPanel . select ( browser )  ;", "}", "METHOD_END"], "methodName": ["selectBrowser"], "fileName": "com.intellij.ide.browsers.BrowserSettings"}, {"methodBody": ["METHOD_START", "{", "GeneralSettings   settings    =    GeneralSettings . getInstance (  )  ;", "settings . setUseDefaultBrowser (  (  ( getDefaultBrowser (  )  )     =  =     ( DefaultBrowserPolicy . SYSTEM )  )  )  ;", "if    ( alternativeBrowserPathField . isEnabled (  )  )     {", "settings . setBrowserPath ( alternativeBrowserPathField . getText (  )  )  ;", "}", "WebBrowserManager   browserManager    =    WebBrowserManager . getInstance (  )  ;", "browserManager . setShowBrowserHover ( showBrowserHover . isSelected (  )  )  ;", "browserManager . defaultBrowserPolicy    =    getDefaultBrowser (  )  ;", "browserManager . setList ( browsersEditor . apply (  )  )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "com.intellij.ide.browsers.BrowserSettingsPanel"}, {"methodBody": ["METHOD_START", "{", "TableModelEditor . DialogItemEditor < ConfigurableWebBrowser >    itemEditor    =    new   TableModelEditor . DialogItemEditor < ConfigurableWebBrowser >  (  )     {", "@ NotNull", "@ Override", "public   Class < ConfigurableWebBrowser >    getItemClass (  )     {", "return    . class ;", "}", "@ Override", "public   ConfigurableWebBrowser   clone (  @ NotNull", "ConfigurableWebBrowser   item ,    boolean   forInPlaceEditing )     {", "return   new   ConfigurableWebBrowser (  ( forInPlaceEditing    ?    item . getId (  )     :    UUID . randomUUID (  )  )  ,    item . getFamily (  )  ,    item . getName (  )  ,    item . getPath (  )  ,    item . isActive (  )  ,     ( forInPlaceEditing    ?    item . getSpecificSettings (  )     :    cloneSettings ( item )  )  )  ;", "}", "@ Override", "public   void   edit (  @ NotNull", "ConfigurableWebBrowser   browser ,     @ NotNull", "Function < ConfigurableWebBrowser ,    ConfigurableWebBrowser >    mutator ,    boolean   isAdd )     {", "BrowserSpecificSettings   settings    =    cloneSettings ( browser )  ;", "if    (  ( settings    !  =    null )     &  &     ( ShowSettingsUtil . getInstance (  )  . editConfigurable ( browsersTable ,    settings . createConfigurable (  )  )  )  )     {", "mutator . fun ( browser )  . setSpecificSettings ( settings )  ;", "}", "}", "@ Nullable", "private   BrowserSpecificSettings   cloneSettings (  @ NotNull", "ConfigurableWebBrowser   browser )     {", "BrowserSpecificSettings   settings    =    browser . getSpecificSettings (  )  ;", "if    ( settings    =  =    null )     {", "return   null ;", "}", "BrowserSpecificSettings   newSettings    =    browser . getFamily (  )  . createBrowserSpecificSettings (  )  ;", "assert   newSettings    !  =    null ;", "TableModelEditor . cloneUsingXmlSerialization ( settings ,    newSettings )  ;", "return   newSettings ;", "}", "@ Override", "public   void   applyEdited (  @ NotNull", "ConfigurableWebBrowser   oldItem ,     @ NotNull", "ConfigurableWebBrowser   newItem )     {", "oldItem . setSpecificSettings ( newItem . getSpecificSettings (  )  )  ;", "}", "@ Override", "public   boolean   isEditable (  @ NotNull", "ConfigurableWebBrowser   browser )     {", "return    ( browser . getSpecificSettings (  )  )     !  =    null ;", "}", "@ Override", "public   boolean   isRemovable (  @ NotNull", "ConfigurableWebBrowser   item )     {", "return    !  ( WebBrowserManager . getInstance (  )  . isPredefinedBrowser ( item )  )  ;", "}", "}  ;", "browsersEditor    =    new   TableModelEditor (  . COLUMNS ,    itemEditor ,     \" No   web   browsers   configured \"  )  . modelListener ( new   TableModelEditor . DataChangedListener < ConfigurableWebBrowser >  (  )     {", "@ Override", "public   void   tableChanged (  @ NotNull", "TableModelEvent   event )     {", "update (  )  ;", "}", "@ Override", "public   void   dataChanged (  @ NotNull", "ColumnInfo < ConfigurableWebBrowser ,     ?  >    columnInfo ,    int   rowIndex )     {", "if    (  ( columnInfo    =  =     (  . PATH _ COLUMN _ INFO )  )     |  |     ( columnInfo    =  =     (  . ACTIVE _ COLUMN _ INFO )  )  )     {", "update (  )  ;", "}", "}", "private   void   update (  )     {", "if    (  ( getDefaultBrowser (  )  )     =  =    DefaultBrowserPolicy . FIRST )     {", "setCustomPathToFirstListed (  )  ;", "}", "}", "}  )  ;", "browsersTable    =    browsersEditor . createComponent (  )  ;", "}", "METHOD_END"], "methodName": ["createUIComponents"], "fileName": "com.intellij.ide.browsers.BrowserSettingsPanel"}, {"methodBody": ["METHOD_START", "{", "return   root ;", "}", "METHOD_END"], "methodName": ["getComponent"], "fileName": "com.intellij.ide.browsers.BrowserSettingsPanel"}, {"methodBody": ["METHOD_START", "{", "return    (  ( DefaultBrowserPolicy )     ( defaultBrowserPolicyComboBox . getSelectedItem (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultBrowser"], "fileName": "com.intellij.ide.browsers.BrowserSettingsPanel"}, {"methodBody": ["METHOD_START", "{", "DefaultBrowserPolicy   policy    =    manager . getDefaultBrowserPolicy (  )  ;", "if    (  ( policy    !  =     ( DefaultBrowserPolicy . SYSTEM )  )     |  |     ( BrowserLauncherAppless . canUseSystemDefaultBrowserPolicy (  )  )  )     {", "return   policy ;", "}", "return   DefaultBrowserPolicy . ALTERNATIVE ;", "}", "METHOD_END"], "methodName": ["getDefaultBrowserPolicy"], "fileName": "com.intellij.ide.browsers.BrowserSettingsPanel"}, {"methodBody": ["METHOD_START", "{", "WebBrowserManager   browserManager    =    WebBrowserManager . getInstance (  )  ;", "GeneralSettings   generalSettings    =    GeneralSettings . getInstance (  )  ;", "DefaultBrowserPolicy   defaultBrowserPolicy    =    getDefaultBrowser (  )  ;", "if    (  (  (  . getDefaultBrowserPolicy ( browserManager )  )     !  =    defaultBrowserPolicy )     |  |     (  ( browserManager . isShowBrowserHover (  )  )     !  =     ( showBrowserHover . isSelected (  )  )  )  )     {", "return   true ;", "}", "if    (  ( defaultBrowserPolicy    =  =     ( DefaultBrowserPolicy . ALTERNATIVE )  )     &  &     (  !  ( Comparing . strEqual ( generalSettings . getBrowserPath (  )  ,    alternativeBrowserPathField . getText (  )  )  )  )  )     {", "return   true ;", "}", "return   browsersEditor . isModified (  )  ;", "}", "METHOD_END"], "methodName": ["isModified"], "fileName": "com.intellij.ide.browsers.BrowserSettingsPanel"}, {"methodBody": ["METHOD_START", "{", "final   WebBrowserManager   browserManager    =    WebBrowserManager . getInstance (  )  ;", "DefaultBrowserPolicy   effectiveDefaultBrowserPolicy    =     . getDefaultBrowserPolicy ( browserManager )  ;", "defaultBrowserPolicyComboBox . setSelectedItem ( effectiveDefaultBrowserPolicy )  ;", "GeneralSettings   settings    =    GeneralSettings . getInstance (  )  ;", "showBrowserHover . setSelected ( browserManager . isShowBrowserHover (  )  )  ;", "browsersEditor . reset ( browserManager . getList (  )  )  ;", "customPathValue    =    settings . getBrowserPath (  )  ;", "alternativeBrowserPathField . setEnabled (  ( effectiveDefaultBrowserPolicy    =  =     ( DefaultBrowserPolicy . ALTERNATIVE )  )  )  ;", "updateCustomPathTextFieldValue ( effectiveDefaultBrowserPolicy )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.intellij.ide.browsers.BrowserSettingsPanel"}, {"methodBody": ["METHOD_START", "{", "if    ( browser   instanceof   ConfigurableWebBrowser )     {", "Editor . selectItem (  (  ( ConfigurableWebBrowser )     ( browser )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["selectBrowser"], "fileName": "com.intellij.ide.browsers.BrowserSettingsPanel"}, {"methodBody": ["METHOD_START", "{", "ListTableModel < ConfigurableWebBrowser >    model    =    browsersEditor . getModel (  )  ;", "for    ( int   i    =     0  ,    n    =    model . getRowCount (  )  ;    i    <    n ;    i +  +  )     {", "ConfigurableWebBrowser   browser    =    model . getRowValue ( i )  ;", "if    (  ( browser . isActive (  )  )     &  &     (  ( browser . getPath (  )  )     !  =    null )  )     {", "alternativeBrowserPathField . setText ( browser . getPath (  )  )  ;", "return ;", "}", "}", "alternativeBrowserPathField . setText (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["setCustomPathToFirstListed"], "fileName": "com.intellij.ide.browsers.BrowserSettingsPanel"}, {"methodBody": ["METHOD_START", "{", "if    ( browser    =  =     ( DefaultBrowserPolicy . ALTERNATIVE )  )     {", "alternativeBrowserPathField . setText ( customPathValue )  ;", "} else", "if    ( browser    =  =     ( DefaultBrowserPolicy . FIRST )  )     {", "setCustomPathToFirstListed (  )  ;", "} else    {", "alternativeBrowserPathField . setText (  \"  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateCustomPathTextFieldValue"], "fileName": "com.intellij.ide.browsers.BrowserSettingsPanel"}, {"methodBody": ["METHOD_START", "{", "if    ( isOutdated (  )  )     {", ". LOG . info (  (  (  \" Opening    \"     +    hostAndPort )     +     \"    aborted \"  )  )  ;", "} else", "if    ( com . intellij . util . net . NetUtils . canConnectToRemoteSocket ( hostAndPort . getHost (  )  ,    hostAndPort . getPort (  )  )  )     {", "openPageNow (  )  ;", "} else", "if    ( attemptNumber    <     1  0  0  )     {", "int   delayMillis    =     . getDelayMillis ( attemptNumber )  ;", ". LOG . info (  (  (  (  (  (  (  \"  #  \"     +    attemptNumber )     +     \"    check    \"  )     +    hostAndPort )     +     \"    failed ,    scheduling   next   check   in    \"  )     +    delayMillis )     +     \" ms \"  )  )  ;", "checkAndOpenPageLater ( hostAndPort ,     ( attemptNumber    +     1  )  ,    delayMillis )  ;", "} else    {", ". LOG . info (  (  (  (  (  (  \"  #  \"     +    attemptNumber )     +     \"    check    \"  )     +    hostAndPort )     +     \"    failed .    Too   many   failed   checks ,    opening    \"  )     +    hostAndPort )  )  ;", "openPageNow (  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkAndOpenPage"], "fileName": "com.intellij.ide.browsers.BrowserStarter"}, {"methodBody": ["METHOD_START", "{", "JobScheduler . getScheduler (  )  . schedule (  (  )     -  >    checkAndOpenPage ( hostAndPort ,    attemptNumber )  ,    delayMillis ,    TimeUnit . MILLISECONDS )  ;", "}", "METHOD_END"], "methodName": ["checkAndOpenPageLater"], "fileName": "com.intellij.ide.browsers.BrowserStarter"}, {"methodBody": ["METHOD_START", "{", "if    ( attemptNumber    <     1  0  )     {", "return    5  0  0  ;", "}", "if    ( attemptNumber    <     2  0  )     {", "return    1  0  0  0  ;", "}", "return    5  0  0  0  ;", "}", "METHOD_END"], "methodName": ["getDelayMillis"], "fileName": "com.intellij.ide.browsers.BrowserStarter"}, {"methodBody": ["METHOD_START", "{", "URI   url    =    Urls . parseAsJavaUriWithoutParameters ( rawUrl )  ;", "if    ( url    =  =    null )     {", "return   null ;", "}", "int   port    =    url . getPort (  )  ;", "if    ( port    =  =     (  -  1  )  )     {", "port    =     (  \" https \"  . equals ( url . getScheme (  )  )  )     ?     4  4  3     :     8  0  ;", "}", "return   HostAndPort . fromParts ( StringUtil . notNullize ( url . getHost (  )  ,     \"  1  2  7  .  0  .  0  .  1  \"  )  ,    port )  ;", "}", "METHOD_END"], "methodName": ["getHostAndPort"], "fileName": "com.intellij.ide.browsers.BrowserStarter"}, {"methodBody": ["METHOD_START", "{", "return   myOutdated . compute (  )  ;", "}", "METHOD_END"], "methodName": ["isOutdated"], "fileName": "com.intellij.ide.browsers.BrowserStarter"}, {"methodBody": ["METHOD_START", "{", "JobScheduler . getScheduler (  )  . schedule (  (  )     -  >    openPageNow (  )  ,     1  0  0  0  ,    TimeUnit . MILLISECONDS )  ;", "}", "METHOD_END"], "methodName": ["openPageLater"], "fileName": "com.intellij.ide.browsers.BrowserStarter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isOutdated (  )  )  )     {", "JavaScriptDebugg . Util . startDebugOrLaunchBrowser ( myRunConfiguration ,    mySettings )  ;", "}", "}", "METHOD_END"], "methodName": ["openPageNow"], "fileName": "com.intellij.ide.browsers.BrowserStarter"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( mySettings . isSelected (  )  )  )     |  |     (  ( mySettings . getUrl (  )  )     =  =    null )  )     {", "return ;", "}", "HostAndPort   hostAndPort    =     . getHostAndPort ( mySettings . getUrl (  )  )  ;", "if    ( hostAndPort    !  =    null )     {", "checkAndOpenPageLater ( hostAndPort ,     1  ,     3  0  0  )  ;", "} else    {", "openPageLater (  )  ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "com.intellij.ide.browsers.BrowserStarter"}, {"methodBody": ["METHOD_START", "{", "return   WebBrowserManager . checkNameAndPath ( what ,    this )  ;", "}", "METHOD_END"], "methodName": ["checkNameAndPath"], "fileName": "com.intellij.ide.browsers.ConfigurableWebBrowser"}, {"methodBody": ["METHOD_START", "{", "return   active ;", "}", "METHOD_END"], "methodName": ["isActive"], "fileName": "com.intellij.ide.browsers.ConfigurableWebBrowser"}, {"methodBody": ["METHOD_START", "{", "active    =    value ;", "}", "METHOD_END"], "methodName": ["setActive"], "fileName": "com.intellij.ide.browsers.ConfigurableWebBrowser"}, {"methodBody": ["METHOD_START", "{", "family    =    value ;", "}", "METHOD_END"], "methodName": ["setFamily"], "fileName": "com.intellij.ide.browsers.ConfigurableWebBrowser"}, {"methodBody": ["METHOD_START", "{", "name    =    value ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "com.intellij.ide.browsers.ConfigurableWebBrowser"}, {"methodBody": ["METHOD_START", "{", "path    =    PathUtil . toSystemIndependentName ( StringUtil . nullize ( value )  )  ;", "}", "METHOD_END"], "methodName": ["setPath"], "fileName": "com.intellij.ide.browsers.ConfigurableWebBrowser"}, {"methodBody": ["METHOD_START", "{", "specificSettings    =    value ;", "}", "METHOD_END"], "methodName": ["setSpecificSettings"], "fileName": "com.intellij.ide.browsers.ConfigurableWebBrowser"}, {"methodBody": ["METHOD_START", "{", "StartBrowserSettings   browserSettings    =    new   StartBrowserSettings (  )  ;", "browserSettings . setSelected ( isSelected (  )  )  ;", "browserSettings . setBrowser ( myBrowserSelector . getSelected (  )  )  ;", "browserSettings . setStartJavaScriptDebugger ( myStartJavaScriptDebuggerCheckBox . isSelected (  )  )  ;", "browserSettings . setUrl ( getUrl (  )  )  ;", "return   browserSettings ;", "}", "METHOD_END"], "methodName": ["createSettings"], "fileName": "com.intellij.ide.browsers.StartBrowserPanel"}, {"methodBody": ["METHOD_START", "{", "myBrowserSelector    =    new   BrowserSelector (  )  ;", "myBrowserComboBox    =    myBrowserSelector . getMainComponent (  )  ;", "if    ( UIUtil . isUnderAquaLookAndFeel (  )  )     {", "myBrowserComboBox . setBorder ( new   EmptyBorder (  3  ,     0  ,     0  ,     0  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createUIComponents"], "fileName": "com.intellij.ide.browsers.StartBrowserPanel"}, {"methodBody": ["METHOD_START", "{", "return   myBrowserSelector ;", "}", "METHOD_END"], "methodName": ["getBrowserSelector"], "fileName": "com.intellij.ide.browsers.StartBrowserPanel"}, {"methodBody": ["METHOD_START", "{", "return   myRoot ;", "}", "METHOD_END"], "methodName": ["getComponent"], "fileName": "com.intellij.ide.browsers.StartBrowserPanel"}, {"methodBody": ["METHOD_START", "{", "return   myStartJavaScriptDebuggerCheckBox ;", "}", "METHOD_END"], "methodName": ["getStartJavaScriptDebuggerCheckBox"], "fileName": "com.intellij.ide.browsers.StartBrowserPanel"}, {"methodBody": ["METHOD_START", "{", "String   url    =    StringUtil . nullize ( myUrlField . getText (  )  ,    true )  ;", "if    ( url    !  =    null )     {", "url    =    url . trim (  )  ;", "if    (  !  ( URLUtil . containsScheme ( url )  )  )     {", "return   VirtualFileManager . constructUrl ( HTTP _ PROTOCOL ,    url )  ;", "}", "}", "return   url ;", "}", "METHOD_END"], "methodName": ["getUrl"], "fileName": "com.intellij.ide.browsers.StartBrowserPanel"}, {"methodBody": ["METHOD_START", "{", "return   myStartBrowserCheckBox . isSelected (  )  ;", "}", "METHOD_END"], "methodName": ["isSelected"], "fileName": "com.intellij.ide.browsers.StartBrowserPanel"}, {"methodBody": ["METHOD_START", "{", "setSelected ( settings . isSelected (  )  )  ;", "setUrl ( settings . getUrl (  )  )  ;", "myStartJavaScriptDebuggerCheckBox . setSelected ( settings . isStartJavaScriptDebugger (  )  )  ;", "myBrowserSelector . setSelected ( settings . ge (  )  )  ;", "}", "METHOD_END"], "methodName": ["setFromSettings"], "fileName": "com.intellij.ide.browsers.StartBrowserPanel"}, {"methodBody": ["METHOD_START", "{", "myStartBrowserCheckBox . setSelected ( value )  ;", "}", "METHOD_END"], "methodName": ["setSelected"], "fileName": "com.intellij.ide.browsers.StartBrowserPanel"}, {"methodBody": ["METHOD_START", "{", "myUrlField . setText ( url )  ;", "}", "METHOD_END"], "methodName": ["setUrl"], "fileName": "com.intellij.ide.browsers.StartBrowserPanel"}, {"methodBody": ["METHOD_START", "{", "FileChooserDescriptor   descriptor    =    new   FileChooserDescriptor ( true ,    false ,    false ,    false ,    false ,    false )     {", "@ Override", "public   boolean   isFileSelectable ( VirtualFile   file )     {", "return    ( HtmlUtil . isHtmlFile ( file )  )     |  |     (  (  . virtualFileToUrl ( file ,    project )  )     !  =    null )  ;", "}", "}  ;", "descriptor . setTitle ( XmlBundle . message (  \" title \"  )  )  ;", "descriptor . setDescription ( XmlBundle . message (  \" subtitle \"  )  )  ;", "descriptor . setRoots ( ProjectRootManager . getInstance ( project )  . getContentRoots (  )  )  ;", "field . addBrowseFolderListener ( new   TextBrowseFolderListener ( descriptor ,    project )     {", "@ NotNull", "@ Override", "protected   String   chosenFileToResultingText (  @ NotNull", "VirtualFile   chosenFile )     {", "if    ( chosenFile . isDirectory (  )  )     {", "return   chosenFile . getPath (  )  ;", "}", "Url   url    =     . virtualFileToUrl ( chosenFile ,    project )  ;", "return   url    =  =    null    ?    chosenFile . getUrl (  )     :    url . toDecodedForm (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["setupUrlField"], "fileName": "com.intellij.ide.browsers.StartBrowserPanel"}, {"methodBody": ["METHOD_START", "{", "PsiFile   psiFile    =    ReadAction . compute (  (  )     -  >    PsiManager . getInstance ( project )  . findFile ( file )  )  ;", "return   WebServiceImpl . getDebuggableUrl ( psiFile )  ;", "}", "METHOD_END"], "methodName": ["virtualFileToUrl"], "fileName": "com.intellij.ide.browsers.StartBrowserPanel"}, {"methodBody": ["METHOD_START", "{", "return   myBrowser ;", "}", "METHOD_END"], "methodName": ["getBrowser"], "fileName": "com.intellij.ide.browsers.StartBrowserSettings"}, {"methodBody": ["METHOD_START", "{", "return   myUrl ;", "}", "METHOD_END"], "methodName": ["getUrl"], "fileName": "com.intellij.ide.browsers.StartBrowserSettings"}, {"methodBody": ["METHOD_START", "{", "return   mySelected ;", "}", "METHOD_END"], "methodName": ["isSelected"], "fileName": "com.intellij.ide.browsers.StartBrowserSettings"}, {"methodBody": ["METHOD_START", "{", "return   myStartJavaScriptDebugger ;", "}", "METHOD_END"], "methodName": ["isStartJavaScriptDebugger"], "fileName": "com.intellij.ide.browsers.StartBrowserSettings"}, {"methodBody": ["METHOD_START", "{", "Element   state    =    parent . getChild (  \" browser \"  )  ;", "settings    =    new    (  )  ;", "if    ( state    !  =    null )     {", "XmlSerializer . deserializeInto ( settings ,    state )  ;", "}", "return   settings ;", "}", "METHOD_END"], "methodName": ["readExternal"], "fileName": "com.intellij.ide.browsers.StartBrowserSettings"}, {"methodBody": ["METHOD_START", "{", "myBrowser    =    value ;", "}", "METHOD_END"], "methodName": ["setBrowser"], "fileName": "com.intellij.ide.browsers.StartBrowserSettings"}, {"methodBody": ["METHOD_START", "{", "mySelected    =    selected ;", "}", "METHOD_END"], "methodName": ["setSelected"], "fileName": "com.intellij.ide.browsers.StartBrowserSettings"}, {"methodBody": ["METHOD_START", "{", "myStartJavaScriptDebugger    =    value ;", "}", "METHOD_END"], "methodName": ["setStartJavaScriptDebugger"], "fileName": "com.intellij.ide.browsers.StartBrowserSettings"}, {"methodBody": ["METHOD_START", "{", "String   normalized    =    StringUtil . nullize ( value ,    true )  ;", "if    ( normalized    !  =    null )     {", "normalized    =    WHITESPACE . trimFrom ( normalized )  ;", "}", "myUrl    =    normalized ;", "}", "METHOD_END"], "methodName": ["setUrl"], "fileName": "com.intellij.ide.browsers.StartBrowserSettings"}, {"methodBody": ["METHOD_START", "{", "Element   state    =    XmlSerializer . serialize ( this ,    new   SkipDefaultValuesSerializationFilters (  )  )  ;", "if    (  !  ( JDOMUtil . isEmpty ( state )  )  )     {", "parent . addContent ( state )  ;", "}", "}", "METHOD_END"], "methodName": ["writeExternal"], "fileName": "com.intellij.ide.browsers.StartBrowserSettings"}, {"methodBody": ["METHOD_START", "{", "final   ConfigurableWebBrowser   browser    =    new   ConfigurableWebBrowser ( id ,    family ,    name ,    path ,    active ,    specificSettings )  ;", "browsers . add ( browser )  ;", "incModificationCount (  )  ;", "return   browser ;", "}", "METHOD_END"], "methodName": ["addBrowser"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtil . containsIgnoreCase ( browser . getName (  )  ,    what )  )     {", "return   true ;", "}", "String   path    =    browser . getPath (  )  ;", "if    ( path    !  =    null )     {", "int   index    =    path . lastIndexOf (  '  /  '  )  ;", "return   index    >     0     ?     ( path . indexOf ( what ,     ( index    +     1  )  )  )     !  =     (  -  1  )     :    path . contains ( what )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["checkNameAndPath"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtil . isEmpty ( idOrFamilyName )  )     {", "return   null ;", "}", "UUID   id    =     . parseUuid ( idOrFamilyName )  ;", "if    ( id    =  =    null )     {", "for    ( ConfigurableWebBrowser   browser    :    browsers )     {", "if    (  ( browser . getFamily (  )  . name (  )  . equalsIgnoreCase ( idOrFamilyName )  )     |  |     ( browser . getFamily (  )  . getName (  )  . equalsIgnoreCase ( idOrFamilyName )  )  )     {", "return   browser ;", "}", "}", "return   null ;", "}", "for    ( ConfigurableWebBrowser   browser    :    browsers )     {", "if    ( browser . getId (  )  . equals ( id )  )     {", "return   browser ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findBrowserById"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "return   getBrowsers ( Conditions . alwaysTrue (  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["getActiveBrowsers"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( browsers )  ;", "}", "METHOD_END"], "methodName": ["getBrowsers"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "return   getBrowsers ( condition ,    true )  ;", "}", "METHOD_END"], "methodName": ["getBrowsers"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "List < WebBrowser >    result    =    new   com . intellij . util . SmartList (  )  ;", "for    ( ConfigurableWebBrowser   browser    :    browsers )     {", "if    (  (  (  ! onlyActive )     |  |     ( browser . isActive (  )  )  )     &  &     ( condition . value ( browser )  )  )     {", "result . add ( browser )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getBrowsers"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "return   defaultBrowserPolicy ;", "}", "METHOD_END"], "methodName": ["getDefaultBrowserPolicy"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "for    ( ConfigurableWebBrowser   browser    :    browsers )     {", "if    (  ( browser . isActive (  )  )     &  &     (  ( browser . getPath (  )  )     !  =    null )  )     {", "return   browser ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getFirstActiveBrowser"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "WebBrowser   result    =    getFirstBrowserOrNull ( family )  ;", "if    ( result    =  =    null )     {", "throw   new   IllegalStateException (  \" Must   be   at   least   one   browser   per   family \"  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getFirstBrowser"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "for    ( ConfigurableWebBrowser   browser    :    browsers )     {", "if    (  ( browser . isActive (  )  )     &  &     ( family . equals ( browser . getFamily (  )  )  )  )     {", "return   browser ;", "}", "}", "for    ( ConfigurableWebBrowser   browser    :    browsers )     {", "if    ( family . equals ( browser . getFamily (  )  )  )     {", "return   browser ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getFirstBrowserOrNull"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "return   ServiceManager . getService ( WebBrowserManager . class )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "return   browsers ;", "}", "METHOD_END"], "methodName": ["getList"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . asList ( new   ConfigurableWebBrowser ( WebBrowserManager . PREDEFINED _ CHROME _ ID ,    BrowserFamily . CHROME )  ,    new   ConfigurableWebBrowser ( WebBrowserManager . PREDEFINED _ FIREFOX _ ID ,    BrowserFamily . FIREFOX )  ,    new   ConfigurableWebBrowser ( WebBrowserManager . PREDEFINED _ SAFARI _ ID ,    BrowserFamily . SAFARI )  ,    new   ConfigurableWebBrowser ( WebBrowserManager . PREDEFINED _ OPERA _ ID ,    BrowserFamily . OPERA )  ,    new   ConfigurableWebBrowser ( WebBrowserManager . PREDEFINED _ YANDEX _ ID ,    BrowserFamily . CHROME ,     \" Yandex \"  ,     ( SystemInfo . isWindows    ?     \" browser \"     :    SystemInfo . isMac    ?     \" Yandex \"     :     \" yandex \"  )  ,    false ,    CHROME . createBrowserSpecificSettings (  )  )  ,    new   ConfigurableWebBrowser ( WebBrowserManager . PREDEFINED _ EXPLORER _ ID ,    BrowserFamily . EXPLORER )  )  ;", "}", "METHOD_END"], "methodName": ["getPredefinedBrowsers"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( browser   instanceof   ConfigurableWebBrowser )  )     |  |     (  (  ( ConfigurableWebBrowser )     ( browser )  )  . isActive (  )  )  ;", "}", "METHOD_END"], "methodName": ["isActive"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "return    ( browser . getFamily (  )  . equals ( CHROME )  )     &  &     ( WebBrowserManager . checkNameAndPath (  \" Dartium \"  ,    browser )  )  ;", "}", "METHOD_END"], "methodName": ["isDartium"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "UUID   id    =    browser . getId (  )  ;", "for    ( UUID   predefinedBrowserId    :     . PREDEFINED _ BROWSER _ IDS )     {", "if    ( id . equals ( predefinedBrowserId )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isPredefinedBrowser"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "return   myShowBrowserHover ;", "}", "METHOD_END"], "methodName": ["isShowBrowserHover"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "return    ( browser . getFamily (  )  . equals ( CHROME )  )     &  &     (  ( browser . getId (  )  . equals ( WebBrowserManager . PREDEFINED _ YANDEX _ ID )  )     |  |     ( WebBrowserManager . checkNameAndPath (  \" Yandex \"  ,    browser )  )  )  ;", "}", "METHOD_END"], "methodName": ["isYandexBrowser"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "if    (  ( id . indexOf (  '  -  '  )  )     =  =     (  -  1  )  )     {", "return   null ;", "}", "try    {", "return   UUID . fromString ( id )  ;", "}    catch    ( IllegalArgumentException   ignored )     {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["parseUuid"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   BrowserFamily . valueOf ( value )  ;", "}    catch    ( RuntimeException   e )     {", ". LOG . warn ( e )  ;", "for    ( BrowserFamily   family    :    BrowserFamily . values (  )  )     {", "if    ( family . getName (  )  . equalsIgnoreCase ( value )  )     {", "return   family ;", "}", "}", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["readFamily"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtil . isEmpty ( value )  )     {", "UUID   id ;", "switch    ( family )     {", "case   CHROME    :", "id    =     . PREDEFINED _ CHROME _ ID ;", "break ;", "case   EXPLORER    :", "id    =     . PREDEFINED _ EXPLORER _ ID ;", "break ;", "case   FIREFOX    :", "id    =     . PREDEFINED _ FIREFOX _ ID ;", "break ;", "case   OPERA    :", "id    =     . PREDEFINED _ OPERA _ ID ;", "break ;", "case   SAFARI    :", "id    =     . PREDEFINED _ SAFARI _ ID ;", "break ;", "default    :", "return   null ;", "}", "for    ( ConfigurableWebBrowser   browser    :    existingBrowsers )     {", "if    (  ( browser . getId (  )  )     =  =    id )     {", "return   null ;", "}", "}", "return   id ;", "} else    {", "try    {", "return   UUID . fromString ( value )  ;", "}    catch    ( Exception   e )     {", ". LOG . warn ( e )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["readId"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "(  ( ConfigurableWebBrowser )     ( browser )  )  . setPath ( path )  ;", "(  ( ConfigurableWebBrowser )     ( browser )  )  . setActive ( isActive )  ;", "incModificationCount (  )  ;", "}", "METHOD_END"], "methodName": ["setBrowserPath"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "(  ( ConfigurableWebBrowser )     ( browser )  )  . setSpecificSettings ( specificSettings )  ;", "}", "METHOD_END"], "methodName": ["setBrowserSpecificSettings"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "browsers    =    value ;", "incModificationCount (  )  ;", "}", "METHOD_END"], "methodName": ["setList"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "myShowBrowserHover    =    showBrowserHover ;", "}", "METHOD_END"], "methodName": ["setShowBrowserHover"], "fileName": "com.intellij.ide.browsers.WebBrowserManager"}, {"methodBody": ["METHOD_START", "{", "return   ServiceManager . getService ( WebBrowserService . class )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "com.intellij.ide.browsers.WebBrowserService"}, {"methodBody": ["METHOD_START", "{", "return    (  ( language    =  =     ( HTMLLanguage . INSTANCE )  )     |  |     ( language    =  =     ( XHTMLLanguage . INSTANCE )  )  )     |  |     ( language    =  =     ( XMLLanguage . INSTANCE )  )  ;", "}", "METHOD_END"], "methodName": ["isHtmlOrXmlFile"], "fileName": "com.intellij.ide.browsers.WebBrowserService"}, {"methodBody": ["METHOD_START", "{", "if    (  _ keys 1     !  =    null )     {", "for    ( IElementType   iElementType    :     _ keys 1  . keySet (  )  )     {", "if    (  !  (  . keys 1  . containsKey ( iElementType )  )  )     {", ". keys 1  . put ( iElementType ,     _ keys 1  . get ( iElementType )  )  ;", "}", "}", "}", "if    (  _ keys 2     !  =    null )     {", "for    ( IElementType   iElementType    :     _ keys 2  . keySet (  )  )     {", "if    (  !  (  . keys 2  . containsKey ( iElementType )  )  )     {", ". keys 2  . put ( iElementType ,     _ keys 2  . get ( iElementType )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["registerEmbeddedTokenAttributes"], "fileName": "com.intellij.ide.highlighter.HtmlFileHighlighter"}, {"methodBody": ["METHOD_START", "{", "SyntaxHighlighter   highlighter    =    new   HtmlFileHighlighter (  )  ;", "return    . createHighlighter ( highlighter ,    settings )  ;", "}", "METHOD_END"], "methodName": ["createHTMLHighlighter"], "fileName": "com.intellij.ide.highlighter.HtmlHighlighterFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  _ keys 1     !  =    null )     {", ". keys 1  . putAll (  _ keys 1  )  ;", "}", "if    (  _ keys 2     !  =    null )     {", ". keys 2  . putAll (  _ keys 2  )  ;", "}", "}", "METHOD_END"], "methodName": ["registerEmbeddedTokenAttributes"], "fileName": "com.intellij.ide.highlighter.XmlFileHighlighter"}, {"methodBody": ["METHOD_START", "{", "return   HighlighterFactory . createHighlighter ( new   XmlFileHighlighter (  )  ,    settings )  ;", "}", "METHOD_END"], "methodName": ["createXMLHighlighter"], "fileName": "com.intellij.ide.highlighter.XmlHighlighterFactory"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isCaseSensitive"], "fileName": "com.intellij.ide.highlighter.XmlLikeFileType"}, {"methodBody": ["METHOD_START", "{", "final   XmlStructureViewElementProvider [  ]    providers    =     (  ( XmlStructureViewElementProvider [  ]  )     ( Extensions . getExtensions ( XmlStructureViewElementProvider . EXTENSION _ POINT _ NAME )  )  )  ;", "return   ContainerUtil . map 2 List ( subTags ,     (    xmlTag )     -  >     {", "for    ( final   XmlStructureViewElementProvider   provider    :    providers )     {", "final   StructureViewTreeElement   element    =    provider . createCustom ( xmlTag )  ;", "if    ( element    !  =    null )     {", "return   element ;", "}", "}", "return   new    ( xmlTag )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["getStructureViewTreeElements"], "fileName": "com.intellij.ide.structureView.impl.xml.AbstractXmlTagTreeElement"}, {"methodBody": ["METHOD_START", "{", "final   List < StructureViewTreeElement >    elements    =    new   ArrayList <  >  (  )  ;", "XmlUtil . processXmlElements ( element ,    new   PsiElementProcessor (  )     {", "@ Override", "public   boolean   execute (  @ NotNull", "final   PsiElement   element )     {", "if    (  ( element   instanceof   XmlElementDecl )     |  |     ( element   instanceof   XmlEntityDecl )  )     {", "elements . add ( new    . DtdTreeElement (  (  ( PsiNamedElement )     ( element )  )  )  )  ;", "}", "return   true ;", "}", "}  ,    false )  ;", "return   elements ;", "}", "METHOD_END"], "methodName": ["collectElements"], "fileName": "com.intellij.ide.structureView.impl.xml.DtdFileTreeElement"}, {"methodBody": ["METHOD_START", "{", "if    ( id    !  =    null )     {", "id    =    id . trim (  )  ;", "if    ( id . isEmpty (  )  )     {", "ren   null ;", "}", "}", "ren   id ;", "}", "METHOD_END"], "methodName": ["toCanonicalForm"], "fileName": "com.intellij.ide.structureView.impl.xml.XmlTagTreeElement"}, {"methodBody": ["METHOD_START", "{", "if    ( myHtml 4 RadioButton . isSelected (  )  )     {", "return   XmlUtil . XHTML 4  _ SCHEMA _ LOCATION ;", "}", "if    ( myHtml 5 RadioButton . isSelected (  )  )     {", "return   Html 5 Provider . getHtml 5 Location (  )  ;", "}", "return   myDoctypeTextField . getText (  )  ;", "}", "METHOD_END"], "methodName": ["getDoctype"], "fileName": "com.intellij.javaee.DefaultSchemasConfigurable"}, {"methodBody": ["METHOD_START", "{", "return   myXMLSchema 1  0 JBRadioButton . isSelected (  )     ?    ExternalResourceManagerEx . XMLSchemaVersion . XMLSchema _  1  _  0     :    ExternalResourceManagerEx . XMLSchemaVersion . XMLSchema _  1  _  1  ;", "}", "METHOD_END"], "methodName": ["getSchemaVersion"], "fileName": "com.intellij.javaee.DefaultSchemasConfigurable"}, {"methodBody": ["METHOD_START", "{", "return   new   FileChooserDescriptor ( true ,    false ,    false ,    false ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["getChooserDescriptor"], "fileName": "com.intellij.javaee.EditLocationDialog"}, {"methodBody": ["METHOD_START", "{", "String   path    =    myTfPath . getText (  )  . trim (  )  ;", "String   url    =    myTfUrl . getText (  )  . trim (  )  ;", "return   new   NamePair ( url ,    path ,    myTfShared )  ;", "}", "METHOD_END"], "methodName": ["getPair"], "fileName": "com.intellij.javaee.EditLocationDialog"}, {"methodBody": ["METHOD_START", "{", "myTfUrl . setText ( origin . myName )  ;", "myTfPath . setText ( origin . my )  ;", "myTfShared    =    origin . myShared ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "com.intellij.javaee.EditLocationDialog"}, {"methodBody": ["METHOD_START", "{", "MapExternalResourceDialog   dialog    =    new   MapExternalResourceDialog ( null ,    myProject ,    null ,    null )  ;", "if    (  !  ( dialog . showAndGet (  )  )  )     {", "return   null ;", "}", "setModified ( true )  ;", "return   new   NameLocationPair ( dialog . getUri (  )  ,    dialog . getResourceLocation (  )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["addExtLocation"], "fileName": "com.intellij.javaee.ExternalResourceConfigurable"}, {"methodBody": ["METHOD_START", "{", "EditLocationDialog   dialog    =    new   EditLocationDialog ( null ,    false )  ;", "if    (  !  ( dialog . showAndGet (  )  )  )     {", "return   null ;", "}", "setModified ( true )  ;", "return   dialog . getPair (  )  . myName ;", "}", "METHOD_END"], "methodName": ["addIgnoreLocation"], "fileName": "com.intellij.javaee.ExternalResourceConfigurable"}, {"methodBody": ["METHOD_START", "{", "NameLocationPair   pair    =     (  ( NameLocationPair )     ( o )  )  ;", "MapDialog   dialog    =    new   MapDialog ( pair . getName (  )  ,    myProject ,    null ,    pair . getLocation (  )  )  ;", "if    (  !  ( dialog . showAndGet (  )  )  )     {", "return   null ;", "}", "setModified ( true )  ;", "return   new   NameLocationPair ( dialog . getUri (  )  ,    dialog . getResourceLocation (  )  ,    pair . myShared )  ;", "}", "METHOD_END"], "methodName": ["editExtLocation"], "fileName": "com.intellij.javaee.ExternalResourceConfigurable"}, {"methodBody": ["METHOD_START", "{", "EditLocationDialog   dialog    =    new   EditLocationDialog ( null ,    false )  ;", "dialogit ( new   NameLocationPair ( o . toStg (  )  ,    null ,    false )  )  ;", "if    (  !  ( dialog . showAndGet (  )  )  )     {", "return   null ;", "}", "setModified ( true )  ;", "return   dialog . getPair (  )  . myName ;", "}", "METHOD_END"], "methodName": ["editIgnoreLocation"], "fileName": "com.intellij.javaee.ExternalResourceConfigurable"}, {"methodBody": ["METHOD_START", "{", "return   ServiceManager . getService ( ExternalResourceManager . class )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "com.intellij.javaee.ExternalResourceManager"}, {"methodBody": ["METHOD_START", "{", "return    (  ( ExternalResourceManagerEx )     ( ExternalResourceManager . getInstance (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getInstanceEx"], "fileName": "com.intellij.javaee.ExternalResourceManagerEx"}, {"methodBody": ["METHOD_START", "{", "Application   app    =    ApplicationManager . getApplication (  )  ;", "if    ( app . isWriteAccessAllowed (  )  )     {", "doAddIgnoreds ( urls ,    disposable )  ;", "} else    {", "app . runWriteAction (  (  )     -  >     {", "doAddIgnoreds ( urls ,    disposable )  ;", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["addIgnoredResources"], "fileName": "com.intellij.javaee.ExternalResourceManagerExImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( myStandardIgnoredResources . contains ( url )  )     {", "return   false ;", "}", "if    ( myIgnoredResources . add ( url )  )     {", "incModificationCount (  )  ;", "return   true ;", "} else    {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["addIgnoredSilently"], "fileName": "com.intellij.javaee.ExternalResourceManagerExImpl"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    T >    resources    =    ExternalResourceManagerExImpl . getMap ( resourcesMap ,    version ,    false )  ;", "if    ( resources    !  =    null )     {", "result . addAll ( resources . keySet (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addResourcesFromMap"], "fileName": "com.intellij.javaee.ExternalResourceManagerExImpl"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    map    =    ExternalResourceManagerExImpl . getMap ( myResources ,    version ,    true )  ;", "assert   map    !  =    null ;", "map . put ( url ,    location )  ;", "myResourceLocations . add ( location )  ;", "incModificationCount (  )  ;", "}", "METHOD_END"], "methodName": ["addSilently"], "fileName": "com.intellij.javaee.ExternalResourceManagerExImpl"}, {"methodBody": ["METHOD_START", "{", "final   ExternalResourceManagerExImpl   instance    =     (  ( ExternalResourceManagerExImpl )     ( ExternalResourceManager . getInstance (  )  )  )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >    instance . addResource ( url ,    location )  )  ;", "Disposer . register ( parentDisposable ,    new   Disposable (  )     {", "@ Override", "public   void   dispose (  )     {", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >    instance . removeResource ( url )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addTestResource"], "fileName": "com.intellij.javaee.ExternalResourceManagerExImpl"}, {"methodBody": ["METHOD_START", "{", "ResourceRegistrarImpl   registrar    =    new   ResourceRegistrarImpl (  )  ;", "for    ( StandardResourceProvider   provider    :    StandardResourceProvider . EP _ NAME . getExtensions (  )  )     {", "provider . registerResources ( registrar )  ;", "}", "for    ( StandardResourceEP   extension    :    StandardResourceEP . EP _ NAME . getExtensions (  )  )     {", "registrar . addStdResource ( extension . url ,    extension . version ,    extension . resourcePath ,    null ,    extension . getLoaderForClass (  )  )  ;", "}", "myStandardIgnoredResources . addAll ( registrar . getIgnored (  )  )  ;", "return   registrar . getResources (  )  ;", "}", "METHOD_END"], "methodName": ["computeStdResources"], "fileName": "com.intellij.javaee.ExternalResourceManagerExImpl"}, {"methodBody": ["METHOD_START", "{", "long   modificationCount    =    getModificationCount (  )  ;", "for    ( String   url    :    urls )     {", "addIgnoredSilently ( url )  ;", "}", "if    ( modificationCount    !  =     ( getModificationCount (  )  )  )     {", "if    ( disposable    !  =    null )     {", "Disposer . register ( disposable ,     (  )     -  >     {", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >     {", "boolean   isChanged    =    false ;", "for    ( String   url    :    urls )     {", "if    ( myIgnoredResources . remove ( url )  )     {", "isChanged    =    true ;", "}", "}", "if    ( isChanged )     {", "fireChanged (  )  ;", "}", "}  )  ;", "}  )  ;", "}", "fireChanged (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doAddIgnoredResources"], "fileName": "com.intellij.javaee.ExternalResourceManagerExImpl"}, {"methodBody": ["METHOD_START", "{", "for    ( ExternalResourceListener   listener    :    myListeners )     {", "listener . externalResourceChanged (  )  ;", "}", "incModificationCount (  )  ;", "}", "METHOD_END"], "methodName": ["fireExternalResourceChanged"], "fileName": "com.intellij.javaee.ExternalResourceManagerExImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( myCatalogManager )     =  =    null )     &  &     (  ( myCatalogPropertiesFile )     !  =    null )  )     {", "myCatalogManager    =    new   XMLCatalogManager ( myCatalogPropertiesFile )  ;", "}", "return   myCatalogManager ;", "}", "METHOD_END"], "methodName": ["getCatalogManager"], "fileName": "com.intellij.javaee.ExternalResourceManagerExImpl"}, {"methodBody": ["METHOD_START", "{", "version    =    StringUtil . notNullize ( version ,    ExternalResourceManagerExImpl . DEFAULT _ VERSION )  ;", "Map < String ,    T >    map    =    resources . get ( version )  ;", "if    ( map    =  =    null )     {", "if    ( create )     {", "map    =    new   gnu . trove . THashMap (  )  ;", "resources . put ( version ,    map )  ;", "} else", "if    (  !  ( version . equals ( ExternalResourceManagerExImpl . DEFAULT _ VERSION )  )  )     {", "map    =    resources . get ( ExternalResourceManagerExImpl . DEFAULT _ VERSION )  ;", "}", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["getMap"], "fileName": "com.intellij.javaee.ExternalResourceManagerExImpl"}, {"methodBody": ["METHOD_START", "{", "return   ExternalResourceManagerExImpl . INSTANCE _ CACHE . getValue ( project )  ;", "}", "METHOD_END"], "methodName": ["getProjectResources"], "fileName": "com.intellij.javaee.ExternalResourceManagerExImpl"}, {"methodBody": ["METHOD_START", "{", "ExternalResourceManagerExImpl   projectResources    =    ExternalResourceManagerExImpl . getProjectResources ( project )  ;", "String   location    =    projectResources . getResourceLocation ( url ,    version )  ;", "if    (  ( location    =  =    null )     |  |     ( location . equals ( url )  )  )     {", "if    (  ( projectResources . myXMLSchemaVersion )     =  =     ( ExternalResourceManagerEx . XMLSchemaVersion . XMLSchema _  1  _  1  )  )     {", "if    ( XmlUtil . XML _ SCHEMA _ URI . equals ( url )  )", "return   ExternalResourceManagerExImpl . XSD _  1  _  1  ;", "if    (  (  ( XmlUtil . XML _ SCHEMA _ URI )     +     \"  . xsd \"  )  . equals ( url )  )", "return   ExternalResourceManagerExImpl . XSD _  1  _  1  ;", "}", "return   getResourceLocation ( url ,    version )  ;", "} else    {", "return   location ;", "}", "}", "METHOD_END"], "methodName": ["getResourceLocation"], "fileName": "com.intellij.javaee.ExternalResourceManagerExImpl"}, {"methodBody": ["METHOD_START", "{", "return   myStandardResources . getValue (  )  . values (  )  ;", "}", "METHOD_END"], "methodName": ["getStandardResources"], "fileName": "com.intellij.javaee.ExternalResourceManagerExImpl"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    map    =    ExternalResourceManagerExImpl . getMap ( myResources ,    version ,    false )  ;", "return   map    !  =    null    ?    map . get ( url )     :    null ;", "}", "METHOD_END"], "methodName": ["getUserResource"], "fileName": "com.intellij.javaee.ExternalResourceManagerExImpl"}, {"methodBody": ["METHOD_START", "{", "for    ( ImplicitNamespaceDescriptorProvider   provider    :    ImplicitNamespaceDescriptorProvider . EP _ NAME . getExtensions (  )  )     {", "if    (  ( provider . getNamespaceDescriptor ( null ,    url ,    null )  )     !  =    null )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isImplicitNamespaceDescriptor"], "fileName": "com.intellij.javaee.ExternalResourceManagerExImpl"}, {"methodBody": ["METHOD_START", "{", "Application   app    =    ApplicationManager . getApplication (  )  ;", "app . runWriteAction (  (  )     -  >    getInstance (  )  . add ( url ,    location )  )  ;", "Disposer . register ( disposable ,     (  )     -  >    app . runWriteAction (  (  )     -  >    getInstance (  )  . remove ( url )  )  )  ;", "}", "METHOD_END"], "methodName": ["registerResourceTemporarily"], "fileName": "com.intellij.javaee.ExternalResourceManagerExImpl"}, {"methodBody": ["METHOD_START", "{", "incModificationCount (  )  ;", "if    ( Html 5 SchemaProvider . getHtml 5 SchemaLocation (  )  . equals ( defaultHtmlDoctype )  )     {", "myDefaultHtmlDoctype    =     . HTML 5  _ DOCTYPE _ ELEMENT ;", "} else    {", "myDefaultHtmlDoctype    =    defaultHtmlDoctype ;", "}", "fireExternalResourceChanged (  )  ;", "}", "METHOD_END"], "methodName": ["setDefaultHtmlDoctype"], "fileName": "com.intellij.javaee.ExternalResourceManagerExImpl"}, {"methodBody": ["METHOD_START", "{", "FileTextField   field    =    FileChooserFactory . getInstance (  )  . createFileTextField ( MapExternalResourceDialog . FILE _ CHOOSER _ DESCRIPTOR ,    getDisposable (  )  )  ;", "myFileTextField    =    new   com . intellij . openapi . ui . TextFieldWithBrowseButton ( field . getField (  )  )  ;", "}", "METHOD_END"], "methodName": ["createUIComponents"], "fileName": "com.intellij.javaee.MapExternalResourceDialog"}, {"methodBody": ["METHOD_START", "{", "if    ( mySchemasTree . hasFocus (  )  )     {", "TreePath   path    =    mySchemasTree . getSelectionPath (  )  ;", "if    ( path    =  =    null )", "return   null ;", "Object   object    =     (  ( DefaultMutableTreeNode )     ( path . getLastPathComponent (  )  )  )  . getUserObject (  )  ;", "if    (  !  ( object   instanceof   PsiFile )  )", "return   null ;", "return   FileUtil . toSystemIndependentName (  (  ( PsiFile )     ( object )  )  . getVirtualFile (  )  . getPath (  )  )  ;", "} else    {", "return   myFileTextField . getText (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getResourceLocation"], "fileName": "com.intellij.javaee.MapExternalResourceDialog"}, {"methodBody": ["METHOD_START", "{", "return   myUri . getText (  )  ;", "}", "METHOD_END"], "methodName": ["getUri"], "fileName": "com.intellij.javaee.MapExternalResourceDialog"}, {"methodBody": ["METHOD_START", "{", "DefaultMutableTreeNode   root    =    new   DefaultMutableTreeNode (  )  ;", "mySchemasTree . setModel ( new   DefaultTreeModel ( root )  )  ;", "ConfigFileSearcher   searcher    =    new   ConfigFileSearcher (  ( file    =  =    null    ?    null    :    ModuleUtilCore . findModuleForPsiElement ( file )  )  ,    project )     {", "@ Override", "public   Set < PsiFile >    search (  @ Nullable", "Module   module ,     @ NotNull", "Project   project )     {", "List < IndexedRelevantResource < String ,    XsdNamespaceBuilder >  >    resources    =    XmlNamespaceIndex . getAllResources ( module ,    project ,    null )  ;", "HashSet < PsiFile >    files    =    new   HashSet <  >  (  )  ;", "PsiManager   psiManager    =    PsiManager . getInstance ( project )  ;", "for    ( IndexedRelevantResource < String ,    XsdNamespaceBuilder >    resource    :    resources )     {", "VirtualFile   file    =    resource . getFile (  )  ;", "PsiFile   psiFile    =    psiManager . findFile ( file )  ;", "ContainerUtil . addIfNotNull ( files ,    psiFile )  ;", "}", "return   files ;", "}", "}  ;", "searcher . search (  )  ;", "new   ConfigFilesTreeBuilder ( mySchemasTree )  . buildTree ( root ,    searcher )  ;", "TreeUtil . expandAll ( mySchemasTree )  ;", "mySchemasTree . setRootVisible ( false )  ;", "mySchemasTree . setShowsRootHandles ( true )  ;", "ColoredTreeCellRenderer   renderer    =    new   ColoredTreeCellRenderer (  )     {", "@ Override", "public   void   customizeCellRenderer (  @ NotNull", "JTree   tree ,    Object   value ,    boolean   selected ,    boolean   expanded ,    boolean   leaf ,    int   row ,    boolean   hasFocus )     {", "ConfigFilesTreeBuilder . renderNode ( value ,    expanded ,    this )  ;", "}", "}  ;", "renderer . setFont ( EditorColorsManager . getInstance (  )  . getGlobalScheme (  )  . getFont ( PLAIN )  )  ;", "mySchemasTree . setCellRenderer ( renderer )  ;", "MouseAdapter   mouseAdapter    =    new   MouseAdapter (  )     {", "@ Override", "public   void   mouseClicked ( MouseEvent   e )     {", "if    (  (  ( e . getClickCount (  )  )     >     1  )     &  &     ( isOKActionEnabled (  )  )  )     {", "doOKAction (  )  ;", "}", "}", "}  ;", "mySchemasTree . addMouseListener ( mouseAdapter )  ;", "mySchemasTree . getSelectionModel (  )  . addTreeSelectionListener ( new   TreeSelectionListener (  )     {", "@ Override", "public   void   valueChanged ( TreeSelectionEvent   e )     {", "validateInput (  )  ;", "}", "}  )  ;", "mySchemasTree . setSelectionRow (  0  )  ;", "PsiFile   schema    =    null ;", "if    ( file    !  =    null )     {", "schema    =    XmlUtil . findNamespaceByLocation ( file ,    uri )  ;", "} else", "if    ( location    !  =    null )     {", "VirtualFile   virtualFile    =    openapi . vfs . VfsUtilCore . findRelativeFile ( location ,    null )  ;", "if    ( virtualFile    !  =    null )     {", "schema    =    PsiManager . getInstance ( project )  . findFile ( virtualFile )  ;", "}", "}", "if    ( schema    !  =    null )     {", "DefaultMutableTreeNode   node    =    TreeUtil . findNodeWithObject ( root ,    schema )  ;", "if    ( node    !  =    null )     {", "mySchemaFound    =    true ;", "TreeUtil . selectNode ( mySchemasTree ,    node )  ;", "}", "myFileTextField . setText ( schema . getVirtualFile (  )  . getCanonicalPath (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setupSchemasTree"], "fileName": "com.intellij.javaee.MapExternalResourceDialog"}, {"methodBody": ["METHOD_START", "{", "setOKActionEnabled (  (  (  !  ( StringUtil . isEmpty ( myUri . getText (  )  )  )  )     &  &     (  ( getResourceLocation (  )  )     !  =    null )  )  )  ;", "}", "METHOD_END"], "methodName": ["validateInput"], "fileName": "com.intellij.javaee.MapExternalResourceDialog"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( obj   instanceof   NameLocationPair )  )", "return   false ;", "return    ( compareTo ( obj )  )     =  =     0  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.intellij.javaee.NameLocationPair"}, {"methodBody": ["METHOD_START", "{", "return   myLocation ;", "}", "METHOD_END"], "methodName": ["getLocation"], "fileName": "com.intellij.javaee.NameLocationPair"}, {"methodBody": ["METHOD_START", "{", "return   myName ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.intellij.javaee.NameLocationPair"}, {"methodBody": ["METHOD_START", "{", "return   myName . hashCode (  )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.intellij.javaee.NameLocationPair"}, {"methodBody": ["METHOD_START", "{", "addInternalResource ( resource ,    null ,    fileName ,    getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["addInternalResource"], "fileName": "com.intellij.javaee.ResourceRegistrarImpl"}, {"methodBody": ["METHOD_START", "{", "addInternalResource ( resource ,    null ,    fileName ,    clazz )  ;", "}", "METHOD_END"], "methodName": ["addInternalResource"], "fileName": "com.intellij.javaee.ResourceRegistrarImpl"}, {"methodBody": ["METHOD_START", "{", "addInternalResource ( resource ,    version ,    fileName ,    getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["addInternalResource"], "fileName": "com.intellij.javaee.ResourceRegistrarImpl"}, {"methodBody": ["METHOD_START", "{", "addStdResource ( resource ,    version ,     (  ( ExternalResourceManagerEx . STANDARD _ SCHEMAS )     +    fileName )  ,    clazz )  ;", "}", "METHOD_END"], "methodName": ["addInternalResource"], "fileName": "com.intellij.javaee.ResourceRegistrarImpl"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    ExternalResourceManagerExImpl . Resource >    map    =    ExternalResourceManagerExImpl . getMap ( myResources ,    version ,    true )  ;", "assert   map    !  =    null ;", "map . put ( resource ,    new   ExternalResourceManagerExImpl . Resource ( fileName ,    klass ,    classLoader )  )  ;", "}", "METHOD_END"], "methodName": ["addStdResource"], "fileName": "com.intellij.javaee.ResourceRegistrarImpl"}, {"methodBody": ["METHOD_START", "{", "return   myIgnored ;", "}", "METHOD_END"], "methodName": ["getIgnored"], "fileName": "com.intellij.javaee.ResourceRegistrarImpl"}, {"methodBody": ["METHOD_START", "{", "return   myResources ;", "}", "METHOD_END"], "methodName": ["getResources"], "fileName": "com.intellij.javaee.ResourceRegistrarImpl"}, {"methodBody": ["METHOD_START", "{", "String   location    =    ExternalResourceManager . getInstance (  )  . getResourceLocation ( uri ,    base . getProject (  )  )  ;", "return   VfsCore . findRelativeFile ( location ,    base . getVirtualFile (  )  )  ;", "}", "METHOD_END"], "methodName": ["findRelative"], "fileName": "com.intellij.javaee.UriUtil"}, {"methodBody": ["METHOD_START", "{", "return   VfsUtilCore . findRelativeFile ( ExternalResourceManager . getInstance (  )  . getResourceLocation ( uri )  ,    base )  ;", "}", "METHOD_END"], "methodName": ["findRelativeFile"], "fileName": "com.intellij.javaee.UriUtil"}, {"methodBody": ["METHOD_START", "{", "return   StringUtil . trimStart ( StringUtil . trimEnd ( path ,     \"  /  \"  )  ,     \"  /  \"  )  ;", "}", "METHOD_END"], "methodName": ["trimSlashFrom"], "fileName": "com.intellij.javaee.UriUtil"}, {"methodBody": ["METHOD_START", "{", "return   myManager ;", "}", "METHOD_END"], "methodName": ["getManager"], "fileName": "com.intellij.javaee.XMLCatalogManager"}, {"methodBody": ["METHOD_START", "{", "try    {", "Catalog   catalog    =    myManager . getCatalog (  )  ;", "if    ( catalog    =  =    null )", "return   null ;", "String   resolved    =    catalog . resolveSystem ( uri )  ;", "return   resolved    =  =    null    ?    catalog . resolvePublic ( uri ,    null )     :    resolved ;", "}    catch    ( IOException   e )     {", ". LOG . warn ( e )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "com.intellij.javaee.XMLCatalogManager"}, {"methodBody": ["METHOD_START", "{", "return   language    =  =    null    ?    null    :    LanguageHtmlInlineScriptTokenTypesProvider . INSTANCE . forLanguage ( language )  ;", "}", "METHOD_END"], "methodName": ["getInlineScriptProvider"], "fileName": "com.intellij.lang.LanguageHtmlInlineScriptTokenTypesProvider"}, {"methodBody": ["METHOD_START", "{", "return   LanguageHtmlScriptContentProvider . INSTANCE . forLanguage ( language )  ;", "}", "METHOD_END"], "methodName": ["getScriptContentProvider"], "fileName": "com.intellij.lang.LanguageHtmlScriptContentProvider"}, {"methodBody": ["METHOD_START", "{", "addToFold ( foldings ,    tag ,    document )  ;", "doAddForChildren ( tag ,    foldings ,    document )  ;", "}", "METHOD_END"], "methodName": ["addElementsToFold"], "fileName": "com.intellij.lang.XmlCodeFoldingBuilder"}, {"methodBody": ["METHOD_START", "{", "PsiUtilCore . ensureValid ( elementToFold )  ;", "TextRange   range    =    getRangeToFold ( elementToFold )  ;", "if    ( range    =  =    null )", "return   false ;", "if    (  (  (  ( range . getStartOffset (  )  )     >  =     0  )     &  &     (  ( range . getEndOffset (  )  )     <  =     ( elementToFold . getContainingFile (  )  . getTextRange (  )  . getEndOffset (  )  )  )  )     &  &     (  ( range . getEndOffset (  )  )     <  =     ( document . getTextLength (  )  )  )  )     {", "int   startLine    =    document . getLineNumber ( range . getStartOffset (  )  )  ;", "int   endLine    =    document . getLineNumber (  (  ( range . getEndOffset (  )  )     -     1  )  )  ;", "final   boolean   entity    =    isEntity ( elementToFold )  ;", "if    (  (  ( startLine    <    endLine )     |  |     ( elementToFold   instanceof   XmlAttribute )  )     |  |    entity )     {", "if    (  (  (  ( range . getStartOffset (  )  )     +     (  . MIN _ TEXT _ RANGE _ LENGTH )  )     <     ( range . getEndOffset (  )  )  )     |  |    entity )     {", "foldings . add ( new   FoldingDescriptor ( elementToFold . getNode (  )  ,    range )  )  ;", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["addToFold"], "fileName": "com.intellij.lang.XmlCodeFoldingBuilder"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement [  ]    children    =    tag . getChildren (  )  ;", "for    ( PsiElement   child    :    children )     {", "ProgressManager . checkCanceled (  )  ;", "if    (  ( child   instanceof   XmlTag )     |  |     ( child   instanceof   XmlConditionalSection )  )     {", "addElementsToFold ( foldings ,     (  ( XmlElement )     ( child )  )  ,    document )  ;", "} else", "if    ( child   instanceof   com . intellij . psi . xml . XmlComment )     {", "addToFold ( foldings ,    child ,    document )  ;", "} else", "if    (  ( child   instanceof   com . intellij . psi . xml . XmlText )     |  |     ( child   instanceof   com . intellij . psi . xml . XmlProlog )  )     {", "final   PsiElement [  ]    grandChildren    =    child . getChildren (  )  ;", "for    ( PsiElement   grandChild    :    grandChildren )     {", "ProgressManager . checkCanceled (  )  ;", "if    (  ( grandChild   instanceof   com . intellij . psi . xml . XmlComment )     |  |     ( isEntity ( grandChild )  )  )     {", "addToFold ( foldings ,    grandChild ,    document )  ;", "}", "}", "} else", "if    (  ( isEntity ( child )  )     |  |     (  ( child   instanceof   com . intellij . psi . xml . XmlAttribute )     &  &     (  . isAttributeShouldBeFolded (  (  ( com . intellij . psi . xml . XmlAttribute )     ( child )  )  )  )  )  )     {", "addToFold ( foldings ,    child ,    document )  ;", "} else    {", "final   Language   language    =    child . getLanguage (  )  ;", "if    (  (  !  ( language   instanceof   com . intellij . lang . xml . XMLLanguage )  )     &  &     ( language    !  =     ( Language . ANY )  )  )     {", "final   com . intellij . lang . folding . FoldingBuilder   foldingBuilder    =    LanguageFolding . INSTANCE . forLanguage ( language )  ;", "if    ( foldingBuilder    !  =    null )     {", "final   FoldingDescriptor [  ]    foldingDescriptors    =    foldingBuilder . buildFoldRegions ( child . getNode (  )  ,    document )  ;", "com . intellij . util . containers . ContainerUtil . addAll ( foldings ,    foldingDescriptors )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["doAddForChildren"], "fileName": "com.intellij.lang.XmlCodeFoldingBuilder"}, {"methodBody": ["METHOD_START", "{", "return    ( settings . isCollapseDataUri (  )  )     &  &     (  \" src \"  . equals ( psi . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["foldSrc"], "fileName": "com.intellij.lang.XmlCodeFoldingBuilder"}, {"methodBody": ["METHOD_START", "{", "return    ( settings . isCollapseHtmlStyleAttribute (  )  )     &  &     ( HtmlUtil . STYLE _ ATTRIBUTE _ NAME . equalsIgnoreCase ( psi . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["foldStyle"], "fileName": "com.intellij.lang.XmlCodeFoldingBuilder"}, {"methodBody": ["METHOD_START", "{", "return   XmlCodeFoldingBuilder . MIN _ TEXT _ RANGE _ LENGTH ;", "}", "METHOD_END"], "methodName": ["getCommentStartEnd"], "fileName": "com.intellij.lang.XmlCodeFoldingBuilder"}, {"methodBody": ["METHOD_START", "{", "return    4  ;", "}", "METHOD_END"], "methodName": ["getCommentStartOffset"], "fileName": "com.intellij.lang.XmlCodeFoldingBuilder"}, {"methodBody": ["METHOD_START", "{", "String   text    =    psi . getText (  )  ;", "String   fastPath    =    StringUtil . unescapeXml ( text )  ;", "if    (  !  ( StringUtil . equals ( fastPath ,    text )  )  )", "return   fastPath ;", "if    ( psi . isValid (  )  )     {", "final   XmlEntityDecl   resolve    =    XmlEntityRefImpl . resolveEntity (  (  ( XmlElement )     ( psi )  )  ,    text ,    psi . getContainingFile (  )  )  ;", "final   XmlAttributeValue   value    =     ( resolve    !  =    null )     ?    resolve . getValueElement (  )     :    null ;", "if    ( value    !  =    null )     {", "return    . getEntityValue ( value )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getEntityPlaceholder"], "fileName": "com.intellij.lang.XmlCodeFoldingBuilder"}, {"methodBody": ["METHOD_START", "{", "final   String   result    =    value . getValue (  )  ;", "final   int   i    =    result . indexOf (  '  #  '  )  ;", "if    ( i    >     0  )     {", "final   int   charNum    =    StringUtil . parseInt ( StringUtil . trimEnd ( result . substring (  ( i    +     1  )  )  ,     \"  ;  \"  )  ,     (  -  1  )  )  ;", "return   charNum    >  =     0     ?    String . valueOf (  (  ( char )     ( charNum )  )  )     :    null ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getEntityValue"], "fileName": "com.intellij.lang.XmlCodeFoldingBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( element   instanceof   XmlTag )     {", "final   ASTNode   tagNode    =    element . getNode (  )  ;", "XmlToken   tagNameElement    =    XmlTagUtil . getStartTagNameElement (  (  ( XmlTag )     ( element )  )  )  ;", "if    ( tagNameElement    =  =    null )", "return   null ;", "int   nameEnd    =    tagNameElement . getTextRange (  )  . getEndOffset (  )  ;", "int   end    =     ( tagNode . getLastChildNode (  )  . getTextRange (  )  . getEndOffset (  )  )     -     1  ;", "ASTNode [  ]    attributes    =    tagNode . getChildren (  . XML _ ATTRIBUTE _ SET )  ;", "if    (  ( attributes . length )     >     0  )     {", "ASTNode   lastAttribute    =    attributes [  (  ( attributes . length )     -     1  )  ]  ;", "ASTNode   lastAttributeBeforeCR    =    null ;", "for    ( ASTNode   child    =    tagNode . getFirstChildNode (  )  ;    child    !  =     ( lastAttribute . getTreeNext (  )  )  ;    child    =    child . getTreeNext (  )  )     {", "if    (  ( child . getElementType (  )  )     =  =     ( XmlElementType . XML _ ATTRIBUTE )  )     {", "lastAttributeBeforeCR    =    child ;", "} else", "if    (  ( child . getPsi (  )  )    instanceof   com . intellij . psi . PsiWhiteSpace )     {", "if    ( child . textContains (  '  \\ n '  )  )", "break ;", "}", "}", "if    ( lastAttributeBeforeCR    !  =    null )     {", "int   attributeEnd    =    lastAttributeBeforeCR . getTextRange (  )  . getEndOffset (  )  ;", "return   new   UnfairTextRange ( attributeEnd ,    end )  ;", "}", "}", "return   new   UnfairTextRange ( nameEnd ,    end )  ;", "} else", "if    ( element   instanceof   com . intellij . psi . xml . XmlComment )     {", "final   com . intellij . psi . xml . XmlComment   xmlComment    =     (  ( com . intellij . psi . xml . XmlComment )     ( element )  )  ;", "final   com . intellij . openapi . util . TextRange   textRange    =    element . getTextRange (  )  ;", "int   commentStartOffset    =    getCommentStartOffset ( xmlComment )  ;", "int   commentEndOffset    =    getCommentStartEnd ( xmlComment )  ;", "if    (  (  ( textRange . getEndOffset (  )  )     -     ( textRange . getStartOffset (  )  )  )     >     ( commentStartOffset    +    commentEndOffset )  )     {", "return   new   com . intellij . openapi . util . TextRange (  (  ( textRange . getStartOffset (  )  )     +    commentStartOffset )  ,     (  ( textRange . getEndOffset (  )  )     -    commentEndOffset )  )  ;", "} else    {", "return   null ;", "}", "} else", "if    ( element   instanceof   com . intellij . psi . xml . XmlConditionalSection )     {", "final   com . intellij . psi . xml . XmlConditionalSection   conditionalSection    =     (  ( com . intellij . psi . xml . XmlConditionalSection )     ( element )  )  ;", "final   com . intellij . openapi . util . TextRange   textRange    =    element . getTextRange (  )  ;", "final   PsiElement   bodyStart    =    conditionalSection . getBodyStart (  )  ;", "int   startOffset    =     ( bodyStart    !  =    null )     ?    bodyStart . getStartOffsetInParent (  )     :     . MIN _ TEXT _ RANGE _ LENGTH ;", "int   endOffset    =     . MIN _ TEXT _ RANGE _ LENGTH ;", "if    (  (  ( textRange . getEndOffset (  )  )     -     ( textRange . getStartOffset (  )  )  )     >     ( startOffset    +    endOffset )  )     {", "return   new   com . intellij . openapi . util . TextRange (  (  ( textRange . getStartOffset (  )  )     +    startOffset )  ,     (  ( textRange . getEndOffset (  )  )     -    endOffset )  )  ;", "} else    {", "return   null ;", "}", "} else", "if    ( element   instanceof   com . intellij . psi . xml . XmlAttribute )     {", "final   com . intellij . psi . xml . XmlAttributeValue   valueElement    =     (  ( com . intellij . psi . xml . XmlAttribute )     ( element )  )  . getValueElement (  )  ;", "return   valueElement    !  =    null    ?    valueElement . getValueTextRange (  )     :    null ;", "} else", "if    ( isEntity ( element )  )     {", "return   element . getTextRange (  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getRangeToFold"], "fileName": "com.intellij.lang.XmlCodeFoldingBuilder"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    ( getEntityPlaceho ( psi )  )     !  =    null ;", "}    catch    ( IndexNotReadyException   e )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["hasEntityPlaceholder"], "fileName": "com.intellij.lang.XmlCodeFoldingBuilder"}, {"methodBody": ["METHOD_START", "{", "return    ( HtmlUtil . isHtmlFile ( child . getContainingFile (  )  )  )     &  &     (  ( HtmlUtil . STYLE _ ATTRIBUTE _ NAME . equalsIgnoreCase ( child . getName (  )  )  )     |  |     (  (  (  \" src \"  . equals ( child . getName (  )  )  )     &  &     (  ( child . getValue (  )  )     !  =    null )  )     &  &     ( URLUtil . isDataUri ( child . getValue (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAttributeShouldBeFolded"], "fileName": "com.intellij.lang.XmlCodeFoldingBuilder"}, {"methodBody": ["METHOD_START", "{", "return    ( psi   instanceof   XmlEntityRef )     |  |     (  ( psi   instanceof   XmlTokenImpl )     &  &     (  (  (  ( XmlTokenImpl )     ( psi )  )  . getElementType (  )  )     =  =     ( XmlTokenType . XML _ CHAR _ ENTITY _ REF )  )  )  ;", "}", "METHOD_END"], "methodName": ["isEntity"], "fileName": "com.intellij.lang.XmlCodeFoldingBuilder"}, {"methodBody": ["METHOD_START", "{", "destination . append ( type )  . append (  \"  :  & nbsp ;  < b >  \"  )  . append ( name )  . append (  \"  <  / b >  < br >  \"  )  ;", "}", "METHOD_END"], "methodName": ["formatEntityName"], "fileName": "com.intellij.lang.documentation.DocumentationUtil"}, {"methodBody": ["METHOD_START", "{", "return   new   HtmlParsing ( builder )  ;", "}", "METHOD_END"], "methodName": ["createHtmlParsing"], "fileName": "com.intellij.lang.html.HTMLParser"}, {"methodBody": ["METHOD_START", "{", "HTMLParser . parseWithoutBuildingTree ( root ,    builder ,    new   HtmlParsing ( builder )  )  ;", "}", "METHOD_END"], "methodName": ["parseWithoutBuildingTree"], "fileName": "com.intellij.lang.html.HTMLParser"}, {"methodBody": ["METHOD_START", "{", "builder . enforceCommentTokens ( EMPTY )  ;", "final   PsiBuilder . Marker   file    =    builder . mark (  )  ;", "Parsing . parseDocument (  )  ;", "file . done ( root )  ;", "}", "METHOD_END"], "methodName": ["parseWithoutBuildingTree"], "fileName": "com.intellij.lang.html.HTMLParser"}, {"methodBody": ["METHOD_START", "{", "myBuilder . advanceLexer (  )  ;", "}", "METHOD_END"], "methodName": ["advance"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "boolean   isCell    =     ( HtmlParsing . TD _ TAG . equals ( childName )  )     |  |     ( HtmlParsing . TH _ TAG . equals ( childName )  )  ;", "boolean   isRow    =    HtmlParsing . TR _ TAG . equals ( childName )  ;", "boolean   isStructure    =    HtmlParsing . isStructure ( childName )  ;", "for    ( int   i    =     ( myTagNamesStack . size (  )  )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "String   parentName    =    myTagNamesStack . get ( i )  ;", "final   boolean   isParentTable    =    HtmlParsing . TABLE _ TAG . equals ( parentName )  ;", "final   boolean   isParentStructure    =    HtmlParsing . isStructure ( parentName )  ;", "if    (  (  ( isCell    &  &     (  (  ( HtmlParsing . TR _ TAG . equals ( parentName )  )     |  |    isParentStructure )     |  |    isParentTable )  )     |  |     ( isRow    &  &     ( isParentStructure    |  |    isParentTable )  )  )     |  |     ( isStructure    &  &    isParentTable )  )     {", "return   false ;", "}", "if    (  (  \" li \"  . equals ( childName )  )     &  &     (  (  \" ul \"  . equals ( parentName )  )     |  |     (  \" ol \"  . equals ( parentName )  )  )  )     {", "return   false ;", "}", "if    (  (  \" dl \"  . equals ( parentName )  )     &  &     (  (  \" dd \"  . equals ( childName )  )     |  |     (  \" dt \"  . equals ( childName )  )  )  )     {", "return   false ;", "}", "if    ( HtmlUtil . canTerminate ( childName ,    parentName )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["childTerminatesParentInStack"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "myTagNamesStack . pop (  )  ;", "myOrigalTagNamesStack . pop (  )  ;", "return   myTagMarkersStack . pop (  )  ;", "}", "METHOD_END"], "methodName": ["closeTag"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "tag . done ( XmlElementType . HTML _ TAG )  ;", "final   String   tagName    =    myTagNamesStack . peek (  )  ;", "closeTag (  )  ;", "final   String   parentTagName    =     ( hasTags (  )  )     ?    myTagNamesStack . peek (  )     :     \"  \"  ;", "boolean   isInlineTagContainer    =    Util . isInlineTagContainerL ( parentTagName )  ;", "boolean   isOptionalTagEnd    =    Util . isOptionalEndForTagL ( parentTagName )  ;", "if    (  (  ( isInlineTagContainer    &  &     ( Util . isBlockTagL ( tagName )  )  )     &  &    isOptionalTagEnd )     &  &     (  !  ( Util . isPossiblyInlineTag ( tagName )  )  )  )     {", "PsiBuilder . Marker   top    =    closeTag (  )  ;", "top . doneBefore ( XmlElementType . HTML _ TAG ,    tag )  ;", "}", "}", "METHOD_END"], "methodName": ["doneTag"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "return   myBuilder . eof (  )  ;", "}", "METHOD_END"], "methodName": ["eof"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "myBuilder . error ( message )  ;", "}", "METHOD_END"], "methodName": ["error"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "if    ( error    !  =    null )     {", "error . error ( XmlErrorMessages . message (  \" xml . p . unexpected . tokens \"  )  )  ;", "error    =    null ;", "}", "return   error ;", "}", "METHOD_END"], "methodName": ["flushError"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "return    !  ( myTagNamesStack . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasTags"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "return   HtmlUtil . isSingleHtmlTagL ( tagName )  ;", "}", "METHOD_END"], "methodName": ["isSingleTag"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "return    (  (  \" thead \"  . equals ( childName )  )     |  |     (  \" tbody \"  . equals ( childName )  )  )     |  |     (  \" tfoot \"  . equals ( childName )  )  ;", "}", "METHOD_END"], "methodName": ["isStructure"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "return   myBuilder . mark (  )  ;", "}", "METHOD_END"], "methodName": ["mark"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "assert    ( token (  )  )     =  =     ( XmlTokenType . XML _ NAME )  ;", "final   PsiBuilder . Marker   att    =    mark (  )  ;", "advance (  )  ;", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ EQ )  )     {", "advance (  )  ;", "peAttributeValue (  )  ;", "att . done ( XmlElementType . XML _ ATTRIBUTE )  ;", "} else    {", "att . done ( XmlElementType . XML _ ATTRIBUTE )  ;", "}", "}", "METHOD_END"], "methodName": ["parseAttribute"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   attValue    =    mark (  )  ;", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ START _ DELIMITER )  )     {", "while    ( true )     {", "final   IElementType   tt    =    token (  )  ;", "if    (  (  (  (  ( tt    =  =    null )     |  |     ( tt    =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ END _ DELIMITER )  )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ END _ TAG _ START )  )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ EMPTY _ ELEMENT _ END )  )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ START _ TAG _ START )  )  )     {", "break ;", "}", "if    ( tt    =  =     ( XmlTokenType . XML _ BAD _ CHARACTER )  )     {", "final   PsiBuilder . Marker   error    =    mark (  )  ;", "advance (  )  ;", "error . error ( XmlErrorMessages . message (  \" unescaped . ampersand . or . nonterminated . character . entity . reference \"  )  )  ;", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )     {", "parseReference (  )  ;", "} else    {", "advance (  )  ;", "}", "}", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ END _ DELIMITER )  )     {", "advance (  )  ;", "} else    {", "error ( XmlErrorMessages . message (  \" xml . p . unclosed . attribute . value \"  )  )  ;", "}", "} else    {", "if    (  (  ( token (  )  )     !  =     ( XmlTokenType . XML _ TAG _ END )  )     &  &     (  ( token (  )  )     !  =     ( XmlTokenType . XML _ EMPTY _ ELEMENT _ END )  )  )     {", "advance (  )  ;", "}", "}", "attValue . done ( XmlElementType . XML _ ATTRIBUTE _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["parseAttributeValue"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "assert    ( token (  )  )     =  =     ( XmlTokenType . XML _ CDATA _ START )  ;", "final   PsiBuilder . Marker   cdata    =    mark (  )  ;", "while    (  (  ( token (  )  )     !  =     ( XmlTokenType . XML _ CDATA _ END )  )     &  &     (  !  ( eof (  )  )  )  )     {", "advance (  )  ;", "}", "if    (  !  ( eof (  )  )  )     {", "advance (  )  ;", "}", "cdata . done ( XmlElementType . XML _ CDATA )  ;", "}", "METHOD_END"], "methodName": ["parseCData"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   comment    =    mark (  )  ;", "advance (  )  ;", "while    ( true )     {", "final   IElementType   tt    =    token (  )  ;", "if    (  (  (  (  ( tt    =  =     ( XmlTokenType . XML _ COMMENT _ CHARACTERS )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ CONDITIONAL _ COMMENT _ START )  )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ CONDITIONAL _ COMMENT _ START _ END )  )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ CONDITIONAL _ COMMENT _ END _ START )  )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ CONDITIONAL _ COMMENT _ END )  )  )     {", "advance (  )  ;", "continue ;", "}", "if    (  ( tt    =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ CHAR _ ENTITY _ REF )  )  )     {", "parseReference (  )  ;", "continue ;", "}", "if    ( tt    =  =     ( XmlTokenType . XML _ BAD _ CHARACTER )  )     {", "final   PsiBuilder . Marker   error    =    mark (  )  ;", "advance (  )  ;", "error . error ( XmlErrorMessages . message (  \" xml . p . bad . character \"  )  )  ;", "continue ;", "}", "if    ( tt    =  =     ( XmlTokenType . XML _ COMMENT _ END )  )     {", "advance (  )  ;", "}", "break ;", "}", "comment . done ( XmlElementType . XML _ COMMENT )  ;", "}", "METHOD_END"], "methodName": ["parseComment"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "assert    ( token (  )  )     =  =     ( XmlTokenType . XML _ DOCTYPE _ START )     :     \" Doctype   start   expected \"  ;", "final   PsiBuilder . Marker   doctype    =    mark (  )  ;", "advance (  )  ;", "while    (  (  ( token (  )  )     !  =     ( XmlTokenType . XML _ DOCTYPE _ END )  )     &  &     (  !  ( eof (  )  )  )  )", "advance (  )  ;", "if    ( eof (  )  )     {", "error ( XmlErrorMessages . message (  \" xml . p . unexpected . end . of . file \"  )  )  ;", "} else    {", "advance (  )  ;", "}", "doctype . done ( XmlElementType . XML _ DOCTYPE )  ;", "}", "METHOD_END"], "methodName": ["parseDoctype"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   document    =    mark (  )  ;", "while    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ COMMENT _ START )  )     {", "parseComment (  )  ;", "}", "parseProlog (  )  ;", "PsiBuilder . Marker   error    =    null ;", "while    (  !  ( eof (  )  )  )     {", "final   IElementType   tt    =    token (  )  ;", "if    ( tt    =  =     ( XmlTokenType . XML _ START _ TAG _ START )  )     {", "error    =     . flushError ( error )  ;", "parseTag (  )  ;", "myTagMarkersStack . clear (  )  ;", "myTagNamesStack . clear (  )  ;", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ COMMENT _ START )  )     {", "error    =     . flushError ( error )  ;", "parseComment (  )  ;", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ PI _ START )  )     {", "error    =     . flushError ( error )  ;", "parseProcessingInstruction (  )  ;", "} else", "if    (  ( tt    =  =     ( XmlTokenType . XML _ CHAR _ ENTITY _ REF )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )  )     {", "parseReference (  )  ;", "} else", "if    (  ( tt    =  =     ( XmlTokenType . XML _ REAL _ WHITE _ SPACE )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ DATA _ CHARACTERS )  )  )     {", "error    =     . flushError ( error )  ;", "advance (  )  ;", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ END _ TAG _ START )  )     {", "final   PsiBuilder . Marker   tagEndError    =    myBuilder . mark (  )  ;", "advance (  )  ;", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ NAME )  )     {", "advance (  )  ;", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ TAG _ END )  )     {", "advance (  )  ;", "}", "}", "tagEndError . error ( XmlErrorMessages . message (  \" xml . parsing . closing . tag . matches . nothing \"  )  )  ;", "} else    {", "if    ( error    =  =    null )", "error    =    mark (  )  ;", "advance (  )  ;", "}", "}", "if    ( error    !  =    null )     {", "error . error ( XmlErrorMessages . message (  \" top . level . element . is . not . completed \"  )  )  ;", "}", "document . done ( XmlElementType . HTML _ DOCUMENT )  ;", "}", "METHOD_END"], "methodName": ["parseDocument"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "boolean   freeMakerTag    =     (  !  ( tagName . isEmpty (  )  )  )     &  &     (  '  #  '     =  =     ( tagName . charAt (  0  )  )  )  ;", "do    {", "final   IElementType   tt    =    token (  )  ;", "if    ( freeMakerTag )     {", "if    (  (  (  ( tt    =  =     ( XmlTokenType . XML _ EMPTY _ ELEMENT _ END )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ TAG _ END )  )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ END _ TAG _ START )  )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ START _ TAG _ START )  )  )", "break ;", "advance (  )  ;", "} else    {", "if    ( tt    =  =     ( XmlTokenType . XML _ NAME )  )     {", "peAttribute (  )  ;", "} else", "if    (  ( tt    =  =     ( XmlTokenType . XML _ CHAR _ ENTITY _ REF )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )  )     {", "peReference (  )  ;", "} else    {", "break ;", "}", "}", "}    while    (  !  ( eof (  )  )     )  ;", "}", "METHOD_END"], "methodName": ["parseHeader"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "assert    ( token (  )  )     =  =     ( XmlTokenType . XML _ PI _ START )  ;", "final   PsiBuilder . Marker   pi    =    mark (  )  ;", "advance (  )  ;", "if    (  (  ( token (  )  )     =  =     ( XmlTokenType . XML _ NAME )  )     |  |     (  ( token (  )  )     =  =     ( XmlTokenType . XML _ PI _ TARGET )  )  )     {", "advance (  )  ;", "}", "while    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ NAME )  )     {", "advance (  )  ;", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ EQ )  )     {", "advance (  )  ;", "} else    {", "error ( XmlErrorMessages . message (  \" expected . attribute . eq . sign \"  )  )  ;", "}", "parseAttributeValue (  )  ;", "}", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ PI _ END )  )     {", "advance (  )  ;", "} else    {", "error ( XmlErrorMessages . message (  \" xml . p . unterminated . processing . instruction \"  )  )  ;", "}", "pi . done ( XmlElementType . XML _ PROCESSING _ INSTRUCTION )  ;", "}", "METHOD_END"], "methodName": ["parseProcessingInstruction"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "while    ( true )     {", "final   IElementType   tt    =    token (  )  ;", "if    ( tt    =  =     ( XmlTokenType . XML _ COMMENT _ START )  )     {", "parseComment (  )  ;", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ REAL _ WHITE _ SPACE )  )     {", "advance (  )  ;", "} else    {", "break ;", "}", "}", "final   PsiBuilder . Marker   prolog    =    mark (  )  ;", "while    ( true )     {", "final   IElementType   tt    =    token (  )  ;", "if    ( tt    =  =     ( XmlTokenType . XML _ PI _ START )  )     {", "parseProcesInstruction (  )  ;", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ DOCTYPE _ START )  )     {", "parseDoctype (  )  ;", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ COMMENT _ START )  )     {", "parseComment (  )  ;", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ REAL _ WHITE _ SPACE )  )     {", "advance (  )  ;", "} else    {", "break ;", "}", "}", "prolog . done ( XmlElementType . XML _ PROLOG )  ;", "}", "METHOD_END"], "methodName": ["parseProlog"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ CHAR _ ENTITY _ REF )  )     {", "advance (  )  ;", "} else", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )     {", "final   PsiBuilder . Marker   ref    =    mark (  )  ;", "advance (  )  ;", "ref . done ( com . intellij . psi . xml . XmlElementType . XML _ ENTITY _ REF )  ;", "} else    {", "assert   false    :     \" Unexpected   token \"  ;", "}", "}", "METHOD_END"], "methodName": ["parseReference"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "assert    ( token (  )  )     =  =     ( XmlTokenType . XML _ START _ TAG _ START )     :     \" Tag   start   expected \"  ;", "String   originalTagName ;", "PsiBuilder . Marker   xmlText    =    null ;", "while    (  !  ( eof (  )  )  )     {", "final   IElementType   tt    =    token (  )  ;", "if    ( tt    =  =     ( XmlTokenType . XML _ START _ TAG _ START )  )     {", "xmlText    =    HtmlParsing . terminateText ( xmlText )  ;", "final   PsiBuilder . Marker   tag    =    mark (  )  ;", "advance (  )  ;", "if    (  ( token (  )  )     !  =     ( XmlTokenType . XML _ NAME )  )     {", "error ( XmlErrorMessages . message (  \" xml . parsing . tag . name . expected \"  )  )  ;", "originalTagName    =     \"  \"  ;", "} else    {", "originalTagName    =    myBuilder . getTokenText (  )  ;", "advance (  )  ;", "}", "String   tagName    =    StringUtil . toLowerCase ( originalTagName )  ;", "while    ( childTerminatesParentInStack ( tagName )  )     {", "PsiBuilder . Marker   top    =    closeTag (  )  ;", "top . doneBefore ( XmlElementType . HTML _ TAG ,    tag )  ;", "}", "myTagMarkersStack . push ( tag )  ;", "myTagNamesStack . push ( tagName )  ;", "myOriginalTagNamesStack . push ( originalTagName )  ;", "parseHeader ( tagName )  ;", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ EMPTY _ ELEMENT _ END )  )     {", "advance (  )  ;", "doneTag ( tag )  ;", "continue ;", "}", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ TAG _ END )  )     {", "advance (  )  ;", "} else    {", "error ( XmlErrorMessages . message (  \" tag . start . is . not . closed \"  )  )  ;", "doneTag ( tag )  ;", "continue ;", "}", "if    (  ( originalTagName    !  =    null )     &  &     ( isSingleTag ( tagName ,    originalTagName )  )  )     {", "final   PsiBuilder . Marker   footer    =    mark (  )  ;", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ END _ TAG _ START )  )     {", "advance (  )  ;", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ NAME )  )     {", "if    ( tagName . equalsIgnoreCase ( myBuilder . getTokenText (  )  )  )     {", "advance (  )  ;", "footer . drop (  )  ;", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ TAG _ END )  )     {", "advance (  )  ;", "}", "doneTag ( tag )  ;", "continue ;", "}", "}", "}", "footer . rollbackTo (  )  ;", "doneTag ( tag )  ;", "}", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ PI _ START )  )     {", "xmlText    =    HtmlParsing . terminateText ( xmlText )  ;", "parseProcessingInstruction (  )  ;", "} else", "if    (  ( tt    =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ CHAR _ ENTITY _ REF )  )  )     {", "xmlText    =    startText ( xmlText )  ;", "parseReference (  )  ;", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ CDATA _ START )  )     {", "xmlText    =    startText ( xmlText )  ;", "parseCData (  )  ;", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ COMMENT _ START )  )     {", "xmlText    =    startText ( xmlText )  ;", "parseComment (  )  ;", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ BAD _ CHARACTER )  )     {", "xmlText    =    startText ( xmlText )  ;", "final   PsiBuilder . Marker   error    =    mark (  )  ;", "advance (  )  ;", "error . error ( XmlErrorMessages . message (  \" unescaped . ampersand . or . nonterminated . character . entity . reference \"  )  )  ;", "} else", "if    (  ( tt   instanceof   psi . tree . ICustomParsingType )     |  |     ( tt   instanceof   psi . tree . ILazyParseableElementType )  )     {", "xmlText    =    HtmlParsing . terminateText ( xmlText )  ;", "advance (  )  ;", "} else", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ END _ TAG _ START )  )     {", "xmlText    =    HtmlParsing . terminateText ( xmlText )  ;", "final   PsiBuilder . Marker   footer    =    mark (  )  ;", "advance (  )  ;", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ NAME )  )     {", "String   endName    =    StringUtil . toLowerCase ( myBuilder . getTokenText (  )  )  ;", "final   String   parentTagName    =     (  !  ( myTagNamesStack . isEmpty (  )  )  )     ?    myTagNamesStack . peek (  )     :     \"  \"  ;", "if    (  (  !  ( parentTagName . equals ( endName )  )  )     &  &     (  !  ( endName . endsWith ( HtmlParsing . COMPLETION _ NAME )  )  )  )     {", "final   boolean   isOptionalTagEnd    =    HtmlUtil . isOptionalEndForHtmlTagL ( parentTagName )  ;", "final   boolean   hasChancesToMatch    =     ( HtmlUtil . isOptionalEndForHtmlTagL ( endName )  )     ?    childTerminatesParentInStack ( endName )     :    myTagNamesStack . contains ( endName )  ;", "if    ( hasChancesToMatch )     {", "footer . rollbackTo (  )  ;", "if    (  ! isOptionalTagEnd )     {", "error ( XmlErrorMessages . message (  \" named . element . is . not . closed \"  ,    myOriginalTagNamesStack . peek (  )  )  )  ;", "}", "doneTag ( myTagMarkersStack . peek (  )  )  ;", "} else    {", "advance (  )  ;", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ TAG _ END )  )", "advance (  )  ;", "footer . error ( XmlErrorMessages . message (  \" xml . parsing . closing . tag . matches . nothing \"  )  )  ;", "}", "continue ;", "}", "advance (  )  ;", "while    (  (  (  (  ( token (  )  )     !  =     ( XmlTokenType . XML _ TAG _ END )  )     &  &     (  ( token (  )  )     !  =     ( XmlTokenType . XML _ START _ TAG _ START )  )  )     &  &     (  ( token (  )  )     !  =     ( XmlTokenType . XML _ END _ TAG _ START )  )  )     &  &     (  !  ( eof (  )  )  )  )     {", "error ( XmlErrorMessages . message (  \" xml . parsing . unexpected . token \"  )  )  ;", "advance (  )  ;", "}", "} else    {", "error ( XmlErrorMessages . message (  \" xml . parsing . closing . tag . name . missing \"  )  )  ;", "}", "footer . drop (  )  ;", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ TAG _ END )  )     {", "advance (  )  ;", "} else    {", "error ( XmlErrorMessages . message (  \" xml . parsing . closing . tag . is . not . done \"  )  )  ;", "}", "if    ( hasTags (  )  )", "doneTag ( myTagMarkersStack . peek (  )  )  ;", "} else", "if    (  (  (  ( token (  )  )     =  =     ( XmlTokenType . XML _ REAL _ WHITE _ SPACE )  )     |  |     (  ( token (  )  )     =  =     ( XmlTokenType . XML _ DATA _ CHARACTERS )  )  )     &  &     (  !  ( hasTags (  )  )  )  )     {", "xmlText    =    HtmlParsing . terminateText ( xmlText )  ;", "advance (  )  ;", "} else    {", "xmlText    =    startText ( xmlText )  ;", "advance (  )  ;", "}", "}", "HtmlParsing . terminateText ( xmlText )  ;", "while    ( hasTags (  )  )     {", "final   String   tagName    =    myTagNamesStack . peek (  )  ;", "if    (  (  (  !  ( HtmlUtil . isOptionalEndForHtmlTagL ( tagName )  )  )     &  &     (  !  (  \" html \"  . equals ( tagName )  )  )  )     &  &     (  !  (  \" body \"  . equals ( tagName )  )  )  )     {", "error ( XmlErrorMessages . message (  \" named . element . is . not . closed \"  ,    myOriginalTagNamesStack . peek (  )  )  )  ;", "}", "doneTag ( myTagMarkersStack . peek (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseTag"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "if    ( xmlText    =  =    null )     {", "xmlText    =    mark (  )  ;", "assert   xmlText    !  =    null ;", "}", "return   xmlText ;", "}", "METHOD_END"], "methodName": ["startText"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "if    ( xmlText    !  =    null )     {", "xmlText . done ( XmlElementType . XML _ TEXT )  ;", "xmlText    =    null ;", "}", "return   xmlText ;", "}", "METHOD_END"], "methodName": ["terminateText"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "return   myBuilder . getTokenType (  )  ;", "}", "METHOD_END"], "methodName": ["token"], "fileName": "com.intellij.lang.html.HtmlParsing"}, {"methodBody": ["METHOD_START", "{", "if    (  ( buf . length (  )  )     >  =    maximumTextLength )", "return ;", "final   String   text    =    tag . getValue (  )  . getTrimmedText (  )  ;", "if    (  !  ( text . isEmpty (  )  )  )     {", "buf . append ( text )  ;", "} else    {", "for    ( XmlTag   subTag    :    tag . getSubTags (  )  )     {", ". appendTextRecursively ( subTag ,    buf ,    maximumTextLength )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["appendTextRecursively"], "fileName": "com.intellij.lang.html.structureView.Html5SectionsProcessor"}, {"methodBody": ["METHOD_START", "{", "return    ( Html 5 SectionsProcessor . getHeaderRank ( header 2  )  )     -     ( Html 5 SectionsProcessor . getHeaderRank ( header 1  )  )  ;", "}", "METHOD_END"], "methodName": ["compareHeaderRanks"], "fileName": "com.intellij.lang.html.structureView.Html5SectionsProcessor"}, {"methodBody": ["METHOD_START", "{", "return    (  )     -  >     {", "final   Collection < STreeElement >    result    =    new   ArrayList <  >  (  )  ;", "for    ( Section   section    :    children )     {", "result . add ( createHtml 5 SectionTreeElement ( section )  )  ;", "}", "return   result ;", "}  ;", "}", "METHOD_END"], "methodName": ["createChildrenComputable"], "fileName": "com.intellij.lang.html.structureView.Html5SectionsProcessor"}, {"methodBody": ["METHOD_START", "{", "return   new   Html 5 SectionTreeElement ( section . getTag (  )  ,    Html 5 SectionsProcessor . createChildrenComputable ( section . getChildren (  )  )  ,    Html 5 SectionsProcessor . getHeaderText ( section . getHeader (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createHtml5SectionTreeElement"], "fileName": "com.intellij.lang.html.structureView.Html5SectionsProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( Html 5 SectionsProcessor . HGROUP _ ELEMENT . equalsIgnoreCase ( header . getLocalName (  )  )  )     {", "int   minIndex    =    Html 5 SectionsProcessor . HEADER _ ELEMENTS . length ;", "for    ( XmlTag   subTag    :    header . getSubTags (  )  )     {", "final   int   index    =    ArrayUtil . indexOf ( Html 5 SectionsProcessor . HEADER _ ELEMENTS ,    subTag . getLocalName (  )  . toLowerCase (  )  )  ;", "if    ( index    <    minIndex )     {", "minIndex    =    index ;", "if    ( minIndex    =  =     0  )", "break ;", "}", "}", "if    ( minIndex    =  =     ( Html 5 SectionsProcessor . HEADER _ ELEMENTS . length )  )     {", "minIndex    =     0  ;", "}", "return   minIndex    +     1  ;", "}", "final   int   index    =    ArrayUtil . indexOf ( Html 5 SectionsProcessor . HEADER _ ELEMENTS ,    header . getLocalName (  )  . toLowerCase (  )  )  ;", "if    ( index    <     0  )", "throw   new   IllegalArgumentException ( header . getName (  )  )  ;", "return   index    +     1  ;", "}", "METHOD_END"], "methodName": ["getHeaderRank"], "fileName": "com.intellij.lang.html.structureView.Html5SectionsProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( header    =  =    null )", "return   null ;", "final   StringBuilder   buf    =    new   StringBuilder (  )  ;", "if    (  . HGROUP _ ELEMENT . equalsIgnoreCase ( header . getLocalName (  )  )  )     {", "for    ( XmlTag   subTag    :    header . getSubTags (  )  )     {", "if    ( ArrayUtil . contains ( subTag . getLocalName (  )  . toLowerCase (  )  ,     . HEADER _ ELEMENTS )  )     {", "if    (  ( buf . length (  )  )     >     0  )     {", "buf . append (  \"     \"  )  ;", "}", ". appendTextRecursively ( subTag ,    buf ,     (  ( HtmlTagTreeElement . MAX _ TEXT _ LENGTH )     *     2  )  )  ;", "}", "}", "} else    {", ". appendTextRecursively ( header ,    buf ,     (  ( HtmlTagTreeElement . MAX _ TEXT _ LENGTH )     *     2  )  )  ;", "}", "return   buf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getHeaderText"], "fileName": "com.intellij.lang.html.structureView.Html5SectionsProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Collection < Html 5 SectionTreeElement >    result    =    new   ArrayList <  >  (  )  ;", "for    (  . SectionHolder   sectionHolder    :    myRootSectionHolders )     {", "for    (  . Section   section    :    sectionHolder . getChildren (  )  )     {", "result . add (  . createHtml 5 SectionTreeElement ( section )  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getRootSections"], "fileName": "com.intellij.lang.html.structureView.Html5SectionsProcessor"}, {"methodBody": ["METHOD_START", "{", "return    ( ArrayUtil . contains ( tag . getLocalName (  )  . toLowerCase (  )  ,    Html 5 SectionsProcessor . HEADER _ ELEMENTS )  )     |  |     ( Html 5 SectionsProcessor . HGROUP _ ELEMENT . equalsIgnoreCase ( tag . getLocalName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isHeader"], "fileName": "com.intellij.lang.html.structureView.Html5SectionsProcessor"}, {"methodBody": ["METHOD_START", "{", "return   ArrayUtil . contains ( tag . getLocalName (  )  . toLowerCase (  )  ,    Html 5 SectionsProcessor . SECTIONING _ CONTENT _ ELEMENTS )  ;", "}", "METHOD_END"], "methodName": ["isSectioningContentElement"], "fileName": "com.intellij.lang.html.structureView.Html5SectionsProcessor"}, {"methodBody": ["METHOD_START", "{", "return   ArrayUtil . contains ( tag . getLocalName (  )  . toLowerCase (  )  ,    Html 5 SectionsProcessor . SECTIONING _ ROOT _ ELEMENTS )  ;", "}", "METHOD_END"], "methodName": ["isSectioningRootElement"], "fileName": "com.intellij.lang.html.structureView.Html5SectionsProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Html 5 SectionsProcessor   processor    =    new   Html 5 SectionsProcessor (  )  ;", "Html 5 SectionsProcessor . processRecursively ( rootTag ,    processor )  ;", "return   processor . getRootSections (  )  ;", "}", "METHOD_END"], "methodName": ["processAndGetRootSections"], "fileName": "com.intellij.lang.html.structureView.Html5SectionsProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( tag . getAttribute (  \" hidden \"  )  )     !  =    null )", "return ;", "processor . tagEntered ( tag )  ;", "if    (  !  (  . isHeader ( tag )  )  )     {", "for    ( final   XmlTag   subTag    :    tag . getSubTags (  )  )     {", ". processRecursively ( subTag ,    processor )  ;", "}", "}", "processor . tagExited ( tag )  ;", "}", "METHOD_END"], "methodName": ["processRecursively"], "fileName": "com.intellij.lang.html.structureView.Html5SectionsProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Html 5 SectionsProcessor . isSectioningContentElement ( tag )  )     |  |     ( Html 5 SectionsProcessor . isSectioningRootElement ( tag )  )  )     {", "if    (  ( myCurrentOutlinee )     !  =    null )     {", "myStack . push ( myCurrentOutlinee )  ;", "}", "myCurrentOutlinee    =    new   Html 5 SectionsProcessor . SectionHolder ( tag )  ;", "myCurrentSection    =    new   Html 5 SectionsProcessor . Section ( tag )  ;", "myCurrentOutlinee . addChildSection ( myCurrentSection )  ;", "} else", "if    (  ( myCurrentOutlinee )     =  =    null )     {", "} else", "if    ( Html 5 SectionsProcessor . isHeader ( tag )  )     {", "if    (  ( myCurrentSection . getHeader (  )  )     =  =    null )     {", "myCurrentSection . setHeader ( tag )  ;", "} else", "if    (  (  ( myCurrentOutlinee . getChildren (  )  . getLast (  )  . getHeader (  )  )     =  =    null )     |  |     (  ( Html 5 SectionsProcessor . compareHeaderRanks ( tag ,    myCurrentOutlinee . getChildren (  )  . getLast (  )  . getHeader (  )  )  )     >  =     0  )  )     {", "myCurrentSection    =    new   Html 5 SectionsProcessor . Section ( tag )  ;", "myCurrentSection . setHeader ( tag )  ;", "myCurrentOutlinee . addChildSection ( myCurrentSection )  ;", "} else    {", "Html 5 SectionsProcessor . Section   candidateSection    =    myCurrentSection ;", "do    {", "if    (  ( Html 5 SectionsProcessor . compareHeaderRanks ( tag ,    candidateSection . getHeader (  )  )  )     <     0  )     {", "myCurrentSection    =    new   Html 5 SectionsProcessor . Section ( tag )  ;", "myCurrentSection . setHeader ( tag )  ;", "candidateSection . addChildSection ( myCurrentSection )  ;", "break ;", "}", "candidateSection    =    candidateSection . getParent (  )  ;", "}    while    ( true    )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["tagEntered"], "fileName": "com.intellij.lang.html.structureView.Html5SectionsProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( myStack . isEmpty (  )  )  )     &  &     (  ( myStack . peek (  )  . getTag (  )  )     =  =    tag )  )     {", "assert   false ;", "} else", "if    (  (  !  ( myStack . isEmpty (  )  )  )     &  &     (  . isHeader ( tag )  )  )     {", "} else", "if    (  (  !  ( myStack . isEmpty (  )  )  )     &  &     (  . isSectioningContentElement ( tag )  )  )     {", "final    . SectionHolder   exitedSectioningContent    =    myCurrentOutlinee ;", "assert    ( exitedSectioningContent . getTag (  )  )     =  =    tag ;", "myCurrentOutlinee    =    myStack . pop (  )  ;", "myCurrentSection    =    myCurrentOutlinee . getChildren (  )  . getLast (  )  ;", "for    (  . Section   section    :    exitedSectioningContent . getChildren (  )  )     {", "myCurrentSection . addChildSection ( section )  ;", "}", "} else", "if    (  (  !  ( myStack . isEmpty (  )  )  )     &  &     (  . isSectioningRootElement ( tag )  )  )     {", "final    . SectionHolder   exitedSectioningRoot    =    myCurrentOutlinee ;", "assert    ( exitedSectioningRoot . getTag (  )  )     =  =    tag ;", "myRootSectionHolders . add ( exitedSectioningRoot )  ;", "myCurrentOutlinee    =    myStack . pop (  )  ;", "myCurrentSection    =    myCurrentOutlinee . getChildren (  )  . getLast (  )  ;", "while    (  !  ( myCurrentSection . getChildren (  )  . isEmpty (  )  )  )     {", "myCurrentSection    =    myCurrentSection . getChildren (  )  . getLast (  )  ;", "}", "} else", "if    (  (  . isSectioningContentElement ( tag )  )     |  |     (  . isSectioningRootElement ( tag )  )  )     {", "assert   myStack . isEmpty (  )  ;", "assert    ( myCurrentOutlinee . getTag (  )  )     =  =    tag ;", "myRootSectionHolders . add ( myCurrentOutlinee )  ;", "myCurrentOutlinee    =    null ;", "myCurrentSection    =    null ;", "}", "}", "METHOD_END"], "methodName": ["tagExited"], "fileName": "com.intellij.lang.html.structureView.Html5SectionsProcessor"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   xmlFile    =    getElement (  )  ;", "if    ( xmlFile    =  =    null )", "return   false ;", "if    ( myInStructureViewPopup )     {", "final   String   propertyName    =    TreeStructureUtil . getPropertyName ( Html 5 SectionsNodeProvider . HTML 5  _ OUTLINE _ PROVIDER _ PROPERTY )  ;", "if    ( PropertiesComponent . getInstance (  )  . getBoolean ( propertyName )  )     {", "return   true ;", "}", "} else", "if    ( com . intellij . ideStructureViewFactoryEx . getInstanceEx ( xmlFile . getProject (  )  )  . isActionActive ( Html 5 SectionsNodeProvider . ACTION _ ID )  )     {", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isHtml5SectionsMode"], "fileName": "com.intellij.lang.html.structureView.HtmlFileTreeElement"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtil . isEmpty ( src )  )     {", "return   null ;", "} else    {", "return   StringUtil . shortenPathWithEllipsis ( src ,     . MAX _ TEXT _ LENGTH ,    true )  ;", "}", "}", "METHOD_END"], "methodName": ["getPathDescription"], "fileName": "com.intellij.lang.html.structureView.HtmlTagTreeElement"}, {"methodBody": ["METHOD_START", "{", "if    ( text . isEmpty (  )  )     {", "ren   null ;", "}", "final   StringBuilder   buf    =    new   StringBuilder ( text . length (  )  )  ;", "for    ( int   i    =     0  ,    length    =    text . length (  )  ;    i    <    length ;    i +  +  )     {", "char   c    =    text . charAt ( i )  ;", "if    (  ( c    <  =     '     '  )     |  |     ( Character . isSpaceChar ( c )  )  )     {", "if    (  (  ( buf . length (  )  )     =  =     0  )     |  |     (  ( buf . charAt (  (  ( buf . length (  )  )     -     1  )  )  )     !  =     '     '  )  )     {", "buf . append (  '     '  )  ;", "}", "} else    {", "buf . append ( c )  ;", "}", "}", "ren   buf ;", "}", "METHOD_END"], "methodName": ["normalizeSpaces"], "fileName": "com.intellij.lang.html.structureView.HtmlTagTreeElement"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    HtmlTagTreeElement . normalizeSpaces ( text )  ;", "return   builder    =  =    null    ?    null    :    HtmlTagTreeElement . shortenTextIfLong ( builder )  ;", "}", "METHOD_END"], "methodName": ["normalizeSpacesAndShortenIfLong"], "fileName": "com.intellij.lang.html.structureView.HtmlTagTreeElement"}, {"methodBody": ["METHOD_START", "{", "if    (  ( text . length (  )  )     <  =     ( HtmlTagTreeElement . MAX _ TEXT _ LENGTH )  )     {", "return   text . toString (  )  ;", "}", "int   index ;", "for    ( index    =    HtmlTagTreeElement . MAX _ TEXT _ LENGTH ;    index    >     (  ( HtmlTagTreeElement . MAX _ TEXT _ LENGTH )     -     2  0  )  ;    index -  -  )     {", "if    (  !  ( Character . isLetter ( text . charAt ( index )  )  )  )     {", "break ;", "}", "}", "text . setLength (  ( Character . isLetter ( index )     ?    HtmlTagTreeElement . MAX _ TEXT _ LENGTH    :    index )  )  ;", "return   text . append (  \"  \\ u 2  0  2  6  \"  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["shortenTextIfLong"], "fileName": "com.intellij.lang.html.structureView.HtmlTagTreeElement"}, {"methodBody": ["METHOD_START", "{", "if    (  ( message    !  =    null )     &  &     (  !  ( message . isEmpty (  )  )  )  )     {", "if    ( context   instanceof   XmlTag )     {", ". addMessagesForTag (  (  ( XmlTag )     ( context )  )  ,    message ,    type ,    myHolder ,    fixes )  ;", "} else    {", "if    ( type    =  =     ( ErrorType . ERROR )  )     {", ". appendFixes ( myHolder . createErrorAnnotation ( context ,    message )  ,    fixes )  ;", "} else    {", ". appendFixes ( myHolder . createWarningAnnotation ( context ,    message )  ,    fixes )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["addMessageWithFixes"], "fileName": "com.intellij.lang.xml.XMLExternalAnnotator"}, {"methodBody": ["METHOD_START", "{", "XmlToken   childByRole    =    XmlTagUtil . getStartTagNameElement ( tag )  ;", ". addMessagesForTreeChild ( childByRole ,    type ,    message ,    myHolder ,    actions )  ;", "childByRole    =    XmlTagUtil . getEndTagNameElement ( tag )  ;", ". addMessagesForTreeChild ( childByRole ,    type ,    message ,    myHolder ,    actions )  ;", "}", "METHOD_END"], "methodName": ["addMessagesForTag"], "fileName": "com.intellij.lang.xml.XMLExternalAnnotator"}, {"methodBody": ["METHOD_START", "{", "if    ( childByRole    !  =    null )     {", "Annotation   annotation ;", "if    ( type    =  =     ( ErrorType . ERROR )  )     {", "annotation    =    myHolder . createErrorAnnotation ( childByRole ,    message )  ;", "} else    {", "annotation    =    myHolder . createWarningAnnotation ( childByRole ,    message )  ;", "}", ". appendFixes ( annotation ,    actions )  ;", "}", "}", "METHOD_END"], "methodName": ["addMessagesForTreeChild"], "fileName": "com.intellij.lang.xml.XMLExternalAnnotator"}, {"methodBody": ["METHOD_START", "{", "if    ( actions    !  =    null )     {", "for    ( IntentionAction   action    :    actions )", "aion . registerFix ( action )  ;", "}", "}", "METHOD_END"], "methodName": ["appendFixes"], "fileName": "com.intellij.lang.xml.XMLExternalAnnotator"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( left . getElementType (  )  )     =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ TOKEN )  )     |  |     (  ( right . getElementType (  )  )     =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ TOKEN )  )  )     {", "return   SpaceRequirements . MUST _ NOT ;", "}", "if    (  (  ( left . getElementType (  )  )     =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ END _ DELIMITER )  )     &  &     (  ( right . getElementType (  )  )     =  =     ( XmlTokenType . XML _ NAME )  )  )     {", "return   SpaceRequirements . MUST ;", "}", "if    (  (  ( left . getElementType (  )  )     =  =     ( XmlTokenType . XML _ NAME )  )     &  &     (  ( right . getElementType (  )  )     =  =     ( XmlTokenType . XML _ NAME )  )  )     {", "return   SpaceRequirements . MUST ;", "}", "if    (  (  ( left . getElementType (  )  )     =  =     ( XmlTokenType . XML _ TAG _ NAME )  )     &  &     (  ( right . getElementType (  )  )     =  =     ( XmlTokenType . XML _ NAME )  )  )     {", "return   SpaceRequirements . MUST ;", "}", "return   SpaceRequirements . MAY ;", "}", "METHOD_END"], "methodName": ["canStickTokensTogetherByLexerInXml"], "fileName": "com.intellij.lang.xml.XMLParserDefinition"}, {"methodBody": ["METHOD_START", "{", "final   int   firstCrInGeneratedWs    =    whiteSpace . indexOf (  '  \\ n '  )  ;", "final   int   secondCrInGeneratedWs    =     ( firstCrInGeneratedWs    !  =     (  -  1  )  )     ?    whiteSpace . indexOf (  '  \\ n '  ,     ( firstCrInGeneratedWs    +     1  )  )     :     -  1  ;", "final   int   firstCrInPreviousWs    =    s . indexOf (  '  \\ n '  )  ;", "final   int   secondCrInPreviousWs    =     ( firstCrInPreviousWs    !  =     (  -  1  )  )     ?    s . indexOf (  '  \\ n '  ,     ( firstCrInPreviousWs    +     1  )  )     :     -  1  ;", "boolean   knowHowToModifyCData    =    false ;", "if    (  (  (  ( secondCrInPreviousWs    !  =     (  -  1  )  )     &  &     ( secondCrInGeneratedWs    !  =     (  -  1  )  )  )     &  &     ( cdataPos    >    firstCrInPreviousWs )  )     &  &     ( cdataPos    <    secondCrInPreviousWs )  )     {", "whiteSpace    =     (  ( whiteSpace . substring (  0  ,    secondCrInGeneratedWs )  )     +     ( s . substring (  ( firstCrInPreviousWs    +     1  )  ,    secondCrInPreviousWs )  )  )     +     ( whiteSpace . substring ( secondCrInGeneratedWs )  )  ;", "knowHowToModifyCData    =    true ;", "}", "if    (  ! knowHowToModifyCData )", "whiteSpace    =    null ;", "return   whiteSpace ;", "}", "METHOD_END"], "methodName": ["mergeWsWithCdataMarker"], "fileName": "com.intellij.lang.xml.XmlFormattingModel"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlBlock ( root ,    null ,    null ,    new   XmlPolicy ( settings ,    documentModel )  ,    null ,    null ,    false )  ;", "}", "METHOD_END"], "methodName": ["createBlock"], "fileName": "com.intellij.lang.xml.XmlFormattingModelBuilder"}, {"methodBody": ["METHOD_START", "{", "for    ( Language   language    :    XMLLanguage . INSTANCE . getLanguageExtensionsForFile ( psiFile )  )     {", "PsiStructureViewFactory   factory    =    INSTANCE . forLanguage ( language )  ;", "if    ( factory    =  =    null )", "continue ;", "final      builder    =    factory . get ( psiFile )  ;", "if    ( builder    !  =    null )     {", "return   builder ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getStructureViewBuilderForExtensions"], "fileName": "com.intellij.lang.xml.XmlStructureViewBuilderFactory"}, {"methodBody": ["METHOD_START", "{", "return    (  ( XmlStructureViewBuilderProvider [  ]  )     ( Extensions . getExtensions ( XmlStructureViewBuilderProvider . EXTENSION _ POINT _ NAME )  )  )  ;", "}", "METHOD_END"], "methodName": ["getStructureViewBuilderProviders"], "fileName": "com.intellij.lang.xml.XmlStructureViewBuilderFactory"}, {"methodBody": ["METHOD_START", "{", "final   TemplateContext   context    =    template . getTemplateContext (  )  ;", "return    ( context . isEnabled ( new   XmlContextType (  )  )  )     |  |     ( context . isEnabled ( new   HtmlContextType (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isEnabled"], "fileName": "com.intellij.lang.xml.XmlSurroundDescriptor"}, {"methodBody": ["METHOD_START", "{", "final   CharTable   charTable    =    SharedImplUtil . findCharTableByTree ( treePrev )  ;", "final   ASTNode   treeParent    =    treePrev . getTreeParent (  )  ;", "final   boolean   before ;", "final   XmlText   xmlText ;", "if    (  ( treePrev . getElementType (  )  )     =  =     ( XmlElementType . XML _ TEXT )  )     {", "xmlText    =     (  ( XmlText )     ( treePrev . getPsi (  )  )  )  ;", "before    =    true ;", "} else", "if    (  ( treePrev . getTreePrev (  )  . getElementType (  )  )     =  =     ( XmlElementType . XML _ TEXT )  )     {", "xmlText    =     (  ( XmlText )     ( treePrev . getTreePrev (  )  . getPsi (  )  )  )  ;", "before    =    false ;", "} else    {", "xmlText    =     (  ( XmlText )     ( com . intellij . psi . impl . source . tree . Factory . createCompositeElement ( XmlElementType . XML _ TEXT ,    charTable ,    treeParent . getPsi (  )  . getManager (  )  )  )  )  ;", "com . intellij . psi . impl . source . codeStyle . CodeEditUtil . setNodeGenerated ( xmlText . getNode (  )  ,    true )  ;", "treeParent . addChild ( xmlText . getNode (  )  ,    treePrev )  ;", "before    =    true ;", "}", "final   ASTNode   node    =    xmlText . getNode (  )  ;", "assert   node    !  =    null ;", "final   TreeElement   anchorInText    =     (  ( TreeElement )     (  ( before )     ?    node . getFirstChildNode (  )     :    node . getLastChildNode (  )  )  )  ;", "if    ( anchorInText    =  =    null )", "node . addChild ( whiteSpaceElement )  ;", "else", "if    (  ( anchorInText . getElementType (  )  )     !  =     ( com . intellij . psi . xml . XmlTokenType . XML _ WHITE _ SPACE )  )", "node . addChild ( whiteSpaceElement ,     ( before    ?    anchorInText    :    null )  )  ;", "else    {", "final   String   text    =     ( before )     ?     ( whiteSpaceElement . getText (  )  )     +     ( anchorInText . getText (  )  )     :     ( anchorInText . getText (  )  )     +     ( whiteSpaceElement . getText (  )  )  ;", "node . replaceChild ( anchorInText ,    ASTFactory . whitespace ( text )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addWhitespaceToTagBody"], "fileName": "com.intellij.lang.xml.XmlWhiteSpaceFormattingStrategy"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   treeParent    =    place . getTreeParent (  )  ;", "if    (  (  ( treeParent . getElementType (  )  )     !  =     ( XmlElementType . XML _ TAG )  )     &  &     (  ( treeParent . getElementType (  )  )     !  =     ( XmlElementType . HTML _ TAG )  )  )", "return   false ;", "while    ( place    !  =    null )     {", "if    (  ( place . getElementType (  )  )     =  =     ( XmlTokenType . XML _ TAG _ END )  )", "return   true ;", "place    =    place . getTreePrev (  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isInsideTagBody"], "fileName": "com.intellij.lang.xml.XmlWhiteSpaceFormattingStrategy"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( hasSeenScript (  )  )     &  &     ( BaseHtmlLexer . XmlNameHandler . TOKEN _ SCRIPT . equals ( name )  )  )     |  |     (  ( hasSeenStyle (  )  )     &  &     ( BaseHtmlLexer . XmlNameHandler . TOKEN _ STYLE . equals ( name )  )  )  )     |  |     ( DUMMY _ IDENTIFIER _ TRIMMED . equalsIgnoreCase ( name )  )  ;", "}", "METHOD_END"], "methodName": ["endOfTheEmbeddment"], "fileName": "com.intellij.lexer.BaseHtmlLexer"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtil . isEmpty ( mimeType )  )     {", "return    (  . ourDefaultLanguage )     !  =    null    ?    LanguageHtmlScriptContentProvider . getScriptContentProvider (  . ourDefaultLanguage )     :    null ;", "}", "Collection < Language >    instancesByMimeType    =    Language . findInstancesByMimeType ( mimeType . trim (  )  )  ;", "if    (  ( instancesByMimeType . isEmpty (  )  )     &  &     ( mimeType . contains (  \" template \"  )  )  )     {", "instancesByMimeType    =    Collections . singletonList ( HTMLLanguage . INSTANCE )  ;", "}", "for    ( Language   language    :    instancesByMimeType )     {", "HtmlScriptContentProvider   scriptContentProvider    =    LanguageHtmlScriptContentProvider . getScriptContentProvider ( language )  ;", "if    ( scriptContentProvider    !  =    null )     {", "return   scriptContentProvider ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findScriptContentProvider"], "fileName": "com.intellij.lexer.BaseHtmlLexer"}, {"methodBody": ["METHOD_START", "{", "HtmlScriptContentProvider   scriptContentProvider    =    findScriptContentProvider ( scriptType )  ;", "return   scriptContentProvider    =  =    null    ?    null    :    scriptContentProvider . getScriptElementType (  )  ;", "}", "METHOD_END"], "methodName": ["getCurrentScriptElementType"], "fileName": "com.intellij.lexer.BaseHtmlLexer"}, {"methodBody": ["METHOD_START", "{", "Language   language    =    getStyleLanguage (  )  ;", "if    ( language    !  =    null )     {", "for    ( EmbeddedTokenTypesProvidprovid :    EmbeddedTokenTypesProvidEXTENSION _ POINT _ NAME . getExtensions (  )  )     {", "IElementType   elementType    =    providgetElementType (  )  ;", "if    ( language . is ( elementType . getLanguage (  )  )  )     {", "return   elementType ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getCurrentStylesheetElementType"], "fileName": "com.intellij.lexer.BaseHtmlLexer"}, {"methodBody": ["METHOD_START", "{", "Collection < Language >    instancesByMimeType    =    Language . findInstancesByMimeType (  (  ( scriptType )     !  =    null    ?    scriptType . trim (  )     :    null )  )  ;", "return   instancesByMimeType . isEmpty (  )     ?    null    :    instancesByMimeType . iterator (  )  . next (  )  ;", "}", "METHOD_END"], "methodName": ["getScriptLanguage"], "fileName": "com.intellij.lexer.BaseHtmlLexer"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( BaseHtmlLexer . ourDefaultStyleLanguage )     !  =    null )     &  &     (  ( styleType )     !  =    null )  )     &  &     (  !  (  \" text / css \"  . equals ( styleType )  )  )  )     {", "for    ( Language   language    :    BaseHtmlLexer . ourDefaultStyleLanguage . getDialects (  )  )     {", "for    ( String   mimeType    :    language . getMimeTypes (  )  )     {", "if    ( styleType . equals ( mimeType )  )     {", "return   language ;", "}", "}", "}", "}", "return   BaseHtmlLexer . ourDefaultStyleLanguage ;", "}", "METHOD_END"], "methodName": ["getStyleLanguage"], "fileName": "com.intellij.lexer.BaseHtmlLexer"}, {"methodBody": ["METHOD_START", "{", "return   seenAttribute ;", "}", "METHOD_END"], "methodName": ["hasSeenAttribute"], "fileName": "com.intellij.lexer.BaseHtmlLexer"}, {"methodBody": ["METHOD_START", "{", "return   seenScript ;", "}", "METHOD_END"], "methodName": ["hasSeenScript"], "fileName": "com.intellij.lexer.BaseHtmlLexer"}, {"methodBody": ["METHOD_START", "{", "return   seenStyle ;", "}", "METHOD_END"], "methodName": ["hasSeenStyle"], "fileName": "com.intellij.lexer.BaseHtmlLexer"}, {"methodBody": ["METHOD_START", "{", "return   seenTag ;", "}", "METHOD_END"], "methodName": ["hasSeenTag"], "fileName": "com.intellij.lexer.BaseHtmlLexer"}, {"methodBody": ["METHOD_START", "{", "seenScript    =     ( initialState    &     ( BaseHtmlLexer . SEEN _ SCRIPT )  )     !  =     0  ;", "seenStyle    =     ( initialState    &     ( BaseHtmlLexer . SEEN _ STYLE )  )     !  =     0  ;", "seenTag    =     ( initialState    &     ( BaseHtmlLexer . SEEN _ TAG )  )     !  =     0  ;", "seenAttribute    =     ( initialState    &     ( BaseHtmlLexer . SEEN _ ATTRIBUTE )  )     !  =     0  ;", "seenContentType    =     ( initialState    &     ( BaseHtmlLexer . SEEN _ CONTENT _ TYPE )  )     !  =     0  ;", "seenStylesheetType    =     ( initialState    &     ( BaseHtmlLexer . SEEN _ STYLESHEET _ TYPE )  )     !  =     0  ;", "lexerOfCacheBufferSequence    =    null ;", "cachedBufferSequence    =    null ;", "}", "METHOD_END"], "methodName": ["initState"], "fileName": "com.intellij.lexer.BaseHtmlLexer"}, {"methodBody": ["METHOD_START", "{", "return    (  ( tokenType    =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ TOKEN )  )     |  |     ( tokenType    =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )  )     |  |     ( tokenType    =  =     ( XmlTokenType . XML _ CHAR _ ENTITY _ REF )  )  ;", "}", "METHOD_END"], "methodName": ["isValidAttributeValueTokenType"], "fileName": "com.intellij.lexer.BaseHtmlLexer"}, {"methodBody": ["METHOD_START", "{", "final   BaseHtmlLexer . TokenHandler   tokenHandler    =    tokenHandlers . get ( elementType )  ;", "if    ( tokenHandler    !  =    null )     {", "final   BaseHtmlLexer . TokenHandler   newHandler    =    value ;", "value    =    new   BaseHtmlLexer . TokenHandler (  )     {", "@ Override", "public   void   handleElement ( final   Lexer   lexer )     {", "tokenHandler . handleElement ( lexer )  ;", "newHandler . handleElement ( lexer )  ;", "}", "}  ;", "}", "tokenHandlers . put ( elementType ,    value )  ;", "}", "METHOD_END"], "methodName": ["registerHandler"], "fileName": "com.intellij.lexer.BaseHtmlLexer"}, {"methodBody": ["METHOD_START", "{", "Lexer   base    =    getDelegate (  )  ;", "int   tokenEnd    =    base . getTokenEnd (  )  ;", "int   lastState    =     0  ;", "int   lastStart    =     0  ;", "final   CharSequence   buf    =    base . getBufferSequence (  )  ;", "final   char [  ]    bufArray    =    CharArrayUtil . fromSequenceWithoutCopying ( buf )  ;", "if    ( seenTag )     {", "FoundEnd    :    while    ( true )     {", "FoundEndOfTag    :    while    (  ( base . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ END _ TAG _ START )  )     {", "if    (  ( base . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ COMMENT _ CHARACTERS )  )     {", "final   int   end    =    base . getTokenEnd (  )  ;", "for    ( int   i    =    base . getTokenStart (  )  ;    i    <    end ;     +  + i )     {", "if    (  (  (  ( bufArray    !  =    null    ?    bufArray [ i ]     :    buf . charAt ( i )  )     =  =     '  <  '  )     &  &     (  ( i    +     1  )     <    end )  )     &  &     (  ( bufArray    !  =    null    ?    bufArray [  ( i    +     1  )  ]     :    buf . charAt (  ( i    +     1  )  )  )     =  =     '  /  '  )  )     {", "tokenEnd    =    i ;", "lastStart    =    i    -     1  ;", "lastState    =     0  ;", "break   FoundEndOfTag ;", "}", "}", "}", "lastState    =    base . getState (  )  ;", "tokenEnd    =    base . getTokenEnd (  )  ;", "lastStart    =    base . getTokenStart (  )  ;", "if    ( tokenEnd    =  =     ( getBufferEnd (  )  )  )", "break   FoundEnd ;", "base . advance (  )  ;", "}", "if    (  ( base . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ END _ TAG _ START )  )     {", "base . start ( buf ,     ( lastStart    +     1  )  ,    getBufferEnd (  )  ,    lastState )  ;", "base . getTokenType (  )  ;", "base . advance (  )  ;", "} else    {", "base . advance (  )  ;", "}", "while    ( XmlTokenType . WHITESPACES . contains ( base . getTokenType (  )  )  )     {", "base . advance (  )  ;", "}", "if    (  ( base . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ NAME )  )     {", "String   name    =    TreeUtil . getTokenText ( base )  ;", "if    ( caseInsensitive )", "name    =    name . toLowerCase ( US )  ;", "if    ( endOfTheEmbeddment ( name )  )     {", "break ;", "}", "}", "}", "base . start ( buf ,    lastStart ,    getBufferEnd (  )  ,    lastState )  ;", "base . getTokenType (  )  ;", "} else", "if    ( seenAttribute )     {", "while    ( true )     {", "if    (  !  ( isValidAttributeValueTokenType ( base . getTokenType (  )  )  )  )", "break ;", "tokenEnd    =    base . getTokenEnd (  )  ;", "lastState    =    base . getState (  )  ;", "lastStart    =    base . getTokenStart (  )  ;", "if    ( tokenEnd    =  =     ( getBufferEnd (  )  )  )", "break ;", "base . advance (  )  ;", "}", "base . start ( buf ,    lastStart ,    getBufferEnd (  )  ,    lastState )  ;", "base . getTokenType (  )  ;", "}", "return   tokenEnd ;", "}", "METHOD_END"], "methodName": ["skipToTheEndOfTheEmbeddment"], "fileName": "com.intellij.lexer.BaseHtmlLexer"}, {"methodBody": ["METHOD_START", "{", "return   newLexer ;", "}", "METHOD_END"], "methodName": ["createELLexer"], "fileName": "com.intellij.lexer.HtmlHighlightingLexer"}, {"methodBody": ["METHOD_START", "{", "if    ( hasNoLayers )", "LayeredLexer . ourDisableLayersFlag . set ( Boolean . TRUE )  ;", "try    {", "Lexer   newLexer    =    null ;", "if    ( hasSeenStyle (  )  )     {", "Lexer   styleLexer    =    styleLexers . get ( styleType )  ;", "if    ( styleLexer    =  =    null )     {", "if    ( hasSeenTag (  )  )     {", "IElementType   currentStylesheetElementType    =    getCurrentStylesheetElementType (  )  ;", "if    ( currentStylesheetElementType    !  =    null )     {", "Language   language    =    currentStylesheetElementType . getLanguage (  )  ;", "styleLexer    =    SyntaxHighlighterFactory . getSyntaxHighlighter ( language ,    null ,    null )  . getHighlightingLexer (  )  ;", "} else", "if    (  ( ourStyleFileType )     !  =    null )     {", "com . intellij . openapi . fileTypes . SyntaxHighlighter   highlighter    =    SyntaxHighlighterFactory . getSyntaxHighlighter ( ourStyleFileType ,    null ,    null )  ;", ". LOG . assertTrue (  ( highlighter    !  =    null )  ,    ourStyleFileType )  ;", "styleLexer    =    highlighter . getHighlightingLexer (  )  ;", "} else    {", "styleLexer    =    null ;", "}", "styleLexers . put ( styleType ,    styleLexer )  ;", "} else", "if    ( hasSeenAttribute (  )  )     {", "if    (  ( ourStyleFileType )     =  =    null )     {", "styleLexer    =    null ;", "} else    {", "com . intellij . openapi . fileTypes . SyntaxHighlighter   highlighter    =    SyntaxHighlighterFactory . getSyntaxHighlighter ( ourStyleFileType ,    null ,    null )  ;", ". LOG . assertTrue (  ( highlighter    !  =    null )  ,    ourStyleFileType )  ;", "styleLexer    =    highlighter . getHighlightingLexer (  )  ;", "}", "}", "}", "newLexer    =    styleLexer ;", "} else", "if    ( hasSeenScript (  )  )     {", "Lexer   scriptLexer    =    scriptLexers . get ( scriptType )  ;", "if    ( scriptLexer    =  =    null )     {", "if    ( hasSeenTag (  )  )     {", "com . intellij . lang . HtmlScriptContentProvider   provider    =    findScriptContentProvider ( scriptType )  ;", "if    ( provider    !  =    null )     {", "scriptLexer    =    provider . getHighlightingLexer (  )  ;", "} else    {", "scriptLexer    =    SyntaxHighlighterFactory . getSyntaxHighlighter ( PlainTextLanguage . INSTANCE ,    null ,    null )  . getHighlightingLexer (  )  ;", "}", "} else", "if    ( hasSeenAttribute (  )  )     {", "com . intellij . openapi . fileTypes . SyntaxHighlighter   syntaxHighlighter    =     (  (  . ourInlineScriptFileType )     !  =    null )     ?    SyntaxHighlighterFactory . getSyntaxHighlighter (  . ourInlineScriptFileType ,    null ,    null )     :    null ;", "scriptLexer    =     ( syntaxHighlighter    !  =    null )     ?    syntaxHighlighter . getHighlightingLexer (  )     :    null ;", "}", "scriptLexers . put ( scriptType ,    scriptLexer )  ;", "}", "newLexer    =    scriptLexer ;", "} else    {", "newLexer    =    createELLexer ( newLexer )  ;", "}", "if    ( newLexer    !  =    null )     {", "embeddedLexer    =    newLexer ;", "}", "}    finally    {", "if    ( hasNoLayers )", "LayeredLexer . ourDisableLayersFlag . set ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["setEmbeddedLexer"], "fileName": "com.intellij.lexer.HtmlHighlightingLexer"}, {"methodBody": ["METHOD_START", "{", "this . hasNoEmbeddments    =    hasNoEmbeddments ;", "}", "METHOD_END"], "methodName": ["setHasNoEmbeddments"], "fileName": "com.intellij.lexer.HtmlHighlightingLexer"}, {"methodBody": ["METHOD_START", "{", "myTokenType    =    null ;", "supadvance (  )  ;", "}", "METHOD_END"], "methodName": ["advance"], "fileName": "com.intellij.lexer.HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myTokenType )     !  =    null )     {", "return   myTokenEnd ;", "}", "return   supgetTokenEnd (  )  ;", "}", "METHOD_END"], "methodName": ["getTokenEnd"], "fileName": "com.intellij.lexer.HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myTokenType )     !  =    null )     {", "return   myTokenStart ;", "}", "return   supgetTokenStart (  )  ;", "}", "METHOD_END"], "methodName": ["getTokenStart"], "fileName": "com.intellij.lexer.HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myTokenType )     !  =    null )", "return   myTokenType ;", "IElementType   tokenType    =    super . getTokenType (  )  ;", "myTokenStart    =    super . getTokenStart (  )  ;", "myTokenEnd    =    super . getTokenEnd (  )  ;", "if    ( hasSeenStyle (  )  )     {", "if    (  ( hasSeenTag (  )  )     &  &     (  . isStartOfEmbeddmentTagContent ( tokenType )  )  )     {", "Language   stylesheetLanguage    =    getStyleLanguage (  )  ;", "if    (  ( stylesheetLanguage    =  =    null )     |  |     ( LanguageUtil . isInjectableLanguage ( stylesheetLanguage )  )  )     {", "myTokenEnd    =    skipToTheEndOfTheEmbeddment (  )  ;", "IElementType   currentStylesheetElementType    =    getCurrentStylesheetElementType (  )  ;", "tokenType    =     ( currentStylesheetElementType    =  =    null )     ?    XmlTokenType . XML _ DATA _ CHARACTERS    :    currentStylesheetElementType ;", "}", "} else", "if    (  (  (  (  . ourInlineStyleElementType )     !  =    null )     &  &     (  . isStartOfEmbeddmentAttributeValue ( tokenType )  )  )     &  &     ( hasSeenAttribute (  )  )  )     {", "tokenType    =     . ourInlineStyleElementType ;", "}", "} else", "if    ( hasSeenScript (  )  )     {", "if    (  ( hasSeenTag (  )  )     &  &     (  . isStartOfEmbeddmentTagContent ( tokenType )  )  )     {", "Language   scriptLanguage    =    getScriptLanguage (  )  ;", "if    (  ( scriptLanguage    =  =    null )     |  |     ( LanguageUtil . isInjectableLanguage ( scriptLanguage )  )  )     {", "myTokenEnd    =    skipToTheEndOfTheEmbeddment (  )  ;", "IElementType   currentScriptElementType    =    getCurrentScriptElementType (  )  ;", "tokenType    =     ( currentScriptElementType    =  =    null )     ?    XmlTokenType . XML _ DATA _ CHARACTERS    :    currentScriptElementType ;", "}", "} else", "if    (  (  ( hasSeenAttribute (  )  )     &  &     (  . isStartOfEmbeddmentAttributeValue ( tokenType )  )  )     &  &     (  (  . ourInlineScriptElementType )     !  =    null )  )     {", "myTokenEnd    =    skipToTheEndOfTheEmbeddment (  )  ;", "tokenType    =     . ourInlineScriptElementType ;", "}", "}", "return   myTokenType    =    tokenType ;", "}", "METHOD_END"], "methodName": ["getTokenType"], "fileName": "com.intellij.lexer.HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "return    ( state    =  =     (  _ HtmlLexer . START _ TAG _ NAME )  )     |  |     ( state    =  =     (  _ HtmlLexer . END _ TAG _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["isHtmlTagState"], "fileName": "com.intellij.lexer.HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "return   tokenType    =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ TOKEN )  ;", "}", "METHOD_END"], "methodName": ["isStartOfEmbeddmentAttributeValue"], "fileName": "com.intellij.lexer.HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( tokenType    =  =     ( XmlTokenType . XML _ DATA _ CHARACTERS )  )     |  |     ( tokenType    =  =     ( XmlTokenType . XML _ CDATA _ START )  )  )     |  |     ( tokenType    =  =     ( XmlTokenType . XML _ COMMENT _ START )  )  )     |  |     ( tokenType    =  =     ( XmlTokenType . XML _ REAL _ WHITE _ SPACE )  )  )     |  |     ( tokenType    =  =     ( TokenType . WHITE _ SPACE )  )  ;", "}", "METHOD_END"], "methodName": ["isStartOfEmbeddmentTagContent"], "fileName": "com.intellij.lexer.HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "int   state    =     ( getState (  )  )     &     3  1  ;", "if    ( tokenType    =  =     ( XmlTokenType . XML _ NAME )  )     {", "if    (  ( state    =  =     (  _  _ XmlLTAG )  )     |  |     ( state    =  =     (  _  _ XmlLEND _ TAG )  )  )     {", "tokenType    =    XmlTokenType . XML _ TAG _ NAME ;", "}", "} else", "if    ( tokenType    =  =     ( XmlTokenType . XML _ WHITE _ SPACE )  )     {", "switch    ( state )     {", "case    _  _ XmlLATTR _ LIST    :", "case    _  _ XmlLATTR    :", "tokenType    =    XmlTokenType . TAG _ WHITE _ SPACE ;", "break ;", "default    :", "tokenType    =    XmlTokenType . XML _ REAL _ WHITE _ SPACE ;", "break ;", "}", "} else", "if    (  ( tokenType    =  =     ( XmlTokenType . XML _ CHAR _ ENTITY _ REF )  )     |  |     ( tokenType    =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )  )     {", "if    ( state    =  =     (  _  _ XmlLCOMMENT )  )", "return   XmlTokenType . XML _ COMMENT _ CHARACTERS ;", "}", "return   tokenType ;", "}", "METHOD_END"], "methodName": ["fixWrongTokenTypes"], "fileName": "com.intellij.lexer.XmlHighlightingLexer"}, {"methodBody": ["METHOD_START", "{", "return    _ DtdLexer . ZZ _ CMAP _ A [  (  (  (  _ DtdLexer . ZZ _ CMAP _ Y [  (  (  (  _ DtdLexer . ZZ _ CMAP _ Z [  ( ch    >  >     1  0  )  ]  )     <  <     6  )     |     (  ( ch    >  >     4  )     &     6  3  )  )  ]  )     <  <     4  )     |     ( ch    &     1  5  )  )  ]  ;", "}", "METHOD_END"], "methodName": ["ZZ_CMAP"], "fileName": "com.intellij.lexer._DtdLexer"}, {"methodBody": ["METHOD_START", "{", "int   zzInput ;", "int   zzAction ;", "int   zzCurrentPosL ;", "int   zzMarkedPosL ;", "int   zzEndReadL    =    zzEndRead ;", "CharSequence   zzBufferL    =    zzBuffer ;", "int [  ]    zzTransL    =     . ZZ _ TRANS ;", "int [  ]    zzRowMapL    =     . ZZ _ ROWMAP ;", "int [  ]    zzAttrL    =     . ZZ _ ATTRIBUTE ;", "while    ( true )     {", "zzMarkedPosL    =    zzMarkedPos ;", "zzAction    =     -  1  ;", "zzCurrentPosL    =    zzCurrentPos    =    zzStartRead    =    zzMarkedPosL ;", "zzState    =     . ZZ _ LEXSTATE [ zzLexicalState ]  ;", "int   zzAttributes    =    zzAttrL [ zzState ]  ;", "if    (  ( zzAttributes    &     1  )     =  =     1  )     {", "zzAction    =    zzState ;", "}", "zzForAction    :     {", "while    ( true )     {", "if    ( zzCurrentPosL    <    zzEndReadL )     {", "zzInput    =    Character . codePointAt ( zzBufferL ,    zzCurrentPosL )  ;", "zzCurrentPosL    +  =    Character . charCount ( zzInput )  ;", "} else", "if    ( zzAtEOF )     {", "zzInput    =     . YYEOF ;", "break   zzForAction ;", "} else    {", "zzCurrentPos    =    zzCurrentPosL ;", "zzMarkedPos    =    zzMarkedPosL ;", "boolean   eof    =    zzRefill (  )  ;", "zzCurrentPosL    =    zzCurrentPos ;", "zzMarkedPosL    =    zzMarkedPos ;", "zzBufferL    =    zzBuffer ;", "zzEndReadL    =    zzEndRead ;", "if    ( eof )     {", "zzInput    =     . YYEOF ;", "break   zzForAction ;", "} else    {", "zzInput    =    Character . codePointAt ( zzBufferL ,    zzCurrentPosL )  ;", "zzCurrentPosL    +  =    Character . charCount ( zzInput )  ;", "}", "}", "int   zzNext    =    zzTransL [  (  ( zzRowMapL [ zzState ]  )     +     (  . ZZ _ CMAP ( zzInput )  )  )  ]  ;", "if    ( zzNext    =  =     (  -  1  )  )", "break   zzForAction ;", "zzState    =    zzNext ;", "zzAttributes    =    zzAttrL [ zzState ]  ;", "if    (  ( zzAttributes    &     1  )     =  =     1  )     {", "zzAction    =    zzState ;", "zzMarkedPosL    =    zzCurrentPosL ;", "if    (  ( zzAttributes    &     8  )     =  =     8  )", "break   zzForAction ;", "}", "}", "}", "zzMarkedPos    =    zzMarkedPosL ;", "if    (  ( zzInput    =  =     (  . YYEOF )  )     &  &     (  ( zzStartRead )     =  =     ( zzCurrentPos )  )  )     {", "zzAtEOF    =    true ;", "return   null ;", "} else    {", "switch    ( zzAction    <     0     ?    zzAction    :     . ZZ _ ACTION [ zzAction ]  )     {", "case    1     :", "{", "return   XmlTokenType . XML _ ATTRIBUTE _ VALUE _ TOKEN ;", "}", "case    7  2     :", "break ;", "case    2     :", "{", "return   XmlTokenType . XML _ COMMENT _ CHARACTERS ;", "}", "case    7  3     :", "break ;", "case    3     :", "{", "return   XmlTokenType . XML _ DATA _ CHARACTERS ;", "}", "case    7  4     :", "break ;", "case    4     :", "{", "return   XmlTokenType . XML _ WHITE _ SPACE ;", "}", "case    7  5     :", "break ;", "case    5     :", "{", "yybegin (  . TAG _ NAME )  ;", "return   XmlTokenType . XML _ START _ TAG _ START ;", "}", "case    7  6     :", "break ;", "case    6     :", "{", "return   XmlTokenType . XML _ BAD _ CHARACTER ;", "}", "case    7  7     :", "break ;", "case    7     :", "{", "yybegin (  . DECL _ ATTR )  ;", "return   XmlTokenType . XML _ NAME ;", "}", "case    7  8     :", "break ;", "case    8     :", "{", "yybegin (  . YYINITIAL )  ;", "return   XmlTokenType . XML _ BAD _ CHARACTER ;", "}", "case    7  9     :", "break ;", "case    9     :", "{", "return   XmlTokenType . XML _ EQ ;", "}", "case    8  0     :", "break ;", "case    1  0     :", "{", "yybegin (  . DECL _ ATTR _ VALUE _ SQ )  ;", "return   XmlTokenType . XML _ ATTRIBUTE _ VALUE _ START _ DELIMITER ;", "}", "case    8  1     :", "break ;", "case    1  1     :", "{", "yybegin (  . DECL _ ATTR _ VALUE _ DQ )  ;", "return   XmlTokenType . XML _ ATTRIBUTE _ VALUE _ START _ DELIMITER ;", "}", "case    8  2     :", "break ;", "case    1  2     :", "{", "yybegin (  . DECL )  ;", "return   XmlTokenType . XML _ ATTRIBUTE _ VALUE _ END _ DELIMITER ;", "}", "case    8  3     :", "break ;", "case    1  3     :", "{", "yybegin (  . TAG _ ATTRIBUTES )  ;", "return   isHighlightModeOn    ?    XmlTokenType . XML _ TAG _ NAME    :    XmlTokenType . XML _ NAME ;", "}", "case    8  4     :", "break ;", "case    1  4     :", "{", "return   XmlTokenType . XML _ NAME ;", "}", "case    8  5     :", "break ;", "case    1  5     :", "{", "yybegin (  . YYINITIAL )  ;", "return   XmlTokenType . XML _ TAG _ END ;", "}", "case    8  6     :", "break ;", "case    1  6     :", "{", "yybegin (  . ATTRIBUTE _ VALUE _ START )  ;", "return   XmlTokenType . XML _ EQ ;", "}", "case    8  7     :", "break ;", "case    1  7     :", "{", "yybegin (  . ATTRIBUTE _ VALUE _ SQ )  ;", "return   XmlTokenType . XML _ ATTRIBUTE _ VALUE _ START _ DELIMITER ;", "}", "case    8  8     :", "break ;", "case    1  8     :", "{", "yybegin (  . ATTRIBUTE _ VALUE _ DQ )  ;", "return   XmlTokenType . XML _ ATTRIBUTE _ VALUE _ START _ DELIMITER ;", "}", "case    8  9     :", "break ;", "case    1  9     :", "{", "yybegin (  . TAG _ ATTRIBUTES )  ;", "return   XmlTokenType . XML _ ATTRIBUTE _ VALUE _ END _ DELIMITER ;", "}", "case    9  0     :", "break ;", "case    2  0     :", "{", "return   XmlTokenType . XML _ PI _ TARGET ;", "}", "case    9  1     :", "break ;", "case    2  1     :", "{", "yybegin (  . DOCTYPE _ MARKUP )  ;", "return   XmlTokenType . XML _ MARKUP _ START ;", "}", "case    9  2     :", "break ;", "case    2  2     :", "{", "yybegin (  . YYINITIAL )  ;", "return   XmlTokenType . XML _ DOCTYPE _ END ;", "}", "case    9  3     :", "break ;", "case    2  3     :", "{", "yybegin (  . DOCTYPE )  ;", "return   XmlTokenType . XML _ MARKUP _ END ;", "}", "case    9  4     :", "break ;", "case    2  4     :", "{", "return   XmlTokenType . XML _ TAG _ END ;", "}", "case    9  5     :", "break ;", "case    2  5     :", "{", "return   XmlTokenType . XML _ AMP ;", "}", "case    9  6     :", "break ;", "case    2  6     :", "{", "return   XmlTokenType . XML _ SEMI ;", "}", "case    9  7     :", "break ;", "case    2  7     :", "{", "return   XmlTokenType . XML _ PERCENT ;", "}", "case    9  8     :", "break ;", "case    2  8     :", "{", "return   XmlTokenType . XML _ QUESTION ;", "}", "case    9  9     :", "break ;", "case    2  9     :", "{", "yybegin (  . DOCTYPE _ MARKUP _ SQ )  ;", "return   XmlTokenType . XML _ ATTRIBUTE _ VALUE _ START _ DELIMITER ;", "}", "case    1  0  0     :", "break ;", "case    3  0     :", "{", "yybegin (  . DOCTYPE _ MARKUP _ DQ )  ;", "return   XmlTokenType . XML _ ATTRIBUTE _ VALUE _ START _ DELIMITER ;", "}", "case    1  0  1     :", "break ;", "case    3  1     :", "{", "return   XmlTokenType . XML _ LEFT _ PAREN ;", "}", "case    1  0  2     :", "break ;", "case    3  2     :", "{", "return   XmlTokenType . XML _ RIGHT _ PAREN ;", "}", "case    1  0  3     :", "break ;", "case    3  3     :", "{", "return   XmlTokenType . XML _ PLUS ;", "}", "case    1  0  4     :", "break ;", "case    3  4     :", "{", "return   XmlTokenType . XML _ STAR ;", "}", "case    1  0  5     :", "break ;", "case    3  5     :", "{", "return   XmlTokenType . XML _ BAR ;", "}", "case    1  0  6     :", "break ;", "case    3  6     :", "{", "return   XmlTokenType . XML _ COMMA ;", "}", "case    1  0  7     :", "break ;", "case    3  7     :", "{", "yybegin (  . DOCTYPE _ MARKUP )  ;", "return   XmlTokenType . XML _ ATTRIBUTE _ VALUE _ END _ DELIMITER ;", "}", "case    1  0  8     :", "break ;", "case    3  8     :", "{", "yybegin (  . PROCESSING _ INSTRUCTION )  ;", "return   XmlTokenType . XML _ PI _ START ;", "}", "case    1  0  9     :", "break ;", "case    3  9     :", "{", "yybegin (  . TAG _ NAME )  ;", "return   XmlTokenType . XML _ END _ TAG _ START ;", "}", "case    1  1  0     :", "break ;", "case    4  0     :", "{", "yybegin (  . YYINITIAL )  ;", "return   XmlTokenType . XML _ DECL _ END ;", "}", "case    1  1  1     :", "break ;", "case    4  1     :", "{", "yybegin (  . YYINITIAL )  ;", "return   XmlTokenType . XML _ EMPTY _ ELEMENT _ END ;", "}", "case    1  1  2     :", "break ;", "case    4  2     :", "{", "yybegin (  . YYINITIAL )  ;", "return   XmlTokenType . XML _ PI _ END ;", "}", "case    1  1  3     :", "break ;", "case    4  3     :", "{", "yybegin (  . DOCTYPE _ COMMENT )  ;", "return   XmlTokenType . XML _ COMMENT _ START ;", "}", "case    1  1  4     :", "break ;", "case    4  4     :", "{", "yybegin (  . DOCTYPE _ MARKUP )  ;", "return   XmlTokenType . XML _ COMMENT _ END ;", "}", "case    1  1  5     :", "break ;", "case    4  5     :", "{", "yybegin (  . CONDITIONAL )  ;", "return   XmlTokenType . XML _ CONDITIONAL _ SECTION _ START ;", "}", "case    1  1  6     :", "break ;", "case    4  6     :", "{", "yybegin (  . YYINITIAL )  ;", "return   XmlTokenType . XML _ CONDITIONAL _ SECTION _ END ;", "}", "case    1  1  7     :", "break ;", "case    4  7     :", "{", "return   XmlTokenType . XML _ ENTITY _ REF _ TOKEN ;", "}", "case    1  1  8     :", "break ;", "case    4  8     :", "{", "yybegin (  . YYINITIAL )  ;", "return   XmlTokenType . XML _ COMMENT _ END ;", "}", "case    1  1  9     :", "break ;", "case    4  9     :", "{", "return   XmlTokenType . XML _ CONTENT _ ANY ;", "}", "case    1  2  0     :", "break ;", "case    5  0     :", "{", "yybegin (  . YYINITIAL )  ;", "return   XmlTokenType . XML _ CDATA _ END ;", "}", "case    1  2  1     :", "break ;", "case    5  1     :", "{", "yybegin (  . COMMENT )  ;", "return   XmlTokenType . XML _ COMMENT _ START ;", "}", "case    1  2  2     :", "break ;", "case    5  2     :", "{", "return   XmlTokenType . XML _ CHAR _ ENTITY _ REF ;", "}", "case    1  2  3     :", "break ;", "case    5  3     :", "{", "yybegin (  . DOCTYPE _ MARKUP _ STARTED )  ;", "yypushback ( yylength (  )  )  ;", "}", "case    1  2  4     :", "break ;", "case    5  4     :", "{", "return   XmlTokenType . XML _ CONTENT _ EMPTY ;", "}", "case    1  2  5     :", "break ;", "case    5  5     :", "{", "yybegin (  . DECL )  ;", "return   XmlTokenType . XML _ DECL _ START ;", "}", "case    1  2  6     :", "break ;", "case    5  6     :", "{", "yybegin (  . DOCTYPE _ EXTERNAL _ ID )  ;", "return   XmlTokenType . XML _ DOCTYPE _ PUBLIC ;", "}", "case    1  2  7     :", "break ;", "case    5  7     :", "{", "yybegin (  . DOCTYPE _ EXTERNAL _ ID )  ;", "return   XmlTokenType . XML _ DOCTYPE _ SYSTEM ;", "}", "case    1  2  8     :", "break ;", "case    5  8     :", "{", "return   XmlTokenType . XML _ ATT _ FIXED ;", "}", "case    1  2  9     :", "break ;", "case    5  9     :", "{", "return   XmlTokenType . XML _ DOCTYPE _ PUBLIC ;", "}", "case    1  3  0     :", "break ;", "case    6  0     :", "{", "return   XmlTokenType . XML _ DOCTYPE _ SYSTEM ;", "}", "case    1  3  1     :", "break ;", "case    6  1     :", "{", "return   XmlTokenType . XML _ CONDITIONAL _ IGNORE ;", "}", "case    1  3  2     :", "break ;", "case    6  2     :", "{", "return   XmlTokenType . XML _ PCDATA ;", "}", "case    1  3  3     :", "break ;", "case    6  3     :", "{", "return   XmlTokenType . XML _ CONDITIONAL _ INCLUDE ;", "}", "case    1  3  4     :", "break ;", "case    6  4     :", "{", "yybegin (  . DOCTYPE _ MARKUP )  ;", "return   XmlTokenType . XML _ ENTITY _ DECL _ START ;", "}", "case    1  3  5     :", "break ;", "case    6  5     :", "{", "return   XmlTokenType . XML _ ATT _ IMPLIED ;", "}", "case    1  3  6     :", "break ;", "case    6  6     :", "{", "yybegin (  . CDATA )  ;", "return   XmlTokenType . XML _ CDATA _ START ;", "}", "case    1  3  7     :", "break ;", "case    6  7     :", "{", "yybegin (  . DOCTYPE )  ;", "return   XmlTokenType . XML _ DOCTYPE _ START ;", "}", "case    1  3  8     :", "break ;", "case    6  8     :", "{", "yybegin (  . DOCTYPE _ MARKUP )  ;", "return   XmlTokenType . XML _ ATTLIST _ DECL _ START ;", "}", "case    1  3  9     :", "break ;", "case    6  9     :", "{", "yybegin (  . DOCTYPE _ MARKUP )  ;", "return   XmlTokenType . XML _ ELEMENT _ DECL _ START ;", "}", "case    1  4  0     :", "break ;", "case    7  0     :", "{", "return   XmlTokenType . XML _ ATT _ REQUIRED ;", "}", "case    1  4  1     :", "break ;", "case    7  1     :", "{", "yybegin (  . DOCTYPE _ MARKUP )  ;", "return   XmlTokenType . XML _ NOTATION _ DECL _ START ;", "}", "case    1  4  2     :", "break ;", "default    :", "zzScanError (  . ZZ _ NO _ MATCH )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["advance"], "fileName": "com.intellij.lexer._DtdLexer"}, {"methodBody": ["METHOD_START", "{", "return    ( getTokenStart (  )  )     +     ( yylength (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTokenEnd"], "fileName": "com.intellij.lexer._DtdLexer"}, {"methodBody": ["METHOD_START", "{", "return   zzStartRead ;", "}", "METHOD_END"], "methodName": ["getTokenStart"], "fileName": "com.intellij.lexer._DtdLexer"}, {"methodBody": ["METHOD_START", "{", "zzBuffer    =    buffer ;", "zzCurrentPos    =    zzMarkedPos    =    zzStartRead    =    start ;", "zzAtEOF    =    false ;", "zzAtBOL    =    true ;", "zzEndRead    =    end ;", "yybegin ( initialState )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.intellij.lexer._DtdLexer"}, {"methodBody": ["METHOD_START", "{", "zzLexicalState    =    newState ;", "}", "METHOD_END"], "methodName": ["yybegin"], "fileName": "com.intellij.lexer._DtdLexer"}, {"methodBody": ["METHOD_START", "{", "return   zzBuffer . charAt (  (  ( zzStartRead )     +    pos )  )  ;", "}", "METHOD_END"], "methodName": ["yycharat"], "fileName": "com.intellij.lexer._DtdLexer"}, {"methodBody": ["METHOD_START", "{", "return    ( zzMarkedPos )     -     ( zzStartRead )  ;", "}", "METHOD_END"], "methodName": ["yylength"], "fileName": "com.intellij.lexer._DtdLexer"}, {"methodBody": ["METHOD_START", "{", "if    ( number    >     ( yylength (  )  )  )", "zzScanError (  . ZZ _ PUSHBACK _  2 BIG )  ;", "zzMarkedPos    -  =    number ;", "}", "METHOD_END"], "methodName": ["yypushback"], "fileName": "com.intellij.lexer._DtdLexer"}, {"methodBody": ["METHOD_START", "{", "return   zzLexicalState ;", "}", "METHOD_END"], "methodName": ["yystate"], "fileName": "com.intellij.lexer._DtdLexer"}, {"methodBody": ["METHOD_START", "{", "return   zzBuffer . subSequence ( zzStartRead ,    zzMarkedPos )  ;", "}", "METHOD_END"], "methodName": ["yytext"], "fileName": "com.intellij.lexer._DtdLexer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["zzRefill"], "fileName": "com.intellij.lexer._DtdLexer"}, {"methodBody": ["METHOD_START", "{", "String   message ;", "try    {", "message    =     . ZZ _ ERROR _ MSG [ errorCode ]  ;", "}    catch    ( ArrayIndexOutOfBoundsException   e )     {", "message    =     . ZZ _ ERROR _ MSG [  . ZZ _ UNKNOWN _ ERROR ]  ;", "}", "throw   new   Error ( message )  ;", "}", "METHOD_END"], "methodName": ["zzScanError"], "fileName": "com.intellij.lexer._DtdLexer"}, {"methodBody": ["METHOD_START", "{", "int [  ]    result    =    new   int [  3  0  4  ]  ;", "int   offset    =     0  ;", "offset    =     . zzUnpackAction (  . ZZ _ ACTION _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackAction"], "fileName": "com.intellij.lexer._DtdLexer"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "int   j    =    offset ;", "int   l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "int   count    =    packed . charAt (  ( i +  +  )  )  ;", "int   value    =    packed . charAt (  ( i +  +  )  )  ;", "do", "result [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - count )     >     0     )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackAction"], "fileName": "com.intellij.lexer._DtdLexer"}, {"methodBody": ["METHOD_START", "{", "int [  ]    result    =    new   int [  3  0  4  ]  ;", "int   offset    =     0  ;", "offset    =     . zzUnpackAttribute (  . ZZ _ ATTRIBUTE _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackAttribute"], "fileName": "com.intellij.lexer._DtdLexer"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "int   j    =    offset ;", "int   l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "int   count    =    packed . charAt (  ( i +  +  )  )  ;", "int   value    =    packed . charAt (  ( i +  +  )  )  ;", "do", "result [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - count )     >     0     )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackAttribute"], "fileName": "com.intellij.lexer._DtdLexer"}, {"methodBody": ["METHOD_START", "{", "int   size    =     0  ;", "for    ( int   i    =     0  ,    length    =    packed . length (  )  ;    i    <    length ;    i    +  =     2  )     {", "size    +  =    packed . charAt ( i )  ;", "}", "char [  ]    map    =    new   char [ size ]  ;", "int   i    =     0  ;", "int   j    =     0  ;", "while    ( i    <     ( packed . length (  )  )  )     {", "int   count    =    packed . charAt (  ( i +  +  )  )  ;", "char   value    =    packed . charAt (  ( i +  +  )  )  ;", "do", "map [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - count )     >     0     )  ;", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["zzUnpackCMap"], "fileName": "com.intellij.lexer._DtdLexer"}, {"methodBody": ["METHOD_START", "{", "int [  ]    result    =    new   int [  3  0  4  ]  ;", "int   offset    =     0  ;", "offset    =     . zzUnpackRowMap (  . ZZ _ ROWMAP _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackRowMap"], "fileName": "com.intellij.lexer._DtdLexer"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "int   j    =    offset ;", "int   l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "int   high    =     ( packed . charAt (  ( i +  +  )  )  )     <  <     1  6  ;", "result [  ( j +  +  )  ]     =    high    |     ( packed . charAt (  ( i +  +  )  )  )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackRowMap"], "fileName": "com.intellij.lexer._DtdLexer"}, {"methodBody": ["METHOD_START", "{", "int [  ]    result    =    new   int [  1  1  0  6  7  ]  ;", "int   offset    =     0  ;", "offset    =     . zzUnpackTrans (  . ZZ _ TRANS _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackTrans"], "fileName": "com.intellij.lexer._DtdLexer"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "int   j    =    offset ;", "int   l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "int   count    =    packed . charAt (  ( i +  +  )  )  ;", "int   value    =    packed . charAt (  ( i +  +  )  )  ;", "value -  -  ;", "do", "result [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - count )     >     0     )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackTrans"], "fileName": "com.intellij.lexer._DtdLexer"}, {"methodBody": ["METHOD_START", "{", "return    _ HtmlLexer . ZZ _ CMAP _ A [  (  (  (  _ HtmlLexer . ZZ _ CMAP _ Y [  (  (  (  _ HtmlLexer . ZZ _ CMAP _ Z [  ( ch    >  >     1  0  )  ]  )     <  <     6  )     |     (  ( ch    >  >     4  )     &     6  3  )  )  ]  )     <  <     4  )     |     ( ch    &     1  5  )  )  ]  ;", "}", "METHOD_END"], "methodName": ["ZZ_CMAP"], "fileName": "com.intellij.lexer._HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "int   zzInput ;", "int   zzAction ;", "int   zzCurrentPosL ;", "int   zzMarkedPosL ;", "int   zzEndReadL    =    zzEndRead ;", "CharSequence   zzBufferL    =    zzBuffer ;", "int [  ]    zzTransL    =     . ZZ _ TRANS ;", "int [  ]    zzRowMapL    =     . ZZ _ ROWMAP ;", "int [  ]    zzAttrL    =     . ZZ _ ATTRIBUTE ;", "while    ( true )     {", "zzMarkedPosL    =    zzMarkedPos ;", "zzAction    =     -  1  ;", "zzCurrentPosL    =    zzCurrentPos    =    zzStartRead    =    zzMarkedPosL ;", "zzState    =     . ZZ _ LEXSTATE [ zzLexicalState ]  ;", "int   zzAttributes    =    zzAttrL [ zzState ]  ;", "if    (  ( zzAttributes    &     1  )     =  =     1  )     {", "zzAction    =    zzState ;", "}", "zzForAction    :     {", "while    ( true )     {", "if    ( zzCurrentPosL    <    zzEndReadL )     {", "zzInput    =    Character . codePointAt ( zzBufferL ,    zzCurrentPosL )  ;", "zzCurrentPosL    +  =    Character . charCount ( zzInput )  ;", "} else", "if    ( zzAtEOF )     {", "zzInput    =     . YYEOF ;", "break   zzForAction ;", "} else    {", "zzCurrentPos    =    zzCurrentPosL ;", "zzMarkedPos    =    zzMarkedPosL ;", "boolean   eof    =    zzRefill (  )  ;", "zzCurrentPosL    =    zzCurrentPos ;", "zzMarkedPosL    =    zzMarkedPos ;", "zzBufferL    =    zzBuffer ;", "zzEndReadL    =    zzEndRead ;", "if    ( eof )     {", "zzInput    =     . YYEOF ;", "break   zzForAction ;", "} else    {", "zzInput    =    Character . codePointAt ( zzBufferL ,    zzCurrentPosL )  ;", "zzCurrentPosL    +  =    Character . charCount ( zzInput )  ;", "}", "}", "int   zzNext    =    zzTransL [  (  ( zzRowMapL [ zzState ]  )     +     (  . ZZ _ CMAP ( zzInput )  )  )  ]  ;", "if    ( zzNext    =  =     (  -  1  )  )", "break   zzForAction ;", "zzState    =    zzNext ;", "zzAttributes    =    zzAttrL [ zzState ]  ;", "if    (  ( zzAttributes    &     1  )     =  =     1  )     {", "zzAction    =    zzState ;", "zzMarkedPosL    =    zzCurrentPosL ;", "if    (  ( zzAttributes    &     8  )     =  =     8  )", "break   zzForAction ;", "}", "}", "}", "zzMarkedPos    =    zzMarkedPosL ;", "if    (  ( zzInput    =  =     (  . YYEOF )  )     &  &     (  ( zzStartRead )     =  =     ( zzCurrentPos )  )  )     {", "zzAtEOF    =    true ;", "return   null ;", "} else    {", "switch    ( zzAction    <     0     ?    zzAction    :     . ZZ _ ACTION [ zzAction ]  )     {", "case    1     :", "{", "return   XmlTokenType . XML _ DATA _ CHARACTERS ;", "}", "case    3  9     :", "break ;", "case    2     :", "{", "return   XmlTokenType . XML _ PI _ TARGET ;", "}", "case    4  0     :", "break ;", "case    3     :", "{", "return   XmlTokenType . XML _ REAL _ WHITE _ SPACE ;", "}", "case    4  1     :", "break ;", "case    4     :", "{", "return   XmlTokenType . XML _ BAD _ CHARACTER ;", "}", "case    4  2     :", "break ;", "case    5     :", "{", "return   XmlTokenType . XML _ WHITE _ SPACE ;", "}", "case    4  3     :", "break ;", "case    6     :", "{", "yybegin (  . YYINITIAL )  ;", "return   XmlTokenType . XML _ DOCTYPE _ END ;", "}", "case    4  4     :", "break ;", "case    7     :", "{", "return   XmlTokenType . XML _ COMMENT _ CHARACTERS ;", "}", "case    4  5     :", "break ;", "case    8     :", "{", "int   loc    =    getTokenStart (  )  ;", "char   prev    =    zzBuffer . charAt (  ( loc    -     1  )  )  ;", "char   prevPrev    =    zzBuffer . charAt (  ( loc    -     2  )  )  ;", "if    (  ( prev    =  =     '  -  '  )     &  &     ( prevPrev    =  =     '  -  '  )  )     {", "yybegin (  . YYINITIAL )  ;", "return   XmlTokenType . XML _ COMMENT _ END ;", "}", "return   XmlTokenType . XML _ COMMENT _ CHARACTERS ;", "}", "case    4  6     :", "break ;", "case    9     :", "{", "yybegin (  . C _ COMMENT _ START )  ;", "return   XmlTokenType . XML _ CONDITIONAL _ COMMENT _ START ;", "}", "case    4  7     :", "break ;", "case    1  0     :", "{", "yybegin (  . YYINITIAL )  ;", "yypushback (  1  )  ;", "break ;", "}", "case    4  8     :", "break ;", "case    1  1     :", "{", "yybegin (  . BEFORE _ TAG _ ATTRIBUTES )  ;", "return   XmlTokenType . XML _ NAME ;", "}", "case    4  9     :", "break ;", "case    1  2     :", "{", "return   XmlTokenType . XML _ START _ TAG _ START ;", "}", "case    5  0     :", "break ;", "case    1  3     :", "{", "yybegin (  . TAG _ ATTRIBUTES )  ;", "return   XmlTokenType . XML _ WHITE _ SPACE ;", "}", "case    5  1     :", "break ;", "case    1  4     :", "{", "yybegin (  . YYINITIAL )  ;", "return   XmlTokenType . XML _ TAG _ END ;", "}", "case    5  2     :", "break ;", "case    1  5     :", "{", "return   XmlTokenType . XML _ NAME ;", "}", "case    5  3     :", "break ;", "case    1  6     :", "{", "yybegin (  . ATTRIBUTE _ VALUE _ START )  ;", "return   XmlTokenType . XML _ EQ ;", "}", "case    5  4     :", "break ;", "case    1  7     :", "{", "yybegin (  . TAG _ ATTRIBUTES )  ;", "return   XmlTokenType . XML _ ATTRIBUTE _ VALUE _ TOKEN ;", "}", "case    5  5     :", "break ;", "case    1  8     :", "{", "yybegin (  . ATTRIBUTE _ VALUE _ DQ )  ;", "return   XmlTokenType . XML _ ATTRIBUTE _ VALUE _ START _ DELIMITER ;", "}", "case    5  6     :", "break ;", "case    1  9     :", "{", "yybegin (  . ATTRIBUTE _ VALUE _ SQ )  ;", "return   XmlTokenType . XML _ ATTRIBUTE _ VALUE _ START _ DELIMITER ;", "}", "case    5  7     :", "break ;", "case    2  0     :", "{", "return   XmlTokenType . XML _ ATTRIBUTE _ VALUE _ TOKEN ;", "}", "case    5  8     :", "break ;", "case    2  1     :", "{", "yybegin (  . TAG _ ATTRIBUTES )  ;", "return   XmlTokenType . XML _ ATTRIBUTE _ VALUE _ END _ DELIMITER ;", "}", "case    5  9     :", "break ;", "case    2  2     :", "{", "yybegin (  . YYINITIAL )  ;", "return   XmlTokenType . XML _ PI _ END ;", "}", "case    6  0     :", "break ;", "case    2  3     :", "{", "return   XmlTokenType . XML _ TAG _ CHARACTERS ;", "}", "case    6  1     :", "break ;", "case    2  4     :", "{", "yybegin (  . COMMENT )  ;", "return   XmlTokenType . XML _ COMMENT _ CHARACTERS ;", "}", "case    6  2     :", "break ;", "case    2  5     :", "{", "yybegin (  . COMMENT )  ;", "return   XmlTokenType . XML _ CONDITIONAL _ COMMENT _ END ;", "}", "case    6  3     :", "break ;", "case    2  6     :", "{", "yybegin (  . START _ TAG _ NAME )  ;", "yypushback ( yylength (  )  )  ;", "}", "case    6  4     :", "break ;", "case    2  7     :", "{", "yybegin (  . PROCESSING _ INSTRUCTION )  ;", "return   XmlTokenType . XML _ PI _ START ;", "}", "case    6  5     :", "break ;", "case    2  8     :", "{", "return   XmlTokenType . XML _ END _ TAG _ START ;", "}", "case    6  6     :", "break ;", "case    2  9     :", "{", "yybegin (  . YYINITIAL )  ;", "return   XmlTokenType . XML _ EMPTY _ ELEMENT _ END ;", "}", "case    6  7     :", "break ;", "case    3  0     :", "{", "yybegin (  . COMMENT )  ;", "return   XmlTokenType . XML _ CONDITIONAL _ COMMENT _ START _ END ;", "}", "case    6  8     :", "break ;", "case    3  1     :", "{", "yybegin (  . END _ TAG _ NAME )  ;", "yypushback ( yylength (  )  )  ;", "}", "case    6  9     :", "break ;", "case    3  2     :", "{", "return   XmlTokenType . XML _ ENTITY _ REF _ TOKEN ;", "}", "case    7  0     :", "break ;", "case    3  3     :", "{", "yybegin (  . YYINITIAL )  ;", "return   XmlTokenType . XML _ COMMENT _ END ;", "}", "case    7  1     :", "break ;", "case    3  4     :", "{", "yybegin (  . C _ COMMENT _ END )  ;", "return   XmlTokenType . XML _ CONDITIONAL _ COMMENT _ END _ START ;", "}", "case    7  2     :", "break ;", "case    3  5     :", "{", "yybegin (  . COMMENT )  ;", "return   XmlTokenType . XML _ COMMENT _ START ;", "}", "case    7  3     :", "break ;", "case    3  6     :", "{", "return   XmlTokenType . XML _ CHAR _ ENTITY _ REF ;", "}", "case    7  4     :", "break ;", "case    3  7     :", "{", "return   XmlTokenType . XML _ DOCTYPE _ PUBLIC ;", "}", "case    7  5     :", "break ;", "case    3  8     :", "{", "yybegin (  . DOC _ TYPE )  ;", "return   XmlTokenType . XML _ DOCTYPE _ START ;", "}", "case    7  6     :", "break ;", "default    :", "zzScanError (  . ZZ _ NO _ MATCH )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["advance"], "fileName": "com.intellij.lexer._HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "return    ( getTokenStart (  )  )     +     ( yylength (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTokenEnd"], "fileName": "com.intellij.lexer._HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "return   zzStartRead ;", "}", "METHOD_END"], "methodName": ["getTokenStart"], "fileName": "com.intellij.lexer._HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "zzBuffer    =    buffer ;", "zzCurrentPos    =    zzMarkedPos    =    zzStartRead    =    start ;", "zzAtEOF    =    false ;", "zzAtBOL    =    true ;", "zzEndRead    =    end ;", "yybegin ( initialState )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.intellij.lexer._HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "zzLexicalState    =    newState ;", "}", "METHOD_END"], "methodName": ["yybegin"], "fileName": "com.intellij.lexer._HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "return   zzBuffer . charAt (  (  ( zzStartRead )     +    pos )  )  ;", "}", "METHOD_END"], "methodName": ["yycharat"], "fileName": "com.intellij.lexer._HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "return    ( zzMarkedPos )     -     ( zzStartRead )  ;", "}", "METHOD_END"], "methodName": ["yylength"], "fileName": "com.intellij.lexer._HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "if    ( number    >     ( yylength (  )  )  )", "zzScanError (  . ZZ _ PUSHBACK _  2 BIG )  ;", "zzMarkedPos    -  =    number ;", "}", "METHOD_END"], "methodName": ["yypushback"], "fileName": "com.intellij.lexer._HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "return   zzLexicalState ;", "}", "METHOD_END"], "methodName": ["yystate"], "fileName": "com.intellij.lexer._HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "return   zzBuffer . subSequence ( zzStartRead ,    zzMarkedPos )  ;", "}", "METHOD_END"], "methodName": ["yytext"], "fileName": "com.intellij.lexer._HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["zzRefill"], "fileName": "com.intellij.lexer._HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "String   message ;", "try    {", "message    =     . ZZ _ ERROR _ MSG [ errorCode ]  ;", "}    catch    ( ArrayIndexOutOfBoundsException   e )     {", "message    =     . ZZ _ ERROR _ MSG [  . ZZ _ UNKNOWN _ ERROR ]  ;", "}", "throw   new   Error ( message )  ;", "}", "METHOD_END"], "methodName": ["zzScanError"], "fileName": "com.intellij.lexer._HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "int [  ]    result    =    new   int [  1  1  7  ]  ;", "int   offset    =     0  ;", "offset    =     . zzUnpackAction (  . ZZ _ ACTION _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackAction"], "fileName": "com.intellij.lexer._HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "int   j    =    offset ;", "int   l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "int   count    =    packed . charAt (  ( i +  +  )  )  ;", "int   value    =    packed . charAt (  ( i +  +  )  )  ;", "do", "result [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - count )     >     0     )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackAction"], "fileName": "com.intellij.lexer._HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "int [  ]    result    =    new   int [  1  1  7  ]  ;", "int   offset    =     0  ;", "offset    =     . zzUnpackAttribute (  . ZZ _ ATTRIBUTE _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackAttribute"], "fileName": "com.intellij.lexer._HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "int   j    =    offset ;", "int   l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "int   count    =    packed . charAt (  ( i +  +  )  )  ;", "int   value    =    packed . charAt (  ( i +  +  )  )  ;", "do", "result [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - count )     >     0     )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackAttribute"], "fileName": "com.intellij.lexer._HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "int   size    =     0  ;", "for    ( int   i    =     0  ,    length    =    packed . length (  )  ;    i    <    length ;    i    +  =     2  )     {", "size    +  =    packed . charAt ( i )  ;", "}", "char [  ]    map    =    new   char [ size ]  ;", "int   i    =     0  ;", "int   j    =     0  ;", "while    ( i    <     ( packed . length (  )  )  )     {", "int   count    =    packed . charAt (  ( i +  +  )  )  ;", "char   value    =    packed . charAt (  ( i +  +  )  )  ;", "do", "map [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - count )     >     0     )  ;", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["zzUnpackCMap"], "fileName": "com.intellij.lexer._HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "int [  ]    result    =    new   int [  1  1  7  ]  ;", "int   offset    =     0  ;", "offset    =     . zzUnpackRowMap (  . ZZ _ ROWMAP _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackRowMap"], "fileName": "com.intellij.lexer._HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "int   j    =    offset ;", "int   l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "int   high    =     ( packed . charAt (  ( i +  +  )  )  )     <  <     1  6  ;", "result [  ( j +  +  )  ]     =    high    |     ( packed . charAt (  ( i +  +  )  )  )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackRowMap"], "fileName": "com.intellij.lexer._HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "int [  ]    result    =    new   int [  3  9  7  8  ]  ;", "int   offset    =     0  ;", "offset    =     . zzUnpackTrans (  . ZZ _ TRANS _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackTrans"], "fileName": "com.intellij.lexer._HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "int   j    =    offset ;", "int   l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "int   count    =    packed . charAt (  ( i +  +  )  )  ;", "int   value    =    packed . charAt (  ( i +  +  )  )  ;", "value -  -  ;", "do", "result [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - count )     >     0     )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackTrans"], "fileName": "com.intellij.lexer._HtmlLexer"}, {"methodBody": ["METHOD_START", "{", "super . advance (  )  ;", "packState (  )  ;", "}", "METHOD_END"], "methodName": ["advance"], "fileName": "com.intellij.lexer._XmlLexer"}, {"methodBody": ["METHOD_START", "{", "return   myState ;", "}", "METHOD_END"], "methodName": ["getState"], "fileName": "com.intellij.lexer._XmlLexer"}, {"methodBody": ["METHOD_START", "{", "final    _  _ XmlLexer   flex    =     (  (  _  _ XmlLexer )     ( getFlex (  )  )  )  ;", "flex . yybegin (  ( initialState    &     (  _ XmlLexer . STATE _ MASK )  )  )  ;", "flex . pushState (  (  ( initialState    >  >     (  _ XmlLexer . STATE _ SHIFT )  )     &     (  _ XmlLexer . STATE _ MASK )  )  )  ;", "packState (  )  ;", "}", "METHOD_END"], "methodName": ["handleState"], "fileName": "com.intellij.lexer._XmlLexer"}, {"methodBody": ["METHOD_START", "{", "final    _  _ XmlLexer   flex    =     (  (  _  _ XmlLexer )     ( getFlex (  )  )  )  ;", "myState    =     (  (  ( flex . yyprevstate (  )  )     &     (  _ XmlLexer . STATE _ MASK )  )     <  <     (  _ XmlLexer . STATE _ SHIFT )  )     |     (  ( flex . yystate (  )  )     &     (  _ XmlLexer . STATE _ MASK )  )  ;", "}", "METHOD_END"], "methodName": ["packState"], "fileName": "com.intellij.lexer._XmlLexer"}, {"methodBody": ["METHOD_START", "{", "super . start ( buffer ,    startOffset ,    endOffset ,    initialState )  ;", "handleState ( initialState )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "com.intellij.lexer._XmlLexer"}, {"methodBody": ["METHOD_START", "{", "return    _  _ XmlLexer . ZZ _ CMAP _ A [  (  (  (  _  _ XmlLexer . ZZ _ CMAP _ Y [  (  (  (  _  _ XmlLexer . ZZ _ CMAP _ Z [  ( ch    >  >     1  0  )  ]  )     <  <     6  )     |     (  ( ch    >  >     4  )     &     6  3  )  )  ]  )     <  <     4  )     |     ( ch    &     1  5  )  )  ]  ;", "}", "METHOD_END"], "methodName": ["ZZ_CMAP"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "int   zzInput ;", "int   zzAction ;", "int   zzCurrentPosL ;", "int   zzMarkedPosL ;", "int   zzEndReadL    =    zzEndRead ;", "CharSequence   zzBufferL    =    zzBuffer ;", "int [  ]    zzTransL    =     . ZZ _ TRANS ;", "int [  ]    zzRowMapL    =     . ZZ _ ROWMAP ;", "int [  ]    zzAttrL    =     . ZZ _ ATTRIBUTE ;", "while    ( true )     {", "zzMarkedPosL    =    zzMarkedPos ;", "zzAction    =     -  1  ;", "zzCurrentPosL    =    zzCurrentPos    =    zzStartRead    =    zzMarkedPosL ;", "zzState    =     . ZZ _ LEXSTATE [ zzLexicalState ]  ;", "int   zzAttributes    =    zzAttrL [ zzState ]  ;", "if    (  ( zzAttributes    &     1  )     =  =     1  )     {", "zzAction    =    zzState ;", "}", "zzForAction    :     {", "while    ( true )     {", "if    ( zzCurrentPosL    <    zzEndReadL )     {", "zzInput    =    Character . codePointAt ( zzBufferL ,    zzCurrentPosL )  ;", "zzCurrentPosL    +  =    Character . charCount ( zzInput )  ;", "} else", "if    ( zzAtEOF )     {", "zzInput    =     . YYEOF ;", "break   zzForAction ;", "} else    {", "zzCurrentPos    =    zzCurrentPosL ;", "zzMarkedPos    =    zzMarkedPosL ;", "boolean   eof    =    zzRefill (  )  ;", "zzCurrentPosL    =    zzCurrentPos ;", "zzMarkedPosL    =    zzMarkedPos ;", "zzBufferL    =    zzBuffer ;", "zzEndReadL    =    zzEndRead ;", "if    ( eof )     {", "zzInput    =     . YYEOF ;", "break   zzForAction ;", "} else    {", "zzInput    =    Character . codePointAt ( zzBufferL ,    zzCurrentPosL )  ;", "zzCurrentPosL    +  =    Character . charCount ( zzInput )  ;", "}", "}", "int   zzNext    =    zzTransL [  (  ( zzRowMapL [ zzState ]  )     +     (  . ZZ _ CMAP ( zzInput )  )  )  ]  ;", "if    ( zzNext    =  =     (  -  1  )  )", "break   zzForAction ;", "zzState    =    zzNext ;", "zzAttributes    =    zzAttrL [ zzState ]  ;", "if    (  ( zzAttributes    &     1  )     =  =     1  )     {", "zzAction    =    zzState ;", "zzMarkedPosL    =    zzCurrentPosL ;", "if    (  ( zzAttributes    &     8  )     =  =     8  )", "break   zzForAction ;", "}", "}", "}", "zzMarkedPos    =    zzMarkedPosL ;", "if    (  ( zzInput    =  =     (  . YYEOF )  )     &  &     (  ( zzStartRead )     =  =     ( zzCurrentPos )  )  )     {", "zzAtEOF    =    true ;", "return   null ;", "} else    {", "switch    ( zzAction    <     0     ?    zzAction    :     . ZZ _ ACTION [ zzAction ]  )     {", "case    1     :", "{", "return   XmlTokenType . XML _ DATA _ CHARACTERS ;", "}", "case    4  4     :", "break ;", "case    2     :", "{", "return   XmlTokenType . XML _ REAL _ WHITE _ SPACE ;", "}", "case    4  5     :", "break ;", "case    3     :", "{", "if    (  ( yystate (  )  )     =  =     (  . YYINITIAL )  )     {", "return   XmlTokenType . XML _ BAD _ CHARACTER ;", "} else", "yybegin ( popState (  )  )  ;", "yypushback ( yylength (  )  )  ;", "}", "case    4  6     :", "break ;", "case    4     :", "{", "yybegin (  . TAG )  ;", "return   XmlTokenType . XML _ START _ TAG _ START ;", "}", "case    4  7     :", "break ;", "case    5     :", "{", "yybegin (  . ATTR _ LIST )  ;", "pushState (  . TAG )  ;", "return   XmlTokenType . XML _ NAME ;", "}", "case    4  8     :", "break ;", "case    6     :", "{", "return   XmlTokenType . XML _ WHITE _ SPACE ;", "}", "case    4  9     :", "break ;", "case    7     :", "{", "yybegin (  . YYINITIAL )  ;", "return   XmlTokenType . XML _ TAG _ END ;", "}", "case    5  0     :", "break ;", "case    8     :", "{", "yybegin (  . PI _ ANY )  ;", "return   XmlTokenType . XML _ NAME ;", "}", "case    5  1     :", "break ;", "case    9     :", "{", "return   XmlTokenType . XML _ TAG _ CHARACTERS ;", "}", "case    5  2     :", "break ;", "case    1  0     :", "{", "return   XmlTokenType . XML _ NAME ;", "}", "case    5  3     :", "break ;", "case    1  1     :", "{", "return   XmlTokenType . XML _ COMMENT _ CHARACTERS ;", "}", "case    5  4     :", "break ;", "case    1  2     :", "{", "return   XmlTokenType . XML _ BAD _ CHARACTER ;", "}", "case    5  5     :", "break ;", "case    1  3     :", "{", "if    ( myConditionalCommentsSupport )     {", "yybegin (  . C _ COMMENT _ START )  ;", "return   XmlTokenType . XML _ CONDITIONAL _ COMMENT _ START ;", "} else", "return   XmlTokenType . XML _ COMMENT _ CHARACTERS ;", "}", "case    5  6     :", "break ;", "case    1  4     :", "{", "yybegin (  . ATTR )  ;", "return   XmlTokenType . XML _ NAME ;", "}", "case    5  7     :", "break ;", "case    1  5     :", "{", "yybegin (  . ATTR _ LIST )  ;", "yypushback ( yylength (  )  )  ;", "}", "case    5  8     :", "break ;", "case    1  6     :", "{", "yybegin (  . ATTR _ VALUE _ DQ )  ;", "return   XmlTokenType . XML _ ATTRIBUTE _ VALUE _ START _ DELIMITER ;", "}", "case    5  9     :", "break ;", "case    1  7     :", "{", "yybegin (  . ATTR _ VALUE _ SQ )  ;", "return   XmlTokenType . XML _ ATTRIBUTE _ VALUE _ START _ DELIMITER ;", "}", "case    6  0     :", "break ;", "case    1  8     :", "{", "return   XmlTokenType . XML _ EQ ;", "}", "case    6  1     :", "break ;", "case    1  9     :", "{", "return   XmlTokenType . XML _ ATTRIBUTE _ VALUE _ TOKEN ;", "}", "case    6  2     :", "break ;", "case    2  0     :", "{", "yybegin (  . ATTR _ LIST )  ;", "return   XmlTokenType . XML _ ATTRIBUTE _ VALUE _ END _ DELIMITER ;", "}", "case    6  3     :", "break ;", "case    2  1     :", "{", "yybegin (  . YYINITIAL )  ;", "return   XmlTokenType . XML _ DOCTYPE _ END ;", "}", "case    6  4     :", "break ;", "case    2  2     :", "{", "yybegin (  . COMMENT )  ;", "return   XmlTokenType . XML _ COMMENT _ CHARACTERS ;", "}", "case    6  5     :", "break ;", "case    2  3     :", "{", "yybegin (  . COMMENT )  ;", "return   XmlTokenType . XML _ CONDITIONAL _ COMMENT _ END ;", "}", "case    6  6     :", "break ;", "case    2  4     :", "{", "yybegin (  . PROCESSING _ INSTRUCTION )  ;", "return   XmlTokenType . XML _ PI _ START ;", "}", "case    6  7     :", "break ;", "case    2  5     :", "{", "yybegin (  . END _ TAG )  ;", "return   XmlTokenType . XML _ END _ TAG _ START ;", "}", "case    6  8     :", "break ;", "case    2  6     :", "{", "yybegin (  . YYINITIAL )  ;", "return   XmlTokenType . XML _ EMPTY _ ELEMENT _ END ;", "}", "case    6  9     :", "break ;", "case    2  7     :", "{", "yybegin (  . YYINITIAL )  ;", "return   XmlTokenType . XML _ PI _ END ;", "}", "case    7  0     :", "break ;", "case    2  8     :", "{", "return   XmlElementType . XML _ MARKUP _ DECL ;", "}", "case    7  1     :", "break ;", "case    2  9     :", "{", "yybegin (  . COMMENT )  ;", "return   XmlTokenType . XML _ CONDITIONAL _ COMMENT _ START _ END ;", "}", "case    7  2     :", "break ;", "case    3  0     :", "{", "return   elTokenType ;", "}", "case    7  3     :", "break ;", "case    3  1     :", "{", "return   XmlTokenType . XML _ ENTITY _ REF _ TOKEN ;", "}", "case    7  4     :", "break ;", "case    3  2     :", "{", "yybegin (  . ATTR _ LIST )  ;", "pushState (  . PROCESSING _ INSTRUCTION )  ;", "return   XmlTokenType . XML _ NAME ;", "}", "case    7  5     :", "break ;", "case    3  3     :", "{", "yybegin (  . YYINITIAL )  ;", "return   XmlTokenType . XML _ COMMENT _ END ;", "}", "case    7  6     :", "break ;", "case    3  4     :", "{", "if    ( myConditionalCommentsSupport )     {", "yybegin (  . C _ COMMENT _ END )  ;", "return   XmlTokenType . XML _ CONDITIONAL _ COMMENT _ END _ START ;", "} else", "return   XmlTokenType . XML _ COMMENT _ CHARACTERS ;", "}", "case    7  7     :", "break ;", "case    3  5     :", "{", "return   elTokenType 2  ;", "}", "case    7  8     :", "break ;", "case    3  6     :", "{", "return   javaEmbeddedTokenType ;", "}", "case    7  9     :", "break ;", "case    3  7     :", "{", "yybegin (  . YYINITIAL )  ;", "return   XmlTokenType . XML _ CDATA _ END ;", "}", "case    8  0     :", "break ;", "case    3  8     :", "{", "return   XmlTokenType . XML _ CHAR _ ENTITY _ REF ;", "}", "case    8  1     :", "break ;", "case    3  9     :", "{", "yybegin (  . COMMENT )  ;", "return   XmlTokenType . XML _ COMMENT _ START ;", "}", "case    8  2     :", "break ;", "case    4  0     :", "{", "return   XmlTokenType . XML _ DOCTYPE _ PUBLIC ;", "}", "case    8  3     :", "break ;", "case    4  1     :", "{", "return   XmlTokenType . XML _ DOCTYPE _ SYSTEM ;", "}", "case    8  4     :", "break ;", "case    4  2     :", "{", "yybegin (  . CDATA )  ;", "return   XmlTokenType . XML _ CDATA _ START ;", "}", "case    8  5     :", "break ;", "case    4  3     :", "{", "yybegin (  . DOCTYPE )  ;", "return   XmlTokenType . XML _ DOCTYPE _ START ;", "}", "case    8  6     :", "break ;", "default    :", "zzScanError (  . ZZ _ NO _ MATCH )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["advance"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "return    ( getTokenStart (  )  )     +     ( yylength (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTokenEnd"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "return   zzStartRead ;", "}", "METHOD_END"], "methodName": ["getTokenStart"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "final   int   prev    =    myPrevState ;", "myPrevState    =     . YYINITIAL ;", "return   prev ;", "}", "METHOD_END"], "methodName": ["popState"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "myPrevState    =    state ;", "}", "METHOD_END"], "methodName": ["pushState"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "zzBuffer    =    buffer ;", "zzCurrentPos    =    zzMarkedPos    =    zzStartRead    =    start ;", "zzAtEOF    =    false ;", "zzAtBOL    =    true ;", "zzEndRead    =    end ;", "yybegin ( initialState )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "myConditionalCommentsSupport    =    b ;", "}", "METHOD_END"], "methodName": ["setConditionalCommentsSupport"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "elTokenType    =     _ elTokenType ;", "elTokenType 2     =     _ elTokenType 2  ;", "}", "METHOD_END"], "methodName": ["setElTypes"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "javaEmbeddedTokenType    =     _ tokenType ;", "}", "METHOD_END"], "methodName": ["setJavaEmbeddedType"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "zzLexicalState    =    newState ;", "}", "METHOD_END"], "methodName": ["yybegin"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "return   zzBuffer . charAt (  (  ( zzStartRead )     +    pos )  )  ;", "}", "METHOD_END"], "methodName": ["yycharat"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "return    ( zzMarkedPos )     -     ( zzStartRead )  ;", "}", "METHOD_END"], "methodName": ["yylength"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "return   myPrevState ;", "}", "METHOD_END"], "methodName": ["yyprevstate"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "if    ( number    >     ( yylength (  )  )  )", "zzScanError (  . ZZ _ PUSHBACK _  2 BIG )  ;", "zzMarkedPos    -  =    number ;", "}", "METHOD_END"], "methodName": ["yypushback"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "return   zzLexicalState ;", "}", "METHOD_END"], "methodName": ["yystate"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "return   zzBuffer . subSequence ( zzStartRead ,    zzMarkedPos )  ;", "}", "METHOD_END"], "methodName": ["yytext"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["zzRefill"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "String   message ;", "try    {", "message    =     . ZZ _ ERROR _ MSG [ errorCode ]  ;", "}    catch    ( ArrayIndexOutOfBoundsException   e )     {", "message    =     . ZZ _ ERROR _ MSG [  . ZZ _ UNKNOWN _ ERROR ]  ;", "}", "throw   new   Error ( message )  ;", "}", "METHOD_END"], "methodName": ["zzScanError"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "int [  ]    result    =    new   int [  1  4  7  ]  ;", "int   offset    =     0  ;", "offset    =     . zzUnpackAction (  . ZZ _ ACTION _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackAction"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "int   j    =    offset ;", "int   l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "int   count    =    packed . charAt (  ( i +  +  )  )  ;", "int   value    =    packed . charAt (  ( i +  +  )  )  ;", "do", "result [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - count )     >     0     )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackAction"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "int [  ]    result    =    new   int [  1  4  7  ]  ;", "int   offset    =     0  ;", "offset    =     . zzUnpackAttribute (  . ZZ _ ATTRIBUTE _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackAttribute"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "int   j    =    offset ;", "int   l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "int   count    =    packed . charAt (  ( i +  +  )  )  ;", "int   value    =    packed . charAt (  ( i +  +  )  )  ;", "do", "result [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - count )     >     0     )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackAttribute"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "int   size    =     0  ;", "for    ( int   i    =     0  ,    length    =    packed . length (  )  ;    i    <    length ;    i    +  =     2  )     {", "size    +  =    packed . charAt ( i )  ;", "}", "char [  ]    map    =    new   char [ size ]  ;", "int   i    =     0  ;", "int   j    =     0  ;", "while    ( i    <     ( packed . length (  )  )  )     {", "int   count    =    packed . charAt (  ( i +  +  )  )  ;", "char   value    =    packed . charAt (  ( i +  +  )  )  ;", "do", "map [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - count )     >     0     )  ;", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["zzUnpackCMap"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "int [  ]    result    =    new   int [  1  4  7  ]  ;", "int   offset    =     0  ;", "offset    =     . zzUnpackRowMap (  . ZZ _ ROWMAP _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackRowMap"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "int   j    =    offset ;", "int   l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "int   high    =     ( packed . charAt (  ( i +  +  )  )  )     <  <     1  6  ;", "result [  ( j +  +  )  ]     =    high    |     ( packed . charAt (  ( i +  +  )  )  )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackRowMap"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "int [  ]    result    =    new   int [  5  6  0  0  ]  ;", "int   offset    =     0  ;", "offset    =     . zzUnpackTrans (  . ZZ _ TRANS _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackTrans"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "int   j    =    offset ;", "int   l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "int   count    =    packed . charAt (  ( i +  +  )  )  ;", "int   value    =    packed . charAt (  ( i +  +  )  )  ;", "value -  -  ;", "do", "result [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - count )     >     0     )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackTrans"], "fileName": "com.intellij.lexer.__XmlLexer"}, {"methodBody": ["METHOD_START", "{", "List < GotoRelatedItem >    items    =    new   ArrayList <  >  (  )  ;", "for    ( PsiFile   psiFile    :    file . getViewProvider (  )  . getAllFiles (  )  )     {", "if    ( psiFile   instanceof   XmlFile )     {", "final   XmlFile   xmlFile    =     (  ( XmlFile )     ( psiFile )  )  ;", "for    ( RelatedToHtmlFilesContributor   contributor    :    RelatedToHtmlFilesContributor . EP _ NAME . getExtensions (  )  )     {", "HashSet < PsiFile >    resultSet    =    new   HashSet <  >  (  )  ;", "contributor . fillRelatedFiles ( xmlFile ,    resultSet )  ;", "for    ( PsiFile   f    :    resultSet )     {", "items . add ( new   GotoRelatedItem ( f ,    contributor . getGroupName (  )  )  )  ;", "}", "}", "}", "}", "return   items ;", "}", "METHOD_END"], "methodName": ["getRelatedFiles"], "fileName": "com.intellij.navigation.HtmlGotoRelatedProvider"}, {"methodBody": ["METHOD_START", "{", "for    ( PsiFile   file    :    psiFile . getViewProvider (  )  . getAllFiles (  )  )     {", "Language   language    =    file . getLanguage (  )  ;", "if    (  ( language . isKindOf ( HTMLLanguage . INSTANCE )  )     |  |     ( language . isKindOf ( XHTMLLanguage . INSTANCE )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isAvailable"], "fileName": "com.intellij.navigation.HtmlGotoRelatedProvider"}, {"methodBody": ["METHOD_START", "{", "return   DomElementPattern . with ( new   PatternCondition < T >  (  \" withChild \"  )     {", "@ Override", "public   boolean   accepts (  @ NotNull", "final   T   t ,    final   ProcessingContext   context )     {", "for    ( final   AbstractDomChildrenDescription   description    :    t . getGenericInfo (  )  . getChildrenDescriptions (  )  )     {", "if    (  (  !  ( description   instanceof   DomChildrenDescription )  )     |  |     ( localName . equals (  (  ( DomChildrenDescription )     ( description )  )  . getXmlElementName (  )  )  )  )     {", "for    ( final   DomElement   element    :    description . getValues ( t )  )     {", "if    (  ( localName . equals ( element . getXmlElementName (  )  )  )     &  &     ( pattern . accepts ( element ,    context )  )  )     {", "return   true ;", "}", "}", "}", "}", "return   false ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["withChild"], "fileName": "com.intellij.patterns.DomElementPattern"}, {"methodBody": ["METHOD_START", "{", "return   XmlPatterns . xmlAttribute (  )  . withLocalName ( attributeName )  . and ( DomPatterns . withDom ( domPattern )  )  ;", "}", "METHOD_END"], "methodName": ["attributeWithDom"], "fileName": "com.intellij.patterns.DomPatterns"}, {"methodBody": ["METHOD_START", "{", "return   DomPatterns . domElement ( DomElement . class )  ;", "}", "METHOD_END"], "methodName": ["domElement"], "fileName": "com.intellij.patterns.DomPatterns"}, {"methodBody": ["METHOD_START", "{", "return   new   DomElementPattern . Capture <  >  ( aClass )  ;", "}", "METHOD_END"], "methodName": ["domElement"], "fileName": "com.intellij.patterns.DomPatterns"}, {"methodBody": ["METHOD_START", "{", "return   PlatformPatterns . pomElement ( DomPatterns . withDomTarget ( pattern )  )  ;", "}", "METHOD_END"], "methodName": ["domTargetElement"], "fileName": "com.intellij.patterns.DomPatterns"}, {"methodBody": ["METHOD_START", "{", "return   new   GenericDomValuePattern (  )  ;", "}", "METHOD_END"], "methodName": ["genericDomValue"], "fileName": "com.intellij.patterns.DomPatterns"}, {"methodBody": ["METHOD_START", "{", "return    (  ( GenericDomValuePattern )     ( DomPatterns . genericDomValue (  )  )  )  . withValue ( valuePattern )  ;", "}", "METHOD_END"], "methodName": ["genericDomValue"], "fileName": "com.intellij.patterns.DomPatterns"}, {"methodBody": ["METHOD_START", "{", "return   new   GenericDomValuePattern <  >  ( aClass )  ;", "}", "METHOD_END"], "methodName": ["genericDomValue"], "fileName": "com.intellij.patterns.DomPatterns"}, {"methodBody": ["METHOD_START", "{", "return   new   DomFilePattern . Capture ( rootElementClass )  ;", "}", "METHOD_END"], "methodName": ["inDomFile"], "fileName": "com.intellij.patterns.DomPatterns"}, {"methodBody": ["METHOD_START", "{", "return   XmlPatterns . xmlTag (  )  . withLocalName ( tagName )  . and ( DomPatterns . withDom ( domPattern )  )  ;", "}", "METHOD_END"], "methodName": ["tagWithDom"], "fileName": "com.intellij.patterns.DomPatterns"}, {"methodBody": ["METHOD_START", "{", "return   DomPatterns . tagWithDom ( tagName ,    DomPatterns . domElement ( aClass )  )  ;", "}", "METHOD_END"], "methodName": ["tagWithDom"], "fileName": "com.intellij.patterns.DomPatterns"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlElementPattern . Capture (  )  . with ( new   PatternCondition < XmlElement >  (  \" tagWithDom \"  )     {", "@ Override", "public   boolean   accepts (  @ NotNull", "final   XmlElement   xmlElement ,    final   ProcessingContext   context )     {", "final   DomManager   manager    =    DomManager . getDomManager ( xmlElement . getProject (  )  )  ;", "if    ( xmlElement   instanceof   XmlAttribute )     {", "return   pattern . accepts ( manager . getDomElement (  (  ( XmlAttribute )     ( xmlElement )  )  )  ,    context )  ;", "}", "return    ( xmlElement   instanceof   XmlTag )     &  &     ( pattern . accepts ( manager . getDomElement (  (  ( XmlTag )     ( xmlElement )  )  )  ,    context )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["withDom"], "fileName": "com.intellij.patterns.DomPatterns"}, {"methodBody": ["METHOD_START", "{", "return   new   ObjectPattern . Capture <  >  (  . class )  . with ( new   PatternCondition < DomTarget >  (  \" withDomTarget \"  )     {", "@ Override", "public   boolean   accepts (  @ NotNull", "final   DomTarget   target ,    final   ProcessingContext   context )     {", "return   pattern . accepts ( target . getDomElement (  )  ,    context )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["withDomTarget"], "fileName": "com.intellij.patterns.DomPatterns"}, {"methodBody": ["METHOD_START", "{", "return   GenericDomValuePattern . with ( new   PatternCondition < com . intellij . util . xml . GenericDomValue < T >  >  (  \" withStringValue \"  )     {", "@ Override", "public   boolean   accepts (  @ NotNull", "final   com . intellij . util . xml . GenericDomValue < T >    genericDomValue ,    final   ProcessingContext   context )     {", "return   pattern . accepts ( genericDomValue . getStringValue (  )  ,    context )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["withStringValue"], "fileName": "com.intellij.patterns.GenericDomValuePattern"}, {"methodBody": ["METHOD_START", "{", "return   withValue ( StandardPatterns . object ( value )  )  ;", "}", "METHOD_END"], "methodName": ["withValue"], "fileName": "com.intellij.patterns.GenericDomValuePattern"}, {"methodBody": ["METHOD_START", "{", "return   GenericDomValuePattern . with ( new   PatternCondition < com . intellij . util . xml . GenericDomValue < T >  >  (  \" withValue \"  )     {", "@ Override", "public   boolean   accepts (  @ NotNull", "final   com . intellij . util . xml . GenericDomValue < T >    genericDomValue ,    final   ProcessingContext   context )     {", "return   pattern . accepts ( genericDomValue . getValue (  )  ,    context )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["withValue"], "fileName": "com.intellij.patterns.GenericDomValuePattern"}, {"methodBody": ["METHOD_START", "{", "return   with ( new   PsiNamePatternCondition < XmlAttributeValue >  (  \" withLocalName \"  ,    namePattern )     {", "@ Override", "public   String   getPropertyValue (  @ NotNull", "final   Object   o )     {", "if    ( o   instanceof   XmlAttributeValue )     {", "final   XmlAttributeValue   value    =     (  ( XmlAttributeValue )     ( o )  )  ;", "final   PsiElement   parent    =    value . getParent (  )  ;", "if    ( parent   instanceof   XmlAttribute )     {", "return    (  ( XmlAttribute )     ( parent )  )  . getLocalName (  )  ;", "}", "if    ( parent   instanceof   XmlProcessingInstruction )     {", "PsiElement   prev    =    value . getPrevSibling (  )  ;", "if    (  (  !  ( prev   instanceof   XmlToken )  )     |  |     (  (  (  ( XmlToken )     ( prev )  )  . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ EQ )  )  )", "return   null ;", "prev    =    prev . getPrevSibling (  )  ;", "if    (  (  !  ( prev   instanceof   XmlToken )  )     |  |     (  (  (  ( XmlToken )     ( prev )  )  . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ NAME )  )  )", "return   null ;", "return   prev . getText (  )  ;", "}", "}", "return   null ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["withLocalName"], "fileName": "com.intellij.patterns.XmlAttributeValuePattern"}, {"methodBody": ["METHOD_START", "{", "return    ( names . length )     =  =     1     ?    withLocalName ( StandardPatterns . string (  )  . equalTo ( names [  0  ]  )  )     :    withLocalName ( StandardPatterns . string (  )  . oneOf ( names )  )  ;", "}", "METHOD_END"], "methodName": ["withLocalName"], "fileName": "com.intellij.patterns.XmlAttributeValuePattern"}, {"methodBody": ["METHOD_START", "{", "return   withLocalName ( StandardPatterns . string (  )  . oneOfIgnoreCase ( names )  )  ;", "}", "METHOD_END"], "methodName": ["withLocalNameIgnoreCase"], "fileName": "com.intellij.patterns.XmlAttributeValuePattern"}, {"methodBody": ["METHOD_START", "{", "return   with ( new   PsiNamePatternCondition < XmlAttributeValue >  (  \" withNamespace \"  ,    namePattern )     {", "@ Override", "public   String   getPropertyValue (  @ NotNull", "final   Object   o )     {", "if    ( o   instanceof   XmlAttributeValue )     {", "final   PsiElement   parent    =     (  ( XmlAttributeValue )     ( o )  )  . getParent (  )  ;", "if    ( parent   instanceof   XmlAttribute )     {", "return    (  ( XmlAttribute )     ( parent )  )  . getNamespace (  )  ;", "}", "}", "return   null ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["withNamespace"], "fileName": "com.intellij.patterns.XmlAttributeValuePattern"}, {"methodBody": ["METHOD_START", "{", "return    ( names . length )     =  =     1     ?    withNamespace ( StandardPatterns . string (  )  . equalTo ( names [  0  ]  )  )     :    withNamespace ( StandardPatterns . string (  )  . oneOf ( names )  )  ;", "}", "METHOD_END"], "methodName": ["withNamespace"], "fileName": "com.intellij.patterns.XmlAttributeValuePattern"}, {"methodBody": ["METHOD_START", "{", "return   with ( new   PatternCondition < XmlAttributeValue >  (  \" withValue \"  )     {", "@ Override", "public   boolean   accepts (  @ NotNull", "XmlAttributeValue   xmlAttributeValue ,    ProcessingContext   context )     {", "return   valuePattern . accepts ( xmlAttributeValue . getValue (  )  ,    context )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["withValue"], "fileName": "com.intellij.patterns.XmlAttributeValuePattern"}, {"methodBody": ["METHOD_START", "{", "return   XmlFilePattern . with ( new   PatternCondition < XmlFile >  (  \" withRootTag \"  )     {", "@ Override", "public   boolean   accepts (  @ NotNull", "final   XmlFile   xmlFile ,    final   ProcessingContext   context )     {", "XmlDocument   document    =    xmlFile . getDocument (  )  ;", "return    ( document    !  =    null )     &  &     ( rootTag . accepts ( document . getRootTag (  )  ,    context )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["withRootTag"], "fileName": "com.intellij.patterns.XmlFilePattern"}, {"methodBody": ["METHOD_START", "{", "return   XmlNamedElementPattern . with ( new   PsiNamePatternCondition < T >  (  \" withLocalName \"  ,    localName )     {", "@ Override", "public   String   getPropertyValue (  @ NotNull", "final   Object   o )     {", "return   o   instanceof   XmlElement    ?    getLocalName (  (  ( T )     ( o )  )  )     :    null ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["withLocalName"], "fileName": "com.intellij.patterns.XmlNamedElementPattern"}, {"methodBody": ["METHOD_START", "{", "return   withLocalName ( StandardPatterns . string (  )  . equalTo ( localName )  )  ;", "}", "METHOD_END"], "methodName": ["withLocalName"], "fileName": "com.intellij.patterns.XmlNamedElementPattern"}, {"methodBody": ["METHOD_START", "{", "return   withLocalName ( StandardPatterns . string (  )  . oneOf ( localNames )  )  ;", "}", "METHOD_END"], "methodName": ["withLocalName"], "fileName": "com.intellij.patterns.XmlNamedElementPattern"}, {"methodBody": ["METHOD_START", "{", "return   XmlNamedElementPattern . with ( new   PatternConditionPlus < T ,    String >  (  \" withNamespace \"  ,    namespace )     {", "@ Override", "public   boolean   processValues ( T   t ,    ProcessingContext   context ,    PairProcessor < String ,    ProcessingContext >    processor )     {", "return   processor . process ( getNamespace ( t )  ,    context )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["withNamespace"], "fileName": "com.intellij.patterns.XmlNamedElementPattern"}, {"methodBody": ["METHOD_START", "{", "return   withNamespace ( StandardPatterns . string (  )  . equalTo ( namespace )  )  ;", "}", "METHOD_END"], "methodName": ["withNamespace"], "fileName": "com.intellij.patterns.XmlNamedElementPattern"}, {"methodBody": ["METHOD_START", "{", "return   withNamespace ( StandardPatterns . string (  )  . oneOf ( namespaces )  )  ;", "}", "METHOD_END"], "methodName": ["withNamespace"], "fileName": "com.intellij.patterns.XmlNamedElementPattern"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlNamedElementPattern . XmlAttributePattern (  )  ;", "}", "METHOD_END"], "methodName": ["xmlAttribute"], "fileName": "com.intellij.patterns.XmlPatterns"}, {"methodBody": ["METHOD_START", "{", "return   XmlPatterns . xmlAttribute (  )  . withLocalName ( localName )  ;", "}", "METHOD_END"], "methodName": ["xmlAttribute"], "fileName": "com.intellij.patterns.XmlPatterns"}, {"methodBody": ["METHOD_START", "{", "return   XmlAttributeValuePattern . XML _ ATTRIBUTE _ VALUE _ PATTERN ;", "}", "METHOD_END"], "methodName": ["xmlAttributeValue"], "fileName": "com.intellij.patterns.XmlPatterns"}, {"methodBody": ["METHOD_START", "{", "for    ( final   PatternCondition <  ?    super   T >    condition    :    attributePattern . getCondition (  )  . getConditions (  )  )     {", "if    (  ( condition   instanceof   PsiNamePatternCondition )     &  &     (  \" withLocalName \"  . equals ( condition . getDebugMethodName (  )  )  )  )     {", "return    . xmlAttributeValue (  )  . withLocalName (  (  ( PsiNamePatternCondition <  ?  >  )     ( condition )  )  . getNamePattern (  )  )  . withParent ( attributePattern )  ;", "}", "}", "return    . xmlAttributeValue (  )  . withParent ( attributePattern )  ;", "}", "METHOD_END"], "methodName": ["xmlAttributeValue"], "fileName": "com.intellij.patterns.XmlPatterns"}, {"methodBody": ["METHOD_START", "{", "return   XmlPatterns . xmlAttributeValue (  )  . withLocalName ( localNames )  ;", "}", "METHOD_END"], "methodName": ["xmlAttributeValue"], "fileName": "com.intellij.patterns.XmlPatterns"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlElementPattern . XmlEntityRefPattern (  )  ;", "}", "METHOD_END"], "methodName": ["xmlEntityRef"], "fileName": "com.intellij.patterns.XmlPatterns"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlFilePattern . Capture (  )  ;", "}", "METHOD_END"], "methodName": ["xmlFile"], "fileName": "com.intellij.patterns.XmlPatterns"}, {"methodBody": ["METHOD_START", "{", "return   XmlTagPattern . Capture . XML _ TAG _ PATTERN ;", "}", "METHOD_END"], "methodName": ["xmlTag"], "fileName": "com.intellij.patterns.XmlPatterns"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlElementPattern . XmlTextPattern (  )  ;", "}", "METHOD_END"], "methodName": ["xmlText"], "fileName": "com.intellij.patterns.XmlPatterns"}, {"methodBody": ["METHOD_START", "{", "return   XmlTagPattern . with ( new   PatternCondition < XmlTag >  (  \" isFirstSubtag \"  )     {", "@ Override", "public   boolean   accepts (  @ NotNull", "final   XmlTag   xmlTag ,    final   ProcessingContext   context )     {", "final   XmlTag   parent    =    xmlTag . getParentTag (  )  ;", "return    (  ( parent    !  =    null )     &  &     ( pattern . accepts ( parent ,    context )  )  )     &  &     (  ( parent . getSubTags (  )  [  0  ]  )     =  =    xmlTag )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["isFirstSubtag"], "fileName": "com.intellij.patterns.XmlTagPattern"}, {"methodBody": ["METHOD_START", "{", "return   XmlTagPattern . with ( new   PatternCondition < XmlTag >  (  \" withAnyAttribute \"  )     {", "@ Override", "public   boolean   accepts (  @ NotNull", "final   XmlTag   xmlTag ,    final   ProcessingContext   context )     {", "for    ( String   attributeName    :    attributeNames )     {", "if    (  ( xmlTag . getAttribute ( attributeName )  )     !  =    null )     {", "return   true ;", "}", "}", "return   false ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["withAnyAttribute"], "fileName": "com.intellij.patterns.XmlTagPattern"}, {"methodBody": ["METHOD_START", "{", "return   XmlTagPattern . with ( new   PatternCondition < XmlTag >  (  \" withAttributeValue \"  )     {", "@ Override", "public   boolean   accepts (  @ NotNull", "final   XmlTag   xmlTag ,    final   ProcessingContext   context )     {", "return   Comparing . equal ( xmlTag . getAttributeValue ( attributeName )  ,    attributeValue )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["withAttributeValue"], "fileName": "com.intellij.patterns.XmlTagPattern"}, {"methodBody": ["METHOD_START", "{", "return   XmlTagPattern . with ( new   PatternCondition < XmlTag >  (  \" withDescriptor \"  )     {", "@ Override", "public   boolean   accepts (  @ NotNull", "final   XmlTag   xmlTag ,    final   ProcessingContext   context )     {", "return   metaDataPattern . accepts ( xmlTag . getDescriptor (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["withDescriptor"], "fileName": "com.intellij.patterns.XmlTagPattern"}, {"methodBody": ["METHOD_START", "{", "return   withSubTags ( StandardPatterns .  < XmlTag > collection (  )  . first ( pattern )  )  ;", "}", "METHOD_END"], "methodName": ["withFirstSubTag"], "fileName": "com.intellij.patterns.XmlTagPattern"}, {"methodBody": ["METHOD_START", "{", "return   XmlTagPattern . with ( new   PatternCondition < XmlTag >  (  \" withSubTags \"  )     {", "@ Override", "public   boolean   accepts (  @ NotNull", "final   XmlTag   xmlTag ,    final   ProcessingContext   context )     {", "return   pattern . accepts ( Arrays . asList ( xmlTag . getSubTags (  )  )  ,    context )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["withSubTags"], "fileName": "com.intellij.patterns.XmlTagPattern"}, {"methodBody": ["METHOD_START", "{", "return   and ( StandardPatterns . not ( withAttributeValue ( attributeName ,    attributeValue )  )  )  ;", "}", "METHOD_END"], "methodName": ["withoutAttributeValue"], "fileName": "com.intellij.patterns.XmlTagPattern"}, {"methodBody": ["METHOD_START", "{", "ASTNode   parent    =    changedElement . getTreeParent (  )  ;", "TreeChange   changesByElement    =    new   TreeChange (  (  ( CompositeElement )     ( parent )  )  )  ;", "changesByElement . markChildChanged (  (  ( TreeElement )     ( changedElement )  )  ,     0  )  ;", "return   changesByElement ;", "}", "METHOD_END"], "methodName": ["createChildrenChangedInfo"], "fileName": "com.intellij.pom.xml.impl.XmlAspectImpl"}, {"methodBody": ["METHOD_START", "{", "final   PomModelEvent   event    =    new   PomModelEvent ( model )  ;", "final   XmlAspectChangeSetImpl   xmlAspectChangeSet    =    new   XmlAspectChangeSetImpl ( model ,    PsiTreeUtil . getParentOfType ( xmlTag ,    XmlFile . class )  )  ;", "xmlAspectChangeSet . add ( new    ( xmlTag ,    name ,    value )  )  ;", "event . registerChangeSet ( model . getModelAspect ( XmlAspect . class )  ,    xmlAspectChangeSet )  ;", "return   event ;", "}", "METHOD_END"], "methodName": ["createXmlAttributeSet"], "fileName": "com.intellij.pom.xml.impl.events.XmlAttributeSetImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  \" Attribute    \\  \"  \"     +     ( getName (  )  )  )     +     \"  \\  \"    for   tag    \\  \"  \"  )     +     ( getTag (  )  . getName (  )  )  )     +     \"  \\  \"    set   to    \\  \"  \"  )     +     ( getValue (  )  )  )     +     \"  \\  \"  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.pom.xml.impl.events.XmlAttributeSetImpl"}, {"methodBody": ["METHOD_START", "{", "final   PomModelEvent   event    =    new   PomModelEvent ( source )  ;", "XmlFile   xmlFile    =    PsiTreeUtil . getParentOfType ( document ,    XmlFile . class )  ;", "final   XmlAspectChangeSetImpl   xmlAspectChangeSet    =    new   XmlAspectChangeSetImpl ( source ,    xmlFile )  ;", "xmlAspectChangeSet . add ( new    ( document )  )  ;", "event . registerChangeSet ( source . getModelAspect ( XmlAspect . class )  ,    xmlAspectChangeSet )  ;", "return   event ;", "}", "METHOD_END"], "methodName": ["createXmlDocumentChanged"], "fileName": "com.intellij.pom.xml.impl.events.XmlDocumentChangedImpl"}, {"methodBody": ["METHOD_START", "{", "return    \" Xml   document   changed \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.pom.xml.impl.events.XmlDocumentChangedImpl"}, {"methodBody": ["METHOD_START", "{", "return    \" Xml   element   changed :     \"     +     ( myElement )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.pom.xml.impl.events.XmlElementChangedImpl"}, {"methodBody": ["METHOD_START", "{", "final   PomModelEvent   event    =    new   PomModelEvent ( source )  ;", "final   XmlAspectChangeSetImpl   xmlAspectChangeSet    =    new   XmlAspectChangeSetImpl ( source ,    PsiTreeUtil . getParentOfType ( context ,    XmlFile . class )  )  ;", "xmlAspectChangeSet . add ( new    ( context ,    treeElement )  )  ;", "event . registerChangeSet ( source . getModelAspect ( XmlAspect . class )  ,    xmlAspectChangeSet )  ;", "return   event ;", "}", "METHOD_END"], "methodName": ["createXmlTagChildChanged"], "fileName": "com.intellij.pom.xml.impl.events.XmlTagChildChangedImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  (  \" child   changed   in    \"     +     ( getTag (  )  . getName (  )  )  )     +     \"    child :     \"  )     +     ( myChild . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.pom.xml.impl.events.XmlTagChildChangedImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  (  \" child   removed   from    \"     +     ( getTag (  )  . getName (  )  )  )     +     \"    child :     \"  )     +     ( myChild . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.pom.xml.impl.events.XmlTagChildRemovedImpl"}, {"methodBody": ["METHOD_START", "{", "final   PomModelEvent   event    =    new   PomModelEvent ( model )  ;", "final   XmlAspectChangeSetImpl   xmlAspectChangeSet    =    new   XmlAspectChangeSetImpl ( model ,    PsiTreeUtil . getParentOfType ( tag ,    XmlFile . class )  )  ;", "xmlAspectChangeSet . add ( new    ( tag ,    oldName )  )  ;", "event . registerChangeSet ( model . getModelAspect ( XmlAspect . class )  ,    xmlAspectChangeSet )  ;", "return   event ;", "}", "METHOD_END"], "methodName": ["createXmlTagNameChanged"], "fileName": "com.intellij.pom.xml.impl.events.XmlTagNameChangedImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  (  \" tag   name   changed   to    \"     +     ( getTag (  )  . getName (  )  )  )     +     \"    was :     \"  )     +     ( getOldName (  )  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.pom.xml.impl.events.XmlTagNameChangedImpl"}, {"methodBody": ["METHOD_START", "{", "final   PomModelEvent   event    =    new   PomModelEvent ( source )  ;", "final   XmlAspectChangeSetImpl   xmlAspectChangeSet    =    new   XmlAspectChangeSetImpl ( source ,    PsiTreeUtil . getParentOfType ( xmlText ,    XmlFile . class )  )  ;", "xmlAspectChangeSet . add ( new    ( xmlText ,    oldText )  )  ;", "event . registerChangeSet ( source . getModelAspect ( XmlAspect . class )  ,    xmlAspectChangeSet )  ;", "return   event ;", "}", "METHOD_END"], "methodName": ["createXmlTextChanged"], "fileName": "com.intellij.pom.xml.impl.events.XmlTextChangedImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  \" text   changed   to    '  \"     +     ( StringUtil . escapeStringCharacters ( myText . getValue (  )  )  )  )     +     \"  '    was :     '  \"  )     +     ( StringUtil . escapeStringCharacters ( myOldText )  )  )     +     \"  '  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.pom.xml.impl.events.XmlTextChangedImpl"}, {"methodBody": ["METHOD_START", "{", "return   ServiceManager . getService ( project ,    XmlElementFactory . class )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "com.intellij.psi.XmlElementFactory"}, {"methodBody": ["METHOD_START", "{", "final   char   quoteChar ;", "if    (  !  ( value . contains (  \"  \\  \"  \"  )  )  )     {", "quoteChar    =     '  \"  '  ;", "} else", "if    (  !  ( value . contains (  \"  '  \"  )  )  )     {", "quoteChar    =     '  \\  '  '  ;", "} else    {", "quoteChar    =     '  \"  '  ;", "value    =    com . intellij . openapi . util . text . StringUtil . replace ( value ,     \"  \\  \"  \"  ,     \"  & quot ;  \"  )  ;", "}", "final   XmlDocument   document    =    createXmlDocument (  (  (  (  (  (  (  \"  < tag    \"     +    name )     +     \"  =  \"  )     +    quoteChar )     +    value )     +    quoteChar )     +     \"  /  >  \"  )  ,     \" dummy . xml \"  ,    fileType )  ;", "XmlTag   tag    =    document . getRootTag (  )  ;", "assert   tag    !  =    null ;", "XmlAttribute [  ]    attributes    =    tag . getAttributes (  )  ;", ". LOG . assertTrue (  (  ( attributes . length )     =  =     1  )  ,    document . getText (  )  )  ;", "return   attributes [  0  ]  ;", "}", "METHOD_END"], "methodName": ["createAttribute"], "fileName": "com.intellij.psi.XmlElementFactoryImpl"}, {"methodBody": ["METHOD_START", "{", "PsiFile   fileFromText    =    PsiFileFactory . getInstance ( myProject )  . createFileFromText ( fileName ,    fileType ,    text )  ;", "XmlFile   xmlFile ;", "if    ( fileFromText   instanceof   XmlFile )     {", "xmlFile    =     (  ( XmlFile )     ( fileFromText )  )  ;", "} else    {", "xmlFile    =     (  ( XmlFile )     ( fileFromText . getViewProvider (  )  . getPsi (  (  ( LanguageFileType )     ( fileType )  )  . getLanguage (  )  )  )  )  ;", "assert   xmlFile    !  =    null ;", "}", "XmlDocument   document    =    xmlFile . getDocument (  )  ;", "assert   document    !  =    null ;", "return   document ;", "}", "METHOD_END"], "methodName": ["createXmlDocument"], "fileName": "com.intellij.psi.XmlElementFactoryImpl"}, {"methodBody": ["METHOD_START", "{", "visitXmlElement ( attribute )  ;", "}", "METHOD_END"], "methodName": ["visitXmlAttribute"], "fileName": "com.intellij.psi.XmlElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitXmlElement ( value )  ;", "}", "METHOD_END"], "methodName": ["visitXmlAttributeValue"], "fileName": "com.intellij.psi.XmlElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitXmlElement ( comment )  ;", "}", "METHOD_END"], "methodName": ["visitXmlComment"], "fileName": "com.intellij.psi.XmlElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitXmlElement ( decl )  ;", "}", "METHOD_END"], "methodName": ["visitXmlDecl"], "fileName": "com.intellij.psi.XmlElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitXmlElement ( xmlDoctype )  ;", "}", "METHOD_END"], "methodName": ["visitXmlDoctype"], "fileName": "com.intellij.psi.XmlElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitXmlElement ( document )  ;", "}", "METHOD_END"], "methodName": ["visitXmlDocument"], "fileName": "com.intellij.psi.XmlElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitElement ( element )  ;", "}", "METHOD_END"], "methodName": ["visitXmlElement"], "fileName": "com.intellij.psi.XmlElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitFile ( file )  ;", "}", "METHOD_END"], "methodName": ["visitXmlFile"], "fileName": "com.intellij.psi.XmlElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitXmlElement ( processingInstruction )  ;", "}", "METHOD_END"], "methodName": ["visitXmlProcessingInstruction"], "fileName": "com.intellij.psi.XmlElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitXmlElement ( prolog )  ;", "}", "METHOD_END"], "methodName": ["visitXmlProlog"], "fileName": "com.intellij.psi.XmlElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitXmlElement ( tag )  ;", "}", "METHOD_END"], "methodName": ["visitXmlTag"], "fileName": "com.intellij.psi.XmlElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitXmlElement ( text )  ;", "}", "METHOD_END"], "methodName": ["visitXmlText"], "fileName": "com.intellij.psi.XmlElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitXmlElement ( token )  ;", "}", "METHOD_END"], "methodName": ["visitXmlToken"], "fileName": "com.intellij.psi.XmlElementVisitor"}, {"methodBody": ["METHOD_START", "{", "String   elementValue    =    null ;", "if    ( element   instanceof   PsiNamedElement )     {", "if    ( element   instanceof   XmlTag )     {", "elementValue    =     (  ( XmlTag )     ( element )  )  . getLocalName (  )  ;", "} else    {", "elementValue    =     (  ( PsiNamedElement )     ( element )  )  . getName (  )  ;", "}", "} else", "if    ( element   instanceof   PsiElement )     {", "elementValue    =     (  ( PsiElement )     ( element )  )  . getText (  )  ;", "}", "return   elementValue ;", "}", "METHOD_END"], "methodName": ["getTextByElement"], "fileName": "com.intellij.psi.filters.XmlTextFilter"}, {"methodBody": ["METHOD_START", "{", "String   ret    =     \"  (  \"  ;", "for    (    i    =     0  ;    i    <     ( myValue . length )  ;    i +  +  )     {", "ret    +  =    myValue [ i ]  ;", "if    ( i    <     (  ( myValue . length )     -     1  )  )     {", "ret    +  =     \"     |     \"  ;", "}", "}", "ret    +  =     \"  )  \"  ;", "return   ret ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.psi.filters.XmlTextFilter"}, {"methodBody": ["METHOD_START", "{", "final   XmlAttributeDescriptor   descriptor    =    attribute . getDescriptor (  )  ;", "if    ( descriptor    =  =    null )     {", "return   ArrayUtil . EMPTY _ STRING _ ARRAY ;", "}", "String [  ]    result ;", "if    ( descriptor   instanceof   BasicXmlAttributeDescriptor )     {", "result    =     (  ( BasicXmlAttributeDescriptor )     ( descriptor )  )  . getEnumeratedValues ( attribute )  ;", "} else", "if    ( descriptor   instanceof   xml . impl . XmlEnumerationDescriptor )     {", "result    =     (  ( xml . impl . XmlEnumerationDescriptor )     ( descriptor )  )  . getValuesForCompletion (  )  ;", "} else    {", "result    =    descriptor . getEnumeratedValues (  )  ;", "}", "return   result    !  =    null    ?    StringUtil . filterEmptyStrings ( result )     :    ArrayUtil . EMPTY _ STRING _ ARRAY ;", "}", "METHOD_END"], "methodName": ["getEnumeratedValues"], "fileName": "com.intellij.psi.filters.getters.XmlAttributeValueGetter"}, {"methodBody": ["METHOD_START", "{", "for    ( String   aMyValue    :    myNamespaces )     {", "if    ( aMyValue . equals ( ns )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isNamespaceAcceptable"], "fileName": "com.intellij.psi.filters.position.NamespaceFilter"}, {"methodBody": ["METHOD_START", "{", "return    (  \" roottag (  \"     +     ( getFilter (  )  . toString (  )  )  )     +     \"  )  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.psi.filters.position.RootTagFilter"}, {"methodBody": ["METHOD_START", "{", "return    (  \" token - type (  \"     +     ( myType )  )     +     \"  )  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.psi.filters.position.XmlTokenTypeFilter"}, {"methodBody": ["METHOD_START", "{", "return   CodeStyleSettingsManager . getSettings ( getProject (  )  )  . getCustomSettings ( HtmlCodeStyleSettings . class )  ;", "}", "METHOD_END"], "methodName": ["getHtmlSettings"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "final   HtmlCodeStyleSettings   settings    =    HtmlFormatterTest . getHtmlSettings (  )  ;", "settings . HTML _ KEEP _ BLANK _ LINES    =     0  ;", "getSettings (  )  . setDefaultRightMargin (  1  4  0  )  ;", "settings . HTML _ ALIGN _ ATTRIBUTES    =    false ;", "settings . HTML _ ATTRIBUTE _ WRAP    =    CommonCodeStyleSettings . DO _ NOT _ WRAP ;", "settings . HTML _ ALIGN _ TEXT    =    false ;", "settings . HTML _ KEEP _ LINE _ BREAKS    =    false ;", "settings . HTML _ KEEP _ LINE _ BREAKS _ IN _ TEXT    =    false ;", "settings . HTML _ KEEP _ WHITESPACES    =    false ;", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["test1"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "final   HtmlCodeStyleSettings   settings    =    HtmlFormatterTest . getHtmlSettings (  )  ;", "settings . HTML _ KEEP _ LINE _ BREAKS    =    false ;", "getSettings (  )  . setDefaultRightMargin (  1  4  0  )  ;", "settings . HTML _ ALIGN _ ATTRIBUTES    =    false ;", "settings . HTML _ ATTRIBUTE _ WRAP    =    CommonCodeStyleSettings . DO _ NOT _ WRAP ;", "settings . HTML _ ALIGN _ TEXT    =    false ;", "settings . HTML _ KEEP _ LINE _ BREAKS    =    false ;", "settings . HTML _ KEEP _ WHITESPACES    =    false ;", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["test10"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTextTest (  (  \"  < p > foobar <  / p >  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"  < div > foobar <  / div >  \\ n \"     +     \"  < p > foobar <  / p >  \\ n \"  )     +     \"  < div > foobar <  / div >  \\ n \"  )     +     \"  < div > foobar <  / div >  \\ n \"  )     +     \"  < p > foobar <  / p >  \\ n \"  )     +     \"  < p > foobar <  / p >  \\ n \"  )     +     \"  < div >  \\ n \"  )     +     \"              < p > foobar <  / p >  \\ n \"  )     +     \"              < div > foobar <  / div >  \\ n \"  )     +     \"              < p > foobar <  / p >  \\ n \"  )     +     \"              < div > foobar <  / div >  \\ n \"  )     +     \"              < div > foobar <  / div >  \\ n \"  )     +     \"              < p > foobar <  / p >  \\ n \"  )     +     \"              < p > foobar <  / p >  \\ n \"  )     +     \"  <  / div >  \"  )  )  ,     (  \"  < p > foobar <  / p >  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"  < div > foobar <  / div >  \\ n \"     +     \"  < p > foobar <  / p >  \\ n \"  )     +     \"  < div > foobar <  / div >  \\ n \"  )     +     \"  < div > foobar <  / div >  \\ n \"  )     +     \"  < p > foobar <  / p >  \\ n \"  )     +     \"  < p > foobar <  / p >  \\ n \"  )     +     \"  < div >  \\ n \"  )     +     \"              < p > foobar <  / p >  \\ n \"  )     +     \"              < div > foobar <  / div >  \\ n \"  )     +     \"              < p > foobar <  / p >  \\ n \"  )     +     \"              < div > foobar <  / div >  \\ n \"  )     +     \"              < div > foobar <  / div >  \\ n \"  )     +     \"              < p > foobar <  / p >  \\ n \"  )     +     \"              < p > foobar <  / p >  \\ n \"  )     +     \"  <  / div >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["test10809"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "final   HtmlCodeStyleSettings   settings    =    HtmlFormatterTest . getHtmlSettings (  )  ;", "settings . HTML _ KEEP _ LINE _ BREAKS    =    false ;", "getSettings (  )  . setDefaultRightMargin (  1  4  0  )  ;", "settings . HTML _ ALIGN _ TEXT    =    false ;", "settings . HTML _ KEEP _ LINE _ BREAKS    =    false ;", "settings . HTML _ KEEP _ WHITESPACES    =    false ;", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["test11"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "final   HtmlCodeStyleSettings   settings    =    HtmlFormatterTest . getHtmlSettings (  )  ;", "settings . HTML _ KEEP _ LINE _ BREAKS    =    false ;", "getSettings (  )  . setDefaultRightMargin (  1  4  0  )  ;", "settings . HTML _ ALIGN _ TEXT    =    false ;", "settings . HTML _ KEEP _ LINE _ BREAKS    =    false ;", "settings . HTML _ KEEP _ WHITESPACES    =    false ;", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["test12"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "HtmlFormatterTest . getHtmlSettings (  )  . HTML _ KEEP _ LINE _ BREAKS    =    false ;", "doTextTest (  (  \"  < root >  \\ n \"     +     (  (  (  \"              < aaa /  >  \\ n \"     +     \"              < aaa >  <  / aaa >  \\ n \"  )     +     \"              < aaa /  >  \\ n \"  )     +     \"  <  / root >  \"  )  )  ,     (  \"  < root >  \\ n \"     +     (  (  (  \"              < aaa /  >  \\ n \"     +     \"              < aaa >  <  / aaa >  \\ n \"  )     +     \"              < aaa /  >  \\ n \"  )     +     \"  <  / root >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["test13"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["test2"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["test3"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["test4"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "final   HtmlCodeStyleSettings   settings    =    HtmlFormatterTest . getHtmlSettings (  )  ;", "settings . HTML _ ATTRIBUTE _ WRAP    =    CommonCodeStyleSettings . DO _ NOT _ WRAP ;", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["test5"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "final   HtmlCodeStyleSettings   settings    =    HtmlFormatterTest . getHtmlSettings (  )  ;", "getSettings (  )  . setDefaultRightMargin (  1  4  0  )  ;", "settings . HTML _ ALIGN _ ATTRIBUTES    =    false ;", "settings . HTML _ TEXT _ WRAP    =    CommonCodeStyleSettings . WRAP _ AS _ NEEDED ;", "settings . HTML _ ATTRIBUTE _ WRAP    =    CommonCodeStyleSettings . DO _ NOT _ WRAP ;", "settings . HTML _ KEEP _ WHITESPACES    =    false ;", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["test6"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "final   HtmlCodeStyleSettings   settings    =    HtmlFormatterTest . getHtmlSettings (  )  ;", "getSettings (  )  . setDefaultRightMargin (  1  4  0  )  ;", "settings . HTML _ ALIGN _ TEXT    =    false ;", "settings . HTML _ TEXT _ WRAP    =    CommonCodeStyleSettings . WRAP _ AS _ NEEDED ;", "settings . HTML _ KEEP _ LINE _ BREAKS    =    false ;", "settings . HTML _ KEEP _ WHITESPACES    =    false ;", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["test7"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "final   HtmlCodeStyleSettings   settings    =    HtmlFormatterTest . getHtmlSettings (  )  ;", "getSettings (  )  . setDefaultRightMargin (  1  4  0  )  ;", "settings . HTML _ ALIGN _ TEXT    =    false ;", "settings . HTML _ TEXT _ WRAP    =    CommonCodeStyleSettings . WRAP _ AS _ NEEDED ;", "settings . HTML _ ATTRIBUTE _ WRAP    =    CommonCodeStyleSettings . DO _ NOT _ WRAP ;", "settings . HTML _ KEEP _ LINE _ BREAKS    =    false ;", "settings . HTML _ KEEP _ WHITESPACES    =    false ;", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["test8"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "final   HtmlCodeStyleSettings   settings    =    HtmlFormatterTest . getHtmlSettings (  )  ;", "getSettings (  )  . setDefaultRightMargin (  1  4  0  )  ;", "settings . HTML _ ALIGN _ TEXT    =    false ;", "settings . HTML _ ALIGN _ ATTRIBUTES    =    false ;", "settings . HTML _ TEXT _ WRAP    =    CommonCodeStyleSettings . WRAP _ AS _ NEEDED ;", "settings . HTML _ ATTRIBUTE _ WRAP    =    CommonCodeStyleSettings . DO _ NOT _ WRAP ;", "settings . HTML _ KEEP _ LINE _ BREAKS    =    false ;", "settings . HTML _ KEEP _ WHITESPACES    =    false ;", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["test9"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testBody"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTextTest (  \"  < div > ReSharper <  / div >  \"  ,     \"  < div > ReSharper <  / div >  \"  )  ;", "doTextTest (  \"  < div > Re \\ nSharper <  / div >  \"  ,     \"  < div > Re \\ n            Sharper \\ n <  / div >  \"  )  ;", "doTextTest (  \"  < div > Re \\ nSharper    <  / div >  \"  ,     \"  < div > Re \\ n            Sharper \\ n <  / div >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testClosingDivOnNextLine"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testDontAddBreaksInside"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testH1"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "@ NonNls", "String   fileText    =     \"  < html >  \\ n \"     +     (  (  (  (  (  \"        < head >  < title > Simple   jsp   page <  / title >  <  / head >  \\ n \"     +     \"        < body >  \\ n \"  )     +     \"  < p > Place   your   co <  / p >  \\ n \"  )     +     \"  < p > ntent   here <  / p >  \\ n \"  )     +     \"  <  / body >  \\ n \"  )     +     \"  <  / html >  \"  )  ;", "XmlFile   file    =     (  ( XmlFile )     ( PsiFileFactory . getInstance ( getProject (  )  )  . createFileFromText (  \" test . html \"  ,    fileText )  )  )  ;", "final   XmlTag   bodyTag    =    file . getDocument (  )  . getRootTag (  )  . getSubTags (  )  [  1  ]  ;", "CodeStyleManager . getInstance ( getProject (  )  )  . reRange ( bodyTag ,    bodyTag . getTextRange (  )  . getStartOffset (  )  ,    bodyTag . getTextRange (  )  . getEndOffset (  )  )  ;", "}", "METHOD_END"], "methodName": ["testHtmlReformatDoesntProduceAssertion"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "CommonCodeStyleSettings . IndentOptions   htmlIndentOptions    =    getSettings (  )  . getCommonSettings ( HTMLLanguage . INSTANCE )  . getIndentOptions (  )  ;", "assert   htmlIndentOptions    !  =    null    :     \" HTML   Indent   options   not   found !  \"  ;", "int   indentSize    =    htmlIndentOptions . INDENT _ SIZE    =     2  ;", "int   contIndentSize    =    htmlIndentOptions . CONTINUATION _ INDENT _ SIZE ;", "try    {", "htmlIndentOptions . INDENT _ SIZE    =     2  ;", "htmlIndentOptions . CONTINUATION _ INDENT _ SIZE    =     3  ;", "do (  )  ;", "}    finally    {", "htmlIndentOptions . INDENT _ SIZE    =    indentSize ;", "htmlIndentOptions . CONTINUATION _ INDENT _ SIZE    =    contIndentSize ;", "}", "}", "METHOD_END"], "methodName": ["testIndent"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testInvalidChar"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTextTest (  \"  < html >  < body >  < table >  <  / table >  <  / body >  <  / html >  \"  ,     (  \"  < html >  \\ n \"     +     (  (  (  \"  < body >  \\ n \"     +     \"  < table >  <  / table >  \\ n \"  )     +     \"  <  / body >  \\ n \"  )     +     \"  <  / html >  \"  )  )  )  ;", "doTextTest (  \"  < html >  < body >  < table >  <  / table >  < tag >  <  / tag >  <  / body >  <  / html >  \"  ,     (  \"  < html >  \\ n \"     +     (  (  (  (  \"  < body >  \\ n \"     +     \"  < table >  <  / table >  \\ n \"  )     +     \"  < tag >  <  / tag >  \\ n \"  )     +     \"  <  / body >  \\ n \"  )     +     \"  <  / html >  \"  )  )  )  ;", "doTextTest (  \"  < html >  < body >  < table >  <  / table >    text <  / body >  <  / html >  \"  ,     (  \"  < html >  \\ n \"     +     (  (  (  (  \"  < body >  \\ n \"     +     \"  < table >  <  / table >  \\ n \"  )     +     \" text \\ n \"  )     +     \"  <  / body >  \\ n \"  )     +     \"  <  / html >  \"  )  )  )  ;", "doTextTest (  \"  < html >  < body >  < table >  <  / table > text <  / body >  <  / html >  \"  ,     (  \"  < html >  \\ n \"     +     (  (  (  (  \"  < body >  \\ n \"     +     \"  < table >  <  / table >  \\ n \"  )     +     \" text \\ n \"  )     +     \"  <  / body >  \\ n \"  )     +     \"  <  / html >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testLineFeedAfterWrappedTag"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "final   HtmlCodeStyleSettings   settings    =    HtmlFormatterTest . getHtmlSettings (  )  ;", "settings . HTML _ NEWLINE _ BEFORE _ FIRST _ ATTRIBUTE    =    HtmlTagNewLineStyle . WhenMultiline ;", "settings . HTML _ NEWLINE _ AFTER _ LAST _ ATTRIBUTE    =    HtmlTagNewLineStyle . WhenMultiline ;", "String   source    =     \"  < div   class =  \\  \" singleline \\  \"    foo =  \\  \"  1  \\  \"    bar =  \\  \"  2  \\  \"  /  >  \\ n \"     +     (  (  (  (  (  (  (  \"  < div   class =  \\  \" singleline \\  \"  >  <  / div >  \\ n \"     +     \"  < div   class =  \\  \" multiline \\  \"    foo =  \\  \"  1  \\  \"  \\ n \"  )     +     \"                               bar =  \\  \"  2  \\  \"  >  <  / div >  \\ n \"  )     +     \"  < div   class =  \\  \" selfClosingMultiline \\  \"    foo =  \\  \"  1  \\  \"    bar =  \\  \"  2  \\  \"  \\ n \"  )     +     \"  /  >  \\ n \"  )     +     \"  <  !  -  - void   tags -  -  >  \\ n \"  )     +     \"  < input   type =  \\  \" button \\  \"    value =  \\  \" Ok \\  \"  >  \\ n \"  )     +     \"  < br >  \\ n \"  )  ;", "doTextTest ( source ,     (  \"  < div   class =  \\  \" singleline \\  \"    foo =  \\  \"  1  \\  \"    bar =  \\  \"  2  \\  \"  /  >  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  \"  < div   class =  \\  \" singleline \\  \"  >  <  / div >  \\ n \"     +     \"  < div \\ n \"  )     +     \"                         class =  \\  \" multiline \\  \"    foo =  \\  \"  1  \\  \"  \\ n \"  )     +     \"                         bar =  \\  \"  2  \\  \"  \\ n \"  )     +     \"  >  <  / div >  \\ n \"  )     +     \"  < div \\ n \"  )     +     \"                         class =  \\  \" selfClosingMultiline \\  \"    foo =  \\  \"  1  \\  \"    bar =  \\  \"  2  \\  \"  \\ n \"  )     +     \"  /  >  \\ n \"  )     +     \"  <  !  -  - void   tags -  -  >  \\ n \"  )     +     \"  < input   type =  \\  \" button \\  \"    value =  \\  \" Ok \\  \"  >  \\ n \"  )     +     \"  < br >  \\ n \"  )  )  )  ;", "settings . HTML _ SPACE _ INSIDE _ EMPTY _ TAG    =    true ;", "doTextTest ( source ,     (  \"  < div   class =  \\  \" singleline \\  \"    foo =  \\  \"  1  \\  \"    bar =  \\  \"  2  \\  \"     /  >  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  \"  < div   class =  \\  \" singleline \\  \"  >  <  / div >  \\ n \"     +     \"  < div \\ n \"  )     +     \"                         class =  \\  \" multiline \\  \"    foo =  \\  \"  1  \\  \"  \\ n \"  )     +     \"                         bar =  \\  \"  2  \\  \"  \\ n \"  )     +     \"  >  <  / div >  \\ n \"  )     +     \"  < div \\ n \"  )     +     \"                         class =  \\  \" selfClosingMultiline \\  \"    foo =  \\  \"  1  \\  \"    bar =  \\  \"  2  \\  \"  \\ n \"  )     +     \"  /  >  \\ n \"  )     +     \"  <  !  -  - void   tags -  -  >  \\ n \"  )     +     \"  < input   type =  \\  \" button \\  \"    value =  \\  \" Ok \\  \"  >  \\ n \"  )     +     \"  < br >  \\ n \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultilineTags_NewlinesBeforeAndAfterAttributes"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testRemoveSpacesBeforeSpanInBody"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "getSettings (  )  . setDefaultRightMargin (  5  )  ;", ". getHtmlSettings (  )  . HTML _ TEXT _ WRAP    =    CommonCodeStyleSettings . WRAP _ AS _ NEEDED ;", "doTextTest (  (  \"  < html >  \\ n \"     +     (  \" text   textV & aelig ; lg   JE \\ n \"     +     \"  <  / html >  \"  )  )  ,     (  \"  < html >  \\ n \"     +     (  (  (  \" text \\ n \"     +     \" textV & aelig ; lg \\ n \"  )     +     \" JE \\ n \"  )     +     \"  <  / html >  \"  )  )  )  ;", "getSettings (  )  . setDefaultRightMargin (  2  )  ;", "doTextTest (  \"  < html >  < a >  & aelig ;  <  / a >  <  / html >  \"  ,     (  \"  < html >  \\ n \"     +     (  \"  < a >  & aelig ;  <  / a >  \\ n \"     +     \"  <  / html >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSCR3654"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "final   HtmlCodeStyleSettings   settings    =    HtmlFormatterTest . getHtmlSettings (  )  ;", "CodeStyleSettings . QuoteStyle   quoteStyle    =    settings . HTML _ QUOTE _ STYLE ;", "boolean   enforce    =    settings . HTML _ ENFORCE _ QUOTES ;", "try    {", "settings . HTML _ QUOTE _ STYLE    =    QuoteStyle . Single ;", "settings . HTML _ ENFORCE _ QUOTES    =    true ;", "doTest (  )  ;", "}    finally    {", "settings . HTML _ QUOTE _ STYLE    =    quoteStyle ;", "settings . HTML _ ENFORCE _ QUOTES    =    enforce ;", "}", "}", "METHOD_END"], "methodName": ["testSingleQuotes"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "final   HtmlCodeStyleSettings   settings    =    HtmlFormatterTest . getHtmlSettings (  )  ;", "settings . HTML _ SPACE _ INSIDE _ EMPTY _ TAG    =    true ;", "doTextTest (  (  \"  < div   class =  \\  \" emptyWithAttributes \\  \"  /  >  \\ n \"     +     (  \"  < div /  >  \\ n \"     +     \"  < div   class =  \\  \" notEmpty \\  \"  >  <  / div >  \"  )  )  ,     (  \"  < div   class =  \\  \" emptyWithAttributes \\  \"     /  >  \\ n \"     +     (  \"  < div    /  >  \\ n \"     +     \"  < div   class =  \\  \" notEmpty \\  \"  >  <  / div >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpaceInEmptyTag"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTextTest (  \"  < div >    text    < div /  >    text    < div >    text    <  / div >     <  / div >  \"  ,     (  \"  < div >    text \\ n \"     +     (  (  (  \"              < div /  >  \\ n \"     +     \"             text \\ n \"  )     +     \"              < div >    text <  / div >  \\ n \"  )     +     \"  <  / div >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpaces"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testTableformatting"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTextTest (  (  \"  < div    \\ n \"     +     (  (  \" id =  \\  \" some \\  \"  \\ n \"     +     \" class =  \\  \" some \\  \"  \\ n \"  )     +     \"  >  \"  )  )  ,     (  \"  < div \\ n \"     +     (  (  \"                         id =  \\  \" some \\  \"  \\ n \"     +     \"                         class =  \\  \" some \\  \"  \\ n \"  )     +     \"  >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testWeb12840"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTextTest (  (  \"  < div   id =  \\  \" top \\  \"  >  <  / div >  <  !  -  -     /  # top    -  -  >  \\ n \"     +     (  (  \"  < div   id =  \\  \" nav \\  \"  >  \\ n \"     +     \"  < div   id =  \\  \" logo \\  \"  >  <  / div >  <  !  -  -     /  # logo    -  -  >  \\ n \"  )     +     \"  <  / div >  \"  )  )  ,     (  \"  < div   id =  \\  \" top \\  \"  >  <  / div >  <  !  -  -     /  # top    -  -  >  \\ n \"     +     (  (  \"  < div   id =  \\  \" nav \\  \"  >  \\ n \"     +     \"              < div   id =  \\  \" logo \\  \"  >  <  / div >  <  !  -  -     /  # logo    -  -  >  \\ n \"  )     +     \"  <  / div >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testWeb12937"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTextTest (  (  \"  < img \\ n \"     +     (  (  (  (  \" id =  \\  \" image - id \\  \"  \\ n \"     +     \" className =  \\  \" thumbnail \\  \"  \\ n \"  )     +     \" src =  \\  \"  / some / path / to / the / images / image - name . png \\  \"  \\ n \"  )     +     \" alt =  \\  ' image \\  '  \\ n \"  )     +     \"  /  >  \"  )  )  ,     (  \"  < img \\ n \"     +     (  (  (  (  \"                         id =  \\  \" image - id \\  \"  \\ n \"     +     \"                         className =  \\  \" thumbnail \\  \"  \\ n \"  )     +     \"                         src =  \\  \"  / some / path / to / the / images / image - name . png \\  \"  \\ n \"  )     +     \"                         alt =  \\  ' image \\  '  \\ n \"  )     +     \"  /  >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testWeb16223"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTextTest (  (  \"  < div   class =  \\  \" s \\  \"  >  \\ n \"     +     (  (  (  (  \"              < span   class =  \\  \" loading \\  \"  >  <  / span >  \\ n \"     +     \"                          < span >  \\ n \"  )     +     \"                         Loading .  .  .  \\ n \"  )     +     \"                          <  / span >  \\ n \"  )     +     \"  <  / div >  \"  )  )  ,     (  \"  < div   class =  \\  \" s \\  \"  >  \\ n \"     +     (  (  (  (  \"              < span   class =  \\  \" loading \\  \"  >  <  / span >  \\ n \"     +     \"              < span >  \\ n \"  )     +     \"                         Loading .  .  .  \\ n \"  )     +     \"                          <  / span >  \\ n \"  )     +     \"  <  / div >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testWeb18213"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTextTest (  (  \"  <  ! doctype   html >  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  \"  < html >  \\ n \"     +     \"  < body >  \\ n \"  )     +     \"  < section >  \\ n \"  )     +     \"              < pre >  < code   class =  \\  \" language - javascript \\  \"  > function   test ( i )     {  \\ n \"  )     +     \"             if    ( i =  =  =  1  )     {  \\ n \"  )     +     \"                         console . log (  \\  ' output \\  '  )  ;  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"  }  <  / code >  <  / pre >  \\ n \"  )     +     \"  <  / section >  \\ n \"  )     +     \"  <  / body >  \\ n \"  )     +     \"  <  / html >  \"  )  )  ,     (  \"  <  ! doctype   html >  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  \"  < html >  \\ n \"     +     \"  < body >  \\ n \"  )     +     \"  < section >  \\ n \"  )     +     \"              < pre >  < code   class =  \\  \" language - javascript \\  \"  > function   test ( i )     {  \\ n \"  )     +     \"             if    ( i =  =  =  1  )     {  \\ n \"  )     +     \"                         console . log (  \\  ' output \\  '  )  ;  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"  }  <  / code >  <  / pre >  \\ n \"  )     +     \"  <  / section >  \\ n \"  )     +     \"  <  / body >  \\ n \"  )     +     \"  <  / html >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testWeb18909"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "final   HtmlCodeStyleSettings   settings    =    HtmlFormatterTest . getHtmlSettings (  )  ;", "int   noIndentMinLines    =    settings . HTML _ DO _ NOT _ ALIGN _ CHILDREN _ OF _ MIN _ LINES ;", "settings . HTML _ DO _ NOT _ ALIGN _ CHILDREN _ OF _ MIN _ LINES    =     3  ;", "try    {", "doTextTest (  (  \"  < table >  \\ n \"     +     (  (  (  (  (  (  (  \"  < tr >  \\ n \"     +     \"              < td > Cell    1  .  <  / td >  \\ n \"  )     +     \"              < td > Cell    2  .  <  / td >  \\ n \"  )     +     \"  <  / tr >  \\ n \"  )     +     \"  < tr >  \\ n \"  )     +     \"              < td > Cell    3  .  <  / td >  \\ n \"  )     +     \"  <  / tr >  \\ n \"  )     +     \"  <  / table >  \"  )  )  ,     (  \"  < table >  \\ n \"     +     (  (  (  (  (  (  (  \"  < tr >  \\ n \"     +     \"  < td > Cell    1  .  <  / td >  \\ n \"  )     +     \"  < td > Cell    2  .  <  / td >  \\ n \"  )     +     \"  <  / tr >  \\ n \"  )     +     \"  < tr >  \\ n \"  )     +     \"              < td > Cell    3  .  <  / td >  \\ n \"  )     +     \"  <  / tr >  \\ n \"  )     +     \"  <  / table >  \"  )  )  )  ;", "}    finally    {", "settings . HTML _ DO _ NOT _ ALIGN _ CHILDREN _ OF _ MIN _ LINES    =    noIndentMinLines ;", "}", "}", "METHOD_END"], "methodName": ["testWeb2405"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTextTest (  (  \"  < html >  \\ n \"     +     (  (  (  (  (  (  (  \"  < body >  \\ n \"     +     \"  < label >  \\ n \"  )     +     \"              < textarea >  \\ n \"  )     +     \" This   my   text   which   should   appear   as   is \\ n \"  )     +     \"  <  / textarea >  \\ n \"  )     +     \"  <  / label >  \\ n \"  )     +     \"  <  / body >  \\ n \"  )     +     \"  <  / html >  \"  )  )  ,     (  \"  < html >  \\ n \"     +     (  (  (  (  (  (  (  \"  < body >  \\ n \"     +     \"  < label >  \\ n \"  )     +     \"              < textarea >  \\ n \"  )     +     \" This   my   text   which   should   appear   as   is \\ n \"  )     +     \"  <  / textarea >  \\ n \"  )     +     \"  <  / label >  \\ n \"  )     +     \"  <  / body >  \\ n \"  )     +     \"  <  / html >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testWeb456"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "@ NonNls", "String   fileText    =     \"  < html >  \\ n \"     +     (  (  (  (  (  \"        < head >  < title > Simple   jsp   page <  / title >  <  / head >  \\ n \"     +     \"        < body >  \\ n \"  )     +     \"  < p > Place   your   co <  / p >  \\ n \"  )     +     \"  < p > ntent   here <  / p >  \\ n \"  )     +     \"  <  / body >  \\ n \"  )     +     \"  <  / html >  \"  )  ;", "XmlFile   file    =     (  ( XmlFile )     ( PsiFileFactory . getInstance ( getProject (  )  )  . createFileFromText (  \" test . xhtml \"  ,    fileText )  )  )  ;", "final   XmlTag   bodyTag    =    file . getDocument (  )  . getRootTag (  )  . getSubTags (  )  [  1  ]  ;", "CodeStyleManager . getInstance ( getProject (  )  )  . reRange ( bodyTag ,    bodyTag . getTextRange (  )  . getStartOffset (  )  ,    bodyTag . getTextRange (  )  . getEndOffset (  )  )  ;", "}", "METHOD_END"], "methodName": ["testXhtmlReformatDoesntProduceAssertion"], "fileName": "com.intellij.psi.formatter.HtmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "Runtime   runtime    =    Runtime . getRuntime (  )  ;", "long   maxMemory    =    runtime . maxMemory (  )  ;", "return    ( runtime . freeMemory (  )  )     +     ( maxMemory    -     ( runtime . totalMemory (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["currentFreeMemory"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "CodeStyleSettings   settings    =    getSettings (  )  ;", "XmlCodeStyleSettings   xmlSettings    =    getSettings (  )  . getCustomSettings ( XmlCodeStyleSettings . class )  ;", "xmlSettings . XML _ ATTRIBUTE _ WRAP    =    CommonCodeStyleSettings . WRAP _ ON _ EVERY _ ITEM ;", "settings . setRightMargin ( XMLLanguage . INSTANCE ,    rightMargin )  ;", "xmlSettings . XML _ ALIGN _ ATTRIBUTES    =    align ;", "do ( resultNumber )  ;", "}", "METHOD_END"], "methodName": ["doChopDownIfLong"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "XmlCodeStyleSettings   xmlSettings    =    getSettings (  )  . getCustomSettings ( XmlCodeStyleSettings . class )  ;", "boolean   oldValue    =    xmlSettings . XML _ KEEP _ WHITESPACES ;", "xmlSettings . XML _ KEEP _ WHITESPACES    =    false ;", "xmlSettings . XML _ KEEP _ LINE _ BREAKS    =    false ;", "xmlSettings . XML _ KEEP _ LINE _ BREAKS _ IN _ TEXT    =    false ;", "try    {", "do (  )  ;", "}    finally    {", "xmlSettings . XML _ KEEP _ WHITESPACES    =    oldValue ;", "}", "}", "METHOD_END"], "methodName": ["doTestDoNotKeepingWhitespaces"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "XmlCodeStyleSettings   xmlSettings    =    getSettings (  )  . getCustomSettings ( XmlCodeStyleSettings . class )  ;", "boolean   oldValue    =    xmlSettings . XML _ KEEP _ WHITESPACES ;", "xmlSettings . XML _ KEEP _ WHITESPACES    =    false ;", "xmlSettings . XML _ KEEP _ LINE _ BREAKS    =    true ;", "try    {", "do (  )  ;", "}    finally    {", "xmlSettings . XML _ KEEP _ WHITESPACES    =    oldValue ;", "}", "}", "METHOD_END"], "methodName": ["doTestDoNotKeepingWhitespacesKeepingLineBreaks"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "CodeStyleSettings   settings    =    getSettings (  )  ;", "XmlCodeStyleSettings   xmlSettings    =    getSettings (  )  . getCustomSettings ( XmlCodeStyleSettings . class )  ;", "boolean   oldValue    =    xmlSettings . XML _ KEEP _ WHITESPACES ;", "xmlSettings . XML _ ATTRIBUTE _ WRAP    =    CommonCodeStyleSettings . DO _ NOT _ WRAP ;", "xmlSettings . XML _ KEEP _ LINE _ BREAKS    =    true ;", "settings . setRightMargin ( XMLLanguage . INSTANCE ,    rightMargin )  ;", "xmlSettings . XML _ ALIGN _ ATTRIBUTES    =    align ;", "try    {", "do ( resultNumber )  ;", "}    finally    {", "xmlSettings . XML _ KEEP _ WHITESPACES    =    oldValue ;", "}", "}", "METHOD_END"], "methodName": ["doTestDoNotWrap"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "XmlCodeStyleSettings   xmlSettings    =    getSettings (  )  . getCustomSettings ( XmlCodeStyleSettings . class )  ;", "boolean   oldValue    =    xmlSettings . XML _ KEEP _ WHITESPACES ;", "xmlSettings . XML _ KEEP _ WHITESPACES    =    true ;", "try    {", "do ( s )  ;", "}    finally    {", "xmlSettings . XML _ KEEP _ WHITESPACES    =    oldValue ;", "}", "}", "METHOD_END"], "methodName": ["doTestKeepingWhitespacesStrictly"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "CodeStyleSettings   settings    =    getSettings (  )  ;", "XmlCodeStyleSettings   xmlSettings    =    getSettings (  )  . getCustomSettings ( XmlCodeStyleSettings . class )  ;", "xmlSettings . XML _ ATTRIBUTE _ WRAP    =    CommonCodeStyleSettings . WRAP _ AS _ NEEDED ;", "settings . setRightMargin ( XMLLanguage . INSTANCE ,    rightMargin )  ;", "xmlSettings . XML _ ALIGN _ ATTRIBUTES    =    align ;", "do ( resultNumber )  ;", "}", "METHOD_END"], "methodName": ["doTestWrapIfLong"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "CodeStyleSettings   settings    =    getSettings (  )  ;", "XmlCodeStyleSettings   xmlSettings    =    getSettings (  )  . getCustomSettings ( XmlCodeStyleSettings . class )  ;", "xmlSettings . XML _ ATTRIBUTE _ WRAP    =    CommonCodeStyleSettings . WRAP _ ALWAYS ;", "settings . setRightMargin ( XMLLanguage . INSTANCE ,    rightMargin )  ;", "xmlSettings . XML _ ALIGN _ ATTRIBUTES    =    align ;", "do ( resultNumber )  ;", "}", "METHOD_END"], "methodName": ["doWrapAlways"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "if    (  !  (  \" lesya \"  . equals ( SystemProperties . getUserName (  )  )  )  )", "return ;", "String   name    =     \" stress . xml \"  ;", "final   PsiFile   file    =    createFile ( name ,    loadFile ( name ,    null )  )  ;", "long   memoryBefore    =     . currentFreeMemory (  )  ;", "long   timeBefore    =    System . currentTimeMillis (  )  ;", "CommandProcessor . getInstance (  )  . executeCommand ( getProject (  )  ,     (  )     -  >    ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >    performFormatting ( file )  )  ,     \"  \"  ,     \"  \"  )  ;", "long   memoryAfter    =     . currentFreeMemory (  )  ;", "long   timeAfter    =    System . currentTimeMillis (  )  ;", "System . out . println (  (  \"  \\ nMEMORY :     \"     +     ( memoryAfter    -    memoryBefore )  )  )  ;", "System . out . println (  (  \"  \\ nTIME :     \"     +     ( timeAfter    -    timeBefore )  )  )  ;", "}", "METHOD_END"], "methodName": ["excluded_testStressTest"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["test1"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "XmlCodeStyleSettings   xmlSettings    =    getSettings (  )  . getCustomSettings ( XmlCodeStyleSettings . class )  ;", "xmlSettings . XML _ ALIGN _ TEXT    =    true ;", "doDoNotKeepingWhitespacesKeepingLineBreaks (  )  ;", "}", "METHOD_END"], "methodName": ["test10"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTestDoNotWrap (  \" DO _ NOT _ WRAP \"  ,    true ,     1  0  )  ;", "doTestWrapIfLong (  \" WRAP _ IF _ LONG \"  ,    true ,     3  7  )  ;", "doChopDownIfLong (  \" CHOP _ IF _ LONG \"  ,    true ,     3  7  )  ;", "doWrapAlways (  \" WRAP _ ALWAYS \"  ,    true ,     1  4  0  )  ;", "doTestDoNotWrap (  \" ALIGN _ DO _ NOT _ WRAP \"  ,    false ,     1  0  )  ;", "doTestWrapIfLong (  \" ALIGN _ WRAP _ IF _ LONG \"  ,    false ,     3  7  )  ;", "doChopDownIfLong (  \" ALIGN _ CHOP _ IF _ LONG \"  ,    false ,     3  7  )  ;", "doWrapAlways (  \" ALIGN _ WRAP _ ALWAYS \"  ,    false ,     1  4  0  )  ;", "}", "METHOD_END"], "methodName": ["test11"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["test12"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "XmlCodeStyleSettings   xmlSettings    =    getSettings (  )  . getCustomSettings ( XmlCodeStyleSettings . class )  ;", "xmlSettings . XML _ KEEP _ LINE _ BREAKS    =    true ;", "xmlSettings . XML _ KEEP _ BLANK _ LINES    =     2  ;", "doDoNotWrap ( null ,    false ,     1  4  0  )  ;", "}", "METHOD_END"], "methodName": ["test13"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["test14"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["test15"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTestKeepingWhitespacesStrictly ( null )  ;", "}", "METHOD_END"], "methodName": ["test16"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "CodeStyleSettings   settings    =    getSettings (  )  ;", "XmlCodeStyleSettings   xmlSettings    =    settings . getCustomSettings ( XmlCodeStyleSettings . class )  ;", "xmlSettings . XML _ SPACE _ AROUND _ EQUALITY _ IN _ ATTRIBUTE    =    true ;", "xmlSettings . XML _ SPACE _ AFTER _ TAG _ NAME    =    true ;", "try    {", "do (  )  ;", "}    finally    {", "xmlSettings . XML _ SPACE _ AROUND _ EQUALITY _ IN _ ATTRIBUTE    =    false ;", "xmlSettings . XML _ SPACE _ AFTER _ TAG _ NAME    =    false ;", "}", "}", "METHOD_END"], "methodName": ["test17"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "checkFormattingDoesNotProduceException (  \"  1  8  \"  )  ;", "}", "METHOD_END"], "methodName": ["test18"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "myTextRange    =    new   TextRange (  3  1  ,     4  9  )  ;", "do (  )  ;", "}", "METHOD_END"], "methodName": ["test19"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["test2"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["test20"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "CodeStyleSettingsManager . getSettings ( getProject (  )  )  . setRightMargin ( XMLLanguage . INSTANCE ,     2  0  )  ;", "do (  )  ;", "}", "METHOD_END"], "methodName": ["test21"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["test22"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["test3"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["test4"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["test5"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTestKeepingWhitespacesStrictly ( null )  ;", "}", "METHOD_END"], "methodName": ["test6"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTestKeepingWhitespacesStrictly ( null )  ;", "}", "METHOD_END"], "methodName": ["test7"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "final   CodeStyleSettings   settings    =    getSettings (  )  ;", "XmlCodeStyleSettings   xmlSettings    =    getSettings (  )  . getCustomSettings ( XmlCodeStyleSettings . class )  ;", "xmlSettings . XML _ TEXT _ WRAP    =    CommonCodeStyleSettings . WRAP _ AS _ NEEDED ;", "settings . setRightMargin ( XMLLanguage . INSTANCE ,     3  2  )  ;", "doDoNotKeepingWhitespaces (  )  ;", "}", "METHOD_END"], "methodName": ["test8"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "XmlCodeStyleSettings   xmlSettings    =    getSettings (  )  . getCustomSettings ( XmlCodeStyleSettings . class )  ;", "xmlSettings . XML _ TEXT _ WRAP    =    CommonCodeStyleSettings . WRAP _ AS _ NEEDED ;", "doDoNotKeepingWhitespaces (  )  ;", "}", "METHOD_END"], "methodName": ["test9"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "doTestDoNotKeepingWhitespaces (  )  ;", "}", "METHOD_END"], "methodName": ["testCDATA"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testComment"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" DO _ NOT _ KEEP _ WHITESPACES \"  )  ;", "doTestKeepingWhitespacesStrictly (  \" KEEP _ WHITESPACES \"  )  ;", "}", "METHOD_END"], "methodName": ["testComment2"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" DO _ NOT _ KEEP _ WHITESPACES \"  )  ;", "doTestKeepingWhitespacesStrictly (  \" KEEP _ WHITESPACES \"  )  ;", "}", "METHOD_END"], "methodName": ["testComment3"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "final   HtmlCodeStyleSettings   htmlSettings    =    getSettings (  )  . getCustomSettings ( HtmlCodeStyleSettings . class )  ;", "final   XmlCodeStyleSettings   xmlSettings    =    getSettings (  )  . getCustomSettings ( XmlCodeStyleSettings . class )  ;", "getSettings (  )  . setDefaultRightMargin (  1  5  )  ;", "htmlSettings . HTML _ KEEP _ LINE _ BREAKS _ IN _ TEXT    =    false ;", "xmlSettings . XML _ KEEP _ LINE _ BREAKS _ IN _ TEXT    =    false ;", "doText (  \"  < tag > aaa \\ nbbb \\ nccc \\ nddd \\ n <  / tag >  \"  ,     \"  < tag > aaa   bbb \\ n            ccc   ddd \\ n <  / tag >  \"  )  ;", "htmlSettings . HTML _ TEXT _ WRAP    =    CommonCodeStyleSettings . DO _ NOT _ WRAP ;", "xmlSettings . XML _ TEXT _ WRAP    =    CommonCodeStyleSettings . DO _ NOT _ WRAP ;", "doText (  \"  < tag > aaa \\ nbbb \\ nccc \\ nddd \\ n <  / tag >  \"  ,     \"  < tag > aaa   bbb   ccc   ddd \\ n <  / tag >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testDontKeepLineBreaksInText"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testEa305257"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTextTest (  \"  < a   b =  \\  \"  /  >  \"  ,     \"  < a   b =  \\  \"  /  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testIDEA55230"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTextTest (  (  \"  < para >  \\ n \"     +     (  \"       My    < link > link <  / link >    within   text .  \\ n \"     +     \"  <  / para >  \"  )  )  ,     (  \"  < para >  \\ n \"     +     (  \"             My    < link > link <  / link >    within   text .  \\ n \"     +     \"  <  / para >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testIdea52549"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testIdea57965"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testInvalid"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "CodeStyleSettings   settings    =    getSettings (  )  ;", "CodeStyleSettings   xmlSettings    =    settings . getCustomSettings ( CodeStyleSettings . class )  ;", "xmlSettings . XML _ KEEP _ WHITESPACES    =    true ;", "doWrapAlways (  \" ALIGN \"  ,    true ,     1  2  0  )  ;", "doWrapAlways (  \" DO _ NOT _ ALIGN \"  ,    false ,     1  2  0  )  ;", "}", "METHOD_END"], "methodName": ["testKeepingSpacesAndWrapping"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testPreserveSpace"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "XmlCodeStyleSettings   xmlSettings    =    getSettings (  )  . getCustomSettings ( XmlCodeStyleSettings . class )  ;", "xmlSettings . XML _ SPACE _ INSIDE _ EMPTY _ TAG    =    true ;", "doText (  \"  < test /  >  \"  ,     \"  < test    /  >  \"  )  ;", "xmlSettings . XML _ SPACE _ INSIDE _ EMPTY _ TAG    =    false ;", "doText (  \"  < test       /  >  \"  ,     \"  < test /  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSCR1574"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "XmlCodeStyleSettings   xmlSettings    =    getSettings (  )  . getCustomSettings ( XmlCodeStyleSettings . class )  ;", "xmlSettings . XML _ SPACE _ INSIDE _ EMPTY _ TAG    =    true ;", "doText (  \"  < a   attr =  \\  \" value \\  \"  /  >  \"  ,     \"  < a   attr =  \\  \" value \\  \"     /  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSCR1798"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "doSanityTest ( true )  ;", "}", "METHOD_END"], "methodName": ["testSanity"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "CodeStyleSettings   settings    =    getSettings (  )  ;", "XmlCodeStyleSettings   xmlSettings    =    settings . getCustomSettings ( XmlCodeStyleSettings . class )  ;", "xmlSettings . XML _ KEEP _ WHITESPACES    =    false ;", "do (  )  ;", "}", "METHOD_END"], "methodName": ["testWhiteSpaceBeforeText"], "fileName": "com.intellij.psi.formatter.XmlFormatterTest"}, {"methodBody": ["METHOD_START", "{", "String   text    =    loadFile (  ( name    +     \"  . xml \"  )  ,    null )  ;", "final   XmlFileImpl   file    =     (  ( XmlFileImpl )     ( createFile (  ( name    +     \"  . xml \"  )  ,    text )  )  )  ;", "myTextRange    =    new   TextRange (  1  0  0  0  0  ,     1  0  0  0  1  )  ;", "CommandProcessor . getInstance (  )  . executeCommand ( getProject (  )  ,     (  )     -  >    ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >    performing ( file )  )  ,     \"  \"  ,     \"  \"  )  ;", "myTextRange    =    new   TextRange (  1  0  0  0  0  0  0  ,     1  0  0  0  0  0  1  )  ;", "CommandProcessor . getInstance (  )  . executeCommand ( getProject (  )  ,     (  )     -  >    ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >    performing ( file )  )  ,     \"  \"  ,     \"  \"  )  ;", "myTextRange    =    new   TextRange (  0  ,    text . length (  )  )  ;", "CommandProcessor . getInstance (  )  . executeCommand ( getProject (  )  ,     (  )     -  >    ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >    performing ( file )  )  ,     \"  \"  ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["checkFormattingDoesNotProduceException"], "fileName": "com.intellij.psi.formatter.XmlFormatterTestBase"}, {"methodBody": ["METHOD_START", "{", "return    (  )     -  >     {", "final   Document   document    =    PsiDocumentManager . getInst ( getProject (  )  )  . getDocument ( file )  ;", "assertNotNull ( document )  ;", "CodeStyleManager . getInst ( getProject (  )  )  . adjustLineIndent ( file ,    file . getTextRange (  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["createAdjustLineIndentInRangeRunnable"], "fileName": "com.intellij.psi.formatter.XmlPerformanceFormatterTest"}, {"methodBody": ["METHOD_START", "{", "return    (  )     -  >     {", "try    {", "do (  )  ;", "}    finally    {", "UIUtil . dispatchAllInvocationEvents (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createTestRunnable"], "fileName": "com.intellij.psi.formatter.XmlPerformanceFormatterTest"}, {"methodBody": ["METHOD_START", "{", "CodeStyleSettings   settings    =    getSettings (  )  ;", "XmlCodeStyleSettings   xmlSettings    =    settings . getCustomSettings ( XmlCodeStyleSettings . class )  ;", "boolean   oldValue    =    xmlSettings . XML _ KEEP _ WHITESPACES ;", "xmlSettings . XML _ ATTRIBUTE _ WRAP    =    CommonCodeStyleSettings . DO _ NOT _ WRAP ;", "xmlSettings . XML _ KEEP _ LINE _ BREAKS    =    true ;", "settings . setRightMargin ( XMLLanguage . INSTANCE ,    rightMargin )  ;", "xmlSettings . XML _ ALIGN _ ATTRIBUTES    =    align ;", "try    {", "do ( resultNumber )  ;", "}    finally    {", "UIUtil . dispatchAllInvocationEvents (  )  ;", "xmlSettings . XML _ KEEP _ WHITESPACES    =    oldValue ;", "}", "}", "METHOD_END"], "methodName": ["doTestDoNotWrap"], "fileName": "com.intellij.psi.formatter.XmlPerformanceFormatterTest"}, {"methodBody": ["METHOD_START", "{", "CodeInsightTestFixtureImpl . instantiateAndRun ( myFile ,    myEditor ,    new   int [  ]  {    Pass . UPDATE _ ALL ,    Pass . LOCAL _ INSPECTIONS    }  ,    false )  ;", "}", "METHOD_END"], "methodName": ["highlight"], "fileName": "com.intellij.psi.formatter.XmlPerformanceFormatterTest"}, {"methodBody": ["METHOD_START", "{", "CodeStyleSettings   settings    =    getSettings (  )  ;", "XmlCodeStyleSettings   xmlSettings    =    settings . getCustomSettings ( XmlCodeStyleSettings . class )  ;", "xmlSettings . XML _ KEEP _ LINE _ BREAKS    =    true ;", "xmlSettings . XML _ KEEP _ BLANK _ LINES    =     2  ;", "doDoNotWrap ( null ,    true ,     1  4  0  )  ;", "}", "METHOD_END"], "methodName": ["testPerformance"], "fileName": "com.intellij.psi.formatter.XmlPerformanceFormatterTest"}, {"methodBody": ["METHOD_START", "{", "final   FileEditorManager   editorManager    =    FileEditorManager . getInstance ( getProject (  )  )  ;", "try    {", "PlatformTestUtil . startTest (  \" xml   formatter \"  ,     6  8  0  0  ,    createTestRunnable (  )  )  . useLegacyScaling (  )  . assertTiming (  )  ;", "highlight (  )  ;", "long   start    =    System . currentTimeMillis (  )  ;", "final   UndoManager   undoManager    =    UndoManager . getInstance ( getProject (  )  )  ;", "final   FileEditor   selectedEditor    =    editorManager . getSelectedEditor ( myFile . getVirtualFile (  )  )  ;", "assertTrue ( undoManager . isUndoAvailable ( selectedEditor )  )  ;", "undoManager . undo ( selectedEditor )  ;", "long   end    =    System . currentTimeMillis (  )  ;", "PlatformTestUtil . assertTiming (  \" Fix   xml   formatter   undo   performance   problem \"  ,     3  4  0  0  ,     ( end    -    start )  )  ;", "PsiDocumentManager . getInstance ( getProject (  )  )  . commitAllDocuments (  )  ;", "highlight (  )  ;", "start    =    System . currentTimeMillis (  )  ;", "undoManager . redo ( selectedEditor )  ;", "end    =    System . currentTimeMillis (  )  ;", "PlatformTestUtil . assertTiming (  \" Fix   xml   formatter   redo   performance   problem \"  ,     3  4  0  0  ,     ( end    -    start )  )  ;", "}    finally    {", "UIUtil . dispatchAllInvocationEvents (  )  ;", "final   VirtualFile [  ]    selectedFiles    =    editorManager . getSelectedFiles (  )  ;", "if    (  ( selectedFiles . length )     >     0  )", "editorManager . closeFile ( selectedFiles [  0  ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPerformance3"], "fileName": "com.intellij.psi.formatter.XmlPerformanceFormatterTest"}, {"methodBody": ["METHOD_START", "{", "final   FileEditorManager   editorManager    =    FileEditorManager . getInstance ( getProject (  )  )  ;", "try    {", "PlatformTestUtil . startTest (  \" xml   formatter \"  ,     2  0  0  0  0  ,    createTestRunnable (  )  )  . useLegacyScaling (  )  . assertTiming (  )  ;", "}    finally    {", "editorManager . closeFile ( editorManager . getSelectedFiles (  )  [  0  ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPerformance4"], "fileName": "com.intellij.psi.formatter.XmlPerformanceFormatterTest"}, {"methodBody": ["METHOD_START", "{", "final   FileEditorManager   editorManager    =    FileEditorManager . getInstance ( getProject (  )  )  ;", "try    {", "PlatformTestUtil . startTest (  \" xml   formatter \"  ,     1  0  0  0  0  ,    createTestRunnable (  )  )  . useLegacyScaling (  )  . assertTiming (  )  ;", "}    finally    {", "final   VirtualFile [  ]    selectedFiles    =    editorManager . getSelectedFiles (  )  ;", "for    ( VirtualFile   selectedFile    :    selectedFiles )     {", "editorManager . closeFile ( selectedFile )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testPerformance5"], "fileName": "com.intellij.psi.formatter.XmlPerformanceFormatterTest"}, {"methodBody": ["METHOD_START", "{", "final   FileEditorManager   editorManager    =    FileEditorManager . getInstance ( getProject (  )  )  ;", "try    {", "PlatformTestUtil . startTest (  \" xml   formatter \"  ,     2  0  0  0  0  ,    createTestRunnable (  )  )  . useLegacyScaling (  )  . assertTiming (  )  ;", "}    finally    {", "final   VirtualFile [  ]    selectedFiles    =    editorManager . getSelectedFiles (  )  ;", "if    (  ( selectedFiles . length )     >     0  )", "editorManager . closeFile ( selectedFiles [  0  ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPerformance6"], "fileName": "com.intellij.psi.formatter.XmlPerformanceFormatterTest"}, {"methodBody": ["METHOD_START", "{", "final   String   textBefore    =    loadFile (  (  ( getTestName ( true )  )     +     \"  . xml \"  )  ,    null )  ;", "final   PsiFile   file    =    createFileFromText ( textBefore ,     \" before . xml \"  ,    PsiFileFactory . getInstance ( getProject (  )  )  )  ;", "PlatformTestUtil . startPerformanceTest (  \" IDEA -  1  4  8  9  4  3  \"  ,     2  0  0  0  0  ,     . createAdjustLineIndentInRangeRunnable ( file )  )  . assertTiming (  )  ;", "}", "METHOD_END"], "methodName": ["testPerformanceIdea148943"], "fileName": "com.intellij.psi.formatter.XmlPerformanceFormatterTest"}, {"methodBody": ["METHOD_START", "{", "PlatformTestUtil . startPerformanceTest (  \" reformat   code   fragment \"  ,     6  3  0  0  ,     (  )     -  >    checkFormattingDoesNotProduceException (  \" performance \"  )  )  . useLegacyScaling (  )  . assertTiming (  )  ;", "}", "METHOD_END"], "methodName": ["testReformatCodeFragment"], "fileName": "com.intellij.psi.formatter.XmlPerformanceFormatterTest"}, {"methodBody": ["METHOD_START", "{", "return   new   com . intellij . openapi . util . TextRange ( subBlocks . get (  0  )  . getTextRange (  )  . getStartOffset (  )  ,    subBlocks . get (  (  ( subBlocks . size (  )  )     -     1  )  )  . getTextRange (  )  . getEndOffset (  )  )  ;", "}", "METHOD_END"], "methodName": ["calculateTextRange"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return    (  ( myStartTreeNode . getElementType (  )  )     =  =     ( XmlTokenType . XML _ CDATA _ START )  )     &  &     (  ( myEndTreeNode . getElementType (  )  )     =  =     ( XmlTokenType . XML _ CDATA _ END )  )  ;", "}", "METHOD_END"], "methodName": ["containsCDATA"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return   isCDATA ( myStartTreeNode . getLastChildNode (  )  )  ;", "}", "METHOD_END"], "methodName": ["endsWithCDATA"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return   isXmlTag ( myEndTreeNode )  ;", "}", "METHOD_END"], "methodName": ["endsWithTag"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( myEndTreeNode . getElementType (  )  )     =  =     ( XmlElementType . XML _ TEXT )  )     |  |     (  ( myEndTreeNode . getElementType (  )  )     =  =     ( XmlTokenType . XML _ DATA _ CHARACTERS )  )  )     |  |     (  ( myEndTreeNode . getElementType (  )  )     =  =     ( XmlTokenType . XML _ CHAR _ ENTITY _ REF )  )  )     |  |     (  ( myEndTreeNode . getElementType (  )  )     =  =     ( XmlElementType . XML _ ENTITY _ REF )  )  ;", "}", "METHOD_END"], "methodName": ["endsWithText"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "if    ( endsWithText (  )  )", "return   true ;", "if    (  ( isEndOfTag (  )  )     &  &     ( myXmlFingPolicy . isTextElement ( getTag (  )  )  )  )", "return   true ;", "return   isTextTag ( myEndTreeNode )  ;", "}", "METHOD_END"], "methodName": ["endsWithTextElement"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "AbstractSyntheticBlock . LOG . assertTrue (  (  !  ( subBlocks . isEmpty (  )  )  )  )  ;", "final   Block   firstBlock    =    subBlocks . get (  0  )  ;", "if    ( firstBlock   instanceof   AbstractBlock )     {", "return    (  ( AbstractBlock )     ( firstBlock )  )  . getNode (  )  ;", "} else    {", "return   getFirstNode ( firstBlock . getSubBlocks (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getFirstNode"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "AbstractSyntheticBlock . LOG . assertTrue (  (  !  ( subBlocks . isEmpty (  )  )  )  )  ;", "final   Block   lastBlock    =    subBlocks . get (  (  ( subBlocks . size (  )  )     -     1  )  )  ;", "if    ( lastBlock   instanceof   AbstractBlock )     {", "return    (  ( AbstractBlock )     ( lastBlock )  )  . getNode (  )  ;", "} else    {", "return   getLastNode ( lastBlock . getSubBlocks (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getLastNode"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return    (  ( XmlTag )     ( myStartTreeNode . getPsi (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getStartTag"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return   myTag ;", "}", "METHOD_END"], "methodName": ["getTag"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "final   List < Block >    subBlocks    =    getSubBlocks (  )  ;", "final   Block   lastBlock    =    subBlocks . get (  (  ( subBlocks . size (  )  )     -     1  )  )  ;", "if    ( lastBlock   instanceof   XmlTagBlock )     {", "return   insertLineFeedAfter (  (  ( XmlTagBlock )     ( lastBlock )  )  . getTag (  )  )  ;", "}", "if    ( endsWithText (  )  )     {", "return   insertLineFeedAfter ( myTag )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["insertLineFeedAfter"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return    ( myXmlFormattingPolicy . getWrappingTypeForTagBegin ( tag )  )     =  =     ( WrapType . ALWAYS )  ;", "}", "METHOD_END"], "methodName": ["insertLineFeedAfter"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return    ( node    !  =    null )     &  &     (  ( node . getElementType (  )  )     =  =     ( XmlElementType . XML _ CDATA )  )  ;", "}", "METHOD_END"], "methodName": ["isCDATA"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return    ( myEndTreeNode . getElementType (  )  )     =  =     ( XmlTokenType . XML _ TAG _ END )  ;", "}", "METHOD_END"], "methodName": ["isEndOfTag"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isJspTextBlock"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isJspxTextBlock"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return    (  ( myStartTreeNode )     =  =     ( myEndTreeNode )  )     &  &     (  ( myStartTreeNode )    instanceof   OuterLanguageElement )  ;", "}", "METHOD_END"], "methodName": ["isOuterLanguageBlock"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return   AbstractSyntheticBlock . isTagDescription ( myStartTreeNode )  ;", "}", "METHOD_END"], "methodName": ["isStartOfTag"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   startTreeNode    =    myStartTreeNode ;", "return    . isTagDescription ( startTreeNode )  ;", "}", "METHOD_END"], "methodName": ["isTagDescription"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return    (  ( startTreeNode . getElementType (  )  )     =  =     ( XmlTokenType . XML _ START _ TAG _ START )  )     |  |     (  ( startTreeNode . getElementType (  )  )     =  =     ( XmlTokenType . XML _ END _ TAG _ START )  )  ;", "}", "METHOD_END"], "methodName": ["isTagDescription"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return    ( isXmlTag ( treeNode )  )     &  &     ( myXmlFormattingPolicy . isTextElement (  (  ( XmlTag )     ( SourceTreeToPsiMap . treeElementToPsi ( treeNode )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isTextTag"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return    ( treeNode . getPsi (  )  )    instanceof   XmlTag ;", "}", "METHOD_END"], "methodName": ["isXmlTag"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( type 1     =  =     ( XmlTokenType . XML _ NAME )  )     |  |     ( type 1     =  =     ( XmlTokenType . XML _ TAG _ NAME )  )  )     &  &     ( type 2     =  =     ( XmlTokenType . XML _ TAG _ END )  )  )", "return   true ;", "if    (  (  ( type 1     =  =     ( XmlTokenType . XML _ NAME )  )     |  |     ( type 1     =  =     ( XmlTokenType . XML _ TAG _ NAME )  )  )     &  &     ( type 2     =  =     ( XmlTokenType . XML _ EMPTY _ ELEMENT _ END )  )  )     {", "return   true ;", "}", "if    (  ( type 1     =  =     ( XmlElementType . XML _ ATTRIBUTE )  )     &  &     ( type 2     =  =     ( XmlTokenType . XML _ EMPTY _ ELEMENT _ END )  )  )", "return   true ;", "return    ( type 1     =  =     ( XmlElementType . XML _ ATTRIBUTE )  )     &  &     ( type 2     =  =     ( XmlTokenType . XML _ TAG _ END )  )  ;", "}", "METHOD_END"], "methodName": ["isXmlTagName"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return    (  ( myTag )     !  =    null )     &  &     ( myXmlFormattingPolicy . keepWhiteSpacesInsideTag ( myTag )  )  ;", "}", "METHOD_END"], "methodName": ["shouldKeepWhiteSpacesInside"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return   isCDATA ( myStartTreeNode . getFirstChildNode (  )  )  ;", "}", "METHOD_END"], "methodName": ["startsWithCDATA"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return   isXmlTag ( myStartTreeNode )  ;", "}", "METHOD_END"], "methodName": ["startsWithTag"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( myStartTreeNode . getElementType (  )  )     =  =     ( XmlElementType . XML _ TEXT )  )     |  |     (  ( myStartTreeNode . getElementType (  )  )     =  =     ( XmlTokenType . XML _ DATA _ CHARACTERS )  )  )     |  |     (  ( myStartTreeNode . getElementType (  )  )     =  =     ( XmlTokenType . XML _ CHAR _ ENTITY _ REF )  )  )     |  |     (  ( myStartTreeNode . getElementType (  )  )     =  =     ( XmlElementType . XML _ ENTITY _ REF )  )  ;", "}", "METHOD_END"], "methodName": ["startsWithText"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "if    ( startsWithText (  )  )", "return   true ;", "if    (  ( isStartOfTag (  )  )     &  &     ( myXmlFingPolicy . isTextElement ( getTag (  )  )  )  )", "return   true ;", "return   isTextTag ( myStartTreeNode )  ;", "}", "METHOD_END"], "methodName": ["startsWithTextElement"], "fileName": "com.intellij.psi.formatter.xml.AbstractSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "if    ( isBuildIndentsOnly (  )  )", "return   false ;", "if    ( myInjectedBuilder . addInjecteds ( result ,    child ,    wrap ,    alignment ,    indent )  )     {", "return   true ;", "}", "PsiFile   containingFile    =    child . getPsi (  )  . getContainingFile (  )  ;", "FileViewProvider   fileViewProvider    =    containingFile . getViewProvider (  )  ;", "if    ( fileViewProvider   instanceof   TemplateLanguageFileViewProvider )     {", "Language   templateLanguage    =     (  ( TemplateLanguageFileViewProvider )     ( fileViewProvider )  )  . getTemplateDataLanguage (  )  ;", "PsiElement   at    =    fileViewProvider . findElementAt ( child . getStartOffset (  )  ,    templateLanguage )  ;", "if    ( at   instanceof   XmlToken )     {", "at    =    at . getParent (  )  ;", "}", "if    (  (  ( at   instanceof   PsiComment )     &  &     ( at . getTextRange (  )  . equals ( child . getTextRange (  )  )  )  )     &  &     (  ( at . getNode (  )  )     !  =    child )  )     {", "return   buildInjectedPsis ( result ,    at . getNode (  )  ,    wrap ,    alignment ,    indent )  ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["buildInjectedPsiBlocks"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "return    ( tag . getSubTags (  )  . length )     >     0  ;", "}", "METHOD_END"], "methodName": ["canWrapTagEnd"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myNode . getElementType (  )  )     =  =     ( XmlElementType . XML _ TEXT )  )", "return   getAlignment (  )  ;", "final   IElementType   elementType    =    child . getElementType (  )  ;", "if    (  ( elementType    =  =     ( XmlElementType . XML _ ATTRIBUTE )  )     &  &     ( myXmlFingPolicy . getShouldAlignAttributes (  )  )  )", "return   attrAlignment ;", "if    (  ( elementType    =  =     ( XmlElementType . XML _ TEXT )  )     &  &     ( myXmlFingPolicy . getShouldAlignText (  )  )  )", "return   textAlignment ;", "return   null ;", "}", "METHOD_END"], "methodName": ["chooseAlignment"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myNode . getElementType (  )  )     =  =     ( XmlElementType . XML _ TEXT )  )", "return   textWrap ;", "final   IElementType   elementType    =    child . getElementType (  )  ;", "if    ( elementType    =  =     ( XmlElementType . XML _ ATTRIBUTE )  )", "return   attrWrap ;", "if    ( elementType    =  =     ( XmlTokenType . XML _ START _ TAG _ START )  )", "return   tagBeginWrap ;", "if    ( elementType    =  =     ( XmlTokenType . XML _ END _ TAG _ START )  )     {", "final   PsiElement   parent    =    SourceTreeToPsiMap . treeElementToPsi ( child . getTreeParent (  )  )  ;", "if    ( parent   instanceof   XmlTag )     {", "final   XmlTag   tag    =     (  ( XmlTag )     ( parent )  )  ;", "if    ( canWrapTagEnd ( tag )  )     {", "return   getTagEndWrapping ( tag )  ;", "}", "}", "return   null ;", "}", "if    (  ( elementType    =  =     ( XmlElementType . XML _ TEXT )  )     |  |     ( elementType    =  =     ( XmlTokenType . XML _ DATA _ CHARACTERS )  )  )     {", "ASTNode   previous    =    FUtil . getPreviousNonWhitespaceSibling ( child )  ;", "if    (  ( previous    =  =    null )     |  |     (  ( previous . getElementType (  )  )     !  =     ( XmlElementType . XML _ TEXT )  )  )     {", "return   myXmlFormattingPolicy . allowWrapBeforeText (  )     ?    textWrap    :    null ;", "}", "return   textWrap ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["chooseWrap"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "final   List < XmlTag >    result    =    new   ArrayList <  >  (  )  ;", "node . processElements ( new   PsiElementProcessor (  )     {", "@ Override", "public   boolean   execute (  @ NotNull", "final   PsiElement   element )     {", "if    ( element   instanceof   XmlTag )     {", "result . add (  (  ( XmlTag )     ( element )  )  )  ;", "}", "return   true ;", "}", "}  ,    node )  ;", "return   result . toArray ( XmlTag . EMPTY )  ;", "}", "METHOD_END"], "methodName": ["collectSubTags"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   closingTagStart    =    XmlChildRole . CLOSING _ TAG _ START _ FINDER . findChild ( myNode )  ;", "final   ASTNode   startTagStart    =    XmlChildRole . START _ TAG _ END _ FINDER . findChild ( myNode )  ;", "if    (  ( closingTagStart    =  =    null )     &  &     ( startTagStart    =  =    null )  )     {", "return    ( tag . getTextRange (  )  . getEndOffset (  )  )     <  =     ( myNode . getTextRange (  )  . getEndOffset (  )  )  ;", "} else", "if    ( closingTagStart    =  =    null )     {", "return   false ;", "} else    {", "return    ( tag . getTextRange (  )  . getEndOffset (  )  )     <  =     ( closingTagStart . getTextRange (  )  . getEndOffset (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["containsTag"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "PsiElement   psiElement    =    node . getPsi (  )  ;", "if    ( psiElement   instanceof   PsiWhiteSpace )", "return   true ;", "Language   nodeLang    =    psiElement . getLanguage (  )  ;", "if    (  (  (  !  ( nodeLang . isKindOf ( XMLLanguage . INSTANCE )  )  )     |  |     (  . isTextOnlyNode ( node )  )  )     |  |     (  ( node . getElementType (  )  )     =  =     ( XmlElementType . XML _ PROLOG )  )  )     {", "WhiteSpaceFormattingStrategy   strategy    =    WhiteSpaceFormattingStrategyFactory . getStrategy ( nodeLang )  ;", "int   length    =    node . getTextLength (  )  ;", "return    ( strategy . check ( node . getChars (  )  ,     0  ,    length )  )     >  =    length ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsWhiteSpacesOnly"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["createAnotherTreeNode"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["createAnotherTreeTagBlock"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "boolean   shouldKeepLineBreaks    =    getShouldKeepLineBreaks ( inText ,    forceKeepLineBreaks )  ;", "return   Spacing . createSpacing (  0  ,    Integer . MAX _ VALUE ,     0  ,    shouldKeepLineBreaks ,    myXmlFingPolicy . getKeepBlankLines (  )  )  ;", "}", "METHOD_END"], "methodName": ["createDefaultSpace"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "return   myXmlFormattingPolicy ;", "}", "METHOD_END"], "methodName": ["createPolicyFor"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlBlock ( child ,    wrap ,    alignment ,    myXmlFormattingPolicy ,    indent ,    null ,    isPreserveSpace (  )  )  ;", "}", "METHOD_END"], "methodName": ["createSimpleChild"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "return   Wrap . createWrap ( myXmlFormattingPolicy . getWrappingTypeForTagBegin ( tag )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["createTagBeginWrapping"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlTagBlock ( child ,    wrap ,    alignment ,    myXmlFormattingPolicy ,     ( indent    !  =    null    ?    indent    :    Indent . getNoneIndent (  )  )  ,    isPreserveSpace (  )  )  ;", "}", "METHOD_END"], "methodName": ["createTagBlock"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "final   TextRange   tagRange    =    tag . getTextRange (  )  ;", "final   Tag [  ]    subTags    =    getSubTags (  )  ;", "for    ( Tag   subTag    :    subTags )     {", "final   TextRange   subTagRange    =    subTag . getTextRange (  )  ;", "if    (  ( subTagRange . getEndOffset (  )  )     <     ( tagRange . getStartOffset (  )  )  )", "continue ;", "if    (  ( subTagRange . getStartOffset (  )  )     >     ( tagRange . getEndOffset (  )  )  )", "return   true ;", "if    (  (  ( tagRange . getStartOffset (  )  )     >     ( subTagRange . getStartOffset (  )  )  )     &  &     (  ( tagRange . getEndOffset (  )  )     <     ( subTagRange . getEndOffset (  )  )  )  )", "return   false ;", "if    (  (  ( tagRange . getEndOffset (  )  )     >     ( subTagRange . getStartOffset (  )  )  )     &  &     (  ( tagRange . getEndOffset (  )  )     <     ( subTagRange . getEndOffset (  )  )  )  )", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["doesNotIntersectSubTagsWith"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "TreeElement   fileNode    =    TreeUtil . getFileElement (  (  ( TreeElement )     ( child )  )  )  ;", "final   LeafElement   leaf    =    fileNode . findLeafElementAt ( endOffset )  ;", "if    (  (  ( leaf    !  =    null )     &  &     (  ( leaf . getStartOffset (  )  )     =  =    endOffset )  )     &  &     ( endOffset    >     0  )  )     {", "return   fileNode . findLeafElementAt (  ( endOffset    -     1  )  )  ;", "}", "return   leaf ;", "}", "METHOD_END"], "methodName": ["findChildAfter"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["findXmlTagAt"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getAnotherTreeTag"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "return   insertLineBreakBeforeTag (  )     ?     1     :     0  ;", "}", "METHOD_END"], "methodName": ["getBlankLinesBeforeTag"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "if    ( forceKeepLineBreaks )     {", "return   true ;", "}", "if    ( inText    &  &     ( myXmlFingPolicy . getShouldKeepLineBreaksInText (  )  )  )     {", "return   true ;", "}", "if    (  (  ! inText )     &  &     ( myXmlFingPolicy . getShouldKeepLineBreaks (  )  )  )     {", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["getShouldKeepLineBreaks"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myNode )    instanceof   XmlTag )     {", "return    (  ( XmlTag )     ( myNode . getPsi (  )  )  )  . getSubTags (  )  ;", "} else", "if    (  ( myNode . getPsi (  )  )    instanceof   xml . XmlElement )     {", "return   AbstractXmlBlock . collectSubTags (  (  ( xml . XmlElement )     ( myNode . getPsi (  )  )  )  )  ;", "} else    {", "return   XmlTag . EMPTY ;", "}", "}", "METHOD_END"], "methodName": ["getSubTags"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "return   AbstractXmlBlock . getTag ( myNode )  ;", "}", "METHOD_END"], "methodName": ["getTag"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   element    =    SourceTreeToPsiMap . treeElementToPsi ( node )  ;", "if    ( element   instanceof   Tag )     {", "return    (  ( Tag )     ( element )  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getTag"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "return   Wrap . createWrap ( myXmlFormattingPolicy . getWrappingTypeForTagEnd ( parent )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["getTagEndWrapping"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "if    ( type    =  =     ( CommonCodeStyleSettings . DO _ NOT _ WRAP )  )", "return   WrapType . NONE ;", "if    ( type    =  =     ( CommonCodeStyleSettings . WRAP _ ALWAYS )  )", "return   WrapType . ALWAYS ;", "if    ( type    =  =     ( CommonCodeStyleSettings . WRAP _ AS _ NEEDED )  )", "return   WrapType . NORMAL ;", "return   WrapType . CHOP _ DOWN _ IF _ LONG ;", "}", "METHOD_END"], "methodName": ["getWrapType"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "return    ( myNode . getElementType (  )  )     =  =     ( XmlTokenType . XML _ CDATA _ END )  ;", "}", "METHOD_END"], "methodName": ["isCDATAEnd"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "return    ( myNode . getElementType (  )  )     =  =     ( XmlTokenType . XML _ CDATA _ START )  ;", "}", "METHOD_END"], "methodName": ["isCDATAStart"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   psiElement    =    SourceTreeToPsiMap . treeElementToPsi ( node )  ;", "if    ( psiElement   instanceof   PsiComment )", "return   true ;", "final   ParserDefinition   parserDefinition    =    INSTANCELanguage ( psiElement . getLanguage (  )  )  ;", "if    ( parserDefinition    =  =    null )", "return   false ;", "final   TokenSet   commentTokens    =    parserDefinition . getCommentTokens (  )  ;", "return   commentTokens . contains ( node . getElementType (  )  )  ;", "}", "METHOD_END"], "methodName": ["isComment"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isJspxJavaContainingNode"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "return   myPreserveSpace ;", "}", "METHOD_END"], "methodName": ["isPreserveSpace"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "if    (  ( node . getPsi (  )  )    instanceof   XmlText )", "return   true ;", "ASTNode   firstChild    =    node . getFirstChildNode (  )  ;", "ASTNode   lastChild    =    node . getLastChildNode (  )  ;", "if    (  (  ( firstChild    !  =    null )     &  &     ( firstChild    =  =    lastChild )  )     &  &     (  ( firstChild . getPsi (  )  )    instanceof   XmlText )  )     {", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isTextOnlyNode"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "return   isXmlTag ( child . getPsi (  )  )  ;", "}", "METHOD_END"], "methodName": ["isXmlTag"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "return   psi   instanceof   XmlTag ;", "}", "METHOD_END"], "methodName": ["isXmlTag"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "ASTNode   resultNode    =    child ;", "ASTNode   currentChild    =    child . getTreeNext (  )  ;", "while    (  ( currentChild    !  =    null )     &  &     (  ( currentChild . getElementType (  )  )     !  =     ( XmlTokenType . XML _ END _ TAG _ START )  )  )     {", "if    (  !  (  . containsWhiteSpacesOnly ( currentChild )  )  )     {", "currentChild    =    processChild ( result ,    currentChild ,    wrap ,    alignment ,    indent )  ;", "resultNode    =    currentChild ;", "}", "if    ( currentChild    !  =    null )     {", "currentChild    =    currentChild . getTreeNext (  )  ;", "}", "}", "return   resultNode ;", "}", "METHOD_END"], "methodName": ["processAllChildrenFrom"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "final   Language   myLanguage    =    myNode . getPsi (  )  . getLanguage (  )  ;", "final   PsiElement   childPsi    =    child . getPsi (  )  ;", "final   Language   childLanguage    =    childPsi . getLanguage (  )  ;", "if    ( useMyF ( myLanguage ,    childLanguage ,    childPsi )  )     {", "XmlTag   tag    =    getAnotherTreeTag ( child )  ;", "if    (  (  ( tag    !  =    null )     &  &     ( containsTag ( tag )  )  )     &  &     ( doesNotIntersectSubTagsWith ( tag )  )  )     {", "ASTNode   currentChild    =    createAnotherTreeNode ( result ,    child ,    tag ,    indent ,    wrap ,    alignment )  ;", "if    ( currentChild    =  =    null )     {", "return   null ;", "}", "while    (  (  ( currentChild    !  =    null )     &  &     (  ( currentChild . getTreeParent (  )  )     !  =     ( myNode )  )  )     &  &     (  ( currentChild . getTreeParent (  )  )     !  =     ( child . getTreeParent (  )  )  )  )     {", "currentChild    =    processAllChildrenFrom ( result ,    currentChild ,    wrap ,    alignment ,    indent )  ;", "if    (  ( currentChild    !  =    null )     &  &     (  (  ( currentChild . getTreeParent (  )  )     =  =     ( myNode )  )     |  |     (  ( currentChild . getTreeParent (  )  )     =  =     ( child . getTreeParent (  )  )  )  )  )     {", "return   currentChild ;", "}", "if    ( currentChild    !  =    null )     {", "currentChild    =    currentChild . getTreeParent (  )  ;", "}", "}", "return   currentChild ;", "}", "processSimpleChild ( child ,    indent ,    result ,    wrap ,    alignment )  ;", "return   child ;", "} else", "if    (  !  ( isBuildIndentsOnly (  )  )  )     {", "myInjectedBlockBuilder . addInjectedLanguageBlockWrapper ( result ,    child ,    indent ,     0  ,    null )  ;", "}", "return   child ;", "}", "METHOD_END"], "methodName": ["processChild"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "if    ( isXmlTag ( child )  )     {", "result . add ( createTagBlock ( child ,     ( indent    !  =    null    ?    indent    :    Indent . getNoneIndent (  )  )  ,    wrap ,    alignment )  )  ;", "} else", "if    (  ( child . getElementType (  )  )     =  =     ( xml . XmlElementType . XML _ DOCTYPE )  )     {", "result . add ( new   XmlBlock ( child ,    wrap ,    alignment ,    myXmlFormattingPolicy ,    indent ,    null ,    isPreserveSpace (  )  )     {", "@ Override", "protected   Wrap   getDefaultWrap ( final   ASTNode   node )     {", "final   tree . IElementType   type    =    node . getElementType (  )  ;", "return   type    =  =     ( xml . XmlTokenType . XML _ ATTRIBUTE _ VALUE _ TOKEN )     ?    Wrap . createWrap ( AbstractXmlBlock . getWrapType ( myXmlFormattingPolicy . getAttributesWrap (  )  )  ,    false )     :    null ;", "}", "}  )  ;", "} else    {", "result . add ( createSimpleChild ( child ,    indent ,    wrap ,    alignment )  )  ;", "}", "}", "METHOD_END"], "methodName": ["processSimpleChild"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "myXmlFormattingPolicy    =    xmlFormattingPolicy ;", "}", "METHOD_END"], "methodName": ["setXmlFormattingPolicy"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "if    (  ( node . getPsi (  )  )    instanceof   XmlTag )     {", "XmlTag   tag    =     (  ( XmlTag )     ( node . getPsi (  )  )  )  ;", "if    ( tag    !  =    null )     {", "XmlAttribute   spaceAttr    =    tag . getAttribute (  \" xml : space \"  )  ;", "if    ( spaceAttr    !  =    null )     {", "String   value    =    spaceAttr . getValue (  )  ;", "if    (  \" preserve \"  . equals ( value )  )     {", "return   true ;", "}", "if    (  \" default \"  . equals ( value )  )     {", "return   false ;", "}", "}", "}", "}", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["shouldPreserveSpace"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( myLanguage    =  =    childLanguage )     |  |     ( childLanguage    =  =     ( HTML . getLanguage (  )  )  )  )     |  |     ( childLanguage    =  =     ( XHTML . getLanguage (  )  )  )  )     |  |     ( childLanguage    =  =     ( XML . getLanguage (  )  )  )  )     {", "return   true ;", "}", "final   FormattingModelBuilder   childF    =    INSTANCE . forLanguage ( childLanguage )  ;", "return    ( childF    =  =    null )     |  |     (  ( childF   instanceof   DelegatingFormattingModelBuilder )     &  &     (  (  ( DelegatingFormattingModelBuilder )     ( childF )  )  . dontFormatMyModel (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["useMyFormatter"], "fileName": "com.intellij.psi.formatter.xml.AbstractXmlBlock"}, {"methodBody": ["METHOD_START", "{", "if    ( option    =  =    null )", "return   false ;", "( String   name    :    getTagNames ( option )  )     {", "if    ( name . trim (  )  . equalsIgnoreCase ( tag . getName (  )  )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["checkName"], "fileName": "com.intellij.psi.formatter.xml.HtmlPolicy"}, {"methodBody": ["METHOD_START", "{", "if    ( node    =  =    null )", "return   false ;", "if    (  ( node . getElementType (  )  )     =  =     ( TokenType . WHITE _ SPACE )  )", "return   true ;", "if    ( node   instanceof   LeafElement )", "return   false ;", "ASTNode   child    =    node . getFirstChildNode (  )  ;", "while    ( child    !  =    null )     {", "if    (  !  ( containsWhiteSpacesOnly ( child )  )  )", "return   false ;", "child    =    child . getTreeNext (  )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["containsWhiteSpacesOnly"], "fileName": "com.intellij.psi.formatter.xml.HtmlPolicy"}, {"methodBody": ["METHOD_START", "{", "PsiElement   result    =    parentTag . getFirstChild (  )  ;", "while    (  ( result    !  =    null )     &  &     (  ( result . getTextLength (  )  )     =  =     0  )  )     {", "result    =    result . getNextSibling (  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["findFirstNonEmptyChild"], "fileName": "com.intellij.psi.formatter.xml.HtmlPolicy"}, {"methodBody": ["METHOD_START", "{", "final   TextRange   textRange    =    parentTag . getTextRange (  )  ;", "return    (  ( myDocumentModel . getLineNumber ( textRange . getEndOffset (  )  )  )     -     ( myDocumentModel . getLineNumber ( textRange . getStartOffset (  )  )  )  )     +     1  ;", "}", "METHOD_END"], "methodName": ["getLines"], "fileName": "com.intellij.psi.formatter.xml.HtmlPolicy"}, {"methodBody": ["METHOD_START", "{", "if    (  ! enabled )", "return   null ;", "TextRange   range    =     . getStartTagRange ( tag )  ;", "if    ( range    =  =    null )", "return   null ;", "return   Spacing . createDependentLFSpacing ( spaces ,    spaces ,    range ,    getShouldKeepLineBreaks (  )  ,    getKeepBlankLines (  )  )  ;", "}", "METHOD_END"], "methodName": ["getStartTagDependantSpacingOrNull"], "fileName": "com.intellij.psi.formatter.xml.HtmlPolicy"}, {"methodBody": ["METHOD_START", "{", "ASTNode   start    =    tag . getNode (  )  . findChildByType ( XmlTokenType . XML _ START _ TAG _ START )  ;", "ASTNode   end    =    tag . getNode (  )  . findChildByType ( HtmlPolicy . TAG _ END _ TOKEN _ SET )  ;", "return    ( start    !  =    null )     &  &     ( end    !  =    null )     ?    new   openapi . util . TextRange ( start . getTextRange (  )  . getStartOffset (  )  ,    end . getTextRange (  )  . getEndOffset (  )  )     :    null ;", "}", "METHOD_END"], "methodName": ["getStartTagRange"], "fileName": "com.intellij.psi.formatter.xml.HtmlPolicy"}, {"methodBody": ["METHOD_START", "{", "String [  ]    splits    =    myCachedSplits . get ( option )  ;", "if    ( splits    =  =    null )     {", "splits    =    option . split (  \"  ,  \"  )  ;", "myCachedSplits . put ( option ,    splits )  ;", "}", "return   splits ;", "}", "METHOD_END"], "methodName": ["getTagNames"], "fileName": "com.intellij.psi.formatter.xml.HtmlPolicy"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag [  ]    tags    =    tag . getSubTags (  )  ;", "( XmlTag   xmlTag    :    tags )     {", "if    (  !  ( isInlineTag ( xmlTag )  )  )", "return   false ;", "if    (  !  ( hasInlineContentOnly ( xmlTag )  )  )", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["hasInlineContentOnly"], "fileName": "com.intellij.psi.formatter.xml.HtmlPolicy"}, {"methodBody": ["METHOD_START", "{", "return   checkName ( tag ,    myHtmlCodeStyleSettings . HTML _ INLINE _ ELEMENTS )  ;", "}", "METHOD_END"], "methodName": ["isInlineTag"], "fileName": "com.intellij.psi.formatter.xml.HtmlPolicy"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["shouldBeWrapped"], "fileName": "com.intellij.psi.formatter.xml.HtmlPolicy"}, {"methodBody": ["METHOD_START", "{", "return   isAttributeBlock ( getSubBlocks (  )  . get (  (  ( getSubBlocks (  )  . size (  )  )     -     1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["endsWithAttribute"], "fileName": "com.intellij.psi.formatter.xml.SyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return   myChildIndent ;", "}", "METHOD_END"], "methodName": ["getChildIndent"], "fileName": "com.intellij.psi.formatter.xml.SyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "if    ( block   instanceof   XmlBlock )     {", "return    (  (  ( XmlBlock )     ( block )  )  . getNode (  )  . getElementType (  )  )     =  =     ( XmlElementType . XML _ ATTRIBUTE )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isAttributeBlock"], "fileName": "com.intellij.psi.formatter.xml.SyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return    (  ( node . getElementType (  )  )     =  =     ( XmlElementType . XML _ ENTITY _ REF )  )     |  |     (  ( node . getElementType (  )  )     =  =     ( XmlTokenType . XML _ CHAR _ ENTITY _ REF )  )  ;", "}", "METHOD_END"], "methodName": ["isEntityRef"], "fileName": "com.intellij.psi.formatter.xml.SyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( astNode . getElementType (  )  )     =  =     ( XmlElementType . XML _ TAG )  )     &  &     ( SyntheticBlock . isTextOnlyTag ( astNode )  )  )     &  &     ( SyntheticBlock . isTextNotEndingWithLineBreaks ( astNode . getTreePrev (  )  )  )  )     &  &     ( SyntheticBlock . isTextNotStartingWithLineBreaks ( astNode . getTreeNext (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isInlineTag"], "fileName": "com.intellij.psi.formatter.xml.SyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( firstIsText    &  &    secondIsText )     |  |     ( firstIsTag    &  &    secondIsTag )  )     |  |     ( firstIsTag    &  &    secondIsText )  )     |  |     ( firstIsText    &  &    secondIsTag )  ;", "}", "METHOD_END"], "methodName": ["isSpaceInText"], "fileName": "com.intellij.psi.formatter.xml.SyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   parent    =    node . getTreeParent (  )  ;", "return    (  ( parent    !  =    null )     &  &     (  ( parent . getElementType (  )  )     =  =     ( XmlElementType . XML _ TEXT )  )  )     |  |     (  ( node . getElementType (  )  )     =  =     ( XmlTokenType . XML _ DATA _ CHARACTERS )  )  ;", "}", "METHOD_END"], "methodName": ["isTextFragment"], "fileName": "com.intellij.psi.formatter.xml.SyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "if    (  ( astNode    !  =    null )     &  &     (  ( astNode . getElementType (  )  )     =  =     ( XmlElementType . XML _ TEXT )  )  )     {", "ASTNode   lastChild    =    astNode . getLastChildNode (  )  ;", "if    ( lastChild    !  =    null )     {", "return    (  !  (  ( lastChild . getPsi (  )  )    instanceof   PsiWhiteSpace )  )     |  |     (  !  ( CharArrayUtil . containLineBreaks ( lastChild . getChars (  )  )  )  )  ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isTextNotEndingWithLineBreaks"], "fileName": "com.intellij.psi.formatter.xml.SyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "if    (  ( astNode    !  =    null )     &  &     (  ( astNode . getElementType (  )  )     =  =     ( XmlElementType . XML _ TEXT )  )  )     {", "ASTNode   firstChild    =    astNode . getFirstChildNode (  )  ;", "if    ( firstChild    !  =    null )     {", "return    (  !  (  ( firstChild . getPsi (  )  )    instanceof   PsiWhiteSpace )  )     |  |     (  !  ( CharArrayUtil . containLineBreaks ( firstChild . getChars (  )  )  )  )  ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isTextNotStartingWithLineBreaks"], "fileName": "com.intellij.psi.formatter.xml.SyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "ASTNode   child    =    tagNode . getFirstChildNode (  )  ;", "boolean   checkContent    =    false ;", "while    ( child    !  =    null )     {", "IElementType   childType    =    child . getElementType (  )  ;", "if    ( checkContent )     {", "if    ( childType    =  =     ( XmlTokenType . XML _ END _ TAG _ START )  )", "return   true ;", "else", "if    ( childType    !  =     ( xml . XmlElementType . XML _ TEXT )  )", "return   false ;", "} else    {", "if    ( childType    =  =     ( XmlTokenType . XML _ TAG _ END )  )     {", "checkContent    =    true ;", "}", "}", "child    =    child . getTreeNext (  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isTextOnlyTag"], "fileName": "com.intellij.psi.formatter.xml.SyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return    ( myXmlFormattingPolicy . keepWhiteSpacesInsideTag ( getTag (  )  )  )     |  |     ( myXmlFormattingPolicy . getShouldKeepWhiteSpaces (  )  )  ;", "}", "METHOD_END"], "methodName": ["keepWhiteSpaces"], "fileName": "com.intellij.psi.formatter.xml.SyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( node 1  . getElementType (  )  )     =  =     ( XmlTokenType . XML _ START _ TAG _ START )  )     &  &     ( node 1  . textContains (  '  %  '  )  )  )", "return   true ;", "if    (  (  ( node 2  . getElementType (  )  )     =  =     ( XmlTokenType . XML _ EMPTY _ ELEMENT _ END )  )     &  &     ( node 2  . textContains (  '  %  '  )  )  )", "return   true ;", "return   myXmlFingPolicy . getShouldAddSpaceAroundTagName (  )  ;", "}", "METHOD_END"], "methodName": ["shouldAddSpaceAroundTagName"], "fileName": "com.intellij.psi.formatter.xml.SyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "if    ( node   instanceof   OuterLanguageElement )     {", "return   true ;", "}", "ASTNode   child    =    node . getFirstChildNode (  )  ;", "while    ( child    !  =    null )     {", "if    ( child   instanceof   OuterLanguageElement )     {", "return   true ;", "}", "if    (  . containsOuterLanguageElement ( child )  )", "return   true ;", "child    =    child . getTreeNext (  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsOuterLanguageElement"], "fileName": "com.intellij.psi.formatter.xml.XmlBlock"}, {"methodBody": ["METHOD_START", "{", "if    ( node   instanceof   OuterLanguageElement )     {", "processChild ( result ,    node ,    null ,    null ,    null )  ;", "return ;", "}", "ASTNode   child    =    node . getFirstChildNode (  )  ;", "if    (  (  (  ( child    =  =    null )     &  &     (  !  ( node   instanceof   PsiWhiteSpace )  )  )     &  &     (  ( node . getElementType (  )  )     !  =     ( TokenType . ERROR _ ELEMENT )  )  )     &  &     (  ( node . getTextLength (  )  )     >     0  )  )     {", "result . add ( new   ReadOnly ( node )  )  ;", "return ;", "}", "while    ( child    !  =    null )     {", "createLeafs ( child ,    result )  ;", "child    =    child . getTreeNext (  )  ;", "}", "}", "METHOD_END"], "methodName": ["createLeafBlocks"], "fileName": "com.intellij.psi.formatter.xml.XmlBlock"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myNode . getElementType (  )  )     =  =     ( XmlElementType . HTML _ DOCUMENT )  )     {", "return   Indent . getNoneIndent (  )  ;", "}", "if    (  ( myNode . getElementType (  )  )     =  =     ( TokenType . DUMMY _ HOLDER )  )     {", "return   Indent . getNoneIndent (  )  ;", "}", "if    (  ( myNode . getElementType (  )  )     =  =     ( XmlElementType . XML _ PROLOG )  )     {", "return   Indent . getNoneIndent (  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getChildDefaultIndent"], "fileName": "com.intellij.psi.formatter.xml.XmlBlock"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getDefaultWrap"], "fileName": "com.intellij.psi.formatter.xml.XmlBlock"}, {"methodBody": ["METHOD_START", "{", "return   myXmlFormattingPolicy ;", "}", "METHOD_END"], "methodName": ["getPolicy"], "fileName": "com.intellij.psi.formatter.xml.XmlBlock"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type 1     =  =     ( XmlTokenType . XML _ EQ )  )     |  |     ( type 2     =  =     ( XmlTokenType . XML _ EQ )  )  )     {", "int   spaces    =     ( myXmlFingPolicy . getShouldAddSpaceAroundEqualityInAttribute (  )  )     ?     1     :     0  ;", "return   Spacing . createSpacing ( spaces ,    spaces ,     0  ,    myXmlFingPolicy . getShouldKeepLineBreaks (  )  ,    myXmlFingPolicy . getKeepBlankLines (  )  )  ;", "} else    {", "return   createDefaultSpace ( false ,    false )  ;", "}", "}", "METHOD_END"], "methodName": ["getSpacesInsideAttribute"], "fileName": "com.intellij.psi.formatter.xml.XmlBlock"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type 1     =  =     ( XmlTokenType . XML _ DATA _ CHARACTERS )  )     &  &     ( type 2     =  =     ( XmlTokenType . XML _ DATA _ CHARACTERS )  )  )     {", "return   Spacing . createSpacing (  1  ,     1  ,     0  ,    myXmlFingPolicy . getShouldKeepLineBreaksInText (  )  ,    myXmlFingPolicy . getKeepBlankLines (  )  )  ;", "} else    {", "return   createDefaultSpace ( false ,    true )  ;", "}", "}", "METHOD_END"], "methodName": ["getSpacesInsideText"], "fileName": "com.intellij.psi.formatter.xml.XmlBlock"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myNode . getElementType (  )  )     =  =     ( XmlElementType . XML _ TEXT )  )     {", "if    ( myXmlFormattingPolicy . getShouldKeepWhiteSpaces (  )  )     {", "return   true ;", "} else    {", "final   ASTNode   treeParent    =    myNode . getTreeParent (  )  ;", "final   XmlTag   tag    =    Abstract . getTag ( treeParent )  ;", "if    ( tag    !  =    null )     {", "if    ( myXmlFormattingPolicy . keepWhiteSpacesInsideTag ( tag )  )     {", "return   true ;", "}", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["shouldKeepWhitespaces"], "fileName": "com.intellij.psi.formatter.xml.XmlBlock"}, {"methodBody": ["METHOD_START", "{", "final   ArrayList < Block >    result    =    new   ArrayList <  >  (  3  )  ;", "ASTNode   child    =    node . getFirstChildNode (  )  ;", "while    ( child    !  =    null )     {", "if    (  (  ( child . getElementType (  )  )     =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ START _ DELIMITER )  )     |  |     (  ( child . getElementType (  )  )     =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ END _ DELIMITER )  )  )     {", "result . add ( new   XmlBlock ( child ,    null ,    null ,    formattingPolicy ,    null ,    null ,    isPreserveSpace (  )  )  )  ;", "} else", "if    (  (  !  ( child . getPsi (  )  . getLanguage (  )  . isKindOf ( com . intellij . lang . xml . XMLLanguage . INSTANCE )  )  )     &  &     ( XmlBlock . containsOuterLanguageElement ( child )  )  )     {", "createLeafBlocks ( child ,    result )  ;", "} else", "if    (  (  ( child . getElementType (  )  )     !  =     ( TokenType . ERROR _ ELEMENT )  )     |  |     (  ( child . getFirstChildNode (  )  )     !  =    null )  )     {", "result . add ( new   ReadOnlyBlock ( child )  )  ;", "}", "child    =    child . getTreeNext (  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["splitAttribute"], "fileName": "com.intellij.psi.formatter.xml.XmlBlock"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myNode . getElementType (  )  )     !  =     ( XmlElementType . XML _ COMMENT )  )", "return   EMPTY ;", "final   ArrayList < Block >    result    =    new   ArrayList <  >  (  3  )  ;", "ASTNode   child    =    myNode . getFirstChildNode (  )  ;", "boolean   hasOuterLangElements    =    false ;", "while    ( child    !  =    null )     {", "if    ( child   instanceof   OuterLanguageElement )     {", "hasOuterLangElements    =    true ;", "}", "result . add ( new    ( child ,    null ,    null ,    myXmlFormattingPolicy ,    getChildIndent (  )  ,    null ,    isPreserveSpace (  )  )  )  ;", "child    =    child . getTreeNext (  )  ;", "}", "if    ( hasOuterLangElements )     {", "return   result ;", "} else    {", "return   EMPTY ;", "}", "}", "METHOD_END"], "methodName": ["splitComment"], "fileName": "com.intellij.psi.formatter.xml.XmlBlock"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["allowWrapBeforeText"], "fileName": "com.intellij.psi.formatter.xml.XmlFormattingPolicy"}, {"methodBody": ["METHOD_START", "{", "myProcessJsp    =    xmlFormattingPolicy . myProcessJsp ;", "myRootToBlockMap . putAll ( xmlFormattingPolicy . myRootToBlockMap )  ;", "myProcessJavaTree    =    xmlFormattingPolicy . processJavaTree (  )  ;", "}", "METHOD_END"], "methodName": ["copyFrom"], "fileName": "com.intellij.psi.formatter.xml.XmlFormattingPolicy"}, {"methodBody": ["METHOD_START", "{", "final   FormattingModelBuilder   builder    =    INSTANCE . forContext ( root . getSecond (  )  ,    root . getFirst (  )  )  ;", "if    ( builder    !  =    null )     {", "final   Block   result    =    builder . createModel ( root . getFirst (  )  ,    getSettings (  )  )  . getRootBlock (  )  ;", "if    ( result   instanceof   XmlBlock )     {", "final      policy    =    getPolicy (  (  ( XmlBlock )     ( result )  )  )  ;", "policy . setRootModels ( myRootToBlockMap )  ;", "policy . doNotProcessJsp (  )  ;", "}", "return   result ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["createBlockFor"], "fileName": "com.intellij.psi.formatter.xml.XmlFormattingPolicy"}, {"methodBody": ["METHOD_START", "{", "myProcessJsp    =    false ;", "}", "METHOD_END"], "methodName": ["doNotProcessJsp"], "fileName": "com.intellij.psi.formatter.xml.XmlFormattingPolicy"}, {"methodBody": ["METHOD_START", "{", "myProcessJavaTree    =    false ;", "}", "METHOD_END"], "methodName": ["dontProcessJavaTree"], "fileName": "com.intellij.psi.formatter.xml.XmlFormattingPolicy"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getBlankLinesBeforeTag"], "fileName": "com.intellij.psi.formatter.xml.XmlFormattingPolicy"}, {"methodBody": ["METHOD_START", "{", "return   myDocumentModel ;", "}", "METHOD_END"], "methodName": ["getDocumentModel"], "fileName": "com.intellij.psi.formatter.xml.XmlFormattingPolicy"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( myRootToBlockMap . containsKey ( root )  )  )     {", "myRootToBlockMap . put ( root ,    createBlock ( root )  )  ;", "}", "return   myRootToBlockMap . get ( root )  ;", "}", "METHOD_END"], "methodName": ["getOrCreateBlockFor"], "fileName": "com.intellij.psi.formatter.xml.XmlFormattingPolicy"}, {"methodBody": ["METHOD_START", "{", "return   result . getPolicy (  )  ;", "}", "METHOD_END"], "methodName": ["getPolicy"], "fileName": "com.intellij.psi.formatter.xml.XmlFormattingPolicy"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getSpacingAfterLastAttribute"], "fileName": "com.intellij.psi.formatter.xml.XmlFormattingPolicy"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getSpacingBeforeFirstAttribute"], "fileName": "com.intellij.psi.formatter.xml.XmlFormattingPolicy"}, {"methodBody": ["METHOD_START", "{", "return   Indent . getNoneIndent (  )  ;", "}", "METHOD_END"], "methodName": ["getTagEndIndent"], "fileName": "com.intellij.psi.formatter.xml.XmlFormattingPolicy"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isKeepSpacesAroundInlineTags"], "fileName": "com.intellij.psi.formatter.xml.XmlFormattingPolicy"}, {"methodBody": ["METHOD_START", "{", "return   myProcessJavaTree ;", "}", "METHOD_END"], "methodName": ["processJavaTree"], "fileName": "com.intellij.psi.formatter.xml.XmlFormattingPolicy"}, {"methodBody": ["METHOD_START", "{", "return   myProcessJsp ;", "}", "METHOD_END"], "methodName": ["processJsp"], "fileName": "com.intellij.psi.formatter.xml.XmlFormattingPolicy"}, {"methodBody": ["METHOD_START", "{", "myRootToBlockMap . put ( Pair . create ( node . getPsi (  )  ,    node . getPsi (  )  . getLanguage (  )  )  ,    rootBlock )  ;", "}", "METHOD_END"], "methodName": ["setRootBlock"], "fileName": "com.intellij.psi.formatter.xml.XmlFormattingPolicy"}, {"methodBody": ["METHOD_START", "{", "myRootToBlockMap    =    rootToBlockMap ;", "}", "METHOD_END"], "methodName": ["setRootModels"], "fileName": "com.intellij.psi.formatter.xml.XmlFormattingPolicy"}, {"methodBody": ["METHOD_START", "{", "return   new   SyntheticBlock ( localResult ,    this ,    Indent . getNoneIndent (  )  ,    myXmlFormattingPolicy ,    childrenIndent )  ;", "}", "METHOD_END"], "methodName": ["createSyntheticBlock"], "fileName": "com.intellij.psi.formatter.xml.XmlTagBlock"}, {"methodBody": ["METHOD_START", "{", "return   createSyntheticBlock ( localResult ,    getChildrenIndent (  )  )  ;", "}", "METHOD_END"], "methodName": ["createTagContentNode"], "fileName": "com.intellij.psi.formatter.xml.XmlTagBlock"}, {"methodBody": ["METHOD_START", "{", "return   createSyntheticBlock ( localResult ,    null )  ;", "}", "METHOD_END"], "methodName": ["createTagDescriptionNode"], "fileName": "com.intellij.psi.formatter.xml.XmlTagBlock"}, {"methodBody": ["METHOD_START", "{", "while    ( child    !  =    null )     {", "if    (  (  !  ( AbstractXml . containsWhiteSpacesOnly ( child )  )  )     &  &     (  ( child . getTextLength (  )  )     >     0  )  )     {", "final   Indent   indent    =    getChildrenIndent (  )  ;", "child    =    processChild ( list ,    child ,    wrap ,    alignment ,    indent )  ;", "if    ( child    =  =    null )", "return   child ;", "if    (  ( child . getTreeParent (  )  )     !  =    textNode )     {", "if    (  ( child . getTreeParent (  )  )     !  =     ( myNode )  )     {", "return   createXmlTexts ( list ,    child . getTreeParent (  )  ,    child . getTreeNext (  )  ,    wrap ,    alignment )  ;", "} else    {", "return   child ;", "}", "}", "}", "child    =    child . getTreeNext (  )  ;", "}", "return   textNode ;", "}", "METHOD_END"], "methodName": ["createXmlTextBlocks"], "fileName": "com.intellij.psi.formatter.xml.XmlTagBlock"}, {"methodBody": ["METHOD_START", "{", "ASTNode   child    =    textNode . getFirstChildNode (  )  ;", "return   createXmlTexts ( list ,    textNode ,    child ,    wrap ,    alignment )  ;", "}", "METHOD_END"], "methodName": ["createXmlTextBlocks"], "fileName": "com.intellij.psi.formatter.xml.XmlTagBlock"}, {"methodBody": ["METHOD_START", "{", "return   myXmlFormattingPolicy . indentChildrenOf ( getTag (  )  )     ?    Indent . getNormalIndent (  )     :    Indent . getNoneIndent (  )  ;", "}", "METHOD_END"], "methodName": ["getChildrenIndent"], "fileName": "com.intellij.psi.formatter.xml.XmlTagBlock"}, {"methodBody": ["METHOD_START", "{", "if    (  ( syntheticBlock 2  . startsWithCDATA (  )  )     |  |     ( syntheticBlock 1  . endsWithCDATA (  )  )  )     {", "return   Spacing . getReadOnlySpacing (  )  ;", "}", "if    (  (  ( syntheticBlock 1  . containsCDATA (  )  )     &  &     ( syntheticBlock 2  . isTagDescription (  )  )  )     |  |     (  ( syntheticBlock 1  . isTagDescription (  )  )     &  &     ( syntheticBlock 2  . containsCDATA (  )  )  )  )     {", "int   lineFeeds    =     0  ;", "switch    ( myXmlFingPolicy . getWhiteSpaceAroundCDATAOption (  )  )     {", "case   XmlCodeStyleSettings . WS _ AROUND _ CDATA _ NONE    :", "break ;", "case   XmlCodeStyleSettings . WS _ AROUND _ CDATA _ NEW _ LINES    :", "lineFeeds    =     1  ;", "break ;", "case   XmlCodeStyleSettings . WS _ AROUND _ CDATA _ PRESERVE    :", "return   Spacing . getReadOnlySpacing (  )  ;", "default    :", "assert   false    :     \" Unexpected   whitespace   around   CDATA   code   style   option .  \"  ;", "}", "return   Spacing . createSpacing (  0  ,     0  ,    lineFeeds ,    myXmlFingPolicy . getShouldKeepLineBreaks (  )  ,    myXmlFingPolicy . getKeepBlankLines (  )  )  ;", "}", "if    (  ( syntheticBlock 2  . isJspTextBlock (  )  )     |  |     ( syntheticBlock 1  . isJspTextBlock (  )  )  )     {", "return   Spacing . createSafeSpacing ( myXmlFingPolicy . getShouldKeepLineBreaks (  )  ,    myXmlFingPolicy . getKeepBlankLines (  )  )  ;", "}", "if    (  ( syntheticBlock 2  . isJspxTextBlock (  )  )     |  |     ( syntheticBlock 1  . isJspxTextBlock (  )  )  )     {", "return   Spacing . createSpacing (  0  ,     0  ,     1  ,    myXmlFingPolicy . getShouldKeepLineBreaks (  )  ,    myXmlFingPolicy . getKeepBlankLines (  )  )  ;", "}", "if    ( myXmlFingPolicy . keepWhiteSpacesInsideTag ( getTag (  )  )  )", "return   Spacing . getReadOnlySpacing (  )  ;", "if    ( myXmlFingPolicy . getShouldKeepWhiteSpaces (  )  )     {", "return   Spacing . getReadOnlySpacing (  )  ;", "}", "if    ( syntheticBlock 2  . startsWithTag (  )  )     {", "final   XmlTag   startTag    =    syntheticBlock 2  . getStartTag (  )  ;", "if    (  ( myXmlFingPolicy . keepWhiteSpacesInsideTag ( startTag )  )     &  &     ( startTag . textContains (  '  \\ n '  )  )  )     {", "return    ( getChildrenIndent (  )  )     !  =     ( Indent . getNoneIndent (  )  )     ?    Spacing . getReadOnlySpacing (  )     :    Spacing . createSpacing (  0  ,     0  ,     0  ,    true ,    myXmlFingPolicy . getKeepBlankLines (  )  )  ;", "}", "}", "boolean   saveSpacesBetweenTagAndText    =     ( myXmlFingPolicy . shouldSaveSpacesBetweenTagAndText (  )  )     &  &     (  ( syntheticBlock 1  . getTextRange (  )  . getEndOffset (  )  )     <     ( syntheticBlock 2  . getTextRange (  )  . getStartOffset (  )  )  )  ;", "if    (  ( syntheticBlock 1  . endsWithTextElement (  )  )     &  &     ( syntheticBlock 2  . startsWithTextElement (  )  )  )     {", "return   Spacing . createSafeSpacing ( myXmlFingPolicy . getShouldKeepLineBreaksInText (  )  ,    myXmlFingPolicy . getKeepBlankLines (  )  )  ;", "}", "if    ( syntheticBlock 1  . endsWithText (  )  )     {", "if    ( syntheticBlock 1  . insertLineFeedAfter (  )  )     {", "return   Spacing . createDependentLFSpacing (  0  ,     0  ,    getTag (  )  . getTextRange (  )  ,    myXmlFingPolicy . getShouldKeepLineBreaks (  )  ,    myXmlFingPolicy . getKeepBlankLines (  )  )  ;", "}", "if    ( saveSpacesBetweenTagAndText )     {", "return   Spacing . createSafeSpacing ( myXmlFingPolicy . getShouldKeepLineBreaks (  )  ,    myXmlFingPolicy . getKeepBlankLines (  )  )  ;", "}", "return   Spacing . createSpacing (  0  ,     0  ,     0  ,    myXmlFingPolicy . getShouldKeepLineBreaks (  )  ,    myXmlFingPolicy . getKeepBlankLines (  )  )  ;", "} else", "if    (  ( syntheticBlock 1  . isTagDescription (  )  )     &  &     ( syntheticBlock 2  . isTagDescription (  )  )  )     {", "return   Spacing . createSpacing (  0  ,     0  ,     0  ,    myXmlFingPolicy . getShouldKeepLineBreaks (  )  ,    myXmlFingPolicy . getKeepBlankLines (  )  )  ;", "} else", "if    ( syntheticBlock 2  . startsWithText (  )  )     {", "if    ( saveSpacesBetweenTagAndText )     {", "return   Spacing . createSafeSpacing ( true ,    myXmlFingPolicy . getKeepBlankLines (  )  )  ;", "}", "return   Spacing . createSpacing (  0  ,     0  ,     0  ,    true ,    myXmlFingPolicy . getKeepBlankLines (  )  )  ;", "} else", "if    (  ( syntheticBlock 1  . isTagDescription (  )  )     &  &     ( syntheticBlock 2  . startsWithTag (  )  )  )     {", "return   Spacing . createSpacing (  0  ,     0  ,     ( myXmlFingPolicy . insertLineBreakAfterTagBegin ( getTag (  )  )     ?     2     :     0  )  ,    true ,    myXmlFingPolicy . getKeepBlankLines (  )  )  ;", "} else", "if    ( syntheticBlock 1  . insertLineFeedAfter (  )  )     {", "return   Spacing . createSpacing (  0  ,     0  ,     1  ,    true ,    myXmlFingPolicy . getKeepBlankLines (  )  )  ;", "} else", "if    (  ( syntheticBlock 1  . endsWithTag (  )  )     &  &     ( syntheticBlock 2  . isTagDescription (  )  )  )     {", "return   Spacing . createSpacing (  0  ,     0  ,     ( myXmlFingPolicy . insertLineBreakAfterTagBegin ( getTag (  )  )     ?     2     :     0  )  ,    true ,    myXmlFingPolicy . getKeepBlankLines (  )  )  ;", "} else    {", "return   createDefaultSpace ( true ,    true )  ;", "}", "}", "METHOD_END"], "methodName": ["getSpacing"], "fileName": "com.intellij.psi.formatter.xml.XmlTagBlock"}, {"methodBody": ["METHOD_START", "{", "List < Block >    subBlocks    =    getSubBlocks (  )  ;", "int   index    =    newChildIndex    -     1  ;", "Block   prevBlock    =     ( index    <     ( subBlocks . size (  )  )  )     ?    subBlocks . get ( index )     :    null ;", "return    ( prevBlock   instanceof   SyntheticBlock )     &  &     (  (  ( SyntheticBlock )     ( prevBlock )  )  . endsWithAttribute (  )  )  ;", "}", "METHOD_END"], "methodName": ["isAfterAttribute"], "fileName": "com.intellij.psi.formatter.xml.XmlTagBlock"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isJspResult"], "fileName": "com.intellij.psi.formatter.xml.XmlTagBlock"}, {"methodBody": ["METHOD_START", "{", "return   new   XHtmlFilterLexer ( new   HtmlHighlightingLexer ( FileTypeManager . getInstance (  )  . getStdFileType (  \" CSS \"  )  )  ,    consumer )  ;", "}", "METHOD_END"], "methodName": ["createIndexingLexer"], "fileName": "com.intellij.psi.impl.cache.impl.idCache.HtmlIdIndexer"}, {"methodBody": ["METHOD_START", "{", "return   new   XHtmlFilterLexer ( new   XHtmlHighlightingLexer (  )  ,    consumer )  ;", "}", "METHOD_END"], "methodName": ["createIndexingLexer"], "fileName": "com.intellij.psi.impl.cache.impl.idCache.XHtmlIdIndexer"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlFilterLexer ( new   XmlLexer (  )  ,    consumer )  ;", "}", "METHOD_END"], "methodName": ["createIndexingLexer"], "fileName": "com.intellij.psi.impl.cache.impl.idCache.XmlIdIndexer"}, {"methodBody": ["METHOD_START", "{", "return    ( HtmlConditionalCommentInjector . parseConditionalCommentBoundaries ( host )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isConditionalComment"], "fileName": "com.intellij.psi.impl.source.html.HtmlConditionalCommentInjector"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( host   instanceof   XmlComment )  )     {", "return   null ;", "}", "final   ASTNode   comment    =    host . getNode (  )  ;", "if    ( comment    =  =    null )     {", "return   null ;", "}", "final   ASTNode   cStart    =    comment . findChildByType ( TokenSet . create ( XmlTokenType . XML _ CONDITIONAL _ COMMENT _ START _ END )  )  ;", "if    ( cStart    =  =    null )     {", "return   null ;", "}", "final   ASTNode   cEnd    =    comment . findChildByType ( TokenSet . create ( XmlTokenType . XML _ CONDITIONAL _ COMMENT _ END _ START )  )  ;", "if    ( cEnd    =  =    null )     {", "return   null ;", "}", "final   ASTNode   endOfEnd    =    comment . findChildByType ( TokenSet . create ( XmlTokenType . XML _ CONDITIONAL _ COMMENT _ END )  )  ;", "return   endOfEnd    =  =    null    ?    null    :    Pair . create ( cStart ,    cEnd )  ;", "}", "METHOD_END"], "methodName": ["parseConditionalCommentBoundaries"], "fileName": "com.intellij.psi.impl.source.html.HtmlConditionalCommentInjector"}, {"methodBody": ["METHOD_START", "{", "String   s    =    super . toString (  )  ;", "final   IElemType   type    =    getNode (  )  . getElemType (  )  ;", "if    ( type    !  =     ( XmlElemType . HTML _ EMBEDDED _ CONTENT )  )", "s    +  =     \"  :  \"     +    type ;", "return   s ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.psi.impl.source.html.HtmlEmbeddedContentImpl"}, {"methodBody": ["METHOD_START", "{", "return    \" HtmlFile :  \"     +     ( getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.psi.impl.source.html.HtmlFileImpl"}, {"methodBody": ["METHOD_START", "{", "Collection < Language >    allFileLanguages    =    xmlTag . getContainingFile (  )  . getViewProvider (  )  . getLanguages (  )  ;", "for    ( Language   fileLanguage    :    allFileLanguages )     {", "for    ( HtmlScriptInjectionBlocker   blocker    :     . INSTANCE . allForLanguage ( fileLanguage )  )     {", "if    ( blocker . isLanguageInjectionDenied ( xmlTag ,    language )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isInjectionBlocked"], "fileName": "com.intellij.psi.impl.source.html.HtmlScriptInjectionBlockerExtension"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( HtmlUtil . isScriptTag ( xmlTag )  )  )     {", "return   null ;", "}", "String   mimeType    =    xmlTag . getAttributeValue (  \" type \"  )  ;", "Collection <  >    languages    =     . findInstancesByMimeType ( mimeType )  ;", "return    !  ( languages . isEmpty (  )  )     ?    languages . iterator (  )  . next (  )     :     . ANY ;", "}", "METHOD_END"], "methodName": ["getScriptLanguageToInject"], "fileName": "com.intellij.psi.impl.source.html.HtmlScriptLanguageInjector"}, {"methodBody": ["METHOD_START", "{", "return    \" HtmlTag :  \"     +     ( getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.psi.impl.source.html.HtmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "element . putUserData ( ScriptSupportUtil . CachedScriptTagsKey ,    null )  ;", "}", "METHOD_END"], "methodName": ["clearCaches"], "fileName": "com.intellij.psi.impl.source.html.ScriptSupportUtil"}, {"methodBody": ["METHOD_START", "{", "CachedValue < XmlTag [  ]  >    myCachedScriptTags    =    element . getUserData ( ScriptSupportUtil . CachedScriptTagsKey )  ;", "if    ( myCachedScriptTags    =  =    null )     {", "myCachedScriptTags    =    CachedValuesManager . getManager ( element . getProject (  )  )  . createCachedValue (  (  )     -  >     {", "final   List < XmlTag >    scriptTags    =    new   ArrayList <  >  (  )  ;", "final   XmlDocument   document    =    HtmlPsiUtil . getRealXmlDocument ( element . getDocument (  )  )  ;", "if    ( document    !  =    null )     {", "PsiElementProcessor   psiElementProcessor    =    new   PsiElementProcessor (  )     {", "@ Override", "public   boolean   execute (  @ NotNull", "final   PsiElement   element 1  )     {", "if    ( element 1    instanceof   XmlTag )     {", "final   XmlTag   tag    =     (  ( XmlTag )     ( element 1  )  )  ;", "if    ( HtmlUtil . SCRIPT _ TAG _ NAME . equalsIgnoreCase ( tag . getName (  )  )  )     {", "final   XmlElementDescriptor   descriptor    =    tag . getDescriptor (  )  ;", "if    (  ( descriptor    !  =    null )     &  &     ( HtmlUtil . SCRIPT _ TAG _ NAME . equals ( descriptor . getName (  )  )  )  )     {", "scriptTags . add ( tag )  ;", "}", "}", "}", "return   true ;", "}", "}  ;", "XmlPsiUtil . processXmlElements ( document ,    psiElementProcessor ,    true )  ;", "}", "return   new   CachedValueProvider . Result <  >  ( scriptTags . toArray ( XmlTag . EMPTY )  ,    element )  ;", "}  ,    false )  ;", "element . putUserData ( ScriptSupportUtil . CachedScriptTagsKey ,    myCachedScriptTags )  ;", "}", "if    (  ( ScriptSupportUtil . ProcessingDeclarationsFlag . get (  )  )     !  =    null )", "return   true ;", "try    {", "ScriptSupportUtil . ProcessingDeclarationsFlag . set (  \"  \"  )  ;", "for    ( XmlTag   tag    :    myCachedScriptTags . getValue (  )  )     {", "final   XmlTagChild [  ]    children    =    tag . getValue (  )  . getChildren (  )  ;", "for    ( XmlTagChild   child    :    children )     {", "if    (  !  ( child . processDeclarations ( processor ,    state ,    null ,    place )  )  )", "return   false ;", "}", "if    (  ( tag . getAttributeValue (  \" src \"  )  )     !  =    null )     {", "final   XmlAttribute   attribute    =    tag . getAttribute (  \" src \"  ,    null )  ;", "if    ( attribute    !  =    null )     {", "final   PsiFile   psiFile    =    FileReferenceUtil . findFile ( attribute . getValueElement (  )  )  ;", "if    (  ( psiFile    !  =    null )     &  &     ( psiFile . isValid (  )  )  )     {", "if    (  !  ( psiFile . processDeclarations ( processor ,    state ,    null ,    place )  )  )     {", "return   false ;", "}", "}", "}", "}", "}", "}    finally    {", "ScriptSupportUtil . ProcessingDeclarationsFlag . set ( null )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["processDeclarations"], "fileName": "com.intellij.psi.impl.source.html.ScriptSupportUtil"}, {"methodBody": ["METHOD_START", "{", "return   myCaseSensitive ;", "}", "METHOD_END"], "methodName": ["isCaseSensitive"], "fileName": "com.intellij.psi.impl.source.html.dtd.HtmlAttributeDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["allowElementsFromNamespace"], "fileName": "com.intellij.psi.impl.source.html.dtd.HtmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return   super . getAttributesDescriptors ( context )  ;", "}", "METHOD_END"], "methodName": ["getDefaultAttributeDescriptors"], "fileName": "com.intellij.psi.impl.source.html.dtd.HtmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return   HtmlNSDescriptorImpl . myCachedDeclsCache . get ( this )  ;", "}", "METHOD_END"], "methodName": ["buildDeclarationMap"], "fileName": "com.intellij.psi.impl.source.html.dtd.HtmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "HashMap < String ,    XmlElementDescriptor >    decls    =    new   HashMap <  >  (  )  ;", "XmlElementDescriptor [  ]    elements    =     (  ( myDelegate )     =  =    null )     ?    XmlElementDescriptor . EMPTY _ ARRAY    :    myDelegate . getRootElementsDescriptors ( null )  ;", "for    ( XmlElementDescriptor   element    :    elements )     {", "decls . put ( element . getName (  )  ,    new   HtmlElement ( element ,    myRelaxed ,    myCaseSensitive )  )  ;", "}", "return   decls ;", "}", "METHOD_END"], "methodName": ["doBuildCachedMap"], "fileName": "com.intellij.psi.impl.source.html.dtd.HtmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "final   XmlElementDescriptor   descriptor    =    HtmlNSDescriptorImpl . guessTagForCommonAttributes ( context )  ;", "if    ( descriptor    !  =    null )     {", "return   descriptor . getAttributeDescriptor ( attributeName ,    context )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getCommonAttributeDescriptor"], "fileName": "com.intellij.psi.impl.source.html.dtd.HtmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "final   XmlElementDescriptor   descriptor    =    HtmlNSDescriptorImpl . guessTagForCommonAttributes ( context )  ;", "if    ( descriptor    !  =    null )     {", "return   descriptor . getAttributesDescriptors ( context )  ;", "}", "return   XmlAttributeDescriptor . EMPTY ;", "}", "METHOD_END"], "methodName": ["getCommonAttributeDescriptors"], "fileName": "com.intellij.psi.impl.source.html.dtd.HtmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( myCaseSensitive )  )", "name    =    name . toLowerCase (  )  ;", "return   buildDeclarationMap (  )  . get ( name )  ;", "}", "METHOD_END"], "methodName": ["getElementDescriptorByName"], "fileName": "com.intellij.psi.impl.source.html.dtd.HtmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( context    =  =    null )", "return   null ;", "final   XmlNSDescriptor   nsDescriptor    =    context . getNSDescriptor ( context . getNamespace (  )  ,    false )  ;", "if    ( nsDescriptor   instanceof    )     {", "XmlElementDescriptor   descriptor    =     (  (  )     ( nsDescriptor )  )  . getElementDescriptorByName (  \" div \"  )  ;", "descriptor    =     ( descriptor    =  =    null )     ?     (  (  )     ( nsDescriptor )  )  . getElementDescriptorByName (  \" span \"  )     :    descriptor ;", "return   descriptor ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["guessTagForCommonAttributes"], "fileName": "com.intellij.psi.impl.source.html.dtd.HtmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "myBuilder . advanceLexer (  )  ;", "}", "METHOD_END"], "methodName": ["addToken"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( type    =  =     ( XmlTokenType . XML _ DOCTYPE _ PUBLIC )  )     |  |     ( type    =  =     ( XmlTokenType . XML _ DOCTYPE _ SYSTEM )  )  )     |  |     ( type    =  =     ( XmlTokenType . XML _ CONTENT _ EMPTY )  )  )     |  |     ( type    =  =     ( XmlTokenType . XML _ CONTENT _ ANY )  )  )     {", "myBuilder . remapCurrentToken ( XmlTokenType . XML _ NAME )  ;", "addToken (  )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["consumeKeywordAsName"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ! topLevel )     &  &     (  ( myBuilder . rawLookup (  0  )  )     !  =     ( XmlTokenType . XML _ WHITE _ SPACE )  )  )     {", "myBuilder . error ( XmlErrorMessages . message (  \" dtd . parser . message . whitespace . expected \"  )  )  ;", "} else", "if    (  ! topLevel )     {", "final   tree . IElementType   tokenType    =    myBuilder . getTokenType (  )  ;", "String   tokenText ;", "if    (  (  (  (  ( tokenType    !  =     ( XmlTokenType . XML _ LEFT _ PAREN )  )     &  &     ( tokenType    !  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )  )     &  &     ( tokenType    !  =     ( XmlTokenType . XML _ CONTENT _ ANY )  )  )     &  &     ( tokenType    !  =     ( XmlTokenType . XML _ CONTENT _ EMPTY )  )  )     &  &     (  ( tokenType    !  =     ( XmlTokenType . XML _ NAME )  )     |  |     (  (  !  (  \"  -  \"  . equals (  ( tokenText    =    myBuilder . getTokenText (  )  )  )  )  )     &  &     (  !  (  \" O \"  . equals ( tokenText )  )  )  )  )  )     {", "PsiBuilder . Marker   spec    =    myBuilder . mark (  )  ;", "spec . done ( XmlElementType . XML _ ELEMENT _ CONTENT _ SPEC )  ;", "myBuilder . error ( XmlErrorMessages . message (  \" dtd . parser . message . left . paren . or . entityref . or . empty . or . any . expected \"  )  )  ;", "return ;", "}", "}", "PsiBuilder . Marker   spec    =    myBuilder . mark (  )  ;", "parseElementContentSpecInner ( topLevel )  ;", "spec . done ( XmlElementType . XML _ ELEMENT _ CONTENT _ SPEC )  ;", "}", "METHOD_END"], "methodName": ["doParseContentSpec"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "short   state    =     0  ;", "switch    ( context )     {", "case   ELEMENT _ CONTENT _ SPEC    :", "case   ATTRIBUTE _ SPEC    :", "case   ATTLIST _ SPEC    :", "case   ENUMERATED _ TYPE    :", "case   ENTITY _ DECL _ CONTENT    :", "{", "state    =     _ DtdLexer . DOCTYPE _ MARKUP ;", "break ;", "}", "case   ATTR _ VALUE    :", "case   GENERIC _ XML    :", "{", "break ;", "}", "default    :", ". LOG . error (  (  \" context :     \"     +    context )  )  ;", "}", "if    (  ( rootNodeType    =  =     ( XmlElementType . XML _ MARKUP _ DECL )  )     &  &     ( context    =  =     (  . TYPE _ FOR _ MARKUP _ DECL )  )  )     {", "state    =     _ DtdLexer . DOCTYPE ;", "}", "return   state ;", "}", "METHOD_END"], "methodName": ["getLexerInitialState"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "return    ( type    =  =     ( XmlTokenType . XML _ ATTLIST _ DECL _ START )  )     |  |     ( type    =  =     ( XmlTokenType . XML _ ELEMENT _ DECL _ START )  )  ;", "}", "METHOD_END"], "methodName": ["isAnotherDeclStart"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   root    =    myBuilder . mark (  )  ;", "if    (  ( myRootType )     =  =     ( XmlElementType . XML _ MARKUP _ DECL )  )     {", "eTopLevelMarkupDecl (  )  ;", "root . done ( myRootType )  ;", "return   myBuilder . getTreeBuilt (  )  ;", "}", "PsiBuilder . Marker   document    =    null ;", "if    (  ( myRootType )     =  =     ( XmlElementType . DTD _ FILE )  )     {", "document    =    myBuilder . mark (  )  ;", "eProlog (  )  ;", "}", "switch    ( myContextType )     {", "case   GENERIC _ XML    :", "eGenericXml (  )  ;", "break ;", "case   ELEMENT _ CONTENT _ SPEC    :", "doParseContentSpec ( true )  ;", "break ;", "case   ATTLIST _ SPEC    :", "eAttlistContent (  )  ;", "break ;", "case   ATTR _ VALUE    :", "eAttrValue (  )  ;", "case   ATTRIBUTE _ SPEC    :", "eAttributeContentSpec (  )  ;", "break ;", "case   ENTITY _ DECL _ CONTENT    :", "eEntityDeclContent (  )  ;", "break ;", "case   ENUMERATED _ TYPE    :", "eEnumeratedTypeContent (  )  ;", "break ;", "}", "while    (  !  ( myBuilder . eof (  )  )  )", "myBuilder . advanceLexer (  )  ;", "if    ( document    !  =    null )", "document . done ( XmlElementType . XML _ DOCUMENT )  ;", "root . done ( myRootType )  ;", "ASTNode   astNode    =    myBuilder . getTreeBuilt (  )  ;", "if    (  ( myRootType )     !  =     ( XmlElementType . DTD _ FILE )  )     {", "PsiFile   file    =    myBuilder . getUserDataUnprotected ( CONTAINING _ FILE _ KEY )  ;", "if    ( file    !  =    null )     {", "final   DummyHolder   result    =    DummyHolderFactory . createHolder ( file . getManager (  )  ,    DTDLanguage . INSTANCE ,    file )  ;", "final   FileElement   holder    =    result . getTreeElement (  )  ;", "holder . rawAddChildren (  (  ( TreeElement )     ( astNode )  )  )  ;", "}", "}", "return   astNode ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "while    ( true )     {", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )     {", "eEntityRef (  )  ;", "} else", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ COMMENT _ START )  )     {", "eComment (  )  ;", "} else", "if    ( eAttributeDecl (  )  )     {", "} else    {", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseAttlistContent"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myBuilder . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ ATTLIST _ DECL _ START )  )     {", "return ;", "}", "PsiBuilder . Marker   decl    =    myBuilder . mark (  )  ;", "addToken (  )  ;", "if    (  ! eName (  )  )  )     {", "final   IElementType   tokenType    =    myBuilder . getTokenType (  )  ;", "if    ( tokenType    =  =     ( XmlTokenType . XML _ LEFT _ PAREN )  )     {", "eGroup (  )  ;", "} else    {", "myBuilder . error ( XmlErrorMessages . message (  \" dtder . message . name . expected \"  )  )  ;", "decl . done ( XmlElementType . XML _ ATTLIST _ DECL )  ;", "return ;", "}", "}", "eAttlistContent (  )  ;", "skipTillEndOfBlock (  )  ;", "decl . done ( XmlElementType . XML _ ATTLIST _ DECL )  ;", "}", "METHOD_END"], "methodName": ["parseAttlistDecl"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "while    (  ( myBuilder . getTokenType (  )  )     !  =    null )     {", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )     {", "eEntityRef (  )  ;", "} else    {", "addToken (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseAttrValue"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "if    ( parseName (  )  )     {", "} else", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ LEFT _ PAREN )  )     {", "parseEnumeratedType (  )  ;", "} else    {", "return   true ;", "}", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ ATT _ IMPLIED )  )     {", "addToken (  )  ;", "} else", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ ATT _ REQUIRED )  )     {", "addToken (  )  ;", "} else", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ ATT _ FIXED )  )     {", "addToken (  )  ;", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ START _ DELIMITER )  )     {", "parseAttributeValue (  )  ;", "}", "} else", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ START _ DELIMITER )  )     {", "parseAttributeValue (  )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["parseAttributeContentSpec"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myBuilder . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ NAME )  )     {", "return   false ;", "}", "PsiBuilder . Marker   decl    =    myBuilder . mark (  )  ;", "addToken (  )  ;", "final   boolean   b    =    eAttributeContentSpec (  )  ;", "decl . done ( XmlElementType . XML _ ATTRIBUTE _ DECL )  ;", "return   b ;", "}", "METHOD_END"], "methodName": ["parseAttributeDecl"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "int   lastPosition    =     -  1  ;", "while    ( true )     {", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )     {", "eEntityRef (  )  ;", "continue ;", "}", "if    (  ( myBuilder . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ NAME )  )     {", "return ;", "}", "if    ( lastPosition    !  =     (  -  1  )  )     {", "if    ( lastPosition    =  =     ( myBuilder . getCurrentOffset (  )  )  )     {", "myBuilder . error ( XmlErrorMessages . message (  \" expected . whitespace \"  )  )  ;", "lastPosition    =     -  1  ;", "}", "}", "addToken (  )  ;", "if    (  ( myBuilder . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ EQ )  )     {", "myBuilder . error ( XmlErrorMessages . message (  \" expected . attribute . eq . sign \"  )  )  ;", "continue ;", "}", "addToken (  )  ;", "if    (  ( myBuilder . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ START _ DELIMITER )  )     {", "return ;", "}", "addToken (  )  ;", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ TOKEN )  )     {", "addToken (  )  ;", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ END _ DELIMITER )  )     {", "lastPosition    =    myBuilder . getCurrentOffset (  )  ;", "addToken (  )  ;", "} else    {", "lastPosition    =     -  1  ;", "}", "} else", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ END _ DELIMITER )  )     {", "lastPosition    =    myBuilder . getCurrentOffset (  )  ;", "addToken (  )  ;", "} else    {", "lastPosition    =     -  1  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseAttributeList"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myBuilder . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ START _ DELIMITER )  )     {", "return    -  1  ;", "}", "PsiBuilder . Marker   value    =    myBuilder . mark (  )  ;", "addToken (  )  ;", "while    ( true )     {", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ TOKEN )  )     {", "addToken (  )  ;", "} else", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ CHAR _ ENTITY _ REF )  )     {", "addToken (  )  ;", "} else", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )     {", "eEntityRef (  )  ;", "} else    {", "break ;", "}", "}", "if    (  ( myBuilder . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ END _ DELIMITER )  )     {", "value . done ( XmlElementType . XML _ ATTRIBUTE _ VALUE )  ;", "return    -  1  ;", "}", "int   tokenEnd    =    myBuilder . getCurrentOffset (  )  ;", "addToken (  )  ;", "value . done ( XmlElementType . XML _ ATTRIBUTE _ VALUE )  ;", "return   tokenEnd ;", "}", "METHOD_END"], "methodName": ["parseAttributeValue"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "if    (  ! eName (  )  )  )     {", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ LEFT _ PAREN )  )     {", "eGroup (  )  ;", "} else    {", "myBuilder . error ( XmlErrorMessages . message (  \" dtder . message . name . expected \"  )  )  ;", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["parseCompositeName"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myBuilder . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ CONDITIONAL _ SECTION _ START )  )     {", "return   false ;", "}", "PsiBuilder . Marker   conditionalSection    =    myBuilder . mark (  )  ;", "addToken (  )  ;", "IElementType   tokenType    =    myBuilder . getTokenType (  )  ;", "if    (  (  ( tokenType    !  =     ( XmlTokenType . XML _ CONDITIONAL _ IGNORE )  )     &  &     ( tokenType    !  =     ( XmlTokenType . XML _ CONDITIONAL _ INCLUDE )  )  )     &  &     ( tokenType    !  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )  )     {", "conditionalSection . done ( XmlElementType . XML _ CONDITIONAL _ SECTION )  ;", "return   true ;", "}", "if    ( tokenType    =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )     {", "eEntityRef (  )  ;", "} else    {", "addToken (  )  ;", "}", "if    (  ( myBuilder . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ MARKUP _ START )  )     {", "conditionalSection . done ( XmlElementType . XML _ CONDITIONAL _ SECTION )  ;", "return   true ;", "}", "eMarkupContent (  )  ;", "if    (  ( myBuilder . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ CONDITIONAL _ SECTION _ END )  )     {", "conditionalSection . done ( XmlElementType . XML _ CONDITIONAL _ SECTION )  ;", "return   true ;", "}", "addToken (  )  ;", "conditionalSection . done ( XmlElementType . XML _ CONDITIONAL _ SECTION )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["parseConditionalSection"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myBuilder . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ DECL _ START )  )     {", "return ;", "}", "PsiBuilder . Marker   decl    =    myBuilder . mark (  )  ;", "addToken (  )  ;", "eAttributeList (  )  ;", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ DECL _ END )  )     {", "addToken (  )  ;", "} else    {", "myBuilder . error ( XmlErrorMessages . message (  \" expected . prologue . tag . termination . expected \"  )  )  ;", "}", "decl . done ( XmlElementType . XML _ DECL )  ;", "}", "METHOD_END"], "methodName": ["parseDecl"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myBuilder . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ DOCTYPE _ START )  )     {", "return ;", "}", "PsiBuilder . Marker   docType    =    myBuilder . mark (  )  ;", "addToken (  )  ;", "if    (  ( myBuilder . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ NAME )  )     {", "docType . done ( XmlElementType . XML _ DOCTYPE )  ;", "return ;", "}", "addToken (  )  ;", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ DOCTYPE _ SYSTEM )  )     {", "addToken (  )  ;", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ TOKEN )  )     {", "addToken (  )  ;", "}", "} else", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ DOCTYPE _ PUBLIC )  )     {", "addToken (  )  ;", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ TOKEN )  )     {", "addToken (  )  ;", "}", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ TOKEN )  )     {", "addToken (  )  ;", "}", "}", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ MARKUP _ START )  )     {", "eMarkupDecl (  )  ;", "}", "if    (  ( myBuilder . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ DOCTYPE _ END )  )     {", "docType . done ( XmlElementType . XML _ DOCTYPE )  ;", "return ;", "}", "addToken (  )  ;", "docType . done ( XmlElementType . XML _ DOCTYPE )  ;", "}", "METHOD_END"], "methodName": ["parseDocType"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "IElementType   tokenType    =    myBuilder . getTokenType (  )  ;", "boolean   endedWithDelimiter    =    false ;", "while    (  (  (  (  (  ( tokenType    !  =    null )     &  &     ( tokenType    !  =     ( XmlTokenType . XML _ TAG _ END )  )  )     &  &     ( tokenType    !  =     ( XmlTokenType . XML _ START _ TAG _ START )  )  )     &  &     ( tokenType    !  =     ( XmlTokenType . XML _ ELEMENT _ DECL _ START )  )  )     &  &     ( tokenType    !  =     ( XmlTokenType . XML _ RIGHT _ PAREN )  )  )     &  &     ( tokenType    !  =     ( XmlTokenType . XML _ COMMENT _ START )  )  )     {", "if    (  ( tokenType    =  =     ( XmlTokenType . XML _ BAR )  )     &  &    topLevel )     {", "addToken (  )  ;", "tokenType    =    myBuilder . getTokenType (  )  ;", "continue ;", "} else", "if    ( tokenType    =  =     ( XmlTokenType . XML _ LEFT _ PAREN )  )     {", "if    (  ! eGroup (  )  )  )", "return   false ;", "endedWithDelimiter    =    false ;", "} else", "if    ( tokenType    =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )     {", "eEntityRef (  )  ;", "endedWithDelimiter    =    false ;", "} else", "if    (  (  (  ( tokenType    =  =     ( XmlTokenType . XML _ NAME )  )     |  |     ( tokenType    =  =     ( XmlTokenType . XML _ CONTENT _ EMPTY )  )  )     |  |     ( tokenType    =  =     ( XmlTokenType . XML _ CONTENT _ ANY )  )  )     |  |     ( tokenType    =  =     ( XmlTokenType . XML _ PCDATA )  )  )     {", "addToken (  )  ;", "endedWithDelimiter    =    false ;", "} else", "if    ( consumeKeywordAsName ( tokenType )  )     {", "endedWithDelimiter    =    false ;", "} else    {", "myBuilder . error ( XmlErrorMessages . message (  \" dtder . message . name . or . entity . ref . expected \"  )  )  ;", "return   false ;", "}", "tokenType    =    myBuilder . getTokenType (  )  ;", "if    (  (  ( tokenType    =  =     ( XmlTokenType . XML _ STAR )  )     |  |     ( tokenType    =  =     ( XmlTokenType . XML _ PLUS )  )  )     |  |     ( tokenType    =  =     ( XmlTokenType . XML _ QUESTION )  )  )     {", "addToken (  )  ;", "tokenType    =    myBuilder . getTokenType (  )  ;", "if    ( tokenType    =  =     ( XmlTokenType . XML _ PLUS )  )     {", "addToken (  )  ;", "tokenType    =    myBuilder . getTokenType (  )  ;", "}", "}", "if    (  ( tokenType    =  =     ( XmlTokenType . XML _ BAR )  )     |  |     ( tokenType    =  =     ( XmlTokenType . XML _ COMMA )  )  )     {", "addToken (  )  ;", "tokenType    =    myBuilder . getTokenType (  )  ;", "endedWithDelimiter    =    true ;", "}", "}", "if    ( endedWithDelimiter    &  &     ( tokenType    =  =     ( XmlTokenType . XML _ RIGHT _ PAREN )  )  )     {", "myBuilder . error ( XmlErrorMessages . message (  \" dtder . message . name . or . entity . ref . expected \"  )  )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["parseElementContentSpecInner"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myBuilder . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ ELEMENT _ DECL _ START )  )     {", "return ;", "}", "PsiBuilder . Marker   decl    =    myBuilder . mark (  )  ;", "addToken (  )  ;", "if    ( eCompositeName (  )  )     {", "decl . done ( XmlElementType . XML _ ELEMENT _ DECL )  ;", "return ;", "}", "doParseContentSpec ( false )  ;", "skipTillEndOfBlock (  )  ;", "decl . done ( XmlElementType . XML _ ELEMENT _ DECL )  ;", "}", "METHOD_END"], "methodName": ["parseElementDecl"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myBuilder . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ ENTITY _ DECL _ START )  )     {", "return ;", "}", "PsiBuilder . Marker   decl    =    myBuilder . mark (  )  ;", "addToken (  )  ;", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ PERCENT )  )     {", "addToken (  )  ;", "}", "if    ( eCompositeName (  )  )     {", "decl . done ( XmlElementType . XML _ ENTITY _ DECL )  ;", "return ;", "}", "eEntityDeclContent (  )  ;", "if    (  ( myBuilder . getTokenType (  )  )     !  =    null )     {", "addToken (  )  ;", "}", "decl . done ( XmlElementType . XML _ ENTITY _ DECL )  ;", "}", "METHOD_END"], "methodName": ["parseEntityDecl"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "IElementType   tokenType    =    myBuilder . getTokenType (  )  ;", "if    (  (  ( tokenType    !  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ START _ DELIMITER )  )     &  &     ( tokenType    !  =     ( XmlTokenType . XML _ DOCTYPE _ PUBLIC )  )  )     &  &     ( tokenType    !  =     ( XmlTokenType . XML _ DOCTYPE _ SYSTEM )  )  )     {", "myBuilder . error ( XmlErrorMessages . message (  \" dtder . message . literal . public . system . expected \"  )  )  ;", "return ;", "}", "while    (  ( tokenType    !  =     ( XmlTokenType . XML _ TAG _ END )  )     &  &     ( tokenType    !  =    null )  )     {", "if    ( tokenType    =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ START _ DELIMITER )  )     {", "eAttributeValue (  )  ;", "} else    {", "addToken (  )  ;", "}", "tokenType    =    myBuilder . getTokenType (  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseEntityDeclContent"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "PsiBuilder . Marker   ref    =    myBuilder . mark (  )  ;", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )     {", "addToken (  )  ;", "}", "ref . done ( XmlElementType . XML _ ENTITY _ REF )  ;", "}", "METHOD_END"], "methodName": ["parseEntityRef"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "PsiBuilder . Marker   enumeratedType    =    myBuilder . mark (  )  ;", "addToken (  )  ;", "eEnumeratedTypeContent (  )  ;", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ RIGHT _ PAREN )  )     {", "addToken (  )  ;", "}", "enumeratedType . done ( XmlElementType . XML _ ENUMERATED _ TYPE )  ;", "}", "METHOD_END"], "methodName": ["parseEnumeratedType"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "while    ( true )     {", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )     {", "eEntityRef (  )  ;", "continue ;", "}", "if    (  (  ( myBuilder . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ NAME )  )     &  &     (  ( myBuilder . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ BAR )  )  )", "break ;", "addToken (  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseEnumeratedTypeContent"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "IElementType   tokenType ;", "while    (  ( tokenType    =    myBuilder . getTokenType (  )  )     !  =    null )     {", "if    ( tokenType    =  =     ( XmlTokenType . XML _ ATTLIST _ DECL _ START )  )     {", "eAttlistDecl (  )  ;", "} else", "if    ( tokenType    =  =     ( XmlTokenType . XML _ ELEMENT _ DECL _ START )  )     {", "eElementDecl (  )  ;", "} else", "if    ( tokenType    =  =     ( XmlTokenType . XML _ ENTITY _ DECL _ START )  )     {", "eEntityDecl (  )  ;", "} else", "if    ( tokenType    =  =     ( XmlTokenType . XML _ NOTATION _ DECL _ START )  )     {", "eNotationDecl (  )  ;", "} else", "if    ( tokenType    =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )     {", "eEntityRef (  )  ;", "} else", "if    ( eProcessingInstruction (  )  )     {", "} else", "if    ( tokenType    =  =     ( XmlTokenType . XML _ START _ TAG _ START )  )     {", "eTag ( false )  ;", "} else", "if    ( isCommentToken ( tokenType )  )     {", "eComment (  )  ;", "} else", "if    ( eConditionalSection (  )  )     {", "} else", "if    ( tokenType    !  =    null )     {", "addToken (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseGenericXml"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "PsiBuilder . Marker   group    =    myBuilder . mark (  )  ;", "addToken (  )  ;", "boolean   b    =    parseElementContentSpecInner ( false )  ;", "if    ( b    &  &     (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ RIGHT _ PAREN )  )  )     {", "addToken (  )  ;", "group . done ( XmlElementType . XML _ ELEMENT _ CONTENT _ GROUP )  ;", "return   true ;", "} else", "if    ( b )     {", "myBuilder . error ( codeInsight . daemon . XmlErrorMessages . message (  \" dtd . parser . message . rbrace . expected \"  )  )  ;", "group . done ( XmlElementType . XML _ ELEMENT _ CONTENT _ GROUP )  ;", "return   false ;", "}", "group . done ( XmlElementType . XML _ ELEMENT _ CONTENT _ GROUP )  ;", "return   b ;", "}", "METHOD_END"], "methodName": ["parseGroup"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "IElementType   tokenType    =    myBuilder . getTokenType (  )  ;", "if    ( tokenType    =  =     ( XmlTokenType . XML _ MARKUP _ START )  )     {", "addToken (  )  ;", "}", "while    ( true )     {", "tokenType    =    myBuilder . getTokenType (  )  ;", "if    ( tokenType    =  =     ( XmlTokenType . XML _ ELEMENT _ DECL _ START )  )     {", "eElementDecl (  )  ;", "} else", "if    ( tokenType    =  =     ( XmlTokenType . XML _ ATTLIST _ DECL _ START )  )     {", "eAttlistDecl (  )  ;", "} else", "if    ( tokenType    =  =     ( XmlTokenType . XML _ ENTITY _ DECL _ START )  )     {", "eEntityDecl (  )  ;", "} else", "if    ( tokenType    =  =     ( XmlTokenType . XML _ NOTATION _ DECL _ START )  )     {", "eNotationDecl (  )  ;", "} else", "if    ( tokenType    =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )     {", "eEntityRef (  )  ;", "} else", "if    ( tokenType    =  =     ( XmlTokenType . XML _ COMMENT _ START )  )     {", "eComment (  )  ;", "} else", "if    ( eConditionalSection (  )  )     {", "} else    {", "break ;", "}", "}", "if    ( tokenType    =  =     ( XmlTokenType . XML _ MARKUP _ END )  )     {", "addToken (  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseMarkupContent"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "PsiBuilder . Marker   decl    =    myBuilder . mark (  )  ;", "eMarkupContent (  )  ;", "decl . done ( XmlElementType . XML _ MARKUP _ DECL )  ;", "}", "METHOD_END"], "methodName": ["parseMarkupDecl"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "IElementType   type    =    myBuilder . getTokenType (  )  ;", "if    ( type    =  =     ( XmlTokenType . XML _ NAME )  )     {", "addToken (  )  ;", "return   true ;", "}", "if    ( type    =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )     {", "eEntityRef (  )  ;", "return   true ;", "}", "return   consumeKeywordAsName ( type )  ;", "}", "METHOD_END"], "methodName": ["parseName"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myBuilder . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ NOTATION _ DECL _ START )  )     {", "return ;", "}", "PsiBuilder . Marker   decl    =    myBuilder . mark (  )  ;", "addToken (  )  ;", "if    (  !  ( eName (  )  )  )     {", "decl . done ( XmlElementType . XML _ NOTATION _ DECL )  ;", "return ;", "}", "eEntityDeclContent (  )  ;", "if    (  ( myBuilder . getTokenType (  )  )     !  =    null )     {", "addToken (  )  ;", "}", "decl . done ( XmlElementType . XML _ NOTATION _ DECL )  ;", "}", "METHOD_END"], "methodName": ["parseNotationDecl"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myBuilder . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ PI _ START )  )     {", "return   false ;", "}", "PsiBuilder . Marker   tag    =    myBuilder . mark (  )  ;", "addToken (  )  ;", "if    (  ( myBuilder . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ PI _ TARGET )  )     {", "tag . done ( XmlElementType . XML _ PROCESSING _ INSTRUCTION )  ;", "return   true ;", "}", "addToken (  )  ;", "if    (  ( myBuilder . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ PI _ END )  )     {", "tag . done ( XmlElementType . XML _ PROCESSING _ INSTRUCTION )  ;", "return   true ;", "}", "addToken (  )  ;", "tag . done ( XmlElementType . XML _ PROCESSING _ INSTRUCTION )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["parseProcessingInstruction"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "PsiBuilder . Marker   prolog    =    myBuilder . mark (  )  ;", "while    ( eProcessingInstruction (  )  )     {", "}", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ DECL _ START )  )     {", "eDecl (  )  ;", "}", "while    ( eProcessingInstruction (  )  )     {", "}", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ DOCTYPE _ START )  )     {", "eDocType (  )  ;", "}", "while    ( eProcessingInstruction (  )  )     {", "}", "prolog . done ( XmlElementType . XML _ PROLOG )  ;", "}", "METHOD_END"], "methodName": ["parseProlog"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "parseMarkupContent (  )  ;", "while    (  ( myBuilder . getTokenType (  )  )     !  =    null )     {", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )     {", "parseEntityRef (  )  ;", "} else", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ ENTITY _ DECL _ START )  )     {", "parseEntityDecl (  )  ;", "} else    {", "myBuilder . advanceLexer (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseTopLevelMarkupDecl"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "while    (  (  (  !  ( myBuilder . eof (  )  )  )     &  &     (  ( myBuilder . getTokenType (  )  )     !  =     ( XmlTokenType . XML _ TAG _ END )  )  )     &  &     (  !  ( isAnotherDeclStart ( myBuilder . getTokenType (  )  )  )  )  )     {", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ COMMENT _ START )  )", "eComment (  )  ;", "else", "addToken (  )  ;", "}", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ TAG _ END )  )", "addToken (  )  ;", "}", "METHOD_END"], "methodName": ["skipTillEndOfBlock"], "fileName": "com.intellij.psi.impl.source.parsing.xml.DtdParsing"}, {"methodBody": ["METHOD_START", "{", "myNamespacesStack . push ( namespace )  ;", "myPrefixesStack . push ( prefix )  ;", "}", "METHOD_END"], "methodName": ["addImplicitBinding"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlBuilderDriver"}, {"methodBody": ["METHOD_START", "{", "PsiBuilder   b    =    createBuilderAndParse (  )  ;", "FlyweightCapableTreeStructure < LighterASTNode >    structure    =    b . getLightTree (  )  ;", "LighterASTNode   root    =    structure . getRoot (  )  ;", "final   Ref < LighterASTNode [  ]  >    childrenRef    =    Ref . create ( null )  ;", "final   int   count    =    structure . getChildren ( root ,    childrenRef )  ;", "LighterASTNode [  ]    children    =    childrenRef . get (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "LighterASTNode   child    =    children [ i ]  ;", "final   IElementType   tt    =    child . getTokenType (  )  ;", "if    (  ( tt    =  =     ( XmlElementType . XML _ TAG )  )     |  |     ( tt    =  =     ( XmlElementType . HTML _ TAG )  )  )     {", "processTagNode ( b ,    structure ,    child ,    builder )  ;", "} else", "if    ( tt    =  =     ( XmlElementType . XML _ PROLOG )  )     {", "processPrologNode ( b ,    builder ,    structure ,    child )  ;", "}", "}", "structure . disposeChildren ( children ,    count )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlBuilderDriver"}, {"methodBody": ["METHOD_START", "{", "final   CharSequence   name    =    getAttributeName ( attrNode ,    structure )  ;", "if    ( Comparing . equal ( name ,     . XMLNS )  )     {", "myPrefixesStack . push (  \"  \"  )  ;", "myNamespacesStack . push ( getAttributeValue ( attrNode ,    structure )  . toString (  )  )  ;", "} else", "if    ( com . intellij . openapi . util . text . StringUtil . startsWith ( name ,     . XMLNS _ COLON )  )     {", "myPrefixesStack . push ( name . subSequence (  . XMLNS _ COLON . length (  )  ,    name . length (  )  )  . toString (  )  )  ;", "myNamespacesStack . push ( getAttributeValue ( attrNode ,    structure )  . toString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkForXmlns"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlBuilderDriver"}, {"methodBody": ["METHOD_START", "{", "final   ParserDefinition   xmlParserDefinition    =    INSTANCE . forLanguage ( XMLLanguage . INSTANCE )  ;", "assert   xmlParserDefinition    !  =    null ;", "Psi   b    =    PsiFactory . getInstance (  )  . create ( xmlParserDefinition ,    xmlParserDefinition . createLexer ( null )  ,    myText )  ;", "new   XmlParsing ( b )  . parseDocument (  )  ;", "return   b ;", "}", "METHOD_END"], "methodName": ["createBuilderAndParse"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlBuilderDriver"}, {"methodBody": ["METHOD_START", "{", "final   Ref < LighterASTNode [  ]  >    childrenRef    =    Ref . create ( null )  ;", "final   int   count    =    structure . getChildren ( attrNode ,    childrenRef )  ;", "LighterASTNode [  ]    children    =    childrenRef . get (  )  ;", "CharSequence   name    =     \"  \"  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "LighterASTNode   child    =    children [ i ]  ;", "if    (  ( child . getTokenType (  )  )     =  =    tt )     {", "name    =    getTokenText ( child )  ;", "break ;", "}", "}", "structure . disposeChildren ( children ,    count )  ;", "return   name ;", "}", "METHOD_END"], "methodName": ["findTextByTokenType"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlBuilderDriver"}, {"methodBody": ["METHOD_START", "{", "return   findTextByTokenType ( attrNode ,    structure ,    XmlTokenType . XML _ NAME )  ;", "}", "METHOD_END"], "methodName": ["getAttributeName"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlBuilderDriver"}, {"methodBody": ["METHOD_START", "{", "final   CharSequence   fullValue    =    findTextByTokenType ( attrNode ,    structure ,    XmlElementType . XML _ ATTRIBUTE _ VALUE )  ;", "int   start    =     0  ;", "if    (  (  ( fullValue . length (  )  )     >     0  )     &  &     (  ( fullValue . charAt (  0  )  )     =  =     '  \\  \"  '  )  )", "start +  +  ;", "int   end    =    fullValue . length (  )  ;", "if    (  (  ( fullValue . length (  )  )     >    start )     &  &     (  ( fullValue . charAt (  (  ( fullValue . length (  )  )     -     1  )  )  )     =  =     '  \\  \"  '  )  )", "end -  -  ;", "return   fullValue . subSequence ( start ,    end )  ;", "}", "METHOD_END"], "methodName": ["getAttributeValue"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlBuilderDriver"}, {"methodBody": ["METHOD_START", "{", "final   String   namespacePrefix ;", "int   pos    =    StringUtil . indexOf ( tagName ,     '  :  '  )  ;", "if    ( pos    =  =     (  -  1  )  )     {", "namespacePrefix    =     \"  \"  ;", "} else    {", "namespacePrefix    =    tagName . subSequence (  0  ,    pos )  . toString (  )  ;", "}", "for    ( int   i    =     ( myPrefixesStack . size (  )  )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "if    ( namespacePrefix . equals ( myPrefixesStack . get ( i )  )  )", "return   myNamespacesStack . get ( i )  ;", "}", "return    \"  \"  ;", "}", "METHOD_END"], "methodName": ["getNamespace"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlBuilderDriver"}, {"methodBody": ["METHOD_START", "{", "return   myText ;", "}", "METHOD_END"], "methodName": ["getText"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlBuilderDriver"}, {"methodBody": ["METHOD_START", "{", "return   myText . subSequence ( token . getStartOffset (  )  ,    token . getEndOffset (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTokenText"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlBuilderDriver"}, {"methodBody": ["METHOD_START", "{", "builder . attribute ( getAttributeName ( attrNode ,    structure )  ,    getAttributeValue ( attrNode ,    structure )  ,    attrNode . getStartOffset (  )  ,    attrNode . getEndOffset (  )  )  ;", "}", "METHOD_END"], "methodName": ["processAttributeNode"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlBuilderDriver"}, {"methodBody": ["METHOD_START", "{", "final   Ref < LighterASTNode [  ]  >    tokens    =    new   Ref ( null )  ;", "final   int   tokenCount    =    structure . getChildren ( doctype ,    tokens )  ;", "if    ( tokenCount    >     0  )     {", "CharSequence   publicId    =    null ;", "boolean   afterPublic    =    false ;", "CharSequence   systemId    =    null ;", "boolean   afterSystem    =    false ;", "for    ( int   i    =     0  ;    i    <    tokenCount ;    i +  +  )     {", "LighterASTNode   token    =    tokens . get (  )  [ i ]  ;", "if    (  ( token . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ DOCTYPE _ PUBLIC )  )     {", "afterPublic    =    true ;", "} else", "if    (  ( token . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ DOCTYPE _ SYSTEM )  )     {", "afterSystem    =    true ;", "} else", "if    (  (  ( token . getTokenType (  )  )     !  =     ( TokenType . WHITE _ SPACE )  )     &  &     (  ( token . getTokenType (  )  )     !  =     ( xml . XmlElementType . XML _ COMMENT )  )  )     {", "if    (  ( token . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ TOKEN )  )     {", "if    ( afterPublic )", "publicId    =    getTokenText ( token )  ;", "else", "if    ( afterSystem )", "systemId    =    getTokenText ( token )  ;", "}", "afterPublic    =    afterSystem    =    false ;", "}", "}", "builder . doctype ( publicId ,    systemId ,    doctype . getStartOffset (  )  ,    doctype . getEndOffset (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["processDoctypeNode"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlBuilderDriver"}, {"methodBody": ["METHOD_START", "{", "assert    ( node . getTokenType (  )  )     =  =     ( TokenType . ERROR _ ELEMENT )  ;", "String   message    =    PsiImpl . getErrorMessage ( node )  ;", "assert   message    !  =    null ;", "builder . error ( message ,    node . getStartOffset (  )  ,    node . getEndOffset (  )  )  ;", "}", "METHOD_END"], "methodName": ["processErrorNode"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlBuilderDriver"}, {"methodBody": ["METHOD_START", "{", "final   Ref < LighterASTNode [  ]  >    prologChildren    =    new   Ref ( null )  ;", "final   int   prologChildrenCount    =    structure . getChildren ( prolog ,    prologChildren )  ;", "for    ( int   i    =     0  ;    i    <    prologChildrenCount ;    i +  +  )     {", "LighterASTNode   node    =    prologChildren . get (  )  [ i ]  ;", "IElementType   type    =    node . getTokenType (  )  ;", "if    ( type    =  =     ( XmlElementType . XML _ DOCTYPE )  )     {", "processDoctypeNode ( builder ,    structure ,    node )  ;", "break ;", "}", "if    ( type    =  =     ( TokenType . ERROR _ ELEMENT )  )     {", "processErrorNode ( psi ,    node ,    builder )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processPrologNode"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlBuilderDriver"}, {"methodBody": ["METHOD_START", "{", "final   IElementType   nodeTT    =    node . getTokenType (  )  ;", "assert    ( nodeTT    =  =     ( XmlElementType . XML _ TAG )  )     |  |     ( nodeTT    =  =     ( XmlElementType . HTML _ TAG )  )  ;", "final   Ref < LighterASTNode [  ]  >    childrenRef    =    Ref . create ( null )  ;", "final   int   count    =    structure . getChildren ( node ,    childrenRef )  ;", "LighterASTNode [  ]    children    =    childrenRef . get (  )  ;", "int   stackFrameSize    =    myNamespacesStack . size (  )  ;", "CharSequence   tagName    =     \"  \"  ;", "int   headerEndOffset    =    node . getEndOffset (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "LighterASTNode   child    =    children [ i ]  ;", "final   IElementType   tt    =    child . getTokenType (  )  ;", "if    ( tt    =  =     ( XmlElementType . XML _ ATTRIBUTE )  )", "checkForXmlns ( child ,    structure )  ;", "if    (  ( tt    =  =     ( XmlTokenType . XML _ TAG _ END )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ EMPTY _ ELEMENT _ END )  )  )     {", "headerEndOffset    =    child . getEndOffset (  )  ;", "break ;", "}", "if    (  ( tt    =  =     ( XmlTokenType . XML _ NAME )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ TAG _ NAME )  )  )     {", "tagName    =    getTokenText ( child )  ;", "}", "}", "CharSequence   localName    =    XmlUtil . getLocalName ( tagName )  ;", "String   namespace    =    getNamespace ( tagName )  ;", ". ProcessingOrder   order    =    builder . startTag ( localName ,    namespace ,    node . getStartOffset (  )  ,    node . getEndOffset (  )  ,    headerEndOffset )  ;", "boolean   processAttrs    =     ( order    =  =     (  . ProcessingOrder . TAGS _ AND _ ATTRIBUTES )  )     |  |     ( order    =  =     (  . ProcessingOrder . TAGS _ AND _ ATTRIBUTES _ AND _ TEXTS )  )  ;", "boolean   processTexts    =     ( order    =  =     (  . ProcessingOrder . TAGS _ AND _ TEXTS )  )     |  |     ( order    =  =     (  . ProcessingOrder . TAGS _ AND _ ATTRIBUTES _ AND _ TEXTS )  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "LighterASTNode   child    =    children [ i ]  ;", "IElementType   tt    =    child . getTokenType (  )  ;", "if    ( tt    =  =     ( TokenType . ERROR _ ELEMENT )  )", "processErrorNode ( psiBuilder ,    child ,    builder )  ;", "if    (  ( tt    =  =     ( XmlElementType . XML _ TAG )  )     |  |     ( tt    =  =     ( XmlElementType . HTML _ TAG )  )  )", "processTagNode ( psiBuilder ,    structure ,    child ,    builder )  ;", "if    ( processAttrs    &  &     ( tt    =  =     ( XmlElementType . XML _ ATTRIBUTE )  )  )", "processAttributeNode ( child ,    structure ,    builder )  ;", "if    ( processTexts    &  &     ( tt    =  =     ( XmlElementType . XML _ TEXT )  )  )", "processTextNode ( structure ,    child ,    builder )  ;", "if    ( tt    =  =     ( XmlElementType . XML _ ENTITY _ REF )  )", "builder . entityRef ( getTokenText ( child )  ,    child . getStartOffset (  )  ,    child . getEndOffset (  )  )  ;", "}", "builder . endTag ( localName ,    namespace ,    node . getStartOffset (  )  ,    node . getEndOffset (  )  )  ;", "int   framesToDrop    =     ( myNamespacesStack . size (  )  )     -    stackFrameSize ;", "for    ( int   i    =     0  ;    i    <    framesToDrop ;    i +  +  )     {", "myNamespacesStack . pop (  )  ;", "myPrefixesStack . pop (  )  ;", "}", "structure . disposeChildren ( children ,    count )  ;", "}", "METHOD_END"], "methodName": ["processTagNode"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlBuilderDriver"}, {"methodBody": ["METHOD_START", "{", "final   Ref < LighterASTNode [  ]  >    childrenRef    =    Ref . create ( null )  ;", "final   int   count    =    structure . getChildren ( node ,    childrenRef )  ;", "LighterASTNode [  ]    children    =    childrenRef . get (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "LighterASTNode   child    =    children [ i ]  ;", "IElementType   tt    =    child . getTokenType (  )  ;", "final   int   start    =    child . getStartOffset (  )  ;", "final   int   end    =    child . getEndOffset (  )  ;", "final   CharSequence   physical    =    getTokenText ( child )  ;", "if    ( XmlTokenType . COMMENTS . contains ( tt )  )", "continue ;", "if    (  ( tt    =  =     ( XmlTokenType . XML _ CDATA _ START )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ CDATA _ END )  )  )     {", "builder . textElement (  \"  \"  ,    physical ,    start ,    end )  ;", "} else", "if    ( tt    =  =     ( xml . XmlElementType . XML _ CDATA )  )     {", "processTextNode ( structure ,    child ,    builder )  ;", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ CHAR _ ENTITY _ REF )  )     {", "builder . textElement ( new   String ( new   char [  ]  {    com . intellij . xml . util . XmlUtil . getCharFromEntityRef ( physical . toString (  )  )     }  )  ,    physical ,    start ,    end )  ;", "} else    {", "builder . textElement ( physical ,    physical ,    start ,    end )  ;", "}", "}", "structure . disposeChildren ( children ,    count )  ;", "}", "METHOD_END"], "methodName": ["processTextNode"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlBuilderDriver"}, {"methodBody": ["METHOD_START", "{", "myBuilder . advanceLexer (  )  ;", "}", "METHOD_END"], "methodName": ["advance"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlParsing"}, {"methodBody": ["METHOD_START", "{", "return   myBuilder . eof (  )  ;", "}", "METHOD_END"], "methodName": ["eof"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlParsing"}, {"methodBody": ["METHOD_START", "{", "myBuilder . error ( message )  ;", "}", "METHOD_END"], "methodName": ["error"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlParsing"}, {"methodBody": ["METHOD_START", "{", "if    ( error    !  =    null )     {", "error . error ( XmlErrorMessages . message (  \" xmlunexpected . tokens \"  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["flushError"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlParsing"}, {"methodBody": ["METHOD_START", "{", "return   tt    =  =     ( XmlTokenType . XML _ COMMENT _ START )  ;", "}", "METHOD_END"], "methodName": ["isCommentToken"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlParsing"}, {"methodBody": ["METHOD_START", "{", "return   myBuilder . mark (  )  ;", "}", "METHOD_END"], "methodName": ["mark"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlParsing"}, {"methodBody": ["METHOD_START", "{", "assert    ( token (  )  )     =  =     ( XmlTokenType . XML _ NAME )  ;", "final   PsiBuilder . Marker   att    =    mark (  )  ;", "advance (  )  ;", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ EQ )  )     {", "advance (  )  ;", "eAttributeValue (  )  ;", "att . done ( XmlElementType . XML _ ATTRIBUTE )  ;", "} else    {", "error ( XmlErrorMessages . message (  \" expected . attribute . eq . sign \"  )  )  ;", "att . done ( XmlElementType . XML _ ATTRIBUTE )  ;", "}", "}", "METHOD_END"], "methodName": ["parseAttribute"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlParsing"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   attValue    =    mark (  )  ;", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ START _ DELIMITER )  )     {", "while    ( true )     {", "final   IElementType   tt    =    token (  )  ;", "if    (  (  (  (  ( tt    =  =    null )     |  |     ( tt    =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ END _ DELIMITER )  )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ END _ TAG _ START )  )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ EMPTY _ ELEMENT _ END )  )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ START _ TAG _ START )  )  )     {", "break ;", "}", "if    ( tt    =  =     ( XmlTokenType . XML _ BAD _ CHARACTER )  )     {", "final   PsiBuilder . Marker   error    =    mark (  )  ;", "advance (  )  ;", "error . error ( XmlErrorMessages . message (  \" unescaped . ampersand . or . nonterminated . character . entity . reference \"  )  )  ;", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )     {", "parseReference (  )  ;", "} else    {", "advance (  )  ;", "}", "}", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ END _ DELIMITER )  )     {", "advance (  )  ;", "} else    {", "error ( XmlErrorMessages . message (  \" xmlunclosed . attribute . value \"  )  )  ;", "}", "} else    {", "error ( XmlErrorMessages . message (  \" xmlattribute . value . expected \"  )  )  ;", "}", "attValue . done ( XmlElementType . XML _ ATTRIBUTE _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["parseAttributeValue"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlParsing"}, {"methodBody": ["METHOD_START", "{", "assert    ( token (  )  )     =  =     ( XmlTokenType . XML _ CDATA _ START )  ;", "final   PsiBuilder . Marker   cdata    =    mark (  )  ;", "while    (  (  ( token (  )  )     !  =     ( XmlTokenType . XML _ CDATA _ END )  )     &  &     (  !  ( eof (  )  )  )  )     {", "advance (  )  ;", "}", "if    (  !  ( eof (  )  )  )     {", "advance (  )  ;", "}", "cdata . done ( XmlElementType . XML _ CDATA )  ;", "}", "METHOD_END"], "methodName": ["parseCData"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlParsing"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   comment    =    mark (  )  ;", "advance (  )  ;", "while    ( true )     {", "final   IElementType   tt    =    token (  )  ;", "if    (  (  (  (  ( tt    =  =     ( XmlTokenType . XML _ COMMENT _ CHARACTERS )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ CONDITIONAL _ COMMENT _ START )  )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ CONDITIONAL _ COMMENT _ START _ END )  )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ CONDITIONAL _ COMMENT _ END _ START )  )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ CONDITIONAL _ COMMENT _ END )  )  )     {", "advance (  )  ;", "continue ;", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ BAD _ CHARACTER )  )     {", "final   PsiBuilder . Marker   error    =    mark (  )  ;", "advance (  )  ;", "error . error ( codeInsight . daemon . XmlErrorMessages . message (  \" xml . parsing . bad . character \"  )  )  ;", "continue ;", "}", "if    ( tt    =  =     ( XmlTokenType . XML _ COMMENT _ END )  )     {", "advance (  )  ;", "}", "break ;", "}", "comment . done ( XmlElementType . XML _ COMMENT )  ;", "}", "METHOD_END"], "methodName": ["parseComment"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlParsing"}, {"methodBody": ["METHOD_START", "{", "assert    ( token (  )  )     =  =     ( XmlTokenType . XML _ DOCTYPE _ START )     :     \" Doctype   start   expected \"  ;", "final   PsiBuilder . Marker   doctype    =    mark (  )  ;", "advance (  )  ;", "while    (  (  ( token (  )  )     !  =     ( XmlTokenType . XML _ DOCTYPE _ END )  )     &  &     (  !  ( eof (  )  )  )  )", "advance (  )  ;", "if    ( eof (  )  )     {", "error ( XmlErrorMessages . message (  \" xmlunexpected . end . of . file \"  )  )  ;", "} else    {", "advance (  )  ;", "}", "doctype . done ( XmlElementType . XML _ DOCTYPE )  ;", "}", "METHOD_END"], "methodName": ["parseDoctype"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlParsing"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   document    =    mark (  )  ;", "while    ( isCommentToken ( token (  )  )  )     {", "parseComment (  )  ;", "}", "parseProlog (  )  ;", "int   rootTagCount    =     0  ;", "PsiBuilder . Marker   error    =    null ;", "while    (  !  ( eof (  )  )  )     {", "final   IElementType   tt    =    token (  )  ;", "if    ( tt    =  =     ( XmlTokenType . XML _ START _ TAG _ START )  )     {", "error    =     . flushError ( error )  ;", "rootTagCount +  +  ;", "parseTag (  ( rootTagCount    >     1  )  )  ;", "} else", "if    ( isCommentToken ( tt )  )     {", "error    =     . flushError ( error )  ;", "parseComment (  )  ;", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ PI _ START )  )     {", "error    =     . flushError ( error )  ;", "parseProcessingInstruction (  )  ;", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ REAL _ WHITE _ SPACE )  )     {", "error    =     . flushError ( error )  ;", "advance (  )  ;", "} else    {", "if    ( error    =  =    null )", "error    =    mark (  )  ;", "advance (  )  ;", "}", "}", "if    ( error    !  =    null )     {", "error . error ( XmlErrorMessages . message (  \" top . level . element . is . not . completed \"  )  )  ;", "}", "if    ( rootTagCount    =  =     0  )     {", "final   PsiBuilder . Marker   rootTag    =    mark (  )  ;", "error    =    mark (  )  ;", "error . error ( XmlErrorMessages . message (  \" xml . parsing . absent . root . tag \"  )  )  ;", "rootTag . done ( XmlElementType . XML _ TAG )  ;", "}", "document . done ( XmlElementType . XML _ DOCUMENT )  ;", "}", "METHOD_END"], "methodName": ["parseDocument"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlParsing"}, {"methodBody": ["METHOD_START", "{", "assert    ( token (  )  )     =  =     ( XmlTokenType . XML _ PI _ START )  ;", "final   PsiBuilder . Marker   pi    =    mark (  )  ;", "advance (  )  ;", "if    (  ( token (  )  )     !  =     ( XmlTokenType . XML _ NAME )  )     {", "error ( XmlErrorMessages . message (  \" xmlprocessing . instruction . name . expected \"  )  )  ;", "} else    {", "advance (  )  ;", "}", "final   IElementType   tokenType    =    token (  )  ;", "if    ( tokenType    =  =     ( XmlTokenType . XML _ TAG _ CHARACTERS )  )     {", "while    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ TAG _ CHARACTERS )  )     {", "advance (  )  ;", "}", "} else    {", "while    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ NAME )  )     {", "advance (  )  ;", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ EQ )  )     {", "advance (  )  ;", "} else    {", "error ( XmlErrorMessages . message (  \" expected . attribute . eq . sign \"  )  )  ;", "}", "parseAttributeValue (  )  ;", "}", "}", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ PI _ END )  )     {", "advance (  )  ;", "} else    {", "error ( XmlErrorMessages . message (  \" xmlunterminated . processing . instruction \"  )  )  ;", "}", "pi . done ( XmlElementType . XML _ PROCESSING _ INSTRUCTION )  ;", "}", "METHOD_END"], "methodName": ["parseProcessingInstruction"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlParsing"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   prolog    =    mark (  )  ;", "while    ( true )     {", "final   IElementType   tt    =    token (  )  ;", "if    ( tt    =  =     ( XmlTokenType . XML _ PI _ START )  )     {", "eProcessingInstruction (  )  ;", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ DOCTYPE _ START )  )     {", "eDoctype (  )  ;", "} else", "if    ( isCommentToken ( tt )  )     {", "eComment (  )  ;", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ REAL _ WHITE _ SPACE )  )     {", "advance (  )  ;", "} else    {", "break ;", "}", "}", "prolog . done ( XmlElementType . XML _ PROLOG )  ;", "}", "METHOD_END"], "methodName": ["parseProlog"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlParsing"}, {"methodBody": ["METHOD_START", "{", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ CHAR _ ENTITY _ REF )  )     {", "advance (  )  ;", "} else", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )     {", "final   com . intellij . lang . PsiBuilder . Marker   ref    =    mark (  )  ;", "advance (  )  ;", "ref . done ( xml . XmlElementType . XML _ ENTITY _ REF )  ;", "} else    {", "assert   false    :     \" Unexpected   token \"  ;", "}", "}", "METHOD_END"], "methodName": ["parseReference"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlParsing"}, {"methodBody": ["METHOD_START", "{", "assert    ( token (  )  )     =  =     ( XmlTokenType . XML _ START _ TAG _ START )     :     \" Tag   start   expected \"  ;", "final   PsiBuilder . Marker   tag    =    mark (  )  ;", "final   String   tagName    =    parseTagHeader ( multipleRootTagError ,    tag )  ;", "if    ( tagName    =  =    null )", "return ;", "final   PsiBuilder . Marker   content    =    mark (  )  ;", "parseTagContent (  )  ;", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ END _ TAG _ START )  )     {", "final   PsiBuilder . Marker   footer    =    mark (  )  ;", "advance (  )  ;", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ NAME )  )     {", "String   endName    =    myBuilder . getTokenText (  )  ;", "if    (  (  !  ( tagName . equals ( endName )  )  )     &  &     ( myTagNamesStack . contains ( endName )  )  )     {", "footer . rollbackTo (  )  ;", "myTagNamesStack . pop (  )  ;", "tag . doneBefore ( XmlElementType . XML _ TAG ,    content ,    XmlErrorMessages . message (  \" named . element . is . not . closed \"  ,    tagName )  )  ;", "content . drop (  )  ;", "return ;", "}", "advance (  )  ;", "}", "footer . drop (  )  ;", "while    (  (  (  (  ( token (  )  )     !  =     ( XmlTokenType . XML _ TAG _ END )  )     &  &     (  ( token (  )  )     !  =     ( XmlTokenType . XML _ START _ TAG _ START )  )  )     &  &     (  ( token (  )  )     !  =     ( XmlTokenType . XML _ END _ TAG _ START )  )  )     &  &     (  !  ( eof (  )  )  )  )     {", "error ( XmlErrorMessages . message (  \" xmlunexpected . token \"  )  )  ;", "advance (  )  ;", "}", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ TAG _ END )  )     {", "advance (  )  ;", "} else    {", "error ( XmlErrorMessages . message (  \" xmlclosing . tag . is . not . done \"  )  )  ;", "}", "} else    {", "error ( XmlErrorMessages . message (  \" xmlunexpected . end . of . file \"  )  )  ;", "}", "content . drop (  )  ;", "myTagNamesStack . pop (  )  ;", "tag . done ( XmlElementType . XML _ TAG )  ;", "}", "METHOD_END"], "methodName": ["parseTag"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlParsing"}, {"methodBody": ["METHOD_START", "{", "PsiBuilder . Marker   xmlText    =    null ;", "while    (  (  ( token (  )  )     !  =     ( XmlTokenType . XML _ END _ TAG _ START )  )     &  &     (  !  ( eof (  )  )  )  )     {", "final   IElementType   tt    =    token (  )  ;", "if    ( tt    =  =     ( XmlTokenType . XML _ START _ TAG _ START )  )     {", "xmlText    =    XmlParsing . terminateText ( xmlText )  ;", "parseTag ( false )  ;", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ PI _ START )  )     {", "xmlText    =    XmlParsing . terminateText ( xmlText )  ;", "parseProcessingInstruction (  )  ;", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )     {", "xmlText    =    XmlParsing . terminateText ( xmlText )  ;", "parseReference (  )  ;", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ CHAR _ ENTITY _ REF )  )     {", "xmlText    =    startText ( xmlText )  ;", "parseReference (  )  ;", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ CDATA _ START )  )     {", "xmlText    =    startText ( xmlText )  ;", "parseCData (  )  ;", "} else", "if    ( isCommentToken ( tt )  )     {", "xmlText    =    XmlParsing . terminateText ( xmlText )  ;", "parseComment (  )  ;", "} else", "if    ( tt    =  =     ( XmlTokenType . XML _ BAD _ CHARACTER )  )     {", "xmlText    =    startText ( xmlText )  ;", "final   PsiBuilder . Marker   error    =    mark (  )  ;", "advance (  )  ;", "error . error ( com . intellij . codeInsight . daemon . XmlErrorMessages . message (  \" unescaped . ampersand . or . nonterminated . character . entity . reference \"  )  )  ;", "} else", "if    (  ( tt   instanceof   tree . ICustomParsingType )     |  |     ( tt   instanceof   tree . ILazyParseableElementType )  )     {", "xmlText    =    XmlParsing . terminateText ( xmlText )  ;", "advance (  )  ;", "} else    {", "xmlText    =    startText ( xmlText )  ;", "advance (  )  ;", "}", "}", "XmlParsing . terminateText ( xmlText )  ;", "}", "METHOD_END"], "methodName": ["parseTagContent"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlParsing"}, {"methodBody": ["METHOD_START", "{", "if    ( multipleRootTagError )     {", "final   PsiBuilder . Marker   error    =    mark (  )  ;", "advance (  )  ;", "error . error ( XmlErrorMessages . message (  \" xml . parsing . multiple . root . tags \"  )  )  ;", "} else    {", "advance (  )  ;", "}", "final   String   tagName ;", "if    (  (  ( token (  )  )     !  =     ( XmlTokenType . XML _ NAME )  )     |  |     (  ( myBuilder . rawLookup (  (  -  1  )  )  )     =  =     ( TokenType . WHITE _ SPACE )  )  )     {", "error ( XmlErrorMessages . message (  \" xml . parsing . tag . name . expected \"  )  )  ;", "tagName    =     \"  \"  ;", "} else    {", "tagName    =    myBuilder . getTokenText (  )  ;", "assert   tagName    !  =    null ;", "advance (  )  ;", "}", "myTagNamesStack . push ( tagName )  ;", "do    {", "final   IElementType   tt    =    token (  )  ;", "if    ( tt    =  =     ( XmlTokenType . XML _ NAME )  )     {", "parseAttribute (  )  ;", "} else", "if    (  ( tt    =  =     ( XmlTokenType . XML _ CHAR _ ENTITY _ REF )  )     |  |     ( tt    =  =     ( XmlTokenType . XML _ ENTITY _ REF _ TOKEN )  )  )     {", "parseReference (  )  ;", "} else    {", "break ;", "}", "}    while    ( true    )  ;", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ EMPTY _ ELEMENT _ END )  )     {", "advance (  )  ;", "myTagNamesStack . pop (  )  ;", "tag . done ( XmlElementType . XML _ TAG )  ;", "return   null ;", "}", "if    (  ( token (  )  )     =  =     ( XmlTokenType . XML _ TAG _ END )  )     {", "advance (  )  ;", "} else    {", "error ( XmlErrorMessages . message (  \" tag . start . is . not . closed \"  )  )  ;", "myTagNamesStack . pop (  )  ;", "tag . done ( XmlElementType . XML _ TAG )  ;", "return   null ;", "}", "if    (  ( myTagNamesStack . size (  )  )     >     (  . BALANCING _ DEPTH _ THRESHOLD )  )     {", "error ( XmlErrorMessages . message (  \" way . too . unbalanced \"  )  )  ;", "tag . done ( XmlElementType . XML _ TAG )  ;", "return   null ;", "}", "return   tagName ;", "}", "METHOD_END"], "methodName": ["parseTagHeader"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlParsing"}, {"methodBody": ["METHOD_START", "{", "if    ( xmlText    =  =    null )     {", "xmlText    =    mark (  )  ;", "}", "return   xmlText ;", "}", "METHOD_END"], "methodName": ["startText"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlParsing"}, {"methodBody": ["METHOD_START", "{", "if    ( xmlText    !  =    null )     {", "xmlText . done ( XmlElementType . XML _ TEXT )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["terminateText"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlParsing"}, {"methodBody": ["METHOD_START", "{", "return   myBuilder . getTokenType (  )  ;", "}", "METHOD_END"], "methodName": ["token"], "fileName": "com.intellij.psi.impl.source.parsing.xml.XmlParsing"}, {"methodBody": ["METHOD_START", "{", "final   int   offset    =    xmlText . getStartOffsetInParent (  )  ;", "final   String   value    =    xmlText . getValue (  )  ;", "final   String   trimmed    =    value . trim (  )  ;", "final   int   i    =    value . indexOf ( trimmed )  ;", "final   int   start    =     ( xmlText . displayToPhysical ( i )  )     +    offset ;", "return   trimmed . isEmpty (  )     ?    new   TextRange ( start ,    start )     :    new   TextRange ( start ,     (  (  ( xmlText . displayToPhysical (  (  ( i    +     ( trimmed . length (  )  )  )     -     1  )  )  )     +    offset )     +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["getValueRange"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.manipulators.XmlTagManipulator"}, {"methodBody": ["METHOD_START", "{", "final   XmlTagValue   value    =    tag . getValue (  )  ;", "final   XmlText [  ]    texts    =    value . getTextElements (  )  ;", "if    (  ( texts . length )     =  =     0  )     {", "return   new   TextRange [  ]  {    value . getTextRange (  )  . shiftRight (  (  -  ( tag . getTextOffset (  )  )  )  )     }  ;", "} else    {", "final   TextRange [  ]    ranges    =    new   TextRange [ texts . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( texts . length )  ;    i +  +  )     {", "ranges [ i ]     =     . getValueRange ( texts [ i ]  )  ;", "}", "return   ranges ;", "}", "}", "METHOD_END"], "methodName": ["getValueRanges"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.manipulators.XmlTagManipulator"}, {"methodBody": ["METHOD_START", "{", "final   String   value    =    xmlText . getValue (  )  ;", "final   int   i    =    value . indexOf ( value )  ;", "final   int   start    =    xmlText . displayToPhysical ( i )  ;", "return   value . isEmpty (  )     ?    new   TextRange ( start ,    start )     :    new   TextRange ( start ,     (  ( xmlText . displayToPhysical (  (  ( i    +     ( value . length (  )  )  )     -     1  )  )  )     +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["getValueRange"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.manipulators.XmlTextManipulator"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["bindToElement"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.BasicAttributeValueReference"}, {"methodBody": ["METHOD_START", "{", "int   valueEndOffset    =     ( element . getTextLength (  )  )     -    offset ;", "return   new   TextRange ( offset ,    Math . max ( offset ,    valueEndOffset )  )  ;", "}", "METHOD_END"], "methodName": ["createTextRange"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.BasicAttributeValueReference"}, {"methodBody": ["METHOD_START", "{", "final   String   s    =    myElement . getText (  )  ;", "if    (  (  ( myRange . getStartOffset (  )  )     <     ( s . length (  )  )  )     &  &     (  ( myRange . getEndOffset (  )  )     <  =     ( s . length (  )  )  )  )     {", "return   myRange . substring ( s )  ;", "}", "return    \"  \"  ;", "}", "METHOD_END"], "methodName": ["getCanonicalText"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.BasicAttributeValueReference"}, {"methodBody": ["METHOD_START", "{", "return   myElement ;", "}", "METHOD_END"], "methodName": ["getElement"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.BasicAttributeValueReference"}, {"methodBody": ["METHOD_START", "{", "return   myRange ;", "}", "METHOD_END"], "methodName": ["getRangeInElement"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.BasicAttributeValueReference"}, {"methodBody": ["METHOD_START", "{", "return   ElementManipulators . getManipulator ( myElement )  . handleContentChange ( myElement ,    getRangeInElement (  )  ,    newElementName )  ;", "}", "METHOD_END"], "methodName": ["handleElementRename"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.BasicAttributeValueReference"}, {"methodBody": ["METHOD_START", "{", "return   myElement . getManager (  )  . areElementsEquivalent ( element ,    resolve (  )  )  ;", "}", "METHOD_END"], "methodName": ["isReferenceTo"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.BasicAttributeValueReference"}, {"methodBody": ["METHOD_START", "{", "String   schemaPrefix    =    rootTag . getPrefixByNamespace ( XmlUtil . XML _ SCHEMA _ URI )  ;", "if    (  !  ( schemaPrefix . isEmpty (  )  )  )", "schemaPrefix    +  =     \"  :  \"  ;", "template . addTextSeg (  (  (  (  (  (  \"  <  \"     +    schemaPrefix )     +     ( myDeclarationTagName )  )     +     \"    name =  \\  \"  \"  )     +     ( XmlUtil . findLocalNameByQualifiedName ( myRef . getCanonicalText (  )  )  )  )     +     \"  \\  \"  >  \"  )  )  ;", "template . addEndVariable (  )  ;", "template . addTextSeg (  (  (  (  \"  <  /  \"     +    schemaPrefix )     +     ( myDeclarationTagName )  )     +     \"  >  \\ n \"  )  )  ;", "template . setToReformat ( true )  ;", "}", "METHOD_END"], "methodName": ["addTextTo"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.CreateXmlElementIntentionAction"}, {"methodBody": ["METHOD_START", "{", "return   myReference ;", "}", "METHOD_END"], "methodName": ["getNamespaceReference"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.DependentNSReference"}, {"methodBody": ["METHOD_START", "{", "return   myForceFetchResultValid ;", "}", "METHOD_END"], "methodName": ["isForceFetchResultValid"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.DependentNSReference"}, {"methodBody": ["METHOD_START", "{", "final   PsiFile   containingFile    =    element . getContainingFile (  )  ;", "if    (  (  (  ( containingFile . getLanguage (  )  )     =  =     ( HTMLLanguage . INSTANCE )  )     |  |     (  ( containingFile . getLanguage (  )  )     =  =     ( XHTMLLanguage . INSTANCE )  )  )     |  |     (  ( containingFile . getView (  )  )    instanceof   TemplateLanguageFileView )  )     {", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["canHaveAdequateFix"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.DtdReferencesProvider"}, {"methodBody": ["METHOD_START", "{", "return   new   ElementFilter (  )     {", "@ Override", "public   boolean   isAcceptable ( Object   element ,    PsiElement   context )     {", "final   PsiElement   parent    =    context . getParent (  )  ;", "if    (  ( parent   instanceof   XmlEntityDecl )     &  &     (  !  (  (  ( XmlEntityDecl )     ( parent )  )  . isInternal (  )  )  )  )     {", "PsiElement   prevSibling    =    context . getPrevSibling (  )  ;", "if    ( prevSibling   instanceof   PsiWhiteSpace )     {", "prevSibling    =    prevSibling . getPrevSibling (  )  ;", "}", "if    (  (  ( prevSibling   instanceof   XmlToken )     &  &     (  (  (  ( XmlToken )     ( prevSibling )  )  . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ DOCTYPE _ SYSTEM )  )  )     |  |     ( prevSibling   instanceof   XmlAttributeValue )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "@ Override", "public   boolean   isClassAcceptable ( Class   hintClass )     {", "return   true ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getSystemReferenceFilter"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.DtdReferencesProvider"}, {"methodBody": ["METHOD_START", "{", "final   XmlElement   parentThatProvidesMetaData    =    PsiTreeUtil . getParentOfType ( CompletionUtilCoreImpl . getOriginalElement ( element )  ,    XmlDocument . class ,    XmlMarkupDecl . class )  ;", "if    ( parentThatProvidesMetaData   instanceof   XmlDocument )     {", "final   XmlDocument   document    =     (  ( XmlDocument )     ( parentThatProvidesMetaData )  )  ;", "XmlNSDescriptor   rootTagNSDescriptor    =    document . getRootTagNSDescriptor (  )  ;", "if    ( rootTagNSDescriptor    =  =    null )", "rootTagNSDescriptor    =     (  ( XmlNSDescriptor )     ( document . getMetaData (  )  )  )  ;", "return   rootTagNSDescriptor ;", "} else", "if    ( parentThatProvidesMetaData   instanceof   XmlMarkupDecl )     {", "final   XmlMarkupDecl   markupDecl    =     (  ( XmlMarkupDecl )     ( parentThatProvidesMetaData )  )  ;", "final   meta . PsiMetaData   psiMetaData    =    markupDecl . getMetaData (  )  ;", "if    ( psiMetaData   instanceof   XmlNSDescriptor )     {", "return    (  ( XmlNSDescriptor )     ( psiMetaData )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getNsDescriptor"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.DtdResolveUtil"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   rootTagNSDescriptor    =    DtdResolveUtil . getNsDescriptor ( context )  ;", "if    ( rootTagNSDescriptor   instanceof   XmlNSDescriptorImpl )     {", "return    (  ( XmlNSDescriptorImpl )     ( rootTagNSDescriptor )  )  . getElementDescriptor ( name )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["resolveElementReference"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.DtdResolveUtil"}, {"methodBody": ["METHOD_START", "{", "final   FileViewProvider   fileViewProvider    =    file . getViewProvider (  )  ;", "final   PsiFile   baseFile    =    fileViewProvider . getPsi ( fileViewProvider . getBaseLanguage (  )  )  ;", "baseFile . getFirstChild (  )  ;", "return   get ( getKey (  )  ,    baseFile ,    null )  . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["compute"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.FileBasedUserDataCache"}, {"methodBody": ["METHOD_START", "{", "return   new   Object [  ]  {    xmlFile    }  ;", "}", "METHOD_END"], "methodName": ["getDependencies"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.FileBasedUserDataCache"}, {"methodBody": ["METHOD_START", "{", "if    ( element   instanceof   XmlTag )     {", "final   XmlTag   tag    =     (  ( XmlTag )     ( element )  )  ;", "String   s    =    tag . getAttributeValue ( IdReferenceProvider . ID _ ATTR _ NAME )  ;", "if    (  !  ( myIdAttrsOnly )  )     {", "if    ( s    =  =    null )", "s    =    tag . getAttributeValue ( IdReferenceProvider . NAME _ ATTR _ NAME )  ;", "if    ( s    =  =    null )", "s    =    tag . getAttributeValue ( IdReferenceProvider . STYLE _ ID _ ATTR _ NAME )  ;", "}", "return   s    !  =    null    ?    s    :    IdRefReference . getImplicitIdRefValue ( tag )  ;", "} else", "if    ( element   instanceof   PsiComment )     {", "return   IdRefReference . getImplicitIdValue (  (  ( PsiComment )     ( element )  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getIdValue"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.IdRefReference"}, {"methodBody": ["METHOD_START", "{", "if    ( element   instanceof   XmlTag )     {", "final   XmlTag   tag    =     (  ( XmlTag )     ( element )  )  ;", "XmlAttribute   attribute    =    tag . getAttribute ( IdReferenceProvider . ID _ ATTR _ NAME ,    null )  ;", "if    (  !  ( myIdAttrsOnly )  )     {", "if    ( attribute    =  =    null )     {", "attribute    =    tag . getAttribute ( IdReferenceProvider . NAME _ ATTR _ NAME ,    null )  ;", "}", "if    ( attribute    =  =    null )     {", "attribute    =    tag . getAttribute ( IdReferenceProvider . STYLE _ ID _ ATTR _ NAME ,    null )  ;", "}", "}", "return   attribute    !  =    null    ?    attribute . getValueElement (  )     :     . getImplicitIdRefValueElement ( tag )  ;", "} else    {", "return   element ;", "}", "}", "METHOD_END"], "methodName": ["getIdValueElement"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.IdRefReference"}, {"methodBody": ["METHOD_START", "{", "for    ( ImplicitIdRefProvider   idRefProvider    :    Extensions . getExtensions ( ImplicitIdRefProvider . EXTENSION _ POINT _ NAME )  )     {", "XmlAttribute   value    =    idRefProvider . getIdRefAttribute ( tag )  ;", "if    ( value    !  =    null )", "return   value ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getImplicitIdRefAttr"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.IdRefReference"}, {"methodBody": ["METHOD_START", "{", "XmlAttributeValue   attribute    =    IdRefReference . getImplicitIdRefValueElement ( tag )  ;", "return   attribute    !  =    null    ?    attribute . getValue (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getImplicitIdRefValue"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.IdRefReference"}, {"methodBody": ["METHOD_START", "{", "for    ( ImplicitIdRefProvider   idRefProvider    :    Extensions . getExtensions ( ImplicitIdRefProvider . EXTENSION _ POINT _ NAME )  )     {", "XmlAttribute   value    =    idRefProvider . getIdRefAttribute ( tag )  ;", "if    ( value    !  =    null )", "return   value . getValueElement (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getImplicitIdRefValueElement"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.IdRefReference"}, {"methodBody": ["METHOD_START", "{", "return   XmlDeclareIdInCommentAction . getImplicitlyDeclaredId ( comment )  ;", "}", "METHOD_END"], "methodName": ["getImplicitIdValue"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.IdRefReference"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( subTag . getAttributeValue ( IdReferenceProvider . ID _ ATTR _ NAME )  )     !  =    null )     |  |     (  ( subTag . getAttributeValue ( IdReferenceProvider . FOR _ ATTR _ NAME )  )     !  =    null )  )     |  |     (  ( IdRefReference . getImplicitIdRefValue ( subTag )  )     !  =    null )  )     |  |     (  (  ( subTag . getAttributeValue ( IdReferenceProvider . NAME _ ATTR _ NAME )  )     !  =    null )     &  &     (  !  ( subTag . getName (  )  . contains (  \"  . directive \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAcceptableTagType"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.IdRefReference"}, {"methodBody": ["METHOD_START", "{", "return   comment . getText (  )  . contains (  \"  @ declare   id =  \"  )  ;", "}", "METHOD_END"], "methodName": ["isDeclarationComment"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.IdRefReference"}, {"methodBody": ["METHOD_START", "{", "final   PsiFile   psiFile    =    getElement (  )  . getContainingFile (  )  ;", ". process ( processor ,    psiFile )  ;", "}", "METHOD_END"], "methodName": ["process"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.IdRefReference"}, {"methodBody": ["METHOD_START", "{", "for    ( PsiElement   e    :    IdRefReference . ourCachedIdsCache . compute ( file )  )     {", "if    (  !  ( processor . execute ( e )  )  )", "return ;", "}", "}", "METHOD_END"], "methodName": ["process"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.IdRefReference"}, {"methodBody": ["METHOD_START", "{", "return   new   String [  ]  {    IdReferenceProvider . FOR _ ATTR _ NAME ,    IdReferenceProvider . ID _ ATTR _ NAME ,    IdReferenceProvider . NAME _ ATTR _ NAME ,    IdReferenceProvider . STYLE _ ID _ ATTR _ NAME    }  ;", "}", "METHOD_END"], "methodName": ["getIdForAttributeNames"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.IdReferenceProvider"}, {"methodBody": ["METHOD_START", "{", "return   new   ElementFilter (  )     {", "@ Override", "public   boolean   isAcceptable ( Object   element ,    PsiElement   context )     {", "final   PsiElement   grandParent    =     (  ( PsiElement )     ( element )  )  . getParent (  )  . getParent (  )  ;", "if    ( grandParent   instanceof   XmlTag )     {", "final   XmlTag   tag    =     (  ( XmlTag )     ( grandParent )  )  ;", "if    (  !  ( tag . getNamespaefix (  )  . isEmpty (  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "@ Override", "public   boolean   isClassAcceptable ( Class   hintClass )     {", "return   true ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getIdForFilter"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.IdReferenceProvider"}, {"methodBody": ["METHOD_START", "{", "for    ( PsiElement   child    =    element . getFirstChild (  )  ;    child    !  =    null ;    child    =    child . getNextSibling (  )  )     {", "if    ( child   instaof   OuterLanguageElement )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasOuterLanguageElement"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.IdReferenceProvider"}, {"methodBody": ["METHOD_START", "{", "return   new   FileReferenceSet ( str ,    position ,    offsetInPosition ,    provider ,    true )     {", "@ Override", "protected   boolean   useIncludingFileAsContext (  )     {", "return   false ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getFileReferenceSet"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.JspxIncludePathReferenceProvider"}, {"methodBody": ["METHOD_START", "{", "return   JspxIncludePathReferenceProvider . getFileReferenceSet ( str ,    position ,    offsetInPosition ,    provider )  . getAllReferences (  )  ;", "}", "METHOD_END"], "methodName": ["getFileReferencesFromString"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.JspxIncludePathReferenceProvider"}, {"methodBody": ["METHOD_START", "{", "return   JspxIncludePathReferenceProvider . getFileReferencesFromString ( str ,    position ,    offsetInPosition ,    this )  ;", "}", "METHOD_END"], "methodName": ["getReferencesByString"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.JspxIncludePathReferenceProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( element   instanceof   XmlAttributeValue )     {", "final   XmlAttributeValue   attributeValue    =     (  ( XmlAttributeValue )     ( element )  )  ;", "final   String   prefix    =    XmlUtil . findPrefixByQualifiedName ( attributeValue . getValue (  )  )  ;", "if    (  !  ( prefix . isEmpty (  )  )  )     {", "return   new   SchemaPrefix ( attributeValue ,    TextRange . from (  1  ,    prefix . length (  )  )  ,    prefix ,    null )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["createSchemaPrefixReference"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.SchemaReferencesProvider"}, {"methodBody": ["METHOD_START", "{", "return   SchemaReferencesProvider . createTypeOrElementOrAttributeReference ( element ,    null )  ;", "}", "METHOD_END"], "methodName": ["createTypeOrElementOrAttributeReference"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.SchemaReferencesProvider"}, {"methodBody": ["METHOD_START", "{", "final   int   length    =    element . getTextLength (  )  ;", "int   offset    =     ( element   instanceof   XmlAttributeValue )     ?    XmlUtil . findPrefixByQualifiedName (  (  ( XmlAttributeValue )     ( element )  )  . getValue (  )  )  . length (  )     :     0  ;", "if    ( offset    >     0  )", "offset +  +  ;", "final   TypeOrElementOrAttribute   ref    =    new   TypeOrElementOrAttribute ( element ,     ( length    >  =     2     ?    new   TextRange (  (  1     +    offset )  ,     ( length    -     1  )  )     :    TextRange . EMPTY _ RANGE )  )  ;", "ref . setNamespacePrefix ( ns )  ;", "return   ref ;", "}", "METHOD_END"], "methodName": ["createTypeOrElementOrAttributeReference"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.SchemaReferencesProvider"}, {"methodBody": ["METHOD_START", "{", "final   String   localName    =    XmlUtil . findLocalNameByQualifiedName ( text )  ;", "for    ( XmlTag   parentTag    =    tag . getParentTag (  )  ;    parentTag    !  =    null ;    parentTag    =    parentTag . getParentTag (  )  )     {", "if    ( localName . equals ( parentTag . getAttributeValue (  \" name \"  )  )  )     {", "final   XmlTag   grandParent    =    parentTag . getParentTag (  )  ;", "if    (  ( grandParent    !  =    null )     &  &     (  \" redefine \"  . equals ( grandParent . getLocalName (  )  )  )  )     {", "return   XmlNSDescriptorIgetRedefinedElementDescriptor ( grandParent )  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findRedefinedDescriptor"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.SchemaReferencesProvider"}, {"methodBody": ["METHOD_START", "{", "return   new   String [  ]  {    SchemaReferencesProvider . REF _ ATTR _ NAME ,    SchemaReferencesProvider . TYPE _ ATTR _ NAME ,    SchemaReferencesProvider . BASE _ ATTR _ NAME ,    SchemaReferencesProvider . NAME _ ATTR _ NAME ,    SchemaReferencesProvider . SUBSTITUTION _ GROUP _ ATTR _ NAME ,    SchemaReferencesProvider . MEMBER _ TYPES _ ATTR _ NAME ,    SchemaReferencesProvider . VALUE _ ATTR _ NAME ,    SchemaReferencesProvider . ITEM _ TYPE _ ATTR _ NAME    }  ;", "}", "METHOD_END"], "methodName": ["getCandidateAttributeNamesForSchemaReferences"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.SchemaReferencesProvider"}, {"methodBody": ["METHOD_START", "{", "final   XmlAttribute   attribute    =    PsiTreeUtil . getParentOfType ( element ,    XmlAttribute . class )  ;", "if    ( attribute    =  =    null )     {", "return   null ;", "}", "final   XmlTag   tag    =    attribute . getParent (  )  ;", "final   String   localName    =    tag . getLocalName (  )  ;", "final   String   attributeLocalName    =    attribute . getLocalName (  )  ;", "if    (  ( SchemaReferencesProvider . REF _ ATTR _ NAME . equals ( attributeLocalName )  )     |  |     ( SchemaReferencesProvider . SUBSTITUTION _ GROUP _ ATTR _ NAME . equals ( attributeLocalName )  )  )     {", "if    ( localName . equals ( SchemaReferencesProvider . GROUP _ TAG _ NAME )  )     {", "return    . ReferenceType . GroupReference ;", "} else", "if    ( localName . equals ( SchemaReferencesProvider . ATTRIBUTE _ GROUP _ TAG _ NAME )  )     {", "return    . ReferenceType . AttributeGroupReference ;", "} else", "if    ( SchemaReferencesProvider . ELEMENT _ TAG _ NAME . equals ( localName )  )     {", "return    . ReferenceType . ElementReference ;", "} else", "if    ( SchemaReferencesProvider . ATTRIBUTE _ TAG _ NAME . equals ( localName )  )     {", "return    . ReferenceType . AttributeReference ;", "}", "} else", "if    (  (  (  ( SchemaReferencesProvider . TYPE _ ATTR _ NAME . equals ( attributeLocalName )  )     |  |     ( SchemaReferencesProvider . BASE _ ATTR _ NAME . equals ( attributeLocalName )  )  )     |  |     ( SchemaReferencesProvider . MEMBER _ TYPES _ ATTR _ NAME . equals ( attributeLocalName )  )  )     |  |     ( SchemaReferencesProvider . ITEM _ TYPE _ ATTR _ NAME . equals ( attributeLocalName )  )  )     {", "return    . ReferenceType . TypeReference ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["determineReferenceType"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.TypeOrElementOrAttributeReference"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( myType )     !  =     ( TypeOrElementOrAttributeReference . ReferenceType . ElementReference )  )     &  &     (  ( myType )     !  =     ( TypeOrElementOrAttributeReference . ReferenceType . AttributeReference )  )  )     {", "final   PsiElement   parentElement    =    myElement . getContext (  )  ;", "final   PsiElement   grandParentElement    =     ( parentElement    !  =    null )     ?    parentElement . getParent (  )     :    null ;", "boolean   doRedefineCheck    =    false ;", "if    (  ( parentElement   instanceof   XmlAttribute )     &  &     ( grandParentElement   instanceof   XmlTag )  )     {", "final   String   attrName    =     (  ( XmlAttribute )     ( parentElement )  )  . getName (  )  ;", "final   String   tagLocalName    =     (  ( XmlTag )     ( grandParentElement )  )  . getLocalName (  )  ;", "doRedefineCheck    =     (  ( SchemaReferencesProvider . REF _ ATTR _ NAME . equals ( attrName )  )     &  &     (  ( SchemaReferencesProvider . GROUP _ TAG _ NAME . equals ( tagLocalName )  )     |  |     ( SchemaReferencesProvider . ATTRIBUTE _ GROUP _ TAG _ NAME . equals ( tagLocalName )  )  )  )     |  |     (  ( SchemaReferencesProvider . BASE _ ATTR _ NAME . equals ( attrName )  )     |  |     ( SchemaReferencesProvider . MEMBER _ TYPES _ ATTR _ NAME . equals ( attrName )  )  )  ;", "}", "if    ( doRedefineCheck )     {", "XmlNSDescriptorImpl   redefinedDescriptor    =    SchemaReferencesProvider . findRedefinedDescriptor ( tag ,    text )  ;", "if    ( redefinedDescriptor    !  =    null )     {", "redefined [  0  ]     =    true ;", "return   redefinedDescriptor ;", "}", "}", "}", "final   String   namespace    =    TypeOrElementOrAttributeReference . getNamespace ( tag ,    text )  ;", "XmlNSDescriptor   nsDescriptor    =    tag . getNSDescriptor ( namespace ,    true )  ;", "final   PsiFile   file    =    tag . getContainingFile (  )  ;", "if    (  !  ( file   instanceof   XmlFile )  )", "return   null ;", "final   XmlDocument   document    =     (  ( XmlFile )     ( file )  )  . getDocument (  )  ;", "if    ( nsDescriptor    =  =    null )     {", "nsDescriptor    =     (  ( XmlNSDescriptor )     ( document . getMetaData (  )  )  )  ;", "}", "if    ( nsDescriptor    =  =    null )     {", "final   XmlNSDescriptor [  ]    descrs    =    new   XmlNSDescriptor [  1  ]  ;", "URLReference . processWsdlSchemas ( document . getRootTag (  )  ,     (    xmlTag )     -  >     {", "if    ( namespace . equals ( xmlTag . getAttributeValue ( TypeOrElementOrAttributeReference . TARGET _ NAMESPACE )  )  )     {", "descrs [  0  ]     =     (  ( XmlNSDescriptor )     ( xmlTag . getMetaData (  )  )  )  ;", "return   false ;", "}", "return   true ;", "}  )  ;", "if    (  ( descrs [  0  ]  )    instanceof   XmlNSDescriptorImpl )", "return    (  ( XmlNSDescriptorImpl )     ( descrs [  0  ]  )  )  ;", "}", "return   nsDescriptor   instanceof   XsdNsDescriptor    ?     (  ( XsdNsDescriptor )     ( nsDescriptor )  )     :    null ;", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.TypeOrElementOrAttributeReference"}, {"methodBody": ["METHOD_START", "{", "final   String   namespacePrefix    =    XmlUtil . findPrefixByQualifiedName ( text )  ;", "final   String   namespaceByPrefix    =    tag . getNamespaceByPrefix ( namespacePrefix )  ;", "if    (  !  ( namespaceByPrefix . isEmpty (  )  )  )", "return   namespaceByPrefix ;", "final   XmlTag   rootTag    =     (  ( XmlFile )     ( tag . getContainingFile (  )  )  )  . getRootTag (  )  ;", "if    (  (  ( rootTag    !  =    null )     &  &     (  \" schema \"  . equals ( rootTag . getLocalName (  )  )  )  )     &  &     (  ( XmlUtil . ourSchemaUrisList . indexOf ( rootTag . getNamespace (  )  )  )     !  =     (  -  1  )  )  )     {", "final   String   targetNS    =    rootTag . getAttributeValue (  . TARGET _ NAMESPACE )  ;", "if    ( targetNS    !  =    null )     {", "final   String   targetNsPrefix    =    rootTag . getPrefixByNamespace ( targetNS )  ;", "if    (  ( namespacePrefix . equals ( targetNsPrefix )  )     |  |     (  ( namespaceByPrefix . isEmpty (  )  )     &  &     ( targetNsPrefix    =  =    null )  )  )     {", "return   targetNS ;", "}", "}", "}", "return   namespaceByPrefix ;", "}", "METHOD_END"], "methodName": ["getNamespace"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.TypeOrElementOrAttributeReference"}, {"methodBody": ["METHOD_START", "{", "return   myType ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.TypeOrElementOrAttributeReference"}, {"methodBody": ["METHOD_START", "{", "String [  ]    tagNames    =    null ;", "switch    ( type )     {", "case   GroupReference    :", "tagNames    =    new   String [  ]  {    SchemaReferencesProvider . GROUP _ TAG _ NAME    }  ;", "break ;", "case   AttributeGroupReference    :", "tagNames    =    new   String [  ]  {    SchemaReferencesProvider . ATTRIBUTE _ GROUP _ TAG _ NAME    }  ;", "break ;", "case   AttributeReference    :", "tagNames    =    new   String [  ]  {    SchemaReferencesProvider . ATTRIBUTE _ TAG _ NAME    }  ;", "break ;", "case   ElementReference    :", "tagNames    =    new   String [  ]  {    SchemaReferencesProvider . ELEMENT _ TAG _ NAME    }  ;", "break ;", "case   TypeReference    :", "tagNames    =    new   String [  ]  {    SchemaReferencesProvider . SIMPLE _ TYPE _ TAG _ NAME ,    SchemaReferencesProvider . COMPLEX _ TYPE _ TAG _ NAME    }  ;", "break ;", "}", "final   XmlDocument   document    =     (  ( XmlFile )     ( tag . getContainingFile (  )  )  )  . getDocument (  )  ;", "if    ( document    =  =    null )     {", "return   ArrayUtil . EMPTY _ OBJECT _ ARRAY ;", "}", "final   XmlTag   rootTag    =    document . getRootTag (  )  ;", "String   ourNamespace    =     ( rootTag    !  =    null )     ?    rootTag . getAttributeValue (  . TARGET _ NAMESPACE )     :     \"  \"  ;", "if    ( ourNamespace    =  =    null )", "ourNamespace    =     \"  \"  ;", ". CompletionProcessor   processor    =    new    . CompletionProcessor ( tag ,    prefix )  ;", "for    ( String   namespace    :    tag . knownNamespaces (  )  )     {", "if    ( ourNamespace . equals ( namespace )  )", "continue ;", "final   XmlNSDescriptor   nsDescriptor    =    tag . getNSDescriptor ( namespace ,    true )  ;", "if    ( nsDescriptor   instanceof   XsdNsDescriptor )     {", ". processNamespace ( namespace ,    processor ,     (  ( XsdNsDescriptor )     ( nsDescriptor )  )  ,    tagNames )  ;", "}", "}", "XmlNSDescriptor   nsDescriptor    =     (  ( XmlNSDescriptor )     ( document . getMetaData (  )  )  )  ;", "if    ( nsDescriptor   instanceof   XmlNSDescriptorImpl )     {", ". processNamespace ( ourNamespace ,    processor ,     (  ( XmlNSDescriptorImpl )     ( nsDescriptor )  )  ,    tagNames )  ;", "}", "return   ArrayUtil . toStringArray ( processor . myElements )  ;", "}", "METHOD_END"], "methodName": ["getVariants"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.TypeOrElementOrAttributeReference"}, {"methodBody": ["METHOD_START", "{", "cessor . namespace    =    namespace ;", "nsDescriptorcessTagsInNamespace ( tagNames , cessor )  ;", "}", "METHOD_END"], "methodName": ["processNamespace"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.TypeOrElementOrAttributeReference"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    PsiTreeUtil . getContextOfType ( myElement ,    XmlTag . class ,    false )  ;", "if    ( tag    =  =    null )", "return   null ;", "String   canonicalText    =    getCanonicalText (  )  ;", "boolean [  ]    redefined    =    new   boolean [  1  ]  ;", "XsdNsDescriptor   nsDescriptor    =    getDescriptor ( tag ,    canonicalText ,    redefined )  ;", "if    (  (  ( myType )     !  =    null )     &  &     ( nsDescriptor    !  =    null )  )     {", "switch    ( myType )     {", "case   GroupReference    :", "return   nsDescriptor . findGroup ( canonicalText )  ;", "case   AttributeGroupReference    :", "return   nsDescriptor . findAttributeGroup ( canonicalText )  ;", "case   ElementReference    :", "{", "XmlElementDescriptor   descriptor    =    nsDescriptor . getElementDescriptor ( XmlUtil . findLocalNameByQualifiedName ( canonicalText )  ,     . getNamespace ( tag ,    canonicalText )  ,    new   HashSet <  >  (  )  ,    true )  ;", "return   descriptor    !  =    null    ?    descriptor . getDeclaration (  )     :    null ;", "}", "case   AttributeReference    :", "{", "final   String   localNameByQualifiedName    =    XmlUtil . findLocalNameByQualifiedName ( canonicalText )  ;", "XmlAttributeDescriptor   descriptor    =    nsDescriptor . getAttribute ( localNameByQualifiedName ,     . getNamespace ( tag ,    canonicalText )  ,    tag )  ;", "if    ( descriptor    !  =    null )", "return   descriptor . getDeclaration (  )  ;", "return   null ;", "}", "case   TypeReference    :", "{", "TypeDescriptor   typeDescriptor    =     ( redefined [  0  ]  )     ?    nsDescriptor . findTypeDescriptor ( XmlUtil . findLocalNameByQualifiedName ( canonicalText )  ,     \"  \"  )     :    nsDescriptor . getTypeDescriptor ( canonicalText ,    tag )  ;", "if    ( typeDescriptor   instanceof   ComplexTypeDescriptor )     {", "return   typeDescriptor . getDeclaration (  )  ;", "} else", "if    ( typeDescriptor    !  =    null )     {", "return   myElement ;", "}", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["resolveInner"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.TypeOrElementOrAttributeReference"}, {"methodBody": ["METHOD_START", "{", "this . nsPrefix    =    prefix ;", "}", "METHOD_END"], "methodName": ["setNamespacePrefix"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.TypeOrElementOrAttributeReference"}, {"methodBody": ["METHOD_START", "{", "PsiElement   parent    =    element . getParent (  )  ;", "if    (  ( XmlUtil . isUrlText ( s ,    element . getProject (  )  )  )     |  |     (  ( parent   instanceof   XmlAttribute )     &  &     (  (  (  ( XmlAttribute )     ( parent )  )  . isNamespaceDeclaration (  )  )     |  |     (  . NAMESPACE _ ATTR _ NAME . equals (  (  ( XmlAttribute )     ( parent )  )  . getName (  )  )  )  )  )  )     {", "if    (  !  ( s . startsWith ( XmlUtil . TAG _ DIR _ NS _ PREFIX )  )  )     {", "boolean   namespaceSoftRef    =     (  ( parent   instanceof   XmlAttribute )     &  &     (  . NAMESPACE _ ATTR _ NAME . equals (  (  ( XmlAttribute )     ( parent )  )  . getName (  )  )  )  )     &  &     (  (  (  ( XmlAttribute )     ( parent )  )  . getParent (  )  . getAttributeValue ( XmlUtil . SCHEMA _ LOCATION _ ATT )  )     !  =    null )  ;", "if    (  (  (  ! namespaceSoftRef )     &  &     ( parent   instanceof   XmlAttribute )  )     &  &     (  (  ( XmlAttribute )     ( parent )  )  . isNamespaceDeclaration (  )  )  )     {", "namespaceSoftRef    =     ( parent . getContainingFile (  )  . getContext (  )  )     !  =    null ;", "}", "return   new   URLReference ( element ,    null ,    namespaceSoftRef )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getUrlReference"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.URIReferenceProvider"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isSchemaLocation"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.URLReference"}, {"methodBody": ["METHOD_START", "{", "if    (  \" definitions \"  . equals ( rootTag . getLocalName (  )  )  )     {", "final   String   nsPrefix    =    rootTag . getNamespacePrefix (  )  ;", "final   String   types    =     ( nsPrefix . isEmpty (  )  )     ?     \" types \"     :    nsPrefix    +     \"  : types \"  ;", "final   XmlTag   subTag    =    rootTag . findFirstSubTag ( types )  ;", "if    ( subTag    !  =    null )     {", "for    ( int   i    =     0  ;    i    <     ( XmlUtil . SCHEMA _ URIS . length )  ;    i +  +  )     {", "final   XmlTag [  ]    tags    =    subTag . findSubTags (  \" schema \"  ,    XmlUtil . SCHEMA _ URIS [ i ]  )  ;", "for    ( XmlTag   t    :    tags )     {", "if    (  ! cessorcess ( t )  )  )", "return ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processWsdlSchemas"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.URLReference"}, {"methodBody": ["METHOD_START", "{", "XmlTag   tag    =    PsiTreeUtil . getParentOfType ( element ,    XmlTag . class )  ;", "if    (  (  !  ( myAcceptSelf )  )     &  &     ( tag    !  =    null )  )     {", "tag    =    tag . getParentTag (  )  ;", "}", "while    ( tag    !  =    null )     {", "XmlAttribute   base    =    tag . getAttribute (  \" base \"  ,    XmlUtil . XML _ NAMESPACE _ URI )  ;", "if    ( base    !  =    null )     {", "XmlAttributeValue   value    =    base . getValueElement (  )  ;", "if    ( value    !  =    null )     {", "Psi   reference    =    value . get (  )  ;", "if    ( reference   instanceof   PsiPolyVariant )     {", "ResolveResult [  ]    results    =     (  ( PsiPolyVariant )     ( reference )  )  . multiResolve ( false )  ;", "return   ContainerUtil . map ( results ,     (    result )     -  >     (  ( PsiFileSystemItem )     ( result . getElement (  )  )  )  )  ;", "}", "}", "}", "tag    =    tag . getParentTag (  )  ;", "}", "PsiDirectory   directory    =    file . getContainingDirectory (  )  ;", "return   directory    =  =    null    ?    Collections . emptyList (  )     :    Collections . singletonList ( directory )  ;", "}", "METHOD_END"], "methodName": ["getContext"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.XmlBaseReferenceProvider"}, {"methodBody": ["METHOD_START", "{", "final   ElementManipulator < XmlTag >    manipulator    =    ElementManipulators . getManipulator ( myTag )  ;", "manipulator . handleContentChange ( myTag ,    myRange ,    str )  ;", "myRange    =    manipulator . getRangeInElement ( myTag )  ;", "}", "METHOD_END"], "methodName": ["replaceContent"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.XmlValueReference"}, {"methodBody": ["METHOD_START", "{", "return   new   RegExpLexer ( CAPABILITIES )  ;", "}", "METHOD_END"], "methodName": ["createLexer"], "fileName": "com.intellij.psi.impl.source.resolve.reference.impl.providers.XsdRegExpParserDefinition"}, {"methodBody": ["METHOD_START", "{", "elements . add ( LookupElementBuilder . create (  \"  ? xml   version =  \\  \"  1  .  0  \\  \"    encoding =  \\  \"  \\  \"     ?  >  \"  )  . withPresentableText (  \"  <  ? xml   version =  \\  \"  1  .  0  \\  \"    encoding =  \\  \"  \\  \"     ?  >  \"  )  . withInsertHandler ( new   com . intellij . codeInsight . completion . InsertHandler < LookupElement >  (  )     {", "@ Override", "public   void   handleInsert ( InsertionContext   context ,    LookupElement   item )     {", "int   offset    =    context . getEditor (  )  . getCaretModel (  )  . getOffset (  )  ;", "context . getEditor (  )  . getCaretModel (  )  . moveToOffset (  ( offset    -     4  )  )  ;", "AutoPopupController . getInstance ( context . getProject (  )  )  . scheduleAutoPopup ( context . getEditor (  )  )  ;", "}", "}  )  )  ;", "final   FileBasedIndex   fbi    =    FileBasedIndex . getInstance (  )  ;", "Collection < String >    result    =    new   ArrayList <  >  (  )  ;", "Processor < String >    processor    =    Processors . cancelableCollectProcessor ( result )  ;", "fbi . processAllKeys ( XmlNamespaceIndex . NAME ,    processor ,    tag . getProject (  )  )  ;", "final   GlobalSearchScope   scope    =    new   EverythingGlobalScope (  )  ;", "for    ( final   String   ns    :    result )     {", "if    ( ns . startsWith (  \" file :  /  /  \"  )  )", "continue ;", "fbi . processValues ( XmlNamespaceIndex . NAME ,    ns ,    null ,    new   FileBasedIndex . ValueProcessor < XsdNamespaceBuilder >  (  )     {", "@ Override", "public   boolean   process (  @ NotNull", "final   VirtualFile   file ,    XsdNamespaceBuilder   value )     {", "List < String >    tags    =    value . getRootTags (  )  ;", "for    ( String   s    :    tags )     {", "elements . add ( LookupElementBuilder . create ( s )  . withTypeText ( ns )  . withInsertHandler ( new   XmlTagInsertHandler (  )     {", "@ Override", "public   void   handleInsert ( InsertionContext   context ,    LookupElement   item )     {", "final   Editor   editor    =    context . getEditor (  )  ;", "final   Document   document    =    context . getDocument (  )  ;", "final   int   caretOffset    =    editor . getCaretModel (  )  . getOffset (  )  ;", "final   RangeMarker   caretMarker    =    document . createRangeMarker ( caretOffset ,    caretOffset )  ;", "caretMarker . setGreedyToRight ( true )  ;", "XmlFile   psiFile    =     (  ( XmlFile )     ( context . getFile (  )  )  )  ;", "boolean   incomplete    =     (  ( XmlUtil . getTokenOfType ( tag ,    XmlTokenType . XML _ TAG _ END )  )     =  =    null )     &  &     (  ( XmlUtil . getTokenOfType ( tag ,    XmlTokenType . XML _ EMPTY _ ELEMENT _ END )  )     =  =    null )  ;", "XmlNamespaceHelper . getHelper ( psiFile )  . insertNamespaceDeclaration ( psiFile ,    editor ,    Collections . singleton ( ns )  ,    null ,    null )  ;", "editor . getCaretModel (  )  . moveToOffset ( caretMarker . getEndOffset (  )  )  ;", "XmlTag   rootTag    =    psiFile . getRootTag (  )  ;", "if    ( incomplete )     {", "XmlToken   token    =    XmlUtil . getTokenOfType ( rootTag ,    XmlTokenType . XML _ EMPTY _ ELEMENT _ END )  ;", "if    ( token    !  =    null )", "token . delete (  )  ;", "PsiDocumentManager . getInstance ( context . getProject (  )  )  . doPostponedOperationsAndUnblockDocument ( document )  ;", "super . handleInsert ( context ,    item )  ;", "}", "}", "}  )  )  ;", "}", "return   true ;", "}", "}  ,    scope )  ;", "}", "return   elements ;", "}", "METHOD_END"], "methodName": ["getRootTagsVariants"], "fileName": "com.intellij.psi.impl.source.xml.DefaultXmlTagNameProvider"}, {"methodBody": ["METHOD_START", "{", "TextRange   range    =    ElementManipulators . getValueTextRange ( element )  . shiftRight ( element . getStartOffsetInParent (  )  )  ;", "return   new    (  (  ( XmlAttribute )     ( element . getParent (  )  )  )  ,    range ,    prefix )     {", "@ Override", "protected   String   getNamespace (  )     {", "return    (  ( XmlAttribute )     ( getParent (  )  )  )  . getParent (  )  . getAttributeValue (  \" uri \"  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createJspPrefix"], "fileName": "com.intellij.psi.impl.source.xml.SchemaPrefix"}, {"methodBody": ["METHOD_START", "{", "XmlAttribute   parent    =     (  ( XmlAttribute )     ( getParent (  )  )  )  ;", "return   parent    =  =    null    ?    null    :    parent . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getNamespace"], "fileName": "com.intellij.psi.impl.source.xml.SchemaPrefix"}, {"methodBody": ["METHOD_START", "{", "String   ns    =    getNamespace (  )  ;", "StringBuilder   builder    =    new   StringBuilder (  )  . append ( getTypeName (  )  )  . append (  \"     \\  \"  \"  )  . append ( getName (  )  )  . append (  \"  \\  \"  \"  )  ;", "if    ( ns    !  =    null )     {", "builder . append (  \"     (  \"  )  . append ( ns )  . append (  \"  )  \"  )  ;", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getQuickNavigateInfo"], "fileName": "com.intellij.psi.impl.source.xml.SchemaPrefix"}, {"methodBody": ["METHOD_START", "{", "return   myName ;", "}", "METHOD_END"], "methodName": ["getNamespacePrefix"], "fileName": "com.intellij.psi.impl.source.xml.SchemaPrefixReference"}, {"methodBody": ["METHOD_START", "{", "return   myTagNameReference ;", "}", "METHOD_END"], "methodName": ["getTagNameReference"], "fileName": "com.intellij.psi.impl.source.xml.SchemaPrefixReference"}, {"methodBody": ["METHOD_START", "{", "XmlExtension   extension    =    XmlExtension . getExtension ( element . getContainingFile (  )  )  ;", "return   extension . getDeclaration ( PsiTreeUtil . getParentOfType ( element ,    XmlTag . class ,    false )  ,    name )  ;", "}", "METHOD_END"], "methodName": ["resolvePrefix"], "fileName": "com.intellij.psi.impl.source.xml.SchemaPrefixReference"}, {"methodBody": ["METHOD_START", "{", "final   XmlExtension   extension    =    XmlExtension . getExtensionByElement ( element )  ;", "return   extension    =  =    null    ?    null    :    extension . create ( nameElement ,    startTagFlag )  ;", "}", "METHOD_END"], "methodName": ["createTagNameReference"], "fileName": "com.intellij.psi.impl.source.xml.TagNameReference"}, {"methodBody": ["METHOD_START", "{", "return   myNameElement ;", "}", "METHOD_END"], "methodName": ["getNameElement"], "fileName": "com.intellij.psi.impl.source.xml.TagNameReference"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   element    =    getElement (  )  ;", "if    ( element    =  =     ( myElement . getPsi (  )  )  )", "return   null ;", "return    (  ( XmlTag )     ( element )  )  ;", "}", "METHOD_END"], "methodName": ["getTagElement"], "fileName": "com.intellij.psi.impl.source.xml.TagNameReference"}, {"methodBody": ["METHOD_START", "{", "return   myStartTagFlag ;", "}", "METHOD_END"], "methodName": ["isStartTagFlag"], "fileName": "com.intellij.psi.impl.source.xml.TagNameReference"}, {"methodBody": ["METHOD_START", "{", "newElementName    =     (  !  ( namespacePrefix . isEmpty (  )  )     ?    namespacePrefix    +     \"  :  \"     :    namespacePrefix )     +    newElementName ;", "return   newElementName ;", "}", "METHOD_END"], "methodName": ["prependNamespacePrefix"], "fileName": "com.intellij.psi.impl.source.xml.TagNameReference"}, {"methodBody": ["METHOD_START", "{", "return   TagNameVariantCollector . couldContainDescriptor ( parent ,    parent . getDescriptor (  )  ,    child . getDescriptor (  )  ,    child . getNamespace (  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["couldContain"], "fileName": "com.intellij.psi.impl.source.xml.TagNameVariantCollector"}, {"methodBody": ["METHOD_START", "{", "if    ( XmlUtil . nsFromTemplateFramework ( childNamespace )  )", "return   true ;", "if    ( parentTag    =  =    null )", "return   true ;", "if    ( parentDescriptor    =  =    null )", "return   false ;", "final   XmlTag   childTag    =    parentTag . createChildTag ( childDescriptor . getName (  )  ,    childNamespace ,    null ,    false )  ;", "childTag . putUserData ( XmlElement . INCLUDING _ ELEMENT ,    parentTag )  ;", "XmlElementDescriptor   descriptor    =    parentDescriptor . getElementDescriptor ( childTag ,    parentTag )  ;", "return    ( descriptor    !  =    null )     &  &     (  (  ! strict )     |  |     (  !  ( descriptor   instanceof   AnyXmlElementDescriptor )  )  )  ;", "}", "METHOD_END"], "methodName": ["couldContainDescriptor"], "fileName": "com.intellij.psi.impl.source.xml.TagNameVariantCollector"}, {"methodBody": ["METHOD_START", "{", "return   extension . getNSDescriptor ( element ,    namespace ,    strict )  ;", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "com.intellij.psi.impl.source.xml.TagNameVariantCollector"}, {"methodBody": ["METHOD_START", "{", "XmlElementDescriptor   elementDescriptor    =    null ;", "String   elementNamespace    =     ( element . getNamespacePrefix (  )  . isEmpty (  )  )     ?    null    :    element . getNamespace (  )  ;", "final   Map < String ,    XmlElementDescriptor >    descriptorsMap    =    new   HashMap <  >  (  )  ;", "PsiElement   context    =    element . getParent (  )  ;", "PsiElement   curElement    =    element . getParent (  )  ;", "while    ( curElement   instanceof   XmlTag )     {", "final   XmlTag   declarationTag    =     (  ( XmlTag )     ( curElement )  )  ;", "final   String   namespace    =    declarationTag . getNamespace (  )  ;", "if    (  !  ( descriptorsMap . containsKey ( namespace )  )  )     {", "final   XmlElementDescriptor   descriptor    =    declarationTag . getDescriptor (  )  ;", "if    ( descriptor    !  =    null )     {", "descriptorsMap . put ( namespace ,    descriptor )  ;", "if    ( elementDescriptor    =  =    null )     {", "elementDescriptor    =    descriptor ;", "if    ( elementNamespace    =  =    null )     {", "elementNamespace    =    namespace ;", "}", "}", "}", "}", "curElement    =    curElement . getContext (  )  ;", "}", "final   Set < XmlNSDescriptor >    visited    =    new   HashSet <  >  (  )  ;", "final   XmlExtension   extension    =    XmlExtension . getExtension ( element . getContainingFile (  )  )  ;", "final   ArrayList < XmlElementDescriptor >    variants    =    new   ArrayList <  >  (  )  ;", "for    ( final   String   namespace    :    namespaces )     {", "final   int   initialSize    =    variants . size (  )  ;", ". processVariantsInNamespace ( namespace ,    element ,    variants ,    elementDescriptor ,    elementNamespace ,    descriptorsMap ,    visited ,     ( context   instanceof   XmlTag    ?     (  ( XmlTag )     ( context )  )     :    element )  ,    extension )  ;", "if    ( nsInfo    !  =    null )     {", "for    ( int   i    =    initialSize ;    i    <     ( variants . size (  )  )  ;    i +  +  )     {", "XmlElementDescriptor   descriptor    =    variants . get ( i )  ;", "nsInfo . add (  (  ( descriptor   instanceof   XmlElementDescriptorImpl )     &  &     (  !  ( descriptor   instanceof   RelaxedHtmlFromSchemaElementDescriptor )  )     ?     (  ( XmlElementDescriptorImpl )     ( descriptor )  )  . getNamespaceByContext ( element )     :    namespace )  )  ;", "}", "}", "}", "final   boolean   hasPrefix    =    StringUtil . isNotEmpty ( element . getNamespacePrefix (  )  )  ;", "return   ContainerUtil . filter ( variants ,     (    descriptor )     -  >     {", "if    ( descriptor   instanceof   AnyXmlElementDescriptor )     {", "return   false ;", "} else", "if    (  ( hasPrefix    &  &     ( descriptor   instanceof   XmlElementDescriptorImpl )  )     &  &     (  !  ( namespaces . contains (  (  ( XmlElementDescriptorImpl )     ( descriptor )  )  . getNamespace (  )  )  )  )  )     {", "return   false ;", "}", "return   true ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["getTagDescriptors"], "fileName": "com.intellij.psi.impl.source.xml.TagNameVariantCollector"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  !  ( elementDescriptor   instanceof   XmlElementDescriptorAwareAboutChildren )  )     |  |     ( elementNamespace    =  =    null )  )     |  |     ( elementNamespace . equals ( namespace )  )  )     |  |     (  (  ( XmlElementDescriptorAwareAboutChildren )     ( elementDescriptor )  )  . allowElementsFromNamespace ( namespace ,    element . getParentTag (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAcceptableNs"], "fileName": "com.intellij.psi.impl.source.xml.TagNameVariantCollector"}, {"methodBody": ["METHOD_START", "{", "if    ( descriptorsMap . containsKey ( namespace )  )     {", "final   XmlElementDescriptor   descriptor    =    descriptorsMap . get ( namespace )  ;", "if    (  . isAcceptableNs ( element ,    elementDescriptor ,    elementNamespace ,    namespace )  )     {", "for    ( XmlElementDescriptor   containedDescriptor    :    descriptor . getElementsDescriptors ( parent )  )     {", "if    ( containedDescriptor    !  =    null )", "variants . add ( containedDescriptor )  ;", "}", "}", "if    ( element   instanceof   HtmlTag )     {", "HtmlUtil . addHtmlSpecificCompletions ( descriptor ,    element ,    variants )  ;", "}", "visited . add ( descriptor . getNSDescriptor (  )  )  ;", "} else    {", "if    ( namespace    =  =    null )", "return ;", "if    (  ( namespace . isEmpty (  )  )     &  &     (  !  ( visited . isEmpty (  )  )  )  )", "return ;", "XmlNSDescriptor   nsDescriptor    =     . getDescriptor ( element ,    namespace ,    true ,    extension )  ;", "if    ( nsDescriptor    =  =    null )     {", "if    (  !  ( descriptorsMap . isEmpty (  )  )  )", "return ;", "nsDescriptor    =     . getDescriptor ( element ,    namespace ,    false ,    extension )  ;", "}", "if    (  (  ( nsDescriptor    !  =    null )     &  &     (  !  ( visited . contains ( nsDescriptor )  )  )  )     &  &     (  . isAcceptableNs ( element ,    elementDescriptor ,    elementNamespace ,    namespace )  )  )     {", "visited . add ( nsDescriptor )  ;", "final   XmlElementDescriptor [  ]    rootElementsDescriptors    =    nsDescriptor . getRootElementsDescriptors ( PsiTreeUtil . getParentOfType ( element ,    XmlDocument . class )  )  ;", "final   XmlTag   parentTag    =    extension . getParentTagForNamespace ( element ,    nsDescriptor )  ;", "final   XmlElementDescriptor   parentDescriptor ;", "if    ( parentTag    =  =     ( element . getParentTag (  )  )  )     {", "parentDescriptor    =    elementDescriptor ;", "} else    {", "assert   parentTag    !  =    null ;", "parentDescriptor    =    parentTag . getDescriptor (  )  ;", "}", "for    ( XmlElementDescriptor   candidateDescriptor    :    rootElementsDescriptors )     {", "if    (  ( candidateDescriptor    !  =    null )     &  &     (  . couldContainDescriptor ( parentTag ,    parentDescriptor ,    candidateDescriptor ,    namespace ,    false )  )  )     {", "variants . add ( candidateDescriptor )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processVariantsInNamespace"], "fileName": "com.intellij.psi.impl.source.xml.TagNameVariantCollector"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   elementName    =    findElementByTokenType ( XmlTokenType . XML _ NAME )  ;", "final   PsiElement   nextSibling    =     ( elementName    !  =    null )     ?    elementName . getNextSibling (  )     :    null ;", "final   PsiElement   elementType    =     ( nextSibling   instanceof   PsiWhiteSpace )     ?    nextSibling . getNextSibling (  )     :    nextSibling ;", "return   elementType ;", "}", "METHOD_END"], "methodName": ["findElementType"], "fileName": "com.intellij.psi.impl.source.xml.XmlAttributeDeclImpl"}, {"methodBody": ["METHOD_START", "{", "buffer . append ( child . getChars (  )  )  ;", "}", "METHOD_END"], "methodName": ["appendChildToDisplayValue"], "fileName": "com.intellij.psi.impl.source.xml.XmlAttributeImpl"}, {"methodBody": ["METHOD_START", "{", "Project   project    =    getProject (  )  ;", "ExternalReManagerEx   manager    =    ExternalReManagerEx . getInstanceEx (  )  ;", "return    (  )     -  >    manager . getModificationCount ( project )  ;", "}", "METHOD_END"], "methodName": ["externalResourceModificationTracker"], "fileName": "com.intellij.psi.impl.source.xml.XmlAttributeImpl"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   parentElement    =    getParent (  )  ;", "if    ( parentElement    =  =    null )", "return   null ;", "final   XmlTag   tag    =     (  ( XmlTag )     ( parentElement )  )  ;", "final   XmlElementDescriptor   descr    =    tag . getDescriptor (  )  ;", "if    ( descr    =  =    null )", "return   null ;", "final   Descriptor   attributeDescr    =    descr . getAttributeDescriptor ( this )  ;", "return   attributeDescr    =  =    null    ?    descr . getAttributeDescriptor ( getName (  )  ,    tag )     :    attributeDescr ;", "}", "METHOD_END"], "methodName": ["getDescriptorImpl"], "fileName": "com.intellij.psi.impl.source.xml.XmlAttributeImpl"}, {"methodBody": ["METHOD_START", "{", "ApplicationManager . getApplication (  )  . assertReadAccessAllowed (  )  ;", ". VolatileState   state    =    myVolatileState ;", "if    ( state    =  =    null )     {", "state    =    recalculate (  )  ;", "}", "return   state ;", "}", "METHOD_END"], "methodName": ["getFreshState"], "fileName": "com.intellij.psi.impl.source.xml.XmlAttributeImpl"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    getLocalName (  )  ;", "return   name . endsWith ( CompletionUtilCore . DUMMY _ IDENTIFIER _ TRIMMED )     ?    name . substring (  0  ,     (  ( name . length (  )  )     -     ( CompletionUtilCore . DUMMY _ IDENTIFIER _ TRIMMED . length (  )  )  )  )     :    name ;", "}", "METHOD_END"], "methodName": ["getRealLocalName"], "fileName": "com.intellij.psi.impl.source.xml.XmlAttributeImpl"}, {"methodBody": ["METHOD_START", "{", "XmlAttributeValue   value    =    getValueElement (  )  ;", "if    ( value    =  =    null )", "return   null ;", "PsiElement   firstChild    =    value . getFirstChild (  )  ;", "if    ( firstChild    =  =    null )", "return   null ;", "ASTNode   child    =    firstChild . getNode (  )  ;", "TextRange   valueTextRange    =    new   TextRange (  0  ,    value . getTextLength (  )  )  ;", "if    (  ( child    !  =    null )     &  &     (  ( child . getElementType (  )  )     =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ START _ DELIMITER )  )  )     {", "valueTextRange    =    new   TextRange ( child . getTextLength (  )  ,    valueTextRange . getEndOffset (  )  )  ;", "child    =    child . getTreeNext (  )  ;", "}", "final   TIntArrayList   gapsStarts    =    new   TIntArrayList (  )  ;", "final   TIntArrayList   gapsShifts    =    new   TIntArrayList (  )  ;", "StringBuilder   buffer    =    new   StringBuilder ( getTextLength (  )  )  ;", "while    ( child    !  =    null )     {", "final   int   start    =    buffer . length (  )  ;", "IElementType   elementType    =    child . getElementType (  )  ;", "if    ( elementType    =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ END _ DELIMITER )  )     {", "valueTextRange    =    new   TextRange ( valueTextRange . getStartOffset (  )  ,     (  ( child . getTextRange (  )  . getStartOffset (  )  )     -     ( value . getTextRange (  )  . getStartOffset (  )  )  )  )  ;", "break ;", "}", "if    ( elementType    =  =     ( XmlTokenType . XML _ CHAR _ ENTITY _ REF )  )     {", "buffer . append ( XmlUtil . getCharFromEntityRef ( child . getText (  )  )  )  ;", "} else", "if    ( elementType    =  =     ( xml . XmlElementType . XML _ ENTITY _ REF )  )     {", "buffer . append ( XmlUtil . getEntityValue (  (  ( xml . XmlEntityRef )     ( child )  )  )  )  ;", "} else    {", "appendChildToDisplayValue ( buffer ,    child )  ;", "}", "int   end    =    buffer . length (  )  ;", "int   originalLength    =    child . getTextLength (  )  ;", "if    (  ( end    -    start )     !  =    originalLength )     {", "gapsStarts . add ( start )  ;", "gapsShifts . add (  ( originalLength    -     ( end    -    start )  )  )  ;", "}", "child    =    child . getTreeNext (  )  ;", "}", "int [  ]    gapDisplayStarts    =    ArrayUtil . newIntArray ( gapsShifts . size (  )  )  ;", "int [  ]    gapPhysicalStarts    =    ArrayUtil . newIntArray ( gapsShifts . size (  )  )  ;", "int   currentGapsSum    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( gapDisplayStarts . length )  ;    i +  +  )     {", "currentGapsSum    +  =    gapsShifts . get ( i )  ;", "gapDisplayStarts [ i ]     =    gapsStarts . get ( i )  ;", "gapPhysicalStarts [ i ]     =     ( gapDisplayStarts [ i ]  )     +    currentGapsSum ;", "}", "final   XmlAttributeImpl . VolatileState   volatileState    =    new   XmlAttributeImpl . VolatileState ( buffer . toString (  )  ,    gapDisplayStarts ,    gapPhysicalStarts ,    valueTextRange )  ;", "myVolatileState    =    volatileState ;", "return   volatileState ;", "}", "METHOD_END"], "methodName": ["recalculate"], "fileName": "com.intellij.psi.impl.source.xml.XmlAttributeImpl"}, {"methodBody": ["METHOD_START", "{", "return   myDescriptor . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "com.intellij.psi.impl.source.xml.XmlAttributeReference"}, {"methodBody": ["METHOD_START", "{", "if    ( TemplateLanguageUtil . isInsideTemplateFile ( parentTag )  )", "return   null ;", "contentDFA    =    XsContentDFA . createContentDFA ( parentTag )  ;", "if    ( contentDFA    !  =    null )", "return   contentDFA ;", "return   Impl . createContentDFA ( parentTag )  ;", "}", "METHOD_END"], "methodName": ["getContentDFA"], "fileName": "com.intellij.psi.impl.source.xml.XmlContentDFA"}, {"methodBody": ["METHOD_START", "{", "return    (  +  +  ( myOccurs )  )     >  =     ( myGroup . getMaxOccurs (  )  )     ?    XmlContentDFAImpl . Result . PROCEED _ TO _ NEXT    :    XmlContentDFAImpl . Result . CONSUME ;", "}", "METHOD_END"], "methodName": ["consume"], "fileName": "com.intellij.psi.impl.source.xml.XmlContentDFAImpl"}, {"methodBody": ["METHOD_START", "{", "XmlElementDescriptor   descriptor    =    parentTag . getDescriptor (  )  ;", "if    ( descriptor    =  =    null )     {", "return   null ;", "}", "XmlElementsGroup   topGroup    =    descriptor . getTopGroup (  )  ;", "if    ( topGroup    =  =    null )     {", "return   null ;", "}", "return   new    ( topGroup )  ;", "}", "METHOD_END"], "methodName": ["createContentDFA"], "fileName": "com.intellij.psi.impl.source.xml.XmlContentDFAImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myGroup . getGroupType (  )  )     =  =     ( XmlElementsGroup . Type . LEAF )  )     {", "if    ( element . equals ( myGroup . getLeafDescriptor (  )  )  )     {", "return   consume (  )  ;", "} else", "return    . Result . NONE ;", "}", "return   processSubGroups ( element )  ;", "}", "METHOD_END"], "methodName": ["doTransition"], "fileName": "com.intellij.psi.impl.source.xml.XmlContentDFAImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myLastChild )     =  =    null )     {", "List < XmlElementsGroup >    subGroups    =    myGroup . getSubGroups (  )  ;", "if    (  !  ( subGroups . isEmpty (  )  )  )     {", "myLastChild    =    new    ( subGroups . get (  0  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["getLastChild"], "fileName": "com.intellij.psi.impl.source.xml.XmlContentDFAImpl"}, {"methodBody": ["METHOD_START", "{", "List < XmlElementsGroup >    subGroups    =    myGroup . getSubGroups (  )  ;", "int   i    =     ( subGroups . indexOf ( myLastChild . myGroup )  )     +     1  ;", "return   i    =  =     ( subGroups . size (  )  )     ?    null    :    new    ( subGroups . get ( i )  )  ;", "}", "METHOD_END"], "methodName": ["getNextSubGroup"], "fileName": "com.intellij.psi.impl.source.xml.XmlContentDFAImpl"}, {"methodBody": ["METHOD_START", "{", "switch    ( myGroup . getGroupType (  )  )     {", "case   SEQUENCE    :", "getLastChild (  )  ;", "while    (  ( myLastChild )     !  =    null )     {", "myLastChild . getPossibleElements ( elements )  ;", "if    (  ( myLastChild . myGroup . getMinOccurs (  )  )     =  =     0  )     {", "myLastChild    =    getNextSubGroup (  )  ;", "} else", "return ;", "}", "break ;", "case   CHOICE    :", "case   ALL    :", "case   GROUP    :", "for    ( XmlElementsGroup   group    :    myGroup . getSubGroups (  )  )     {", "new    ( group )  . getPossibleElements ( elements )  ;", "}", "break ;", "case   LEAF    :", "ContainerUtil . addIfNotNull ( elements ,    myGroup . getLeafDescriptor (  )  )  ;", "break ;", "}", "}", "METHOD_END"], "methodName": ["getPossibleElements"], "fileName": "com.intellij.psi.impl.source.xml.XmlContentDFAImpl"}, {"methodBody": ["METHOD_START", "{", "getLastChild (  )  ;", "while    (  ( myLastChild )     !  =    null )     {", ". Result   result    =    myLastChild . doTransition ( element )  ;", "switch    ( result )     {", "case   CONSUME    :", "return    . Result . CONSUME ;", "case   NONE    :", "myLastChild    =    getNextSubGroup (  )  ;", "break ;", "case   PROCEED _ TO _ NEXT    :", "myLastChild    =    getNextSubGroup (  )  ;", "return    ( myLastChild )     =  =    null    ?     . Result . PROCEED _ TO _ NEXT    :     . Result . CONSUME ;", "}", "}", "return    . Result . NONE ;", "}", "METHOD_END"], "methodName": ["processSubGroups"], "fileName": "com.intellij.psi.impl.source.xml.XmlContentDFAImpl"}, {"methodBody": ["METHOD_START", "{", "PsiElement   nextSibling    =    element . getNextSibling (  )  ;", "while    ( nextSibling   instanceof   PsiWhiteSpace )     {", "nextSibling    =    nextSibling . getNextSibling (  )  ;", "}", "if    ( nextSibling   instanceof   XmlToken )     {", "IElementType   tokenType    =     (  ( XmlToken )     ( nextSibling )  )  . getTokenType (  )  ;", "if    ( tokenType    =  =     ( XmlTokenType . XML _ PLUS )  )     {", "return    . Quantifier . ONE _ OR _ MORE ;", "} else", "if    ( tokenType    =  =     ( XmlTokenType . XML _ STAR )  )     {", "return    . Quantifier . ZERO _ OR _ MORE ;", "} else", "if    ( tokenType    =  =     ( XmlTokenType . XML _ QUESTION )  )     {", "return    . Quantifier . OPTIONAL ;", "}", "}", "return    . Quantifier . REQUIRED ;", "}", "METHOD_END"], "methodName": ["getQuantifierImpl"], "fileName": "com.intellij.psi.impl.source.xml.XmlContentParticleImpl"}, {"methodBody": ["METHOD_START", "{", "final   XmlDocument   document    =    PsiTreeUtil . getParentOfType ( contextTag ,    XmlDocument . class )  ;", "if    ( document    =  =    null )     {", "return   null ;", "}", "final   XmlNSDescriptor   nsDescriptor    =    document . getDefaultNSDescriptor ( childTag . getNamespace (  )  ,    true )  ;", "if    ( nsDescriptor   instanceof   XmlNSDescriptorEx )     {", "XmlElementDescriptor   descriptor    =     (  ( XmlNSDescriptorEx )     ( nsDescriptor )  )  . getElementDescriptor ( childTag . getLocalName (  )  ,    childTag . getNamespace (  )  )  ;", "return   descriptor    !  =    null    ?     . wrapInDelegating ( descriptor )     :    null ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getElementDescriptor"], "fileName": "com.intellij.psi.impl.source.xml.XmlDescriptorUtil"}, {"methodBody": ["METHOD_START", "{", "XmlDocumentImpl   xmlDocument    =    PsiTreeUtil . getParentOfType ( context ,    XmlDocumentImpl . class )  ;", "if    ( xmlDocument    =  =    null )", "return   XmlElement . EMPTY _ ARRAY ;", "return   ContainerUtil . map 2 Array ( xmlDocument . getRootTagNS (  )  . getRootElementss ( xmlDocument )  ,    XmlElement . class ,     (    descriptor )     -  >    wrapInDelegating ( descriptor )  )  ;", "}", "METHOD_END"], "methodName": ["getElementsDescriptors"], "fileName": "com.intellij.psi.impl.source.xml.XmlDescriptorUtil"}, {"methodBody": ["METHOD_START", "{", "return   descriptor   instanceof   DelegatingRelaxedHtmlElementDescriptor    ?     (  ( DelegatingRelaxedHtmlElementDescriptor )     ( descriptor )  )     :    new   DelegatingRelaxedHtmlElementDescriptor ( descriptor )  ;", "}", "METHOD_END"], "methodName": ["wrapInDelegating"], "fileName": "com.intellij.psi.impl.source.xml.XmlDescriptorUtil"}, {"methodBody": ["METHOD_START", "{", "return   new   URLReference ( this )     {", "@ Override", "@ NotNull", "public   String   getCanonicalText (  )     {", "return    . extractValue ( dtdUrlElement )  ;", "}", "@ NotNull", "@ Override", "public   TextRange   getRangeInElement (  )     {", "return   TextRange . from (  (  (  ( dtdUrlElement . getTextRange (  )  . getStartOffset (  )  )     -     ( getTextRange (  )  . getStartOffset (  )  )  )     +     1  )  ,    Math . max (  (  ( dtdUrlElement . getTextRange (  )  . getLength (  )  )     -     2  )  ,     0  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createUrlReference"], "fileName": "com.intellij.psi.impl.source.xml.XmlDoctypeImpl"}, {"methodBody": ["METHOD_START", "{", "String   text    =    element . getText (  )  ;", "if    (  (  !  ( text . startsWith (  \"  \\  \"  \"  )  )  )     &  &     (  !  ( text . startsWith (  \"  \\  '  \"  )  )  )  )     {", "if    (  . hasInjectedEscapingQuotes ( element ,    text )  )", "return    . stripInjectedEscapingQuotes ( text )  ;", "}", "return   StringUtil . stripQuotesAroundValue ( text )  ;", "}", "METHOD_END"], "methodName": ["extractValue"], "fileName": "com.intellij.psi.impl.source.xml.XmlDoctypeImpl"}, {"methodBody": ["METHOD_START", "{", "for    ( PsiElement   elem    =    getParent (  )  ;    elem    !  =    null ;    elem    =    elem . getParent (  )  )     {", "if    ( elem   instanceof   ument )     {", "return    (  ( ument )     ( elem )  )  ;", "}", "if    ( elem   instanceof   PsiFile )     {", "break ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getContainingDocument"], "fileName": "com.intellij.psi.impl.source.xml.XmlDoctypeImpl"}, {"methodBody": ["METHOD_START", "{", "PsiElement   docTypeSystem    =    findChildByRoleAsPsiElement ( role )  ;", "if    ( docTypeSystem    !  =    null )     {", "PsiElement   element    =    docTypeSystem . getNextSibling (  )  ;", "while    (  ( element   instanceof   PsiWhiteSpace )     |  |     ( element   instanceof   XmlComment )  )     {", "element    =    element . getNextSibling (  )  ;", "}", "if    (  ( element   instanceof   XmlToken )     &  &     (  (  (  ( XmlToken )     ( element )  )  . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ TOKEN )  )  )     {", "if    (  ( element . getTextLength (  )  )     !  =     0  )     {", "return    . extractValue ( element )  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getSomeId"], "fileName": "com.intellij.psi.impl.source.xml.XmlDoctypeImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( text . startsWith (  \"  \\  \\  \"  )  )     &  &     (  ( text . length (  )  )     >  =     4  )  )     {", "char   escapedChar    =    text . charAt (  1  )  ;", "PsiElement   coxt    =    InjectedLanguageManager . getInstance ( element . getContainingFile (  )  . getProject (  )  )  . getInjectionHost ( element . getContainingFile (  )  )  ;", "if    (  (  (  ( coxt    !  =    null )     &  &     ( coxt . textContains ( escapedChar )  )  )     &  &     ( coxt . getText (  )  . startsWith ( String . valueOf ( escapedChar )  )  )  )     &  &     ( text . endsWith (  (  \"  \\  \\  \"     +    escapedChar )  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasInjectedEscapingQuotes"], "fileName": "com.intellij.psi.impl.source.xml.XmlDoctypeImpl"}, {"methodBody": ["METHOD_START", "{", "return   text . substring (  2  ,     (  ( text . length (  )  )     -     2  )  )  ;", "}", "METHOD_END"], "methodName": ["stripInjectedEscapingQuotes"], "fileName": "com.intellij.psi.impl.source.xml.XmlDoctypeImpl"}, {"methodBody": ["METHOD_START", "{", "System . out . println (  \" Statistics :  \"  )  ;", "final   TObjectIntHashMap < Object >    map    =    new   TObjectIntHashMap (  )  ;", "final   PsiEleVisitor   psiRecursiveEleVisitor    =    new   XmlRecursiveEleVisitor (  )     {", "@ NonNls", "private   static   final   String   TOKENS _ KEY    =     \" Tokens \"  ;", "@ NonNls", "private   static   final   String   ELEMENTS _ KEY    =     \" Eles \"  ;", "@ Override", "public   void   visitXmlToken ( XmlToken   token )     {", "inc ( TOKENS _ KEY )  ;", "}", "@ Override", "public   void   visitEle ( PsiEle   ele )     {", "inc ( ELEMENTS _ KEY )  ;", "super . visitEle ( ele )  ;", "}", "private   void   inc ( final   String   key )     {", "map . put ( key ,     (  ( map . get ( key )  )     +     1  )  )  ;", "}", "}  ;", "accept ( psiRecursiveEleVisitor )  ;", "final   Object [  ]    keys    =    map . keys (  )  ;", "for    ( final   Object   key    :    keys )     {", "System . out . println (  (  ( key    +     \"  :     \"  )     +     ( map . get ( key )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["dumpStatistics"], "fileName": "com.intellij.psi.impl.source.xml.XmlDocumentImpl"}, {"methodBody": ["METHOD_START", "{", "return   CachedValuesManager . getCachedValue ( descriptorFile ,     (  )     -  >     {", "final      document    =    descriptorFile . getDocument (  )  ;", "if    ( document    =  =    null )", "return   CachedValueProvider . Result . create ( null ,    descriptorFile )  ;", "return   CachedValueProvider . Result .  < XmlNSDescriptor > create ( new   HtmlNSDescriptorImpl (  (  ( XmlNSDescriptor )     ( document . getMetaData (  )  )  )  )  ,    descriptorFile )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["getCachedHtmlNsDescriptor"], "fileName": "com.intellij.psi.impl.source.xml.XmlDocumentImpl"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   containingFile    =    XmlUtil . getContainingFile ( this )  ;", "if    ( containingFile    =  =    null )", "return   null ;", "final   XmlProlog   prolog    =    getProlog (  )  ;", "final   XmlDoctype   doctype    =     ( prolog    !  =    null )     ?    prolog . getDoctype (  )     :    null ;", "boolean   dtdUriFromDocTypeIsNamespace    =    false ;", "if    ( XmlUtil . HTML _ URI . equals ( namespace )  )     {", "XmlNSDescriptor   nsDescriptor    =     ( doctype    !  =    null )     ?    getNsDescriptorFormDocType ( doctype ,    containingFile ,    true )     :    null ;", "if    ( doctype    !  =    null )     {", "XmlDocumentImpl . LOG . debug (  (  (  (  \" Descriptor   from   doctype    \"     +    doctype )     +     \"    is    \"  )     +     ( nsDescriptor    !  =    null    ?    nsDescriptor . getClass (  )  . getCanonicalName (  )     :     \" NULL \"  )  )  )  ;", "}", "if    ( nsDescriptor    =  =    null )     {", "String   htmlns    =    ExternalResourceManagerEx . getInstanceEx (  )  . getDefaultHtmlDoctype ( getProject (  )  )  ;", "if    ( htmlns . isEmpty (  )  )     {", "htmlns    =    Html 5 SchemaProvider . getHtml 5 SchemaLocation (  )  ;", "}", "nsDescriptor    =    getDefaultNSDescriptor ( htmlns ,    false )  ;", "}", "if    ( nsDescriptor    !  =    null )     {", "final   XmlFile   descriptorFile    =    nsDescriptor . getDescriptorFile (  )  ;", "if    ( descriptorFile    !  =    null )     {", "return   XmlDocumentImpl . getCachedHtmlNsDescriptor ( descriptorFile )  ;", "}", "}", "return   new   HtmlNSDescriptorImpl ( nsDescriptor )  ;", "} else", "if    ( XmlUtil . XHTML _ URI . equals ( namespace )  )     {", "String   xhtmlNamespace    =    XmlUtil . getDefaultXhtmlNamespace ( getProject (  )  )  ;", "if    (  ( xhtmlNamespace    =  =    null )     |  |     ( xhtmlNamespace . isEmpty (  )  )  )     {", "xhtmlNamespace    =    Html 5 SchemaProvider . getXhtml 5 SchemaLocation (  )  ;", "}", "return   getDefaultNSDescriptor ( xhtmlNamespace ,    false )  ;", "} else", "if    (  ( namespace    !  =    null )     &  &     ( namespace    !  =     ( XmlUtil . EMPTY _ URI )  )  )     {", "if    (  ( doctype    =  =    null )     |  |     (  !  ( namespace . equals ( XmlUtil . getDtdUri ( doctype )  )  )  )  )     {", "boolean   documentIsSchemaThatDefinesNs    =    namespace . equals ( XmlUtil . getTargetSchemaNsFromTag ( getRootTag (  )  )  )  ;", "final   XmlFile   xmlFile    =     ( documentIsSchemaThatDefinesNs )     ?    containingFile    :    XmlUtil . findNamespace ( containingFile ,    namespace )  ;", "if    ( xmlFile    !  =    null )     {", "final   xml . XmlDocument   document    =    xmlFile . getDocument (  )  ;", "if    ( document    !  =    null )     {", "return    (  ( XmlNSDescriptor )     ( document . getMetaData (  )  )  )  ;", "}", "}", "} else    {", "dtdUriFromDocTypeIsNamespace    =    true ;", "}", "}", "if    ( strict    &  &     (  ! dtdUriFromDocTypeIsNamespace )  )", "return   null ;", "if    ( doctype    !  =    null )     {", "XmlNSDescriptor   descr    =    getNsDescriptorFormDocType ( doctype ,    containingFile ,    false )  ;", "if    ( descr    !  =    null )     {", "return   XmlExtension . getExtension ( containingFile )  . getDescriptorFromDoctype ( containingFile ,    descr )  ;", "}", "}", "if    ( strict )", "return   null ;", "if    ( namespace    =  =     ( XmlUtil . EMPTY _ URI )  )     {", "final   XmlFile   xmlFile    =    XmlUtil . findNamespace ( containingFile ,    namespace )  ;", "if    ( xmlFile    !  =    null )     {", "return    (  ( XmlNSDescriptor )     ( xmlFile . getDocument (  )  . getMetaData (  )  )  )  ;", "}", "}", "try    {", "final   PsiFile   fileFromText    =    PsiFileFactory . getInstance ( getProject (  )  )  . createFileFromText (  (  ( containingFile . getName (  )  )     +     \"  . dtd \"  )  ,    DTDLanguage . INSTANCE ,    XmlUtil . generateDocumentDTD ( this ,    false )  ,    false ,    false )  ;", "if    ( fileFromText   instanceof   XmlFile )     {", "fileFromText . putUserData ( XmlDocumentImpl . AUTO _ GENERATED ,    Boolean . TRUE )  ;", "return    (  ( XmlNSDescriptor )     (  (  ( XmlFile )     ( fileFromText )  )  . getDocument (  )  . getMetaData (  )  )  )  ;", "}", "}    catch    ( ProcessCanceledException   ex )     {", "throw   ex ;", "}    catch    ( RuntimeException   ignored )     {", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDefaultNSDescriptorInner"], "fileName": "com.intellij.psi.impl.source.xml.XmlDocumentImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( file    =  =    null )     {", "return    \" NULL \"  ;", "}", "final   VirtualFile   vFile    =    file . getVirtualFile (  )  ;", "return   vFile    !  =    null    ?    vFile . getPath (  )     :     \" NULL _ VFILE \"  ;", "}", "METHOD_END"], "methodName": ["getFilePathForLogging"], "fileName": "com.intellij.psi.impl.source.xml.XmlDocumentImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( metaOwner    =  =    null )", "return   null ;", "XmlNSDescriptor   descriptor    =     (  ( XmlNSDescriptor )     ( metaOwner . getMetaData (  )  )  )  ;", "if    ( descriptor    =  =    null )", "return   null ;", "if    ( nonEmpty    &  &     (  ( descriptor . getRootElesDescriptors ( this )  . length )     =  =     0  )  )     {", "return   null ;", "}", "return   descriptor ;", "}", "METHOD_END"], "methodName": ["getNSDescriptorFromMetaData"], "fileName": "com.intellij.psi.impl.source.xml.XmlDocumentImpl"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   descriptor    =    getNSDescriptorFromMetaData ( doctype . getMarkupDecl (  )  ,    true )  ;", "final   String   filePath    =     . getFilePathForLogging ( containingFile )  ;", "final   String   dtdUri    =    XmlUtil . getDtdUri ( doctype )  ;", ". LOG . debug (  (  (  (  (  (  \" DTD   url   for   doctype    \"     +     ( doctype . getText (  )  )  )     +     \"    in   file    \"  )     +    filePath )     +     \"    is    \"  )     +    dtdUri )  )  ;", "if    (  ( dtdUri    !  =    null )     &  &     (  !  ( dtdUri . isEmpty (  )  )  )  )     {", "XmlFile   xmlFile    =    XmlUtil . findNamespace ( containingFile ,    dtdUri )  ;", "if    ( xmlFile    =  =    null )     {", "xmlFile    =    XmlNamespaceIndex . guessDtd ( dtdUri ,    containingFile )  ;", "}", "final   String   schemaFilePath    =     . getFilePathForLogging ( xmlFile )  ;", ". LOG . debug (  (  (  (  \" Schema   file   for    \"     +    filePath )     +     \"    is    \"  )     +    schemaFilePath )  )  ;", "XmlNSDescriptor   descriptorFromDtd    =    getNSDescriptorFromMetaData (  ( xmlFile    =  =    null    ?    null    :    xmlFile . getDocument (  )  )  ,    forHtml )  ;", ". LOG . debug (  (  (  (  \" Descriptor   from   meta   data   for   schema   file    \"     +    schemaFilePath )     +     \"    is    \"  )     +     ( descriptorFromDtd    !  =    null    ?    descriptorFromDtd . getClass (  )  . getCanonicalName (  )     :     \" NULL \"  )  )  )  ;", "if    (  ( descriptor    !  =    null )     &  &     ( descriptorFromDtd    !  =    null )  )     {", "descriptor    =    new   XmlNSDescriptorSequence ( new   XmlNSDescriptor [  ]  {    descriptor ,    descriptorFromDtd    }  )  ;", "} else", "if    ( descriptorFromDtd    !  =    null )     {", "descriptor    =    descriptorFromDtd ;", "}", "}", "return   descriptor ;", "}", "METHOD_END"], "methodName": ["getNsDescriptorFormDocType"], "fileName": "com.intellij.psi.impl.source.xml.XmlDocumentImpl"}, {"methodBody": ["METHOD_START", "{", "return    ( file . getUserData ( XmlDocumentImpl . AUTO _ GENERATED )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isAutoGeneratedSchema"], "fileName": "com.intellij.psi.impl.source.xml.XmlDocumentImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( defaultNSDescriptorInner    =  =    null )     {", "return   false ;", "}", "File   descriptorFile    =    defaultNSDescriptorInner . getDescriptorFile (  )  ;", "if    ( descriptorFile    =  =    null )     {", "return   false ;", "}", "@ NonNls", "String   otherName    =     ( Util . getContainingFile ( this )  . getName (  )  )     +     \"  . dtd \"  ;", "return   descriptorFile . getName (  )  . equals ( otherName )  ;", "}", "METHOD_END"], "methodName": ["isGeneratedFromDtd"], "fileName": "com.intellij.psi.impl.source.xml.XmlDocumentImpl"}, {"methodBody": ["METHOD_START", "{", "copy . myDefaultDescriptorsCacheNotStrict    =    ContainerUtil . newConcurrentMap (  )  ;", "copy . myDefaultDescriptorsCacheStrict    =    ContainerUtil . newConcurrentMap (  )  ;", "for    ( Map . Entry < String ,    CachedValue < XmlNSDescriptor >  >    e    :    cacheStrict . entrySet (  )  )     {", "if    ( e . getValue (  )  . hasUpToDateValue (  )  )     {", "final   XmlNSDescriptor   nsDescriptor    =    e . getValue (  )  . getValue (  )  ;", "if    (  !  ( isGeneratedFromDtd ( nsDescriptor )  )  )", "copy . myDefaultDescriptorsCacheStrict . put ( e . getKey (  )  ,    e . getValue (  )  )  ;", "}", "}", "for    ( Map . Entry < String ,    CachedValue < XmlNSDescriptor >  >    e    :    cacheNotStrict . entrySet (  )  )     {", "if    ( e . getValue (  )  . hasUpToDateValue (  )  )     {", "final   XmlNSDescriptor   nsDescriptor    =    e . getValue (  )  . getValue (  )  ;", "if    (  !  ( isGeneratedFromDtd ( nsDescriptor )  )  )", "copy . myDefaultDescriptorsCacheNotStrict . put ( e . getKey (  )  ,    e . getValue (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["updateSelfDependentDtdDescriptors"], "fileName": "com.intellij.psi.impl.source.xml.XmlDocumentImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( xmlElementDecl . isWritable (  )  )     &  &     ( XmlElementChangeUtil . isInProjectContent ( xmlElementDecl . getProject (  )  ,    xmlElementDecl . getContainingFile (  )  . getVirtualFile (  )  )  )  )     {", "if    ( nameElement    !  =    null )     {", "nameElement . replace ( SourceTreeToPsiMap . treeElementToPsi ( Factory . createSingleLeafElement ( XmlTokenType . XML _ NAME ,    name ,    null ,    xmlElementDecl . getManager (  )  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doNameReplacement"], "fileName": "com.intellij.psi.impl.source.xml.XmlElementChangeUtil"}, {"methodBody": ["METHOD_START", "{", "return    ( vfile    =  =    null )     |  |     (  ( ProjectRootManager . getInstance ( project )  . getFileIndex (  )  . getModuleForFile ( vfile )  )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["isInProjectContent"], "fileName": "com.intellij.psi.impl.source.xml.XmlElementChangeUtil"}, {"methodBody": ["METHOD_START", "{", "final   XmlElement [  ]    result    =    new   XmlElement [  1  ]  ;", "result [  0  ]     =    null ;", "processElements ( new   PsiElementProcessor (  )     {", "@ Override", "public   boolean   execute (  @ NotNull", "PsiElement   element )     {", "if    (  ( element   instanceof   TreeElement )     &  &     (  (  (  ( ASTNode )     ( element )  )  . getElementType (  )  )     =  =    type )  )     {", "result [  0  ]     =     (  ( XmlElement )     ( element )  )  ;", "return   false ;", "}", "return   true ;", "}", "}  ,    this )  ;", "return   result [  0  ]  ;", "}", "METHOD_END"], "methodName": ["findElementByTokenType"], "fileName": "com.intellij.psi.impl.source.xml.XmlElementImpl"}, {"methodBody": ["METHOD_START", "{", "return   super . getParent (  )  ;", "}", "METHOD_END"], "methodName": ["getAstParent"], "fileName": "com.intellij.psi.impl.source.xml.XmlElementImpl"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   node    =    compositeElement . findChildByType ( xmlEntityDeclStart )  ;", "if    ( node    =  =    null )", "return   null ;", "ASTNode   name    =    node . getTreeNext (  )  ;", "if    (  ( name    !  =    null )     &  &     (  ( name . getElementType (  )  )     =  =     ( TokenType . WHITE _ SPACE )  )  )     {", "name    =    name . getTreeNext (  )  ;", "}", "if    (  ( name    !  =    null )     &  &     (  ( name . getElementType (  )  )     =  =     ( Type . XML _ ENTITY _ REF )  )  )     {", "final   StringBuilder   builder    =    new   StringBuilder (  )  ;", "(  (  )     ( name . getPsi (  )  )  )  . processElements ( new   PsiElementProcessor (  )     {", "@ Override", "public   boolean   execute (  @ NotNull", "final   PsiElement   element )     {", "builder . append ( element . getText (  )  )  ;", "return   true ;", "}", "}  ,    name . getPsi (  )  )  ;", "if    (  ( builder . length (  )  )     >     0  )", "return   builder . toString (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getNameFromEntityRef"], "fileName": "com.intellij.psi.impl.source.xml.XmlElementImpl"}, {"methodBody": ["METHOD_START", "{", "return   XmlPsiUtil . processXmlElementChildren ( this ,    processor ,    false )  ;", "}", "METHOD_END"], "methodName": ["processChildren"], "fileName": "com.intellij.psi.impl.source.xml.XmlElementImpl"}, {"methodBody": ["METHOD_START", "{", "synchronized ( XmlEntityCache . LOCK )     {", "final   Map < String ,    CachedValue < XmlEntityDecl >  >    cachingMap    =    XmlEntityCache . getCachingMap ( file )  ;", "final   String   name    =    decl . getName (  )  ;", "if    ( cachingMap . containsKey ( name )  )", "return ;", "final   SmartPsiElementPointer   declPointer    =    SmartPointerManager . getInstance ( file . getProject (  )  )  . createSmartPsiElementPointer ( decl )  ;", "cachingMap . put ( name ,    CachedValuesManager . getManager ( file . getProject (  )  )  . createCachedValue (  (  )     -  >     {", "PsiElement   declElement    =    declPointer . getElement (  )  ;", "if    (  (  ( declElement   instanceof   XmlEntityDecl )     &  &     ( declElement . isValid (  )  )  )     &  &     ( name . equals (  (  ( XmlEntityDecl )     ( declElement )  )  . getName (  )  )  )  )", "return   new   CachedValueProvider . Result <  >  (  (  ( XmlEntityDecl )     ( declElement )  )  ,    declElement )  ;", "cachingMap . put ( name ,    null )  ;", "return   new   CachedValueProvider . Result <  >  ( null ,    ModificationTracker . NEVER _ CHANGED )  ;", "}  ,    false )  )  ;", "}", "}", "METHOD_END"], "methodName": ["cacheParticularEntity"], "fileName": "com.intellij.psi.impl.source.xml.XmlEntityCache"}, {"methodBody": ["METHOD_START", "{", "synchronized ( XmlEntityCache . LOCK )     {", "final   Map < String ,    CachedValue < XmlEntityDecl >  >    cachingMap    =    XmlEntityCache . getCachingMap ( file )  ;", "for    ( Map . Entry < String ,    CachedValue < XmlEntityDecl >  >    entry    :    XmlEntityCache . getCachingMap ( context )  . entrySet (  )  )     {", "cachingMap . put ( entry . getKey (  )  ,    entry . getValue (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["copyEntityCaches"], "fileName": "com.intellij.psi.impl.source.xml.XmlEntityCache"}, {"methodBody": ["METHOD_START", "{", "CachedValue < XmlEntityDecl >    cachedValue ;", "synchronized (  . LOCK )     {", "final   Map < String ,    CachedValue < XmlEntityDecl >  >    cachingMap    =     . getCachingMap ( file )  ;", "cachedValue    =    cachingMap . get ( name )  ;", "}", "return   cachedValue    !  =    null    ?    cachedValue . getValue (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getCachedEntity"], "fileName": "com.intellij.psi.impl.source.xml.XmlEntityCache"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    CachedValue < XmlEntityDecl >  >    map    =    targetElement . getUserData ( XmlEntityCache . XML _ ENTITY _ DECL _ MAP )  ;", "if    ( map    =  =    null )     {", "map    =    new   HashMap (  )  ;", "targetElement . putUserData ( XmlEntityCache . XML _ ENTITY _ DECL _ MAP ,    map )  ;", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["getCachingMap"], "fileName": "com.intellij.psi.impl.source.xml.XmlEntityCache"}, {"methodBody": ["METHOD_START", "{", "final   XmlAttributeValue   attributeValue    =    getValueElement (  )  ;", "if    ( isInternalReference (  )  )", "return   attributeValue ;", "if    ( attributeValue    !  =    null )     {", "final   String   value    =    attributeValue . getValue (  )  ;", "if    ( value    !  =    null )     {", "XmlFile   xmlFile    =    XmlUtil . findNamespaceByLocation ( baseFile ,    value )  ;", "if    ( xmlFile    !  =    null )     {", "return   xmlFile ;", "}", "final   int   i    =    XmlUtil . getPrefixLength ( value )  ;", "if    ( i    >     0  )     {", "return   XmlUtil . findNamespaceByLocation ( baseFile ,    value . substring ( i )  )  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getValueElement"], "fileName": "com.intellij.psi.impl.source.xml.XmlEntityDeclImpl"}, {"methodBody": ["METHOD_START", "{", "PsiElement   e    =    generated ;", "while    ( e    !  =    null )     {", "e . putUserData ( lement . DEPENDING _ ELEMENT ,    dependsOnElement )  ;", "e    =    e . getNextSibling (  )  ;", "}", "return   generated ;", "}", "METHOD_END"], "methodName": ["setDependsOnElement"], "fileName": "com.intellij.psi.impl.source.xml.XmlEntityDeclImpl"}, {"methodBody": ["METHOD_START", "{", "PsiElement   e    =    element ;", "while    ( e    !  =    null )     {", "e . putUserData ( lement . INCLUDING _ ELEMENT ,     (  ( lement )     ( valueElement )  )  )  ;", "e    =    e . getNextSibling (  )  ;", "}", "return   element ;", "}", "METHOD_END"], "methodName": ["setOriginalElement"], "fileName": "com.intellij.psi.impl.source.xml.XmlEntityDeclImpl"}, {"methodBody": ["METHOD_START", "{", "return   RecursionManager . doPreventingRecursion ( targetElement ,    true ,    new   com . intellij . openapi . util . Computable < CachedValueProvider . Result < XmlEntityDecl >  >  (  )     {", "@ Override", "public   CachedValueProvider . Result < XmlEntityDecl >    compute (  )     {", "final   List < PsiElement >    deps    =    new   ArrayList <  >  (  )  ;", "final   XmlEntityDecl [  ]    result    =     {    null    }  ;", "PsiElementProcessor   processor    =    new   PsiElementProcessor (  )     {", "@ Override", "public   boolean   execute (  @ NotNull", "PsiElement   element )     {", "if    ( element   instanceof   XmlDoctype )     {", "XmlDoctype   xmlDoctype    =     (  ( XmlDoctype )     ( element )  )  ;", "final   String   dtdUri    =    getDtdForEntity ( xmlDoctype )  ;", "if    ( dtdUri    !  =    null )     {", "XmlFile   file    =    XmlUtil . getContainingFile ( element )  ;", "if    ( file    =  =    null )", "return   true ;", "final   XmlFile   xmlFile    =    XmlUtil . findNamespace ( file ,    dtdUri )  ;", "if    ( xmlFile    !  =    null )     {", "if    ( xmlFile    !  =    targetElement )     {", "deps . add ( xmlFile )  ;", "if    (  !  ( XmlUtil . processXmlElements ( xmlFile ,    this ,    true )  )  )", "return   false ;", "}", "}", "}", "final   XmlMarkupDecl   markupDecl    =    xmlDoctype . getMarkupDecl (  )  ;", "if    ( markupDecl    !  =    null )     {", "if    (  !  ( XmlUtil . processXmlElements ( markupDecl ,    this ,    true )  )  )", "return   false ;", "}", "} else", "if    ( element   instanceof   XmlEntityDecl )     {", "XmlEntityDecl   entityDecl    =     (  ( XmlEntityDecl )     ( element )  )  ;", "final   String   declName    =    entityDecl . getName (  )  ;", "if    ( com . intellij . openapi . util . text . StringUtil . equals ( declName ,    entityName )  )     {", "result [  0  ]     =    entityDecl ;", "return   false ;", "}", "}", "return   true ;", "}", "}  ;", "FileViewProvider   provider    =    targetElement . getContainingFile (  )  . getViewProvider (  )  ;", "deps . add ( provider . getPsi ( provider . getBaseLanguage (  )  )  )  ;", "boolean   notfound    =    PsiTreeUtil . processElements ( targetElement ,    processor )  ;", "if    ( notfound )     {", "if    (  (  ( contextFile    !  =    targetElement )     &  &     ( contextFile    !  =    null )  )     &  &     ( contextFile . isValid (  )  )  )     {", "notfound    =    PsiTreeUtil . processElements ( contextFile ,    processor )  ;", "}", "}", "if    (  (  ( notfound    &  &     ( targetElement   instanceof   XmlFile )  )     &  &     (  ( deps . size (  )  )     =  =     1  )  )     &  &     (  (  (  ( XmlFile )     ( targetElement )  )  . getFileType (  )  )     !  =    DTDFileType . INSTANCE )  )     {", "XmlDocument   document    =     (  ( XmlFile )     ( targetElement )  )  . getDocument (  )  ;", "final   XmlTag   rootTag    =     ( document    !  =    null )     ?    document . getRootTag (  )     :    null ;", "XmlFile   descriptorFile    =    null ;", "if    ( HtmlUtil . isHtml 5 Document ( document )  )     {", "descriptorFile    =    XmlUtil . findXmlFile (  (  ( XmlFile )     ( targetElement )  )  ,    Html 5 SchemaProvider . getCharsDtdLocation (  )  )  ;", "} else", "if    (  ( rootTag    !  =    null )     &  &     (  ( document . getUserData (  . DISABLE _ ENTITY _ EXPAND )  )     =  =    null )  )     {", "final   com . intellij . xml . XmlElementDescriptor   descriptor    =    rootTag . getDescriptor (  )  ;", "if    (  ( descriptor    !  =    null )     &  &     (  !  ( descriptor   instanceof   com . intellij . xml . impl . schema . AnyXmlElementDescriptor )  )  )     {", "PsiElement   element    =    descriptor . getDeclaration (  )  ;", "final   PsiFile   containingFile    =     ( element    !  =    null )     ?    element . getContainingFile (  )     :    null ;", "descriptorFile    =     ( containingFile   instanceof   XmlFile )     ?     (  ( XmlFile )     ( containingFile )  )     :    null ;", "}", "}", "if    (  ( descriptorFile    !  =    null )     &  &     (  !  ( descriptorFile . getName (  )  . equals (  (  (  (  ( XmlFile )     ( targetElement )  )  . getName (  )  )     +     \"  . dtd \"  )  )  )  )  )     {", "deps . add ( descriptorFile )  ;", "XmlUtil . processXmlElements ( descriptorFile ,    processor ,    true )  ;", "}", "}", "return   new   CachedValueProvider . Result <  >  ( result [  0  ]  ,    ArrayUtil . toObjectArray ( deps )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["doResolveEntity"], "fileName": "com.intellij.psi.impl.source.xml.XmlEntityRefImpl"}, {"methodBody": ["METHOD_START", "{", "return   HtmlUtil . isHtml 5 Doctype ( xmlDoctype )     ?    Html 5 SchemaProvider . getCharsDtdLocation (  )     :    XmlUtil . getDtdUri ( xmlDoctype )  ;", "}", "METHOD_END"], "methodName": ["getDtdForEntity"], "fileName": "com.intellij.psi.impl.source.xml.XmlEntityRefImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( targetFile   instanceof   XmlFile )     {", "XmlDocument   document    =     (  ( XmlFile )     ( targetFile )  )  . getDocument (  )  ;", "if    (  ( document    !  =    null )     &  &     (  ( document . getUserData (  . DISABLE _ ENTITY _ EXPAND )  )     !  =    null )  )", "return   null ;", "}", "final   String   entityName    =    text . substring (  1  ,     (  ( text . length (  )  )     -     1  )  )  ;", "final   PsiElement   targetElement    =     ( targetFile    !  =    null )     ?    targetFile    :    element ;", "CachedValue < XmlEntityDecl >    value ;", "synchronized ( XmlEntityCache . LOCK )     {", "Map < String ,    CachedValue < XmlEntityDecl >  >    map    =    XmlEntityCache . getCachingMap ( targetElement )  ;", "value    =    map . get ( entityName )  ;", "final   PsiFile   containingFile    =    element . getContainingFile (  )  ;", "if    ( value    =  =    null )     {", "final   PsiManager   manager    =    element . getManager (  )  ;", "if    ( manager    =  =    null )     {", "return   doResolveEntity ( targetElement ,    entityName ,    containingFile )  . getValue (  )  ;", "}", "value    =    CachedValuesManager . getManager ( manager . getProject (  )  )  . createCachedValue (  (  )     -  >    doResolveEntity ( targetElement ,    entityName ,    containingFile )  )  ;", "map . put ( entityName ,    value )  ;", "}", "}", "return   value . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["resolveEntity"], "fileName": "com.intellij.psi.impl.source.xml.XmlEntityRefImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( b )", "doc . putUserData (  . DISABLE _ ENTITY _ EXPAND ,    Boolean . TRUE )  ;", "else", "doc . putUserData (  . DISABLE _ ENTITY _ EXPAND ,    null )  ;", "}", "METHOD_END"], "methodName": ["setNoEntityExpandOutOfDocument"], "fileName": "com.intellij.psi.impl.source.xml.XmlEntityRefImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( getLanguage (  )  )     =  =     ( XHTMLLanguage . INSTANCE )  )     |  |     (  ( getLanguage (  )  )     =  =     ( HTMLLanguage . INSTANCE )  )  ;", "}", "METHOD_END"], "methodName": ["isWebFileType"], "fileName": "com.intellij.psi.impl.source.xml.XmlFileImpl"}, {"methodBody": ["METHOD_START", "{", "return    \" XmlFile :  \"     +     ( getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.psi.impl.source.xml.XmlFileImpl"}, {"methodBody": ["METHOD_START", "{", "final   PomModel   model    =    PomManager . getModel ( getProject (  )  )  ;", "if    (  ( anchor    !  =    null )     &  &     (  ( child . getElementType (  )  )     =  =     ( XmlElementType . XML _ TEXT )  )  )     {", "XmlText   psi    =    null ;", "if    (  ( anchor . getPsi (  )  )    instanceof   XmlText )     {", "psi    =     (  ( XmlText )     ( anchor . getPsi (  )  )  )  ;", "} else    {", "final   ASTNode   other    =     ( before )     ?    anchor . getTreePrev (  )     :    anchor . getTreeNext (  )  ;", "if    (  ( other    !  =    null )     &  &     (  ( other . getPsi (  )  )    instanceof   XmlText )  )     {", "before    =     ! before ;", "psi    =     (  ( XmlText )     ( other . getPsi (  )  )  )  ;", "}", "}", "if    ( psi    !  =    null )     {", "if    ( before )     {", "psi . insertText (  (  ( XmlText )     ( child . getPsi (  )  )  )  . getValue (  )  ,     0  )  ;", "} else    {", "psi . insertText (  (  ( XmlText )     ( child . getPsi (  )  )  )  . getValue (  )  ,    psi . getValue (  )  . length (  )  )  ;", "}", "return    (  ( TreeElement )     ( psi . getNode (  )  )  )  ;", "}", "}", ". LOG . assertTrue (  (  (  ( child . getPsi (  )  )    instanceof   XmlAttribute )     |  |     (  ( child . getPsi (  )  )    instanceof   XmlTagChild )  )  )  ;", "final    . InsertTransaction   transaction ;", "if    (  ( child . getElementType (  )  )     =  =     ( XmlElementType . XML _ ATTRIBUTE )  )     {", "transaction    =    new    . InsertAttributeTransaction ( child ,    anchor ,    before ,    model )  ;", "} else", "if    ( anchor    =  =    null )     {", "transaction    =    getBodyInsertTransaction ( child )  ;", "} else    {", "transaction    =    new    . GenericInsertTransaction ( child ,    anchor ,    before )  ;", "}", "model . runTransaction ( transaction )  ;", "return   transaction . getFirstInserted (  )  ;", "}", "METHOD_END"], "methodName": ["addInternal"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "attributesValueMap . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["cacheOneAttributeValue"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "final   List < XmlAttribute >    result    =    new   ArrayList <  >  (  1  0  )  ;", "processChildren ( new   PsiElementProcessor (  )     {", "@ Override", "public   boolean   execute (  @ NotNull", "PsiElement   element )     {", "if    ( element   instanceof   XmlAttribute )     {", "XmlAttribute   attribute    =     (  ( XmlAttribute )     ( element )  )  ;", "result . add ( attribute )  ;", "if    (  (  !  ( myHasNamespaceDeclarations )  )     &  &     ( attribute . isNamespaceDeclaration (  )  )  )", "myHasNamespaceDeclarations    =    true ;", "} else", "if    (  ( element   instanceof   xml . XmlToken )     &  &     (  (  (  ( xml . XmlToken )     ( element )  )  . getTokenType (  )  )     =  =     ( xml . XmlTokenType . XML _ TAG _ END )  )  )     {", "return   false ;", "}", "return   true ;", "}", "}  )  ;", "if    ( result . isEmpty (  )  )     {", "return   XmlAttribute . EMPTY _ ARRAY ;", "} else    {", "return   ContainerUtil . toArray ( result ,    new   XmlAttribute [ result . size (  )  ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["calculateAttributes"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( child . getStartOffsetInParent (  )  )     <  =    offsetInTag )     &  &     ( offsetInTag    <  =     (  ( child . getStartOffsetInParent (  )  )     +     ( child . getTextLength (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["childContainsOffset"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "for    ( XmlElementDescriptorProvider   provider    :    Extensions . getExtensions ( XmlElementDescriptorProvider . EP _ NAME )  )     {", "XmlElementDescriptor   elementDescriptor    =    provider . getDescriptor ( this )  ;", "if    ( elementDescriptor    !  =    null )     {", "return   elementDescriptor ;", "}", "}", "final   String   namespace    =    getNamespace (  )  ;", "if    ( XmlUtil . EMPTY _ URI . equals ( namespace )  )     {", "final   XmlTag   parent    =    getParentTag (  )  ;", "if    ( parent    !  =    null )     {", "final   XmlElementDescriptor   descriptor    =    parent . getDescriptor (  )  ;", "if    ( descriptor    !  =    null )     {", "XmlElementDescriptor   fromParent    =    descriptor . getElementDescriptor ( this ,    parent )  ;", "if    (  ( fromParent    !  =    null )     &  &     (  !  ( fromParent   instanceof   AnyXmlElementDescriptor )  )  )     {", "return   fromParent ;", "}", "}", "}", "}", "XmlElementDescriptor   elementDescriptor    =    null ;", "final   XmlNSDescriptor   nsDescriptor    =    getNSDescriptor ( namespace ,    false )  ;", "if    (  . LOG . isDebugEnabled (  )  )     {", ". LOG . debug (  (  (  (  \" Descriptor   for   namespace    \"     +    namespace )     +     \"    is    \"  )     +     ( nsDescriptor    !  =    null    ?    nsDescriptor . getClass (  )  . getCanonicalName (  )     :     \" NULL \"  )  )  )  ;", "}", "if    ( nsDescriptor    !  =    null )     {", "if    (  (  !  ( DumbService . getInstance ( getProject (  )  )  . isDumb (  )  )  )     |  |     ( DumbService . isDumbAware ( nsDescriptor )  )  )     {", "elementDescriptor    =    nsDescriptor . getElementDescriptor ( this )  ;", "}", "}", "if    ( elementDescriptor    =  =    null )     {", "return   XmlUtil . findXmlDescriptorByType ( this )  ;", "}", "return   elementDescriptor ;", "}", "METHOD_END"], "methodName": ["computeElementDescriptor"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "BidirectionalMap < String ,    String >    map    =    null ;", "boolean   hasNamespaceDeclarations    =    hasNamespaceDeclarations (  )  ;", "if    ( hasNamespaceDeclarations )     {", "map    =    new   BidirectionalMap (  )  ;", "final   Attribute [  ]    attributes    =    getAttributes (  )  ;", "for    ( final   Attribute   attribute    :    attributes )     {", "if    ( attribute . isNamespaceDeclaration (  )  )     {", "final   String   name    =    attribute . getName (  )  ;", "int   splitIndex    =    name . indexOf (  '  :  '  )  ;", "final   String   value    =    getRealNs ( attribute . getValue (  )  )  ;", "if    ( value    !  =    null )     {", "if    ( splitIndex    <     0  )     {", "map . put (  \"  \"  ,    value )  ;", "} else    {", "map . put ( Util . findLocalNameByQualifiedName ( name )  ,    value )  ;", "}", "}", "}", "}", "}", "if    ( parent   instanceof   Document )     {", "final   Extension   extension    =    Extension . getExtensionByElement ( parent )  ;", "if    ( extension    !  =    null )     {", "final   String [  ]  [  ]    namespacesFromDocument    =    extension . getNamespacesFromDocument (  (  ( Document )     ( parent )  )  ,    hasNamespaceDeclarations )  ;", "if    ( namespacesFromDocument    !  =    null )     {", "if    ( map    =  =    null )     {", "map    =    new   BidirectionalMap (  )  ;", "}", "for    ( final   String [  ]    prefix 2 ns    :    namespacesFromDocument )     {", "map . put ( prefix 2 ns [  0  ]  ,    getRealNs ( prefix 2 ns [  1  ]  )  )  ;", "}", "}", "}", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["computeNamespaceMap"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    CachedValue < XmlNSDescriptor >  >    map    =    null ;", "final   String   noNamespaceDeclaration    =    getAttributeValue (  \" noNamespaceSchemaLocation \"  ,    XmlUtil . XML _ SCHEMA _ INSTANCE _ URI )  ;", "final   String   schemaLocationDeclaration    =    getAttributeValue (  \" schemaLocation \"  ,    XmlUtil . XML _ SCHEMA _ INSTANCE _ URI )  ;", "if    ( noNamespaceDeclaration    !  =    null )     {", "map    =    initializeSchema ( XmlUtil . EMPTY _ URI ,    null ,    Collections . singleton ( noNamespaceDeclaration )  ,    null ,    myHasNamespaceDeclarations )  ;", "}", "if    ( schemaLocationDeclaration    !  =    null )     {", "final   StringTokenizer   tokenizer    =    new   StringTokenizer ( schemaLocationDeclaration )  ;", "while    ( tokenizer . hasMoreTokens (  )  )     {", "final   String   uri    =    tokenizer . nextToken (  )  ;", "if    ( tokenizer . hasMoreTokens (  )  )     {", "map    =    initializeSchema ( uri ,     . getNSVersion ( uri ,    this )  ,    Collections . singleton ( tokenizer . nextToken (  )  )  ,    map ,    myHasNamespaceDeclarations )  ;", "}", "}", "}", "if    ( hasNamespaceDeclarations (  )  )     {", "for    ( final   XmlAttribute   attribute    :    getAttributes (  )  )     {", "if    ( attribute . isNamespaceDeclaration (  )  )     {", "String   ns    =    attribute . getValue (  )  ;", "if    ( ns    =  =    null )", "ns    =    XmlUtil . EMPTY _ URI ;", "ns    =    getRealNs ( ns )  ;", "if    (  ( map    =  =    null )     |  |     (  !  ( map . containsKey ( ns )  )  )  )     {", "Set < String >    locations    =    getNsLocations ( ns )  ;", "map    =    initializeSchema ( ns ,     . getNSVersion ( ns ,    this )  ,    locations ,    map ,    true )  ;", "}", "}", "}", "}", "return   map    =  =    null    ?    Collections . emptyMap (  )     :    map ;", "}", "METHOD_END"], "methodName": ["computeNsDescriptorMap"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "return   new   SchemaPrefixReference ( this ,    TextRange . from (  (  ( startTagName . getStartOffset (  )  )     -     ( getStartOffset (  )  )  )  ,    prefix . length (  )  )  ,    prefix ,    tagRef )  ;", "}", "METHOD_END"], "methodName": ["createPrefixReference"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "ASTNode   endTagStart    =    XmlChildRole . CLOSING _ TAG _ START _ FINDER . findChild ( this )  ;", "if    ( endTagStart    =  =    null )     {", "final      tagFromText    =     (  (  )     ( XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  (  (  (  (  \"  <  \"     +     ( getName (  )  )  )     +     \"  >  <  /  \"  )     +     ( getName (  )  )  )     +     \"  >  \"  )  )  )  )  ;", "final   ASTNode   startTagStart    =    XmlChildRole . START _ TAG _ END _ FINDER . findChild ( tagFromText )  ;", "endTagStart    =    XmlChildRole . CLOSING _ TAG _ START _ FINDER . findChild ( tagFromText )  ;", "final   LeafElement   emptyTagEnd    =     (  ( LeafElement )     ( XmlChildRole . EMPTY _ TAG _ END _ FINDER . findChild ( this )  )  )  ;", "if    ( emptyTagEnd    !  =    null )", "removeChild ( emptyTagEnd )  ;", "addChildren ( startTagStart ,    null ,    null )  ;", "}", "return   endTagStart ;", "}", "METHOD_END"], "methodName": ["expandTag"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "Project   project    =    getProject (  )  ;", "ExternalReManagerEx   manager    =    ExternalReManagerEx . getInstanceEx (  )  ;", "return    (  )     -  >    manager . getModificationCount ( project )  ;", "}", "METHOD_END"], "methodName": ["externalResourceModificationTracker"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "processElements ( new   PsiElementProcessor (  )     {", "@ Override", "public   boolean   execute (  @ NotNull", "PsiElement   element )     {", "if    ( element   instanceof    )     {", "PsiUtilCore . ensureValid ( element )  ;", "result . add (  (  (  )     ( element )  )  )  ;", "}", "return   true ;", "}", "}  ,    this )  ;", "}", "METHOD_END"], "methodName": ["fillSubTags"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlTagImpl . BodyInsertTransaction ( child )  ;", "}", "METHOD_END"], "methodName": ["getBodyInsertTransaction"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   descriptor    =    getImplicitNamespaceDescriptor ( fileLocation )  ;", "if    ( descriptor    !  =    null )     {", "return   descriptor ;", "}", "if    ( currentFile    =  =    null )     {", "final   XmlDocument   document    =    XmlUtil . getContainingFile ( this )  . getDocument (  )  ;", "if    ( document    !  =    null )     {", "final   String   uri    =    XmlUtil . getDtdUri ( document )  ;", "if    ( uri    !  =    null )     {", "final   XmlFile   containingFile    =    XmlUtil . getContainingFile ( document )  ;", "final   XmlFile   xmlFile    =    XmlUtil . findNamespace ( containingFile ,    uri )  ;", "descriptor    =     ( xmlFile    =  =    null )     ?    null    :     (  ( XmlNSDescriptor )     ( xmlFile . getDocument (  )  . getMetaData (  )  )  )  ;", "}", "if    ( descriptor   instanceof   XmlNSDescriptorImpl )     {", "final   XmlElementDescriptor   elementDescriptor    =    descriptor . getElementDescriptor ( this )  ;", "if    ( elementDescriptor    !  =    null )     {", "final   XmlAttributeDescriptor   attributeDescriptor    =    elementDescriptor . getAttributeDescriptor (  \" xmlns \"  ,    this )  ;", "if    (  ( attributeDescriptor    !  =    null )     &  &     ( attributeDescriptor . isFixed (  )  )  )     {", "final   String   defaultValue    =    attributeDescriptor . getDefaultValue (  )  ;", "if    (  ( defaultValue    !  =    null )     &  &     ( defaultValue . equals ( namespace )  )  )     {", "return   descriptor ;", "}", "}", "}", "}", "}", "}", "PsiMetaOwner   currentOwner    =    retrieveOwner ( currentFile ,    namespace )  ;", "if    ( currentOwner    !  =    null )     {", "return    (  ( XmlNSDescriptor )     ( currentOwner . getMetaData (  )  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "final   XmlDocument   document    =    containingFile . getDocument (  )  ;", "if    ( document    =  =    null )     {", "return   null ;", "}", "final   String   url    =    XmlUtil . getDtdUri ( document )  ;", "if    ( url    =  =    null )     {", "return   null ;", "}", "return   document . getDefaultNSDescriptor ( url ,    true )  ;", "}", "METHOD_END"], "methodName": ["getDtdDescriptor"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "PsiFile   file    =    getContainingFile (  )  ;", "if    ( file    =  =    null )", "return   null ;", "Module   module    =    ModuleUtilCore . findModuleForPsiElement ( file )  ;", "if    ( module    !  =    null )     {", "for    ( icitNamespaceDescriptorProvider   provider    :    Extensions . getExtensions ( icitNamespaceDescriptorProvider . EP _ NAME )  )     {", "XmlNSDescriptor   nsDescriptor    =    provider . getNamespaceDescriptor ( module ,    ns ,    file )  ;", "if    ( nsDescriptor    !  =    null )", "return   nsDescriptor ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getImplicitNamespaceDescriptor"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "return   CachedValuesManager . getCachedValue ( this ,     (  )     -  >    Result . create ( computeNsDescriptorMap (  )  ,    PsiModificationTracker . MODIFICATION _ COUNT ,    externalResourceModificationTracker (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getNSDescriptorsMap"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "String   versionValue    =    xmlTag . getAttributeValue (  \" version \"  )  ;", "if    (  ( versionValue    !  =    null )     &  &     ( xmlTag . getNamespace (  )  . equals ( ns )  )  )     {", "return   versionValue ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getNSVersion"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "return   CachedValuesManager . getCachedValue ( this ,     (  )     -  >    Result . create ( computeNamespaceMap ( getParent (  )  )  ,    PsiModificationTracker . MODIFICATION _ COUNT )  )  ;", "}", "METHOD_END"], "methodName": ["getNamespaceMap"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( XmlUtil . XHTML _ URI . equals ( ns )  )     {", "return   Collections . singleton ( XmlUtil . getDefaultXhtmlNamespace ( getProject (  )  )  )  ;", "}", "Set < String >    locations    =    new   HashSet <  >  (  )  ;", "if    ( XmlNSDescriptorImpl . equalsToSchemaName ( this ,    XmlNSDescriptorImpl . SCHEMA _ TAG _ NAME )  )     {", "for    (    subTag    :    getSubTags (  )  )     {", "if    (  ( XmlNSDescriptorImpl . equalsToSchemaName ( subTag ,    XmlNSDescriptorImpl . IMPORT _ TAG _ NAME )  )     &  &     ( ns . equals ( subTag . getAttributeValue (  \" namespace \"  )  )  )  )     {", "String   location    =    subTag . getAttributeValue (  \" schemaLocation \"  )  ;", "ContainerUtil . addIfNotNull ( locations ,    location )  ;", "}", "}", "}", "if    ( locations . isEmpty (  )  )     {", "locations . add ( XmlUtil . getSchemaLocation ( this ,    ns )  )  ;", "}", "return   locations ;", "}", "METHOD_END"], "methodName": ["getNsLocations"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getRealNs"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   startTagName    =    XmlChildRole . START _ TAG _ NAME _ FINDER . findChild ( this )  ;", "if    ( startTagName    =  =    null )", "return   PsiReference . EMPTY _ ARRAY ;", "final   ASTNode   endTagName    =    XmlChildRole . CLOSING _ TAG _ NAME _ FINDER . findChild ( this )  ;", "List < PsiReference >    refs    =    new   ArrayList <  >  (  )  ;", "String   prefix    =    getNamespacePrefix (  )  ;", "boolean   inStartTag    =     (  ( hints . offsetInElement )     =  =    null )     |  |     (  . childContainsOffset ( startTagName . getPsi (  )  ,    hints . offsetInElement )  )  ;", "if    ( inStartTag )     {", "TagNameReference   startTagRef    =    TagNameReference . createTagNameReference ( this ,    startTagName ,    true )  ;", "if    ( startTagRef    !  =    null )     {", "refs . add ( startTagRef )  ;", "}", "if    (  !  ( prefix . isEmpty (  )  )  )     {", "refs . add ( createPrefixReference ( startTagName ,    prefix ,    startTagRef )  )  ;", "}", "}", "boolean   inEndTag    =     ( endTagName    !  =    null )     &  &     (  (  ( hints . offsetInElement )     =  =    null )     |  |     (  . childContainsOffset ( endTagName . getPsi (  )  ,    hints . offsetInElement )  )  )  ;", "if    ( inEndTag )     {", "TagNameReference   endTagRef    =    TagNameReference . createTagNameReference ( this ,    endTagName ,    false )  ;", "if    ( endTagRef    !  =    null )     {", "refs . add ( endTagRef )  ;", "}", "prefix    =    XmlUtil . findPrefixByQualifiedName ( endTagName . getText (  )  )  ;", "if    ( StringUtil . isNotEmpty ( prefix )  )     {", "refs . add ( createPrefixReference ( endTagName ,    prefix ,    endTagRef )  )  ;", "}", "}", "if    (  (  (  (  ( hints . offsetInElement )     =  =    null )     |  |    inStartTag )     |  |    inEndTag )     |  |     ( isInsideXmlText ( hints . offsetInElement )  )  )     {", "Collections . addAll ( refs ,    ReferenceProvidersRegistry . getReferencesFromProviders ( this ,    hints )  )  ;", "}", "return   ContainerUtil . toArray ( refs ,    new   PsiReference [ refs . size (  )  ]  )  ;", "}", "METHOD_END"], "methodName": ["getReferencesImpl"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "TextRange [  ]    elements    =    myTextElements ;", "if    ( elements    =  =    null )     {", "List < TextRange >    list    =    ContainerUtil . newSmartList (  )  ;", "for    ( ASTNode   child    =    getFirstChildNode (  )  ;    child    !  =    null ;    child    =    child . getTreeNext (  )  )     {", "PsiElement   psi    =    child . getPsi (  )  ;", "if    ( psi   instanceof   ext )     {", "list . add ( TextRange . from ( psi . getStartOffsetInParent (  )  ,    psi . getTextLength (  )  )  )  ;", "}", "}", "myTextElements    =    elements    =    list . toArray ( new   TextRange [  0  ]  )  ;", "}", "return   elements ;", "}", "METHOD_END"], "methodName": ["getValueTextRanges"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( map    =  =    null )", "map    =    new   gnu . trove . THashMap (  )  ;", "map . put ( namespace ,    CachedValuesManager . getManager ( getManager (  )  . getProject (  )  )  . createCachedValue (  (  )     -  >     {", "final   XmlFile [  ]    file    =    new   XmlFile [  1  ]  ;", "List < XmlNSDescriptor >    descriptors    =    fileLocations . stream (  )  . map (  (    s )     -  >     {", "file [  0  ]     =    retrieveFile ( s ,    version ,    namespace ,    nsDecl )  ;", "return   getDescriptor ( file [  0  ]  ,    s ,    namespace )  ;", "}  )  . filter ( Objects :  : nonNull )  . collect ( Collectors . toList (  )  )  ;", "XmlNSDescriptor   descriptor    =    null ;", "if    (  ( descriptors . size (  )  )     =  =     1  )     {", "descriptor    =    descriptors . get (  0  )  ;", "} else", "if    (  ( descriptors . size (  )  )     >     1  )     {", "descriptor    =    new   xml . impl . schema . MultiFileNsDescriptor ( descriptors . stream (  )  . map (  (    descriptor 1  )     -  >     (  ( xml . impl . schema . XmlNSDescriptorImpl )     ( descriptor 1  )  )  )  . collect ( Collectors . toList (  )  )  )  ;", "}", "if    ( descriptor    =  =    null )     {", "return   new   Result <  >  ( null ,    this ,     (  ( file [  0  ]  )     =  =    null    ?    this    :    file [  0  ]  )  ,    ExternalResourceManager . getInstance (  )  )  ;", "}", "return   new   Result <  >  ( descriptor ,    descriptor . getDependences (  )  ,    this )  ;", "}  ,    false )  )  ;", "return   map ;", "}", "METHOD_END"], "methodName": ["initializeSchema"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isCaseSensitive"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "TextRange [  ]    ranges    =    getValueTextRanges (  )  ;", "if    (  ( ranges . length )     =  =     0  )", "return   false ;", "if    (  ( offsetInTag    <     ( ranges [  0  ]  . getStartOffset (  )  )  )     |  |     ( offsetInTag    >     ( ranges [  (  ( ranges . length )     -     1  )  ]  . getEndOffset (  )  )  )  )", "return   false ;", "int   i    =    Arrays . binarySearch ( ranges ,    TextRange . from ( offsetInTag ,     0  )  ,     . RANGE _ COMPARATOR )  ;", "return    ( i    >  =     0  )     |  |     ( ranges [  (  (  - i )     -     2  )  ]  . containsOffset ( offsetInTag )  )  ;", "}", "METHOD_END"], "methodName": ["isInsideXmlText"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "final   String   targetNs    =    XmlUtil . getTargetSchemaNsFromTag ( this )  ;", "if    ( fileLocation . equals ( targetNs )  )     {", "return   null ;", "}", "final   XmlFile   file    =    XmlUtil . getContainingFile ( this )  ;", "if    ( file    =  =    null )", "return   null ;", "final   PsiFile   psiFile    =    ExternalReManager . getInstance (  )  . getReLocation ( fileLocation ,    file ,    version )  ;", "if    ( psiFile   instanceof   XmlFile )     {", "return    (  ( XmlFile )     ( psiFile )  )  ;", "}", "return   XmlNamespaceIndex . guessSchema ( namespace ,     ( nsDecl    ?    null    :    myLocalName )  ,    version ,    fileLocation ,    file )  ;", "}", "METHOD_END"], "methodName": ["retrieveFile"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( file    =  =    null )     {", "return   namespaequals ( XmlUtil . getTargetSchemaNsFromTag ( this )  )     ?    this    :    null ;", "}", "return   file . getDocument (  )  ;", "}", "METHOD_END"], "methodName": ["retrieveOwner"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "return    \" XmlTag :  \"     +     ( getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagImpl"}, {"methodBody": ["METHOD_START", "{", "final   List < XmlTagChild >    bodyElements    =    new   ArrayList <  >  (  )  ;", "tag . processElements ( new   PsiElementProcessor (  )     {", "boolean   insideBody ;", "@ Override", "public   boolean   execute (  @ NotNull", "PsiElement   element )     {", "final   ASTNode   treeElement    =    element . getNode (  )  ;", "if    ( insideBody )     {", "if    (  ( treeElement    !  =    null )     &  &     (  ( treeElement . getElementType (  )  )     =  =     ( XmlTokenType . XML _ END _ TAG _ START )  )  )", "return   false ;", "if    (  !  ( element   instanceof   XmlTagChild )  )", "return   true ;", "bodyElements . add (  (  ( XmlTagChild )     ( element )  )  )  ;", "} else", "if    (  ( treeElement    !  =    null )     &  &     (  ( treeElement . getElementType (  )  )     =  =     ( XmlTokenType . XML _ TAG _ END )  )  )", "insideBody    =    true ;", "return   true ;", "}", "}  ,    tag )  ;", "XmlTagChild [  ]    tagChildren    =    ContainerUtil . toArray ( bodyElements ,    new   XmlTagChild [ bodyElements . size (  )  ]  )  ;", "return   new    ( tagChildren ,    tag )  ;", "}", "METHOD_END"], "methodName": ["createXmlTagValue"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagValueImpl"}, {"methodBody": ["METHOD_START", "{", "try    {", "XmlText   text    =    null ;", "if    ( value    !  =    null )     {", "final   XmlText [  ]    texts    =    getTextElements (  )  ;", "if    (  ( texts . length )     =  =     0  )     {", "text    =     (  ( XmlText )     ( myTag . add ( XmlElementFactory . getInstance ( myTag . getProject (  )  )  . createDisplayText (  \" x \"  )  )  )  )  ;", "} else    {", "text    =    texts [  0  ]  ;", "}", "if    ( StringUtil . isEmpty ( value )  )     {", "text . delete (  )  ;", "} else    {", "if    ( defaultPolicy    &  &     ( text   instanceof   XmlTextImpl )  )     {", "(  ( XmlTextImpl )     ( text )  )  . doSetValue ( value ,    new   DefaultXmlPsiPolicy (  )  )  ;", "} else    {", "text . setValue ( value )  ;", "}", "}", "}", "if    (  ( myElements . length )     >     0  )     {", "for    ( final   XmlTagChild   child    :    myElements )     {", "if    ( child    !  =    text )     {", "child . delete (  )  ;", "}", "}", "}", "}    catch    ( IncorrectOperationException   e )     {", ". LOG . error ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["setText"], "fileName": "com.intellij.psi.impl.source.xml.XmlTagValueImpl"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   xmlTag    =     (  ( XmlTag )     ( getParent (  )  )  )  ;", "if    ( displayOffset    =  =     0  )", "return   this ;", "final   int   length    =    getValue (  )  . length (  )  ;", "if    ( displayOffset    >  =    length )     {", "return   null ;", "}", "final   PomModel   model    =    PomManager . getModel ( xmlTag . getProject (  )  )  ;", "final   XmlAspect   aspect    =    model . getModelAspect ( XmlAspect . class )  ;", "class   MyTransaction   extends   PomTransactionBase    {", "private      myRight ;", "MyTransaction (  )     {", "super ( xmlTag ,    aspect )  ;", "}", "@ Override", "@ Nullable", "public   PomModelEvent   runInner (  )    throws   IncorrectOperationException    {", "final   String   oldText    =    getValue (  )  ;", "final   int   physicalOffset    =    displayToPhysical ( displayOffset )  ;", "PsiElement   childElement    =    findElementAt ( physicalOffset )  ;", "if    (  ( childElement    !  =    null )     &  &     (  ( childElement . getNode (  )  . getElementType (  )  )     =  =     ( XmlTokenType . XML _ DATA _ CHARACTERS )  )  )     {", "FileElement   holder    =    DummyHolderFactory . createHolder ( getManager (  )  ,    null )  . getTreeElement (  )  ;", "int   splitOffset    =    physicalOffset    -     ( childElement . getStartOffsetInParent (  )  )  ;", "myRight    =     (  (  )     ( ASTFactory . composite ( XmlElementType . XML _ TEXT )  )  )  ;", "CodeEditUtil . setNodeGenerated ( myRight ,    true )  ;", "holder . rawAddChildren ( myRight )  ;", "PsiElement   e    =    childElement ;", "while    ( e    !  =    null )     {", "CodeEditUtil . setNodeGenerated ( e . getNode (  )  ,    true )  ;", "e    =    e . getNextSibling (  )  ;", "}", "String   leftText    =    childElement . getText (  )  . substring (  0  ,    splitOffset )  ;", "String   rightText    =    childElement . getText (  )  . substring ( splitOffset )  ;", "LeafElement   rightElement    =    ASTFactory . leaf ( XmlTokenType . XML _ DATA _ CHARACTERS ,    holder . getCharTable (  )  . intern ( rightText )  )  ;", "CodeEditUtil . setNodeGenerated ( rightElement ,    true )  ;", "LeafElement   leftElement    =    ASTFactory . leaf ( XmlTokenType . XML _ DATA _ CHARACTERS ,    holder . getCharTable (  )  . intern ( leftText )  )  ;", "CodeEditUtil . setNodeGenerated ( leftElement ,    true )  ;", "rawInsertAfterMe ( myRight )  ;", "myRight . rawAddChildren ( rightElement )  ;", "if    (  ( childElement . getNextSibling (  )  )     !  =    null )     {", "myRight . rawAddChildren (  (  ( TreeElement )     ( childElement . getNextSibling (  )  )  )  )  ;", "}", "(  ( TreeElement )     ( childElement )  )  . rawRemove (  )  ;", ". this . rawAddChildren ( leftElement )  ;", "} else    {", "final   PsiFile   containingFile    =    xmlTag . getContainingFile (  )  ;", "final   FileElement   holder    =    DummyHolderFactory . createHolder ( containingFile . getManager (  )  ,    null ,     (  ( PsiFileImpl )     ( containingFile )  )  . getTreeElement (  )  . getCharTable (  )  )  . getTreeElement (  )  ;", "final      rightText    =     (  (  )     ( ASTFactory . composite ( XmlElementType . XML _ TEXT )  )  )  ;", "CodeEditUtil . setNodeGenerated ( rightText ,    true )  ;", "holder . rawAddChildren ( rightText )  ;", "(  ( ASTNode )     ( xmlTag )  )  . addChild ( rightText ,    getTreeNext (  )  )  ;", "final   String   value    =    getValue (  )  ;", "setValue ( value . substring (  0  ,    displayOffset )  )  ;", "rightText . setValue ( value . substring ( displayOffset )  )  ;", "CodeEditUtil . setNodeGenerated ( rightText ,    true )  ;", "myRight    =    rightText ;", "}", "clearCaches (  )  ;", "myRight . clearCaches (  )  ;", "return   createEvent ( new   XmlTextChangedImpl (  . this ,    oldText )  ,    new   XmlTagChildAddImpl ( xmlTag ,    myRight )  )  ;", "}", "public   XmlText   getResult (  )     {", "return   myRight ;", "}", "}", "final   MyTransaction   transaction    =    new   MyTransaction (  )  ;", "model . runTransaction ( transaction )  ;", "return   transaction . getResult (  )  ;", "}", "METHOD_END"], "methodName": ["_splitText"], "fileName": "com.intellij.psi.impl.source.xml.XmlTextImpl"}, {"methodBody": ["METHOD_START", "{", "final   PomModelEvent   event    =    new   PomModelEvent ( PomManager . getModel ( getProject (  )  )  )  ;", "final   XmlAspectChangeSe   xmlAspectChangeSet    =    new   XmlAspectChangeSe ( PomManager . getModel ( getProject (  )  )  ,     (  ( XmlFile )     ( getContainingFile (  )  )  )  )  ;", "for    ( XmlChange   xmlChange    :    events )     {", "xmlAspectChangeSet . add ( xmlChange )  ;", "}", "event . registerChangeSet ( PomManager . getModel ( getProject (  )  )  . getModelAspect ( XmlAspect . class )  ,    xmlAspectChangeSet )  ;", "return   event ;", "}", "METHOD_END"], "methodName": ["createEvent"], "fileName": "com.intellij.psi.impl.source.xml.XmlTextImpl"}, {"methodBody": ["METHOD_START", "{", "final   PomModel   model    =    PomManager . getModel ( getProject (  )  )  ;", "final   XmlAspect   aspect    =    model . getModelAspect ( XmlAspect . class )  ;", "model . runTransaction ( new   PomTransactionBase ( this ,    aspect )     {", "@ Override", "public   PomModelEvent   runInner (  )     {", "final   String   oldText    =    getText (  )  ;", "final   ASTNode   firstEncodedElement    =    policy . encodeXmlTextContents ( s ,     . this )  ;", "if    ( firstEncodedElement    =  =    null )     {", "delete (  )  ;", "} else    {", "replaceAllChildrenToChildrenOf ( firstEncodedElement . getTreeParent (  )  )  ;", "}", "clearCaches (  )  ;", "return   XmlTextChangedImpl . createXmlTextChanged ( model ,     . this ,    oldText )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["doSetValue"], "fileName": "com.intellij.psi.impl.source.xml.XmlTextImpl"}, {"methodBody": ["METHOD_START", "{", "PsiElement [  ]    elements    =    getChildren (  )  ;", "int   first    =     0  ;", "if    (  (  ( elements . length )     >     0  )     &  &     (  ( elements [  0  ]  )    instanceof   PsiWhiteSpace )  )     {", "first +  +  ;", "}", "int   start    =     0  ;", "if    (  (  ( elements . length )     >    first )     &  &     (  ( elements [ first ]  . getNode (  )  . getElementType (  )  )     =  =     ( XmlElementType . XML _ CDATA )  )  )     {", "ASTNode   startNode    =    elements [ first ]  . getNode (  )  . findChildByType ( okenType . XML _ CDATA _ START )  ;", "if    ( startNode    !  =    null )     {", "start    =     ( startNode . getTextRange (  )  . getEndOffset (  )  )     -     ( getTextRange (  )  . getStartOffset (  )  )  ;", "}", "}", "int   end    =    getTextLength (  )  ;", "int   last    =     ( elements . length )     -     1  ;", "if    (  ( last    >     0  )     &  &     (  ( elements [ last ]  )    instanceof   PsiWhiteSpace )  )     {", "last -  -  ;", "}", "if    (  ( last    >  =     0  )     &  &     (  ( elements [ last ]  . getNode (  )  . getElementType (  )  )     =  =     ( XmlElementType . XML _ CDATA )  )  )     {", "ASTNode   startNode    =    elements [ last ]  . getNode (  )  . findChildByType ( okenType . XML _ CDATA _ END )  ;", "if    ( startNode    !  =    null )     {", "end    =     ( startNode . getTextRange (  )  . getStartOffset (  )  )     -     ( getTextRange (  )  . getStartOffset (  )  )  ;", "}", "}", "return   new   TextRange ( start ,    end )  ;", "}", "METHOD_END"], "methodName": ["getCDATAInterior"], "fileName": "com.intellij.psi.impl.source.xml.XmlTextImpl"}, {"methodBody": ["METHOD_START", "{", "return   LanguageXmlPsiPolicy . INSTANCE . forLanguage ( getLanguage (  )  )  ;", "}", "METHOD_END"], "methodName": ["getPolicy"], "fileName": "com.intellij.psi.impl.source.xml.XmlTextImpl"}, {"methodBody": ["METHOD_START", "{", "return    \" XmlText \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.psi.impl.source.xml.XmlTextImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getTokenType (  )  )    instanceof   IDTDElementType )     {", "return    \" DTDToken :  \"     +     ( getTokenType (  )  . toString (  )  )  ;", "}", "return    \"  :  \"     +     ( getTokenType (  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.psi.impl.source.xml.XmlTokenImpl"}, {"methodBody": ["METHOD_START", "{", "final   PsiFile   file    =    parentTag . getContainingFile (  )  . getOriginalFile (  )  ;", "if    (  !  ( file   instanceof   XmlFile )  )", "return   null ;", "XSModel   xsModel    =    ReadAction . compute (  (  )     -  >    getXSModel (  (  ( XmlFile )     ( file )  )  )  )  ;", "if    ( xsModel    =  =    null )     {", "return   null ;", "}", "XSElementDeclaration   decl    =     . getElementDeclaration ( parentTag ,    xsModel )  ;", "if    ( decl    =  =    null )     {", "return   null ;", "}", "return   new    ( decl ,    parentTag )  ;", "}", "METHOD_END"], "methodName": ["createContentDFA"], "fileName": "com.intellij.psi.impl.source.xml.XsContentDFA"}, {"methodBody": ["METHOD_START", "{", "String   namespace    =    tag . getNamespace (  )  ;", "return   new   QName ( tag . getNamespacePrefix (  ) rn (  )  ,    tag . getLocalName (  ) rn (  )  ,    tag . getName (  ) rn (  )  ,     ( namespace . isEmpty (  )     ?    null    :    namespacern (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createQName"], "fileName": "com.intellij.psi.impl.source.xml.XsContentDFA"}, {"methodBody": ["METHOD_START", "{", "List < XmlTag >    ancestors    =    new   ArrayList <  >  (  )  ;", "for    ( XmlTag   t    =    tag ;    t    !  =    null ;    t    =    t . getParentTag (  )  )     {", "ancestors . add ( t )  ;", "}", "Collections . reverse ( ancestors )  ;", "XSElementDeclaration   declaration    =    null ;", "SubstitutionGroupHandler   fSubGroupHandler    =    new   SubstitutionGroupHandler ( new    . MyXSElementDeclHelper (  )  )  ;", "CMBuilder   cmBuilder    =    new   CMBuilder ( new   CMNodeFactory (  )  )  ;", "for    ( XmlTag   ancestor    :    ancestors )     {", "if    ( declaration    =  =    null )     {", "declaration    =    xsModel . getElementDeclaration ( ancestor . getLocalName (  )  ,    ancestor . getNamespace (  )  )  ;", "if    ( declaration    =  =    null )", "return   null ;", "else", "continue ;", "}", "XSTypeDefinition   typeDefinition    =    declaration . getTypeDefinition (  )  ;", "if    (  !  ( typeDefinition   instanceof   XSComplexTypeDecl )  )     {", "return   null ;", "}", "XSCMValidator   model    =     (  ( XSComplexTypeDecl )     ( typeDefinition )  )  . getContentModel ( cmBuilder )  ;", "int [  ]    ints    =    model . startContentModel (  )  ;", "for    ( XmlTag   subTag    :    ancestor . getParentTag (  )  . getSubTags (  )  )     {", "QName   qName    =     . createQName ( subTag )  ;", "Object   o    =    model . oneTransition ( qName ,    ints ,    fSubGroupHandler )  ;", "if    ( subTag    =  =    ancestor )     {", "if    ( o   instanceof   XSElementDecl )     {", "declaration    =     (  ( XSElementDecl )     ( o )  )  ;", "break ;", "} else", "return   null ;", "}", "}", "}", "return   declaration ;", "}", "METHOD_END"], "methodName": ["getElementDeclaration"], "fileName": "com.intellij.psi.impl.source.xml.XsContentDFA"}, {"methodBody": ["METHOD_START", "{", "ValidateXmlActionHandler   handler    =    new   ValidateXmlActionHandler ( false )     {", "@ Override", "protected   SAXParser   createParser (  )    throws   ParserConfigurationException ,    SAXException    {", "SAXParser   parser    =    super . createParser (  )  ;", "if    ( parser    !  =    null )     {", "parser . getXMLReader (  )  . setFeature (  (  ( Constants . XERCES _ FEATURE _ PREFIX )     +     ( Constants . CONTINUE _ AFTER _ FATAL _ ERROR _ FEATURE )  )  ,    true )  ;", "}", "return   parser ;", "}", "}  ;", "handler . setErrorReporter ( new   ErrorReporter ( handler )     {", "int   count ;", "@ Override", "public   void   processError ( SAXParseException   ex ,    ValidateXmlActionHandler . ProblemType   warning )    throws   SAXException    {", "if    (  ( warning    !  =     ( ValidateXmlActionHandler . ProblemType . WARNING )  )     &  &     (  (  ( count )  +  +  )     >     1  0  0  )  )     {", "throw   new   SAXException ( ex )  ;", "}", "}", "@ Override", "public   boolean   isUniqueProblem ( SAXParseException   e )     {", "return   true ;", "}", "}  )  ;", "handler . doValidate ( file )  ;", "XMLGrammarPool   grammarPool    =    ValidateXmlActionHandler . getGrammarPool ( file )  ;", "if    ( grammarPool    =  =    null )     {", "return   null ;", "}", "Grammar [  ]    grammars    =    grammarPool . retrieveInitialGrammarSet ( XML _ SCHEMA )  ;", "return    ( grammars . length )     =  =     0     ?    null    :     (  ( XSGrammar )     ( grammars [  0  ]  )  )  . toXSModel ( ainerUtil . map ( grammars ,     (    grammar )     -  >     (  ( XSGrammar )     ( grammar )  )  ,    new   XSGrammar [  0  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["getXSModel"], "fileName": "com.intellij.psi.impl.source.xml.XsContentDFA"}, {"methodBody": ["METHOD_START", "{", "final   FileElement   dummyParent    =    DummyHolderFactory . createHolder ( manager ,    null ,    charTableByTree )  . getTreeElement (  )  ;", "final   CompositeElement   cdata    =    ASTFactory . composite ( XmlElementType . XML _  )  ;", "dummyParent . rawAddChildren ( cdata )  ;", "cdata . rawAddChildren ( ASTFactory . leaf ( XmlTokenType . XML _  _ START ,     \"  <  !  [  [  \"  )  )  ;", "cdata . rawAddChildren ( ASTFactory . leaf ( XmlTokenType . XML _ DATA _ CHARACTERS ,    dummyParent . getCharTable (  )  . intern ( displayText )  )  )  ;", "cdata . rawAddChildren ( ASTFactory . leaf ( XmlTokenType . XML _  _ END ,     \"  ]  ]  >  \"  )  )  ;", "dummyParent . acceptTree ( new   GeneratedMarkerVisitor (  )  )  ;", "return   dummyParent ;", "}", "METHOD_END"], "methodName": ["createCDATAElement"], "fileName": "com.intellij.psi.impl.source.xml.behavior.CDATAOnAnyEncodedPolicy"}, {"methodBody": ["METHOD_START", "{", "switch    ( ch )     {", "case    '  <  '     :", "return   ASTFactory . leaf ( XmlTokenType . XML _ CHAR _ ENTITY _ REF ,     \"  & lt ;  \"  )  ;", "case    '  \\  '  '     :", "return   ASTFactory . leaf ( XmlTokenType . XML _ CHAR _ ENTITY _ REF ,     \"  & apos ;  \"  )  ;", "case    '  \"  '     :", "return   ASTFactory . leaf ( XmlTokenType . XML _ CHAR _ ENTITY _ REF ,     \"  & quot ;  \"  )  ;", "case    '  >  '     :", "return   ASTFactory . leaf ( XmlTokenType . XML _ CHAR _ ENTITY _ REF ,     \"  & gt ;  \"  )  ;", "case    '  &  '     :", "return   ASTFactory . leaf ( XmlTokenType . XML _ CHAR _ ENTITY _ REF ,     \"  & amp ;  \"  )  ;", "case    '  \\ u 0  0 a 0  '     :", "return   ASTFactory . leaf ( XmlTokenType . XML _ CHAR _ ENTITY _ REF ,     \"  & nbsp ;  \"  )  ;", "default    :", "final   String   charing    =     (  \"  &  #  \"     +     (  ( int )     ( ch )  )  )     +     \"  ;  \"  ;", "return   ASTFactory . leaf ( XmlTokenType . XML _ CHAR _ ENTITY _ REF ,    charTable . intern ( charing )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createCharEntity"], "fileName": "com.intellij.psi.impl.source.xml.behavior.EncodeEachSymbolPolicy"}, {"methodBody": ["METHOD_START", "{", "return    (  \"  <  &  >  \\ u 0  0 a 0  \\  '  \\  \"  \"  . indexOf ( ch )  )     >  =     0  ;", "}", "METHOD_END"], "methodName": ["toCode"], "fileName": "com.intellij.psi.impl.source.xml.behavior.EncodeEachSymbolPolicy"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( str . length (  )  )  ;    i +  +  )     {", "final   char   ch    =    str . charAt ( i )  ;", "if    (  . toCode ( ch )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["toCode"], "fileName": "com.intellij.psi.impl.source.xml.behavior.EncodeEachSymbolPolicy"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["skipValidation"], "fileName": "com.intellij.psi.xml.XmlElement"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   PsiElement   element    =    attribute . setName ( newName )  ;", "if    ( listener    !  =    null )     {", "listener . elementRenamed ( element )  ;", "}", "}    catch    ( IncorrectOperationException   e )     {", ". LOG . error ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["doRenameXmlAttribute"], "fileName": "com.intellij.refactoring.rename.RenameXmlAttributeProcessor"}, {"methodBody": ["METHOD_START", "{", "RenameXmlAttributeProcessor . LOG . assertTrue ( value . isValid (  )  )  ;", "RenameXmlAttributeProcessor . renameAll ( value ,    infos ,    newName ,    value . getValue (  )  )  ;", "PsiManager   psiManager    =    value . getManager (  )  ;", "RenameXmlAttributeProcessor . LOG . assertTrue (  ( psiManager    !  =    null )  )  ;", "XmlFile   file    =     (  ( XmlFile )     ( PsiFileFactory . getInstance ( psiManager . getProject (  )  )  . createFileFromText (  \" dummy . xml \"  ,    XMLLanguage . INSTANCE ,     (  (  \"  < a   attr =  \\  \"  \"     +    newName )     +     \"  \\  \"  /  >  \"  )  )  )  )  ;", "@ SuppressWarnings (  \" ConstantConditions \"  )", "PsiElement   element    =    value . replace ( file . getRootTag (  )  . getAttributes (  )  [  0  ]  . getValueElement (  )  )  ;", "if    ( listener    !  =    null )     {", "listener . elementRenamed ( element )  ;", "}", "}", "METHOD_END"], "methodName": ["doRenameXmlAttributeValue"], "fileName": "com.intellij.refactoring.rename.RenameXmlAttributeProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( newName . equals ( originalName )  )", "return ;", "Queue < PsiReference >    queue    =    new   Queue ( infos . length )  ;", "for    ( UsageInfo   info    :    infos )     {", "if    (  ( info . getElement (  )  )     =  =    null )", "continue ;", "PsiReference   ref    =    info . getReference (  )  ;", "if    ( ref    =  =    null )", "continue ;", "queue . addLast ( ref )  ;", "}", "while    (  !  ( queue . isEmpty (  )  )  )     {", "final   PsiReference   reference    =    queue . pullFirst (  )  ;", "final   PsiElement   oldElement    =    reference . getElement (  )  ;", "if    (  (  !  ( oldElement . isValid (  )  )  )     |  |     ( oldElement    =  =    originalElement )  )", "continue ;", "final   PsiElement   newElement    =    reference . handleElementRename ( newName )  ;", "if    (  !  ( oldElement . isValid (  )  )  )     {", "for    ( PsiReference   psiReference    :    ReferencesSearch . search ( originalElement ,    new   psi . search . LocalSearchScope ( newElement )  ,    false )  )     {", "queue . addLast ( psiReference )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["renameAll"], "fileName": "com.intellij.refactoring.rename.RenameXmlAttributeProcessor"}, {"methodBody": ["METHOD_START", "{", "Module [  ]    modules    =    ModuleContextProvider . getModules ( getFile (  )  )  ;", "if    (  ( modules . length )     >     0  )", "return   modules ;", "final   Module   module    =    getModule (  )  ;", "if    ( module    !  =    null )", "return   new   Module [  ]  {    module    }  ;", "return   Module . EMPTY _ ARRAY ;", "}", "METHOD_END"], "methodName": ["getConvertContextModules"], "fileName": "com.intellij.util.xml.AbstractConvertContext"}, {"methodBody": ["METHOD_START", "{", "return   getInvocationElement (  )  . getManager (  )  . getProject (  )  ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "com.intellij.util.xml.ConvertContext"}, {"methodBody": ["METHOD_START", "{", "return   PsiManager . getInstance ( getProject (  )  )  ;", "}", "METHOD_END"], "methodName": ["getPsiManager"], "fileName": "com.intellij.util.xml.ConvertContext"}, {"methodBody": ["METHOD_START", "{", "final   XmlElement   element    =    getXmlElement (  )  ;", "if    ( element   instanceof   XmlTag )     {", "return   element ;", "}", "if    ( element   instanceof   XmlAttribute )     {", "return    (  ( XmlAttribute )     ( element )  )  . getValueElement (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getReferenceXmlElement"], "fileName": "com.intellij.util.xml.ConvertContext"}, {"methodBody": ["METHOD_START", "{", "return   CodeInsightBundle . message (  \" error . cannot . convert . default . message \"  ,    s )  ;", "}", "METHOD_END"], "methodName": ["getErrorMessage"], "fileName": "com.intellij.util.xml.Converter"}, {"methodBody": ["METHOD_START", "{", "final   DomAnnotationsTest . MyElement   element    =    createElement (  \"  < a /  >  \"  ,    DomAnnotationsTest . MyElement . class )  ;", "final   DomElementsProblemsHolderImpl   holder    =    new   DomElementsProblemsHolderImpl ( DomUtil . getFileElement ( element )  )  ;", "final   DomElementProblemDescriptorImpl   error    =    new   DomElementProblemDescriptorImpl ( element ,     \" abc \"  ,    HighlightSeverity . ERROR )  ;", "final   DomElementProblemDescriptorImpl   warning    =    new   DomElementProblemDescriptorImpl ( element ,     \" abc \"  ,    HighlightSeverity . WARNING )  ;", "holder . addProblem ( error ,    MockDomInspection . class )  ;", "holder . addProblem ( warning ,    MockDomInspection . class )  ;", "assertEquals ( Arrays . asList ( error )  ,    holder . getProblems ( element ,    true ,    true ,    ERROR )  )  ;", "assertEquals ( Arrays . asList ( error ,    warning )  ,    holder . getProblems ( element ,    true ,    true ,    WARNING )  )  ;", "}", "METHOD_END"], "methodName": ["testMinSeverity"], "fileName": "com.intellij.util.xml.DomAnnotationsTest"}, {"methodBody": ["METHOD_START", "{", "final   DomAnnotationsTest . MyElement   myElement    =    createElement (  \"  < a >  < my - class > abc <  / my - class >  <  / a >  \"  ,    DomAnnotationsTest . MyElement . class )  ;", "new   MockDomInspection ( DomAnnotationsTest . MyElement . class )  . checkFile ( DomUtil . getFile ( myElement )  ,    InspectionManager . getInstance ( getProject (  )  )  ,    true )  ;", "final   DomElementsProblemsHolder   holder    =    DomElementAnnotationsManager . getInstance ( getProject (  )  )  . getProblemHolder ( myElement )  ;", "final   DomElement   element    =    myElement . getMyClass (  )  ;", "assertEquals (  0  ,    holder . getProblems ( myElement )  . size (  )  )  ;", "assertEquals (  0  ,    holder . getProblems ( myElement )  . size (  )  )  ;", "assertEquals (  1  ,    holder . getProblems ( element )  . size (  )  )  ;", "assertEquals (  1  ,    holder . getProblems ( element )  . size (  )  )  ;", "assertEquals (  1  ,    holder . getProblems ( myElement ,    true ,    true )  . size (  )  )  ;", "assertEquals (  1  ,    holder . getProblems ( myElement ,    true ,    true )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testResolveProblemsAreReportedOnlyOnce"], "fileName": "com.intellij.util.xml.DomAnnotationsTest"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( expected ,    new   CollectionChildDescriptionImpl ( new   XmlName ( tagName )  ,    DomElement . class ,    null )  . getCommonPresentableName ( strategy )  )  ;", "}", "METHOD_END"], "methodName": ["assertCollectionPresentableName"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  ,    description . getCount (  )  )  ;", "assertEquals ( Arrays . asList ( child )  ,    description . getValues ( child . getParent (  )  )  )  ;", "assertEquals ( tagName ,    description . getXmlElementName (  )  )  ;", "assertEquals (  . MyElement . class ,    description . getType (  )  )  ;", "assertEquals ( JavaMethod . getMethod (  . MyElement . class ,    new   JavaMethodSignature (  (  \" get \"     +     ( StringUtil . capitalize ( tagName )  )  )  )  )  ,    description . getGetterMethod (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["assertFixedChildDescription"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( expected ,    new   FixedChildDescriptionImpl ( new   XmlName ( tagName )  ,    DomElement . class ,     0  ,    new   Collection [  0  ]  )  . getCommonPresentableName ( strategy )  )  ;", "}", "METHOD_END"], "methodName": ["assertFixedPresentableName"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  ,    description . getCount (  )  )  ;", "assertEquals ( Arrays . asList ( child )  ,    description . getValues ( child . getParent (  )  )  )  ;", "assertEquals ( tagName ,    description . getXmlElementName (  )  )  ;", "assertEquals ( GenericDomValue . class ,     (  ( ParameterizedType )     ( description . getType (  )  )  )  . getRawType (  )  )  ;", "assertEquals ( JavaMethod . getMethod (  . MyElement . class ,    new   JavaMethodSignature (  \" getGenericValue \"  )  )  ,    description . getGetterMethod (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["assertGenericChildDescription"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( parent ,    element . getParent (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertParent"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   rootTag    =    file . getDocument (  )  . getRootTag (  )  ;", "assertNotNull ( rootTag )  ;", "assertEquals (  \" root \"  ,    rootTag . getName (  )  )  ;", "return   rootTag ;", "}", "METHOD_END"], "methodName": ["assertRootTag"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "return   DomBasicsTest . assertRootTag ( DomUtil . getFile ( rootElement )  )  ;", "}", "METHOD_END"], "methodName": ["assertRootTag"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "return   createElement ( xml ,    DomBasicsTest . MyElement . class )  ;", "}", "METHOD_END"], "methodName": ["createElement"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =    DomTestCase . createXmlFile (  \"  \"  )  ;", "return   getDomManager (  )  . getFileElement ( file ,     . MyElement . class ,     \" root \"  )  . getRootElement (  )  ;", "}", "METHOD_END"], "methodName": ["createEmptyElement"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "final   DomBasicsTest . MyElement   element    =    createElement (  \"  < a >  < child - element /  >  < child /  >  < child - element /  >  <  / a >  \"  )  ;", "final   Set < DomElement >    visited    =    new   HashSet <  >  (  )  ;", "element . acceptChildren ( new   DomElementVisitor (  )     {", "@ Override", "public   void   visitDomElement ( DomElement   element )     {", "visited . add ( element )  ;", "}", "}  )  ;", "final   DomBasicsTest . MyElement   foo    =    element . getFoo (  )  ;", "final   DomBasicsTest . MyElement   child    =    element . getChild (  )  ;", "final   DomBasicsTest . MyElement   child 1     =    element . getChildElements (  )  . get (  0  )  ;", "final   DomBasicsTest . MyElement   child 2     =    element . getChildElements (  )  . get (  1  )  ;", "final   GenericDomValue < Boolean >    genericValue    =    element . getGenericValue (  )  ;", "assertSameElements ( visited ,    foo ,    child ,    child 1  ,    child 2  ,    genericValue ,    element . getAttr (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAcceptChildren"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "final   DomBasicsTest . MyElement   element    =    createElement (  \"  < a >  < child - element /  >  <  / a >  \"  )  ;", "final   DomGenericInfo   info    =    element . getGenericInfo (  )  ;", "final   DomCollectionChildDescription   collectionChild    =    info . getCollectionChildDescription (  \" child - element \"  )  ;", "final   List <  ?    extends   DomElement >    values    =    collectionChild . getValues ( element )  ;", "DomBasicsTest . MyElement   newChild    =     (  ( DomBasicsTest . MyElement )     ( collectionChild . addValue ( element )  )  )  ;", "List < DomElement >    newChildren    =    Arrays . asList ( values . get (  0  )  ,    newChild )  ;", "assertEquals ( newChildren ,    element . getChildElements (  )  )  ;", "assertEquals ( newChildren ,    collectionChild . getValues ( element )  )  ;", "DomBasicsTest . MyElement   lastChild    =     (  ( DomBasicsTest . MyElement )     ( collectionChild . addValue ( element ,     0  )  )  )  ;", "newChildren    =    Arrays . asList ( lastChild ,    values . get (  0  )  ,    newChild )  ;", "assertEquals ( newChildren ,    element . getChildElements (  )  )  ;", "assertEquals ( newChildren ,    collectionChild . getValues ( element )  )  ;", "}", "METHOD_END"], "methodName": ["testAddChildrenByReflection"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "final   StaticGenericInfo   genericInfo    =    DomApplicationComponent . getInstance (  )  . getStaticGenericInfo ( DomBasicsTest . MyElement . class )  ;", "final   List <  ?    extends   DomAttributeChildDescription >    descriptions    =    genericInfo . getAttributeChildrenDescriptions (  )  ;", "assertEquals (  1  ,    descriptions . size (  )  )  ;", "final   DomAttributeChildDescription   description    =    descriptions . get (  0  )  ;", "final   DomBasicsTest . MyElement   element    =    createElement (  \"  \"  )  ;", "assertEquals ( element . getAttr (  )  ,    description . getValues ( element )  . get (  0  )  )  ;", "assertEquals ( element . getAttr (  )  ,    description . getDomAttributeValue ( element )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeChildrenGenerics"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "final   DomBasicsTest . MyElement   element    =    createElement (  \"  < a >  < child /  >  < child - element /  >  < child - element /  >  <  / a >  \"  )  ;", "final   DomGenericInfo   info    =    element . getGenericInfo (  )  ;", "final   DomFixedChildDescription   foo    =    info . getFixedChildDescription (  \" foo \"  )  ;", "assertFixedChildDescription ( foo ,    element . getFoo (  )  ,     \" foo \"  )  ;", "final   DomFixedChildDescription   child    =    info . getFixedChildDescription (  \" child \"  )  ;", "assertFixedChildDescription ( child ,    element . getChild (  )  ,     \" child \"  )  ;", "final   DomFixedChildDescription   genericChild    =    info . getFixedChildDescription (  \" generic - value \"  )  ;", "DomBasicsTest . assertGenericChildDescription ( genericChild ,    element . getGenericValue (  )  ,     \" generic - value \"  )  ;", "final   DomCollectionChildDescription   collectionChild    =    info . getCollectionChildDescription (  \" child - element \"  )  ;", "assertEquals ( element . getChildElements (  )  ,    collectionChild . getValues ( element )  )  ;", "assertEquals (  \" child - element \"  ,    collectionChild . getXmlElementName (  )  )  ;", "assertEquals ( DomBasicsTest . MyElement . class ,    collectionChild . getType (  )  )  ;", "assertEquals ( DomBasicsTest . MyElement . class . getMethod (  \" getChildElements \"  )  ,    collectionChild . getGetterMethod (  )  . getMethod (  )  )  ;", "assertEquals ( new   HashSet ( Arrays . asList ( foo ,    child ,    collectionChild ,    genericChild ,    info . getAttributeChildrenDescriptions (  )  . get (  0  )  )  )  ,    new   HashSet ( info . getChildrenDescriptions (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testChildrenReflection"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "Module   module    =    new   com . intellij . mock . MockModule ( getTestRootDisposable (  )  )  ;", "DomBasicsTest . MyElement   element 1     =    getDomManager (  )  . createMockElement ( DomBasicsTest . MyElement . class ,    module ,    false )  ;", "DomBasicsTest . MyElement   element 2     =    getDomManager (  )  . createMockElement ( DomBasicsTest . MyElement . class ,    module ,    false )  ;", "element 2  . copyFrom ( element 1  )  ;", "assertNull ( element 2  . getXmlTag (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCopyingFromEmptyToEmpty"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "Module   module    =    new   com . intellij . mock . MockModule ( getTestRootDisposable (  )  )  ;", "final   DomBasicsTest . MyElement   element 1     =    getDomManager (  )  . createMockElement ( DomBasicsTest . MyElement . class ,    module ,    false )  ;", "final   DomBasicsTest . MyElement   element 2     =    getDomManager (  )  . createMockElement ( DomBasicsTest . MyElement . class ,    module ,    false )  ;", "element 2  . ensureTagExists (  )  ;", "assertNull ( element 2  . getChild (  )  . getChild (  )  . getGenericValue (  )  . getStringValue (  )  )  ;", "element 1  . getChild (  )  . getChild (  )  . getGenericValue (  )  . setStringValue (  \" abc \"  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "element 2  . copyFrom ( element 1  )  ;", "}  )  ;", "assertEquals (  \" abc \"  ,    element 2  . getChild (  )  . getChild (  )  . getGenericValue (  )  . getStringValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCopyingFromNonEmptyToEmpty"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "final   DomBasicsTest . MyElement   element    =    createElement (  \"  < a >  < child /  >  <  / a >  \"  )  ;", "assertSame ( element . getChild (  )  ,    element . getChild (  )  )  ;", "assertSame ( element . getXmlTag (  )  . getSubTags (  )  [  0  ]  ,    element . getChild (  )  . getXmlTag (  )  )  ;", "assertCached ( element . getChild (  )  ,    element . getChild (  )  . getXmlTag (  )  )  ;", "}", "METHOD_END"], "methodName": ["testElementCaching"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "final   DomBasicsTest . MyElement   rootElement    =    createEmptyElement (  )  ;", "myCallRegistry . clear (  )  ;", "assertNull ( rootElement . getXmlTag (  )  )  ;", "rootElement . ensureTagExists (  )  ;", "final   DomElement   element    =    rootElement ;", "myCallRegistry . putExpected ( new   DomEvent ( element ,    true )  )  ;", "assertCached ( rootElement ,    assertRootTag ( rootElement )  )  ;", "myCallRegistry . assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["testEnsureRootTagExists"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "final   DomBasicsTest . MyElement   element    =    createElement (  \"  < a /  >  \"  )  ;", "myCallRegistry . clear (  )  ;", "final   DomBasicsTest . MyElement   child    =    element . getChild (  )  ;", "assertNull ( child . getXmlTag (  )  )  ;", "child . ensureTagExists (  )  ;", "final   XmlTag [  ]    subTags    =    element . getXmlTag (  )  . getSubTags (  )  ;", "assertEquals (  1  ,    subTags . length )  ;", "final   XmlTag   childTag    =    subTags [  0  ]  ;", "assertEquals (  \" child \"  ,    childTag . getName (  )  )  ;", "assertCached ( child ,    childTag )  ;", "assertSame ( child . getXmlTag (  )  ,    childTag )  ;", "final   DomElement   element 1     =    child ;", "myCallRegistry . putExpected ( new   DomEvent ( element 1  ,    true )  )  ;", "myCallRegistry . assertResultsAndClear (  )  ;", "final   DomBasicsTest . MyElement   childElement    =    element . addChildElement (  )  ;", "final   XmlTag   childElementTag    =    childElement . getXmlTag (  )  ;", "assertSame ( childElementTag ,    childElement . ensureTagExists (  )  )  ;", "}", "METHOD_END"], "methodName": ["testEnsureTagExists"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =    DomTestCase . createXmlFile (  \"  < a > foo <  / a >  \"  )  ;", "DomFileElementImpl <  . MyElement >    fileElement    =    getDomManager (  )  . getFileElement ( file ,     . MyElement . class ,     \" a \"  )  ;", "final    . MyElement   rootElement    =    fileElement . getRootElement (  )  ;", "assertNotNull ( rootElement )  ;", "assertEquals (  \" foo \"  ,    rootElement . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFile"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =    DomTestCase . createXmlFile (  \"  < a /  >  \"  )  ;", "final   DomManagerImpl   manager    =    getDomManager (  )  ;", "final   DomFileElementImpl < DomElement >    fileElement    =    manager . getFileElement ( file ,    DomElement . class ,     \" a \"  )  ;", "assertEquals ( fileElement ,    manager . getFileElement ( file ,    DomElement . class ,     \" a \"  )  )  ;", "assertCached ( fileElement ,    file )  ;", "assertEquals ( fileElement . getRootElement (  )  ,    fileElement . getRootElement (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFileElementCaching"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "final   DomBasicsTest . MyElement   element    =    createElement (  \"  < a /  >  \"  )  ;", "assertEquals ( DomBasicsTest . MyElement . class . getMethod (  \" getGenericValue \"  )  . getGenericReturnType (  )  ,    element . getGenericValue (  )  . getDomElementType (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetDomElementType"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =    DomTestCase . createXmlFile (  \"  < a >  < foo /  >  < child - element /  >  < child - element /  >  <  / a >  \"  )  ;", "final   DomFileElementImpl <  . MyElement >    fileElement    =    getDomManager (  )  . getFileElement ( file ,     . MyElement . class ,     \" a \"  )  ;", "assertNull ( fileElement . getParent (  )  )  ;", "assertSame ( fileElement ,    DomUtil . getFileElement ( fileElement )  )  ;", "final    . MyElement   rootElement    =    fileElement . getRootElement (  )  ;", "assertSame ( fileElement ,    rootElement . getParent (  )  )  ;", "assertSame ( fileElement ,    DomUtil . getFileElement ( rootElement )  )  ;", ". assertParent ( rootElement . getFoo (  )  ,    rootElement )  ;", ". assertParent ( rootElement . getChildElements (  )  . get (  0  )  ,    rootElement )  ;", ". assertParent ( rootElement . getChildElements (  )  . get (  1  )  ,    rootElement )  ;", "}", "METHOD_END"], "methodName": ["testGetParentAndRoot"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "assertCollectionPresentableName (  \" Aaas \"  ,     \" aaa \"  ,    DomNameStrategy . HYPHEN _ STRATEGY )  ;", "assertCollectionPresentableName (  \" Aaa   Bbbs \"  ,     \" aaa - bbb \"  ,    DomNameStrategy . HYPHEN _ STRATEGY )  ;", "assertCollectionPresentableName (  \" Aaas \"  ,     \" aaa \"  ,    DomNameStrategy . JAVA _ STRATEGY )  ;", "assertCollectionPresentableName (  \" Aaa   Children \"  ,     \" aaaChild \"  ,    DomNameStrategy . JAVA _ STRATEGY )  ;", "assertFixedPresentableName (  \" Aaa   Bbbs \"  ,     \" aaa - bbbs \"  ,    DomNameStrategy . HYPHEN _ STRATEGY )  ;", "assertFixedPresentableName (  \" Aaa   Child \"  ,     \" aaaChild \"  ,    DomNameStrategy . JAVA _ STRATEGY )  ;", "}", "METHOD_END"], "methodName": ["testGetPresentableName"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "DomBasicsTest . MyElement   element    =    createElement (  \"  \"  )  ;", "final   Object   o    =    new   Object (  )  ;", "element . setObject ( o )  ;", "assertSame ( o ,    element . getObject (  )  )  ;", "element    =    createElement (  \"  \"  ,    DomBasicsTest . InheritedElement . class )  ;", "element . setObject ( o )  ;", "assertSame ( o ,    element . getObject (  )  )  ;", "assertSame ( o ,    element . getObject (  )  )  ;", "}", "METHOD_END"], "methodName": ["testInstanceImplementation"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( getDomManager (  )  . getGenericInfo ( DomBasicsTest . MyElement . class )  . isTagValueElement (  )  )  ;", "assertFalse ( getDomManager (  )  . getGenericInfo ( DomBasicsTest . AnotherElement . class )  . isTagValueElement (  )  )  ;", "}", "METHOD_END"], "methodName": ["testIsTagValueElement"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "Module   module    =    new   com . intellij . mock . MockModule ( getTestRootDisposable (  )  )  ;", "final   DomBasicsTest . MyElement   element    =    getDomManager (  )  . createMockElement ( DomBasicsTest . MyElement . class ,    module ,    false )  ;", "assertSame ( module ,    element . getModule (  )  )  ;", "assertTrue ( element . isValid (  )  )  ;", "assertNull ( element . getXmlTag (  )  )  ;", "assertEquals ( element ,    DomUtil . getFileElement ( element )  . getRootElement (  )  )  ;", "assertFalse ( DomUtil . getFile ( element )  . isPhysical (  )  )  ;", "final   DomBasicsTest . MyElement   element 2     =    getDomManager (  )  . createMockElement ( DomBasicsTest . MyElement . class ,    null ,    false )  ;", "assertNull ( element 2  . getModule (  )  )  ;", "assertNull ( element 2  . getXmlTag (  )  )  ;", "element 2  . addChildElement (  )  . getGenericValue (  )  . setStringValue (  \" xxx \"  )  ;", "assertNotNull ( element 2  . getXmlTag (  )  )  ;", "final   DomBasicsTest . MyElement   oldChild    =    element 2  . getChild (  )  ;", "element . getAttr (  )  . setValue (  \" attr \"  )  ;", "element . getGenericValue (  )  . setValue ( Boolean . TRUE )  ;", "element . getChild (  )  . getGenericValue (  )  . setStringValue (  \" abc \"  )  ;", "element . addChildElement (  )  . getGenericValue (  )  . setStringValue (  \" def \"  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "element 2  . copyFrom ( element )  ;", "}  )  ;", "assertEquals (  \" attr \"  ,    element 2  . getAttr (  )  . getValue (  )  )  ;", "assertEquals (  \" true \"  ,    element 2  . getGenericValue (  )  . getStringValue (  )  )  ;", "final   DomBasicsTest . MyElement   newChild    =    element 2  . getChild (  )  ;", "assertEquals (  \" abc \"  ,    newChild . getGenericValue (  )  . getStringValue (  )  )  ;", "final   List < DomBasicsTest . MyElement >    childElements    =    element 2  . getChildElements (  )  ;", "assertEquals (  1  ,    childElements . size (  )  )  ;", "assertEquals (  \" def \"  ,    childElements . get (  0  )  . getGenericValue (  )  . getStringValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMockElements"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "final   DomBasicsTest . MyElement   element    =    createElement (  \"  < a /  >  \"  )  ;", "final   long   count    =    DomUtil . getFileElement ( element )  . getModificationCount (  )  ;", "element . addChildElement (  )  ;", "assertTrue (  (  ( DomUtil . getFileElement ( element )  . getModificationCount (  )  )     >    count )  )  ;", "}", "METHOD_END"], "methodName": ["testModificationCount"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  (  ( createElement (  \"  < a /  >  \"  )  . getNameStrategy (  )  )    instanceof   HyphenNameStrategy )  )  ;", "final    . AnotherElement   anotherElement    =    createElement (  \"  < a /  >  \"  ,     . AnotherElement . class )  ;", "assertTrue (  (  ( anotherElement . getNameStrategy (  )  )    instanceof   JavaNameStrategy )  )  ;", "assertTrue (  (  ( anotherElement . getChild (  )  . getNameStrategy (  )  )    instanceof   JavaNameStrategy )  )  ;", "}", "METHOD_END"], "methodName": ["testNameStrategy"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "DomApplicationComponent . getInstance (  )  . registerImplementation ( DomBasicsTest . AnotherElement . class ,    DomBasicsTest . EmptyImpl . class ,    getTestRootDisposable (  )  )  ;", "DomApplicationComponent . getInstance (  )  . registerImplementation ( DomElement . class ,    DomBasicsTest . BaseImpl . class ,    getTestRootDisposable (  )  )  ;", "final   DomBasicsTest . AnotherElement   element    =    createElement (  \"  \"  ,    DomBasicsTest . AnotherElement . class )  ;", "assertTrue ( element . getClass (  )  . getSuperclass (  )  . getName (  )  ,     ( element   instanceof   DomBasicsTest . EmptyImpl )  )  ;", "}", "METHOD_END"], "methodName": ["testRegisteringImplementation"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =    DomTestCase . createXmlFile (  \"  < a /  >  \"  )  ;", "final   DomManagerImpl   manager    =    getDomManager (  )  ;", "final   DomFileElementImpl < DomElement >    fileElement    =    manager . getFileElement ( file ,    DomElement . class ,     \" a \"  )  ;", "final   DomElement   rootElement    =    fileElement . getRootElement (  )  ;", "assertNotNull ( rootElement )  ;", "assertTrue ( rootElement . exists (  )  )  ;", "rootElement . undefine (  )  ;", "assertFalse ( rootElement . exists (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRootElementUndefineNotExisting"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "DomBasicsTest . InheritedElement   element    =    createElement (  \"  \"  ,    DomBasicsTest . InheritedElement . class )  ;", "final   Object   o    =    new   Object (  )  ;", "element . setObject ( o )  ;", "assertSame ( o ,    element . getObject (  )  )  ;", "assertSame ( o ,    element .  _ getObject (  )  )  ;", "element . setString (  \" foo \"  )  ;", "assertEquals (  \" foo \"  ,    element . getString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSeveralInstanceImplementations"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "final   DomBasicsTest . MyElement   element    =    createElement (  \"  < a >  < child - element /  >  < child - element >  < child /  >  <  / child - element >  <  / a >  \"  )  ;", "final   DomBasicsTest . MyElement   parent    =    element . getChildElements (  )  . get (  1  )  ;", "final   DomBasicsTest . MyElement   child    =    parent . getChild (  )  ;", "final   DomBasicsTest . MyElement   copy    =     (  ( DomBasicsTest . MyElement )     ( child . createStableCopy (  )  )  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "parent . undefine (  )  ;", "element . addChildElement (  )  . getChild (  )  . ensureXmlElementExists (  )  ;", "}  )  ;", "assertFalse ( child . isValid (  )  )  ;", "assertTrue ( copy . isValid (  )  )  ;", "}", "METHOD_END"], "methodName": ["testStableCopies"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "XmlFile   xmlFile    =     (  ( XmlFile )     ( PsiFileFactory . getInstance ( getProject (  )  )  . createFileFromText ( XMLLanguage . INSTANCE ,     \"  < a >  < child - element /  >  < child - element /  >  <  / a >  \"  )  )  )  ;", "VirtualFile   file    =    xmlFile . getViewProvider (  )  . getVirtualFile (  )  ;", "getDomManager (  )  . registerFileDescription ( new   impl . MockDomFileDescription ( DomBasicsTest . MyElement . class ,     \" a \"  ,    file )  ,    getTestRootDisposable (  )  )  ;", "DomBasicsTest . MyElement   element    =    getDomManager (  )  . getFileElement ( xmlFile ,    DomBasicsTest . MyElement . class )  . getRootElement (  )  . getChildElements (  )  . get (  1  )  ;", "DomBasicsTest . MyElement   copy    =    element . createStableCopy (  )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >     (  ( FileManagerImpl )     ( PsiManagerEx . getInstanceEx ( getProject (  )  )  . getFileManager (  )  )  )  . forceReload ( file )  )  ;", "assertFalse ( element . isValid (  )  )  ;", "assertTrue ( copy . isValid (  )  )  ;", "}", "METHOD_END"], "methodName": ["testStableCopySurvivesPsiFileInvalidation"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "final   DomBasicsTest . MyElement [  ]    element    =    new   DomBasicsTest . MyElement [  ]  {    null    }  ;", "final   DomBasicsTest . MyElement   stable    =    getDomManager (  )  . createStableValue (  (  )     -  >     {", "try    {", "return   element [  0  ]     =    createElement (  \"  < root /  >  \"  )  . addChildElement (  )  ;", "}    catch    (    e )     {", "throw   new    < e > RuntimeException (  )  ;", "}", "}  )  ;", "assertNotNull ( element [  0  ]  )  ;", "assertSame ( element [  0  ]  ,     (  ( StableElement )     ( stable )  )  . getWrappedElement (  )  )  ;", "assertEquals ( element [  0  ]  ,    stable )  ;", "assertEquals ( stable ,    element [  0  ]  )  ;", "DomBasicsTest . MyElement   oldElement    =    element [  0  ]  ;", "assertFalse ( stable . getChild (  )  . equals ( stable )  )  ;", "final   GenericDomValue < Boolean >    oldGenericValue    =    stable . getGenericValue (  )  ;", "assertEquals ( oldGenericValue ,    oldElement . getGenericValue (  )  )  ;", "assertEquals ( stable . getChild (  )  ,    oldElement . getChild (  )  )  ;", "assertSame ( element [  0  ]  ,    oldElement )  ;", "final   DomBasicsTest . MyElement   child 1     =    stable . addChildElement (  )  ;", "final   DomBasicsTest . MyElement   child 2     =    stable . addChildElement (  )  ;", "DomBasicsTest . MyElement   oldChild 1     =    oldElement . getChildElements (  )  . get (  0  )  ;", "assertEquals ( oldChild 1  ,    child 1  )  ;", "assertEquals ( child 1  ,    oldChild 1  )  ;", "final   DomBasicsTest . MyElement   oldElement 1     =    oldElement ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "oldElement 1  . undefine (  )  ;", "}  )  ;", "assertFalse ( oldChild 1  . isValid (  )  )  ;", "assertFalse ( oldElement . isValid (  )  )  ;", "assertFalse ( element [  0  ]  . isValid (  )  )  ;", "assertTrue ( stable . isValid (  )  )  ;", "assertTrue ( element [  0  ]  . isValid (  )  )  ;", "assertNotSame ( element [  0  ]  ,    oldElement )  ;", "assertFalse ( child 1  . isValid (  )  )  ;", "assertFalse ( child 2  . isValid (  )  )  ;", "assertEquals ( DomUtil . getFileElement ( element [  0  ]  )  ,    DomUtil . getFileElement ( stable )  )  ;", "assertEquals ( element [  0  ]  . getParent (  )  ,    stable . getParent (  )  )  ;", "oldElement    =    element [  0  ]  ;", "oldChild 1     =    oldElement . getChild (  )  ;", "(  ( StableElement )     ( stable )  )  . invalidate (  )  ;", "assertTrue ( oldElement . isValid (  )  )  ;", "assertTrue ( oldChild 1  . isValid (  )  )  ;", "assertFalse ( oldElement . equals (  (  ( StableElement )     ( stable )  )  . getWrappedElement (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testStableValues"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "final   DomBasicsTest . MyElement   oldElement    =    createElement (  \"  \"  )  ;", "final   DomBasicsTest . MyElement [  ]    element    =    new   DomBasicsTest . MyElement [  ]  {    oldElement    }  ;", "final   DomBasicsTest . MyElement   stable    =    getDomManager (  )  . createStableValue (  (  )     -  >    element [  0  ]  )  ;", "element [  0  ]     =    null ;", "(  ( StableElement )     ( stable )  )  . invalidate (  )  ;", "assertEquals ( stable ,    stable )  ;", "assertEquals ( oldElement . toString (  )  ,    stable . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testStable_Invalidate"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "final   DomBasicsTest . MyElement [  ]    element    =    new   DomBasicsTest . MyElement [  ]  {    createElement (  \"  \"  )     }  ;", "final   DomBasicsTest . MyElement   stable    =    getDomManager (  )  . createStableValue (  (  )     -  >    element [  0  ]  )  ;", "DomBasicsTest . MyElement   oldElement    =    element [  0  ]  ;", "(  ( StableElement )     ( stable )  )  . revalidate (  )  ;", "assertSame ( oldElement ,     (  ( StableElement )     ( stable )  )  . getWrappedElement (  )  )  ;", "element [  0  ]     =    createElement (  \"  \"  )  ;", "assertTrue ( oldElement . isValid (  )  )  ;", "(  ( StableElement )     ( stable )  )  . revalidate (  )  ;", "assertTrue ( oldElement . isValid (  )  )  ;", "assertNotSame ( oldElement ,     (  ( StableElement )     ( stable )  )  . getWrappedElement (  )  )  ;", "assertSame ( element [  0  ]  ,     (  ( StableElement )     ( stable )  )  . getWrappedElement (  )  )  ;", "}", "METHOD_END"], "methodName": ["testStable_Revalidate"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "final   DomBasicsTest . MyElement   element    =    createElement (  \"  \"  )  ;", "final   GenericAttributeValue < String >    attr    =    element . getChild (  )  . getChild (  )  . getAttr (  )  ;", "assertNotNull ( attr )  ;", "assertEquals ( element . getChildChildAttr (  )  ,    attr )  ;", "final   GenericAttributeValue < String >    attr 1     =    element . getChild (  )  . addChildElement (  )  . getAttr (  )  ;", "final   GenericAttributeValue < String >    attr 2     =    element . getChild (  )  . addChildElement (  )  . getAttr (  )  ;", "assertOrderedEquals ( element . getChildChildrenAttr (  )  ,    attr 1  ,    attr 2  )  ;", "}", "METHOD_END"], "methodName": ["testSubPropertyAccessing"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "final   Integer [  ]    visits    =    new   Integer [  ]  {     0  ,     0  ,     0     }  ;", "DomElementVisitor   visitor    =    new    . MyVisitor (  )     {", "@ Override", "public   void   visit (  . InheritedElement   element )     {", "( visits [  0  ]  )  +  +  ;", "}", "@ Override", "public   void   visitDomElement ( DomElement   element )     {", "( visits [  1  ]  )  +  +  ;", "}", "@ Override", "public   void   visitMyElement (  . MyElement   element )     {", "( visits [  2  ]  )  +  +  ;", "}", "}  ;", "createElement (  \"  \"  ,     . MyElement . class )  . accept ( visitor )  ;", "final   List < Integer >    visitsList    =    Arrays . asList ( visits )  ;", "assertEquals ( Arrays . asList (  0  ,     0  ,     1  )  ,    visitsList )  ;", "createElement (  \"  \"  ,     . InheritedElement . class )  . accept ( visitor )  ;", "assertEquals ( Arrays . asList (  1  ,     0  ,     1  )  ,    visitsList )  ;", "createElement (  \"  \"  ,     . AnotherElement . class )  . accept ( visitor )  ;", "assertEquals ( Arrays . asList (  1  ,     1  ,     1  )  ,    visitsList )  ;", "createElement (  \"  \"  ,    DomElement . class )  . accept ( visitor )  ;", "assertEquals ( Arrays . asList (  1  ,     2  ,     1  )  ,    visitsList )  ;", "createElement (  \"  \"  ,     . InheritedElement . class )  . accept ( new   DomElementVisitor (  )     {", "@ Override", "public   void   visitDomElement ( DomElement   element )     {", "( visits [  1  ]  )  +  +  ;", "}", "}  )  ;", "assertEquals ( Arrays . asList (  1  ,     3  ,     1  )  ,    visitsList )  ;", "}", "METHOD_END"], "methodName": ["testVisitor"], "fileName": "com.intellij.util.xml.DomBasicsTest"}, {"methodBody": ["METHOD_START", "{", "ResourceBundle   bundle    =    SoftReference . dereference ( DomBundle . ourBundle )  ;", "if    ( bundle    =  =    null )     {", "bundle    =    ResourceBundle . getBundle ( DomBundle . PATH _ TO _ BUNDLE )  ;", "DomBundle . ourBundle    =    new   SoftReference <  >  ( bundle )  ;", "}", "return   bundle ;", "}", "METHOD_END"], "methodName": ["getBundle"], "fileName": "com.intellij.util.xml.DomBundle"}, {"methodBody": ["METHOD_START", "{", "return   CommonBundle . message ( DomBundle . getBundle (  )  ,    key ,    params )  ;", "}", "METHOD_END"], "methodName": ["message"], "fileName": "com.intellij.util.xml.DomBundle"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  2  ,    subBars . size (  )  )  ;", "assertEquals (  \" foo \"  ,    subBars . get (  0  )  . getValue (  )  )  ;", "assertEquals (  \" bar \"  ,    subBars . get (  1  )  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertSubBars"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "return   createElement ( xml ,    DomChildrenTest . MyElement . class )  ;", "}", "METHOD_END"], "methodName": ["createElement"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "return   ContainerUtil . map 2 List ( DomUtil . getFixedPath ( element )  ,     (    s )     -  >    s . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getFixedPath"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "final   DomChildrenTest . MyElement   element    =    createElement (  \"  < a >  < child - element /  >  <  / a >  \"  )  ;", "assertEquals (  1  ,    element . getChildElements (  )  . size (  )  )  ;", "final   DomChildrenTest . MyElement   firstChild    =    element . getChildElements (  )  . get (  0  )  ;", "final   XmlTag   firstChildTag    =    element . getXmlTag (  )  . findSubTags (  \" child - element \"  )  [  0  ]  ;", "assertCached ( firstChild ,    firstChildTag )  ;", "final   DomChildrenTest . MyElement   child    =    element . addChildElement (  )  ;", "assertEquals ( Arrays . asList ( firstChild ,    child )  ,    element . getChildElements (  )  )  ;", "final   XmlTag   childTag    =    element . getXmlTag (  )  . findSubTags (  \" child - element \"  )  [  1  ]  ;", "putExpected ( new   DomEvent ( element ,    false )  )  ;", "final   DomElement   element 1     =    child . getAttr (  )  ;", "putExpected ( new   DomEvent ( element 1  ,    true )  )  ;", "final   DomElement   element 2     =    child . isGenericValue (  )  ;", "putExpected ( new   DomEvent ( element 2  ,    true )  )  ;", "final   DomChildrenTest . MyElement   newChild    =    element . addChildElement (  1  )  ;", "assertEquals ( Arrays . asList ( firstChild ,    newChild ,    child )  ,    element . getChildElements (  )  )  ;", "final   XmlTag   newChildTag    =    element . getXmlTag (  )  . findSubTags (  \" child - element \"  )  [  1  ]  ;", "putExpected ( new   DomEvent ( element ,    false )  )  ;", "final   DomElement   element 3     =    newChild . getAttr (  )  ;", "putExpected ( new   DomEvent ( element 3  ,    true )  )  ;", "final   DomElement   element 4     =    newChild . isGenericValue (  )  ;", "putExpected ( new   DomEvent ( element 4  ,    true )  )  ;", "final   DomChildrenTest . MyElement   lastChild    =    element . addChildElement (  2  3  9  )  ;", "assertEquals ( Arrays . asList ( firstChild ,    newChild ,    child ,    lastChild )  ,    element . getChildElements (  )  )  ;", "final   XmlTag   lastChildTag    =    element . getXmlTag (  )  . findSubTags (  \" child - element \"  )  [  3  ]  ;", "putExpected ( new   DomEvent ( element ,    false )  )  ;", "final   DomElement   element 5     =    lastChild . getAttr (  )  ;", "putExpected ( new   DomEvent ( element 5  ,    true )  )  ;", "final   DomElement   element 6     =    lastChild . isGenericValue (  )  ;", "putExpected ( new   DomEvent ( element 6  ,    true )  )  ;", "assertResultsAndClear (  )  ;", "assertCached ( firstChild ,    firstChildTag )  ;", "assertCached ( newChild ,    newChildTag )  ;", "assertCached ( child ,    childTag )  ;", "assertCached ( lastChild ,    lastChildTag )  ;", "assertSame ( firstChildTag ,    element . getXmlTag (  )  . findSubTags (  \" child - element \"  )  [  0  ]  )  ;", "assertSame ( newChildTag ,    element . getXmlTag (  )  . findSubTags (  \" child - element \"  )  [  1  ]  )  ;", "assertSame ( childTag ,    element . getXmlTag (  )  . findSubTags (  \" child - element \"  )  [  2  ]  )  ;", "assertSame ( lastChildTag ,    element . getXmlTag (  )  . findSubTags (  \" child - element \"  )  [  3  ]  )  ;", "}", "METHOD_END"], "methodName": ["testAddChild"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "getTypeChooserManager (  )  . registerTypeChooser ( DomChildrenTest . MyAbstractElement . class ,    new   DomChildrenTest . MyTypeChooser (  )  )  ;", "try    {", "DomChildrenTest . MyElement   element    =    createElement (  \"  < a /  >  \"  )  ;", "element . addBarChild (  )  ;", "element . addFooChild (  )  ;", "element . addAbstractElement ( DomChildrenTest . MyFooConcreteElement . class )  ;", "element . addAbstractElement ( DomChildrenTest . MyFooConcreteElement . class ,     1  )  ;", "element . addAbstractElement (  2  ,    DomChildrenTest . MyBarConcreteElement . class )  ;", "Class [  ]    classes    =    new   Class [  ]  {    DomChildrenTest . MyBarConcreteElement . class ,    DomChildrenTest . MyFooConcreteElement . class ,    DomChildrenTest . MyBarConcreteElement . class ,    DomChildrenTest . MyFooConcreteElement . class ,    DomChildrenTest . MyFooConcreteElement . class    }  ;", "final   List < DomChildrenTest . MyAbstractElement >    abstractElements    =    element . getAbstractElements (  )  ;", "for    ( int   i    =     0  ;    i    <     ( abstractElements . size (  )  )  ;    i +  +  )     {", "DomChildrenTest . MyAbstractElement   abstractElement    =    abstractElements . get ( i )  ;", "assertTrue (  (  (  ( String . valueOf ( i )  )     +     \"     \"  )     +     ( abstractElement . getClass (  )  )  )  ,    classes [ i ]  . isInstance ( abstractElement )  )  ;", "assertEquals ( String . valueOf ( i )  ,    classes [ i ]  . getName (  )  ,    abstractElement . getXmlTag (  )  . getAttributeValue (  \" foo \"  )  )  ;", "}", "}    finally    {", "getTypeChooserManager (  )  . unregisterTypeChooser ( DomChildrenTest . MyAbstractElement . class )  ;", "}", "}", "METHOD_END"], "methodName": ["testAddConcreteElements"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "final   DomChildrenTest . MyElement   element    =    createElement (  \"  \"  )  ;", "final   DomChildrenTest . MyBarConcreteElement   bar    =    element . addBarComposite (  )  ;", "final   DomChildrenTest . MyElement   child    =    element . addChildComposite (  )  ;", "final   DomChildrenTest . MyElement   child 2     =    element . addChildElement (  )  ;", "final   DomChildrenTest . MyFooConcreteElement   foo 1     =    element . addFooComposite (  2  )  ;", "final   DomChildrenTest . MyFooConcreteElement   foo 2     =    element . addFooComposite (  0  )  ;", "assertEquals ( Arrays . asList ( foo 2  ,    bar ,    child ,    foo 1  ,    child 2  )  ,    element . getCompositeList (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAddToCompositeCollection"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "final   DomChildrenTest . MyElement   element    =    createElement (  \"  < a /  >  \"  )  ;", "final   GenericAttributeValue < String >    attr    =    element . getAttr (  )  ;", "assertSame ( element . getXmlTag (  )  ,    attr . getXmlTag (  )  )  ;", "assertNull ( attr . getValue (  )  )  ;", "assertNull ( attr . getXmlAttribute (  )  )  ;", "assertEquals ( attr ,    element . getAttr (  )  )  ;", "attr . setValue (  \"  2  3  9  \"  )  ;", "assertEquals (  \"  2  3  9  \"  ,    attr . getValue (  )  )  ;", "final   XmlAttribute   attribute    =    element . getXmlTag (  )  . getAttribute (  \" attr \"  ,    null )  ;", "assertSame ( attribute ,    attr . getXmlAttribute (  )  )  ;", "assertSame ( attribute ,    attr . getXmlElement (  )  )  ;", "assertSame ( attribute ,    attr . ensureXmlElementExists (  )  )  ;", "assertSame ( attribute . getValueElement (  )  ,    attr . getXmlAttributeValue (  )  )  ;", "attr . setValue ( null )  ;", "assertFalse ( attribute . isValid (  )  )  ;", "assertNull ( element . getXmlTag (  )  . getAttributeValue (  \" attr \"  )  )  ;", "assertNull ( attr . getValue (  )  )  ;", "assertNull ( attr . getXmlAttribute (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributes"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "final   DomChildrenTest . MyElement   element    =    createElement (  \"  < a >  < child /  >  <  / a >  \"  )  ;", "final   DomChildrenTest . MyElement   child    =    element . getChild (  )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >    element . undefine (  )  )  ;", "assertTrue ( element . isValid (  )  )  ;", "assertFalse ( child . isValid (  )  )  ;", "}", "METHOD_END"], "methodName": ["testChildrenValidAfterUndefine"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "getTypeChooserManager (  )  . registerTypeChooser ( DomChildrenTest . MyAbstractElement . class ,    new   DomChildrenTest . MyTypeChooser (  )  )  ;", "try    {", "DomChildrenTest . MyElement   element    =    createElement (  (  \"  < a >  \"     +     (  (  (  \"  < abstract - child > Foo <  / abstract - child >  \"     +     \"  < abstract - element > Foo <  / abstract - element >  \"  )     +     \"  < abstract - element > bar <  / abstract - element >  \"  )     +     \"  <  / a >  \"  )  )  )  ;", "assertFalse (  (  ( element . getAbstractChild (  )  )    instanceof   DomChildrenTest . MyBarConcreteElement )  )  ;", "final   List < DomChildrenTest . MyAbstractElement >    abstractElements    =    element . getAbstractElements (  )  ;", "assertTrue (  (  ( abstractElements . get (  0  )  )    instanceof   DomChildrenTest . MyFooConcreteElement )  )  ;", "assertTrue (  (  ( abstractElements . get (  1  )  )    instanceof   DomChildrenTest . MyBarConcreteElement )  )  ;", "}    finally    {", "getTypeChooserManager (  )  . unregisterTypeChooser ( DomChildrenTest . MyAbstractElement . class )  ;", "}", "}", "METHOD_END"], "methodName": ["testClassChoosers"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "final   DomChildrenTest . MyElement   element    =    createElement (  \"  \"  )  . addChildElement (  )  ;", "assertNotNull ( element . getAttr (  )  . getXmlAttribute (  )  )  ;", "assertNotNull ( element . isGenericValue (  )  . getXmlTag (  )  )  ;", "assertTrue ( element . getMyChildren 2  (  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCreateElementWithRequiredChild"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "final   DomChildrenTest . MyElement   myElement    =    createElement (  \"  < a >  < foo /  >  < bar /  >  < foo   xmlns =  \\  \" z \\  \"  /  >  <  / a >  \"  ,    DomChildrenTest . MyElement . class )  ;", "final   XmlTag   tag    =    myElement . getXmlTag (  )  ;", "final   List < DomChildrenTest . MyElement >    customChildren    =    myElement . getCustomChildren (  )  ;", "assertOrderedEquals ( customChildren ,    myElement . getGenericInfo (  )  . getCustomNameChildrenDescription (  )  . get (  0  )  . getValues ( myElement )  )  ;", "assertOrderedCollection ( customChildren ,     (    element )     -  >     {", "assertInstanceOf ( element ,     . class )  ;", "assertEquals ( tag . getSubTags (  )  [  0  ]  ,    element . getXmlTag (  )  )  ;", "}  ,     (    element )     -  >     {", "assertInstanceOf ( element ,     . class )  ;", "assertEquals ( tag . getSubTags (  )  [  1  ]  ,    element . getXmlTag (  )  )  ;", "}  ,     (    element )     -  >     {", "assertInstanceOf ( element ,     . class )  ;", "assertEquals ( tag . getSubTags (  )  [  2  ]  ,    element . getXmlTag (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testCustomNameChildren"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "final   DomChildrenTest . MyElement   element    =    createElement (  \"  < a /  >  \"  )  ;", "final   XmlTag   tag    =    element . getChild 2  (  )  . ensureTagExists (  )  ;", "final   XmlTag [  ]    subTags    =    element . getXmlTag (  )  . findSubTags (  \" child \"  )  ;", "assertEquals (  2  ,    subTags . length )  ;", "assertSame ( tag ,    subTags [  1  ]  )  ;", "assertCached ( element . getChild (  )  ,    subTags [  0  ]  )  ;", "final   DomElement   element 1     =    element . getChild (  )  ;", "putExpected ( new   DomEvent ( element 1  ,    true )  )  ;", "final   DomElement   element 2     =    element . getChild (  )  . getAttr (  )  ;", "putExpected ( new   DomEvent ( element 2  ,    true )  )  ;", "final   DomElement   element 3     =    element . getChild (  )  . isGenericValue (  )  ;", "putExpected ( new   DomEvent ( element 3  ,    true )  )  ;", "final   DomElement   element 4     =    element . getChild 2  (  )  ;", "putExpected ( new   DomEvent ( element 4  ,    true )  )  ;", "final   DomElement   element 5     =    element . getChild 2  (  )  . getAttr (  )  ;", "putExpected ( new   DomEvent ( element 5  ,    true )  )  ;", "final   DomElement   element 6     =    element . getChild 2  (  )  . isGenericValue (  )  ;", "putExpected ( new   DomEvent ( element 6  ,    true )  )  ;", "assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["testDefiningIndexedChild"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "final   DomChildrenTest . MyElement   element    =    createElement (  \"  < a /  >  \"  )  ;", "final   DomChildrenTest . MyElement   child    =    element . getChild (  )  ;", "final   DomChildrenTest . MyElement   child 2     =    element . getChild 2  (  )  ;", "final   PsiElement   tag    =    element . getXmlTag (  )  . add ( createTag (  \"  < child /  >  \"  )  )  ;", "DomTestCase . incModCount (  )  ;", "assertTrue ( child . isValid (  )  )  ;", "assertEquals ( tag ,    child . getXmlTag (  )  )  ;", "assertTrue ( child 2  . isValid (  )  )  ;", "assertNull ( child 2  . getXmlTag (  )  )  ;", "}", "METHOD_END"], "methodName": ["testElementsWithoutXmlGetItLater"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "final   DomChildrenTest . MyElement   element    =    createElement (  \"  < a >  < generic - child >  2  3  9  <  / generic - child >  <  / a >  \"  )  ;", "assertEquals (  2  3  9  ,     (  ( int )     ( element . getGenericChildren (  )  . get (  0  )  . getValue (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericValuesCollection"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "final   DomChildrenTest . MyElement   element    =    createElement (  (  \"  < a >  \"     +     (  \"  < child > foo <  / child >  \"     +     \"  <  / a >  \"  )  )  )  ;", "element . toString (  )  ;", "assertEquals (  \" foo \"  ,    element . getMyChild (  )  . getValue (  )  )  ;", "assertEquals (  \" foo \"  ,    element . getChild (  )  . getValue (  )  )  ;", "assertSame ( element . getChild (  )  ,    element . getMyChild (  )  )  ;", "assertNull ( element . getChild 2  3  9  (  )  . getXmlTag (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetChild"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "final   DomChildrenTest . MyElement   element    =    createElement (  \"  < a >  < child /  >  < child -  2  3  9  /  >  <  / a >  \"  )  ;", "assertNotNull ( element . getChild 2  3  9  (  )  . getXmlTag (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetChild239"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "final   DomChildrenTest . MyElement   element    =    createElement (  (  \"  < a >  \"     +     (  (  \"  < child - element > foo <  / child - element >  \"     +     \"  < child - element > bar <  / child - element >  \"  )     +     \"  <  / a >  \"  )  )  )  ;", "assertSubBars ( element . getMyChildren (  )  )  ;", "assertSubBars ( element . getChildElements (  )  )  ;", "assertSubBars ( element . getMyChildren 2  (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetChildren"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "final   DomChildrenTest . MyElement   element    =    createElement (  (  \"  < a >  \"     +     (  (  (  \"  < child - element >  \"     +     \"     < child - element /  >  \"  )     +     \"  <  / child - element >  \"  )     +     \"  <  / a >  \"  )  )  )  ;", "for    ( int   i    =     0  ;    i    <     2  3  9  ;    i +  +  )     {", "final   List < DomChildrenTest . MyElement >    children    =    element . getChildElements (  )  ;", "final   DomChildrenTest . MyElement   child    =    children . get (  0  )  ;", "final   List < DomChildrenTest . MyElement >    children 1     =    child . getChildElements (  )  ;", "final   DomChildrenTest . MyElement   child 1     =    children 1  . get (  0  )  ;", "assertNotNull ( child 1  . getChild (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testGetChildrenMultipleTimes"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "final   DomChildrenTest . MyElement   element    =    createElement (  \"  \"  )  ;", "final   DomChildrenTest . MyFooConcreteElement   foo    =    element . addFooChild (  )  ;", "final   DomChildrenTest . MyElement   child    =    element . addChildElement (  )  ;", "final   DomChildrenTest . MyBarConcreteElement   bar    =    element . addBarChild (  )  ;", "assertEquals ( Arrays . asList ( foo ,    bar ,    child )  ,    element . getCompositeList (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetCompositeCollection"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "final   DomChildrenTest . MyElement   myElement    =    createElement (  \"  < a >  < abstract - child /  >  < generic - value /  >  < bar /  >  <  / a >  \"  ,    DomChildrenTest . MyElement . class )  ;", "final   XmlTag   tag    =    myElement . getXmlTag (  )  ;", "assertEquals (  1  ,    myElement . getCustomChildren (  )  . size (  )  )  ;", "assertInstanceOf ( getDomManager (  )  . getDomElement ( tag . getSubTags (  )  [  0  ]  )  ,    DomChildrenTest . MyAbstractElement . class )  ;", "assertInstanceOf ( getDomManager (  )  . getDomElement ( tag . getSubTags (  )  [  1  ]  )  ,    GenericDomValue . class )  ;", "assertInstanceOf ( getDomManager (  )  . getDomElement ( tag . getSubTags (  )  [  2  ]  )  ,    DomChildrenTest . MyElement . class )  ;", "}", "METHOD_END"], "methodName": ["testGetDomElementCustomChild"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "final   DomChildrenTest . MyElement   element    =    createElement (  \"  \"  )  ;", "final   DomChildrenTest . MyElement   child 2     =    element . getChild 2  (  )  ;", "assertEquals ( Arrays . asList (  \" getChild 2  \"  ,     \" getChild 2  \"  ,     \" getChild 2  3  9  \"  ,     \" getAbstractChild \"  ,     \" getChild 2  \"  )  ,    getFixedPath ( child 2  . getChild 2  (  )  . getChild 2  3  9  (  )  . getAbstractChild (  )  . getChild 2  (  )  )  )  ;", "assertEquals ( Arrays . asList (  \" getChild 2  \"  )  ,    getFixedPath ( child 2  )  )  ;", "assertEquals ( Arrays . asList (  )  ,    getFixedPath ( element )  )  ;", "assertEquals ( Arrays . asList (  \" getAttr \"  )  ,    getFixedPath ( element . getAttr (  )  )  )  ;", "assertNull ( DomUtil . getFixedPath ( element . addChildElement (  )  . getChild (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetFixedPath"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "getTypeChooserManager (  )  . registerTypeChooser ( DomChildrenTest . MyAbstractElement . class ,    new   DomChildrenTest . MyTypeChooser (  )  )  ;", "try    {", "final   DomChildrenTest . MyElement   element    =    createElement (  \"  \"  )  ;", "final   DomChildrenTest . MyAbstractElement   abstractChild    =    element . getAbstractChild (  )  ;", "final   DomChildrenTest . MyElement   child 2  3  9     =    abstractChild . getChild 2  3  9  (  )  ;", "assertSame ( child 2  3  9  ,    child 2  3  9  . getParentOfType ( DomChildrenTest . MyElement . class ,    false )  )  ;", "assertSame ( abstractChild ,    child 2  3  9  . getParentOfType ( DomChildrenTest . MyElement . class ,    true )  )  ;", "assertSame ( abstractChild ,    child 2  3  9  . getParentOfType ( DomChildrenTest . MyAbstractElement . class ,    true )  )  ;", "assertSame ( DomUtil . getFileElement ( element )  ,    child 2  3  9  . getParentOfType ( DomFileElement . class ,    false )  )  ;", "assertSame ( DomUtil . getFileElement ( element )  ,    DomUtil . getFileElement ( element )  . getParentOfType ( DomFileElement . class ,    false )  )  ;", "assertNull ( DomUtil . getFileElement ( element )  . getParentOfType ( DomFileElement . class ,    true )  )  ;", "}    finally    {", "getTypeChooserManager (  )  . unregisterTypeChooser ( DomChildrenTest . MyAbstractElement . class )  ;", "}", "}", "METHOD_END"], "methodName": ["testGetParentOfType"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "final   DomChildrenTest . MyElement   element    =    createElement (  \"  < a >  < child /  >  < child /  >  < child /  >  <  / a >  \"  )  ;", "XmlTag   third    =    element . getXmlTag (  )  . getSubTags (  )  [  2  ]  ;", "assertNull ( getDomManager (  )  . getDomElement ( third )  )  ;", "assertEmpty ( element . getCustomChildren (  )  )  ;", "}", "METHOD_END"], "methodName": ["testHigherOrderFixedsAreNotCustom"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "DomChildrenTest . MyElement   element    =    createElement (  (  \"  < a >  \"     +     (  (  \"  < child > foo <  / child >  \"     +     \"  < child > bar <  / child >  \"  )     +     \"  <  / a >  \"  )  )  )  ;", "assertCached ( element . getChild 2  (  )  ,    element . getXmlTag (  )  . getSubTags (  )  [  1  ]  )  ;", "assertEquals (  0  ,    element . getChildElements (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testIndexedChild"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "assertNull ( createElement (  \"  \"  )  . isGenericValue (  )  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testIsBooleanGenericValueMethod"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "final   DomChildrenTest . MyElement   myElement    =    createElement (  \"  < a >  <  <  / a >  \"  ,    DomChildrenTest . MyElement . class )  ;", "final   XmlTag   tag    =    myElement . getXmlTag (  )  ;", "assertEquals (  0  ,    myElement . getCustomChildren (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNoChildrenForMalformedTags"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "final   DomChildrenTest . MyElement   element    =    createElement (  \"  < a /  >  \"  )  . getChild (  )  ;", "element . isGenericValue (  )  . setStringValue (  \" true \"  )  ;", "assertEquals (  1  ,    element . getXmlTag (  )  . findSubTags (  \" generic - value \"  )  . length )  ;", "assertTrue ( element . isGenericValue (  )  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetRequiredChildValue"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "final   DomChildrenTest . MyElement   element    =    createElement (  \"  < a >  < child - element /  >  < child - element /  >  < child - element /  >  <  / a >  \"  )  ;", "final   DomChildrenTest . MyElement   child 1     =    element . getChildElements (  )  . get (  0  )  ;", "final   DomChildrenTest . MyElement   child 2     =    element . getChildElements (  )  . get (  1  )  ;", "final   DomChildrenTest . MyElement   child 3     =    element . getChildElements (  )  . get (  2  )  ;", "final   List < XmlTag >    oldChildren    =    new   ArrayList <  >  ( Arrays . asList ( element . getXmlTag (  )  . getSubTags (  )  )  )  ;", "assertTrue ( child 2  . isValid (  )  )  ;", "assertEquals ( element ,    child 2  . getParent (  )  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "child 2  . undefine (  )  ;", "assertFalse ( child 2  . isValid (  )  )  ;", "oldChildren . remove (  1  )  ;", "assertEquals ( oldChildren ,    Arrays . asList ( element . getXmlTag (  )  . getSubTags (  )  )  )  ;", "assertEquals ( Arrays . asList ( child 1  ,    child 3  )  ,    element . getChildElements (  )  )  ;", "assertCached ( child 1  ,    element . getXmlTag (  )  . findSubTags (  \" child - element \"  )  [  0  ]  )  ;", "assertCached ( child 3  ,    element . getXmlTag (  )  . findSubTags (  \" child - element \"  )  [  1  ]  )  ;", "}  )  ;", "myCallRegistry . putExpected ( new   DomEvent ( element ,    false )  )  ;", "myCallRegistry . assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["testUndefineCollectionChild"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "WriteCommandAction . writeCommandAction ( getProject (  )  )  . run (  (  )     -  >     {", "final   MyElement   child    =    createElement (  \"  < a >  < child /  >  <  / a >  \"  )  . get (  )  ;", "incModCount (  )  ;", "child . ensureTagExists (  )  ;", "assertTrue ( child . isValid (  )  )  ;", "assertNotNull ( child . getXmlElement (  )  )  ;", "incModCount (  )  ;", "child . undefine (  )  ;", "assertTrue ( child . isValid (  )  )  ;", "assertNull ( child . getXmlElement (  )  )  ;", "child . ensureTagExists (  )  ;", "incModCount (  )  ;", "assertTrue ( child . isValid (  )  )  ;", "assertNotNull ( child . getXmlElement (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testUndefineFixedChild"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "WriteCommandAction . writeCommandAction ( getProject (  )  )  . run (  (  )     -  >     {", "final   MyElement   element    =    createElement (  \"  < a /  >  \"  )  ;", "final   MyElement   child    =    element . get (  )  ;", "child . undefine (  )  ;", "myCallRegistry . assertResultsAndClear (  )  ;", "assertTrue ( child . isValid (  )  )  ;", "assertEquals (  0  ,    element . getXmlTag (  )  . getSubTags (  )  . length )  ;", "assertSame ( element ,    child . getParent (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testUndefineFixedChildWithNoTag"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "WriteCommandAction . writeCommandAction ( getProject (  )  )  . run (  (  )     -  >     {", "final   MyElement   element    =    createElement (  (  \"  < a >  \"     +     (  (  (  \"  < child >  1  <  / child >  \"     +     \"  < child   attr =  \\  \"  \\  \"  >  2  <  / child >  \"  )     +     \"  < child   attr =  \\  \"  \\  \"  >  2  <  / child >  \"  )     +     \"  <  / a >  \"  )  )  )  ;", "final   MyElement   child    =    element . get (  )  ;", "final   MyElement   child 2     =    element . get 2  (  )  ;", "child 2  . undefine (  )  ;", "myCallRegistry . putExpected ( new   DomEvent ( child 2  ,    false )  )  ;", "myCallRegistry . assertResultsAndClear (  )  ;", "XmlTag [  ]    subTags    =    element . getXmlTag (  )  . getSubTags (  )  ;", "assertTrue ( child . isValid (  )  )  ;", "assertTrue ( child 2  . isValid (  )  )  ;", "assertEquals (  1  ,    subTags . length )  ;", "assertNull ( child 2  . getXmlTag (  )  )  ;", "assertEquals ( element ,    child . getParent (  )  )  ;", "assertEquals ( element ,    child 2  . getParent (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testUndefineLastFixedChild"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "WriteCommandAction . writeCommandAction ( getProject (  )  )  . run (  (  )     -  >     {", "final   MyElement   element    =    createElement (  (  \"  < a >  \"     +     (  (  \"  < child >  1  <  / child >  \"     +     \"  < child   attr =  \\  \"  \\  \"  >  2  <  / child >  \"  )     +     \"  < child /  >  <  / a >  \"  )  )  )  ;", "final   MyElement   child    =    element . get (  )  ;", "final   MyElement   child 2     =    element . get 2  (  )  ;", "assertEquals (  \"  \"  ,    child 2  . getAttr (  )  . getValue (  )  )  ;", "assertTrue ( child . isValid (  )  )  ;", "assertTrue ( child 2  . isValid (  )  )  ;", "child . undefine (  )  ;", "assertTrue ( child . isValid (  )  )  ;", "assertTrue ( child 2  . isValid (  )  )  ;", "assertTrue ( child 2  . equals ( element . get 2  (  )  )  )  ;", "assertNotNull ( child . getXmlTag (  )  )  ;", "child 2  . undefine (  )  ;", "assertTrue ( child . isValid (  )  )  ;", "assertTrue ( child 2  . isValid (  )  )  ;", "assertTrue ( child 2  . equals ( element . get 2  (  )  )  )  ;", "assertEquals ( child ,    element . get (  )  )  ;", "assertEquals (  \"  \"  ,    child . getValue (  )  )  ;", "assertNull ( element . get 2  (  )  . getValue (  )  )  ;", "myCallRegistry . putExpected ( new   DomEvent ( child ,    false )  )  ;", "myCallRegistry . putExpected ( new   DomEvent ( child 2  ,    false )  )  ;", "myCallRegistry . assertResultsAndClear (  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testUndefineLastFixedChildWithNotEmptyCollection"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "WriteCommandAction . writeCommandAction ( getProject (  )  )  . run (  (  )     -  >     {", "final   MyElement   element    =    createElement (  (  \"  < a >  \"     +     (  (  \"  < child >  1  <  / child >  \"     +     \"  < child   attr =  \\  \"  \\  \"  >  2  <  / child >  \"  )     +     \"  <  / a >  \"  )  )  )  ;", "final   MyElement   child    =    element . get (  )  ;", "final   MyElement   child 2     =    element . get 2  (  )  ;", "assertTrue ( child . isValid (  )  )  ;", "assertTrue ( child 2  . isValid (  )  )  ;", "child . undefine (  )  ;", "assertTrue ( child . isValid (  )  )  ;", "assertTrue ( child 2  . isValid (  )  )  ;", "assertEquals ( element ,    child . getParent (  )  )  ;", "assertEquals ( element ,    child 2  . getParent (  )  )  ;", "assertEquals ( child ,    element . get (  )  )  ;", "assertEquals ( child 2  ,    element . get 2  (  )  )  ;", "myCallRegistry . putExpected ( new   DomEvent ( child ,    false )  )  ;", "myCallRegistry . assertResultsAndClear (  )  ;", "XmlTag [  ]    subTags    =    element . getXmlTag (  )  . getSubTags (  )  ;", "assertEquals (  2  ,    subTags . length )  ;", "assertCached ( child ,    subTags [  0  ]  )  ;", "assertCached ( child 2  ,    subTags [  1  ]  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testUndefineNotLastFixedChild"], "fileName": "com.intellij.util.xml.DomChildrenTest"}, {"methodBody": ["METHOD_START", "{", "final   DomExtenderEP   extenderEP    =    new   DomExtenderEP (  )  ;", "extenderEP . domClassName    =    elementClass . getName (  )  ;", "extenderEP . extenderClassName    =    extenderClass . getName (  )  ;", "PlatformTestUregisterExtension ( Extensions . getRootArea (  )  ,    DomExtenderEP . EP _ NAME ,    extenderEP ,    getTestRootDisposable (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerExtender"], "fileName": "com.intellij.util.xml.DomConcurrencyStressTest"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     (  ( threadCount    /     8  )     +     1  )  ;    i +  +  )     {", "final   Ref < Throwable >    exc    =    Ref . create ( null )  ;", "int   N    =     8  ;", "final   CountDownLatch   reads    =    new   CountDownLatch ( N )  ;", "List < Thread >    threads    =    ContainerUtil . map ( Collections . nCopies ( N ,     \"  \"  )  ,     (  ( Function < String ,    Thread >  )     (  (    s )     -  >    new   Thread (  \" dom   concurrency \"  )     {", "@ Override", "public   void   run (  )     {", "try    {", "runnable . run (  )  ;", "}    catch    (    e )     {", "exc . set ( e )  ;", "}    finally    {", "reads . countDown (  )  ;", "}", "}", "}  )  )  )  ;", "threads . forEach ( Thread :  : start )  ;", "reads . await (  )  ;", "if    (  !  ( exc . isNull (  )  )  )     {", "throw   exc . get (  )  ;", "}", "Util . joinAll ( threads )  ;", "}", "}", "METHOD_END"], "methodName": ["runThreads"], "fileName": "com.intellij.util.xml.DomConcurrencyStressTest"}, {"methodBody": ["METHOD_START", "{", "final   int   ITERATIONS    =    Timings . adjustAccordingToMySpeed (  2  3  9  ,    true )  ;", "getDomManager (  )  . registerFileDescription ( new   DomFileDescription (  . MyAllCustomElement . class ,     \" component \"  )  ,    getTestRootDisposable (  )  )  ;", "registerExtender (  . MyAllCustomElement . class ,     . MyAllCustomExtender . class )  ;", "String   line    =     \"  < tag 1  >  < tag 2  >  < tag 3    attr =  \\  \"  4  2  \\  \"  > value <  / tag 3  >  <  / tag 2  >  <  / tag 1  >  \\ n \"  ;", "String   text    =     (  \"  < component >  \\ n \"     +     ( StringUtil . repeat ( line ,     1  0  0  )  )  )     +     \"  <  / component >  \"  ;", "XmlFile   file    =     (  ( XmlFile )     ( createFile (  \" a . xml \"  ,    text )  )  )  ;", ". runThreads (  4  2  ,     (  )     -  >     {", "final   Random   random    =    new   Random (  )  ;", "for    ( int   i    =     0  ;    i    <    ITERATIONS ;    i +  +  )     {", "ApplicationManager . getApplication (  )  . runReadAction (  (  )     -  >     {", "int   offset    =    random . nextInt (  (  ( file . getTextLength (  )  )     -     1  0  )  )  ;", "XmlTag   tag    =    PsiTreeUtil . findElementOfClassAtOffset ( file ,    offset ,     . class ,    false )  ;", "assert   tag    !  =    null    :    offset ;", "DomElement   element    =    DomUtil . getDomElement ( tag )  ;", "assert   element   instanceof   MyAllCustomElement    :    element ;", "}  )  ;", "if    (  ( random . nextInt (  2  0  )  )     =  =     0  )     {", "SemService . getSemService ( getProject (  )  )  . clearCache (  )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testBigCustomFile"], "fileName": "com.intellij.util.xml.DomConcurrencyStressTest"}, {"methodBody": ["METHOD_START", "{", "getDomManager (  )  . registerFileDescription ( new   DomFileDescription ( DomConcurrencyStressTest . MyElement . class ,     \" a \"  )  ,    getTestRootDisposable (  )  )  ;", "registerExtender ( DomConcurrencyStressTest . MyElement . class ,    DomConcurrencyStressTest . MyExtender . class )  ;", "final   XmlFile   file    =    DomTestCase . createXmlFile (  (  \"  < a   attr =  \\  \"  1  \\  \"    attr 2  =  \\  \"  2  \\  \"  >  \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"  < foo - child >  < foo - child /  >  < custom - foo /  >  <  / foo - child >  \"     +     \"  < bar - child >  < foo - child /  >  <  / bar - child >  \"  )     +     \"  < foo - element >  \"  )     +     \"        < foo - child /  >  \"  )     +     \"        < foo - child >  < foo - child   attr =  \\  \"  \\  \"  /  >  <  / foo - child >  \"  )     +     \"        < custom - foo /  >  \"  )     +     \"        < custom - bar /  >  \"  )     +     \"  <  / foo - element >  \"  )     +     \"  < custom - bar /  >  \"  )     +     \"  < custom - bar >  \"  )     +     \"        < foo - child /  >  \"  )     +     \"        < foo - element /  >  \"  )     +     \"        < foo - element /  >  \"  )     +     \"        < custom - bar /  >  \"  )     +     \"  <  / custom - bar >  \"  )     +     \"  < custom - bar   attr =  \\  \"  \\  \"  >  \"  )     +     \"        < foo - child /  >  \"  )     +     \"        < some - child /  >  \"  )     +     \"        < custom - bar /  >  \"  )     +     \"  <  / custom - bar >  \"  )     +     \"  < child /  >  \"  )     +     \"  < child /  >  \"  )     +     \"  < bool /  >  \"  )     +     \"  <  / a >  \"  )  )  )  ;", "final   int   ITERATIONS    =    Timings . adjustAccordingToMySpeed (  2  3  9  ,    true )  ;", "System . out . println (  (  \" ITERATIONS    =  \"     +    ITERATIONS )  )  ;", "DomConcurrencyStressTest . runThreads (  4  2  ,    new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "for    ( int   i    =     0  ;    i    <    ITERATIONS ;    i +  +  )     {", "ApplicationManager . getApplication (  )  . runReadAction ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "final   DomFileElementImpl < DomElement >    element    =    getDomManager (  )  . getFileElement ( file )  ;", "assertNotNull ( element )  ;", "element . getRootElement (  )  . accept ( new   DomElementVisitor (  )     {", "@ Override", "public   void   visitDomElement ( final   DomElement   element )     {", "if    ( DomUtil . hasXml ( element )  )     {", "element . acceptChildren ( this )  ;", "}", "}", "}  )  ;", "}", "}  )  ;", "SemService . getSemService ( getProject (  )  )  . clearCache (  )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testInternalDomLocksReadConsistency"], "fileName": "com.intellij.util.xml.DomConcurrencyStressTest"}, {"methodBody": ["METHOD_START", "{", "return   ServiceManager . getService ( project ,    DomElementsNavigationManager . class )  ;", "}", "METHOD_END"], "methodName": ["getManager"], "fileName": "com.intellij.util.xml.DomElementsNavigationManager"}, {"methodBody": ["METHOD_START", "{", "final   List < DomElement >    children    =    new   ArrayList <  >  (  )  ;", "element . acceptChildren ( new   DomElementVisitor (  )     {", "@ Override", "public   void   visitDomElement ( final   DomElement   element )     {", "if    (  !  (  \" attr \"  . equals ( element . getXmlElementName (  )  )  )  )     {", "children . add ( element )  ;", "}", "}", "}  )  ;", "return   children ;", "}", "METHOD_END"], "methodName": ["getCustomChildren"], "fileName": "com.intellij.util.xml.DomExtensionsTest"}, {"methodBody": ["METHOD_START", "{", "registerDomExtender ( DomExtensionsTest . MyElement . class ,    extender )  ;", "}", "METHOD_END"], "methodName": ["registerDomExtender"], "fileName": "com.intellij.util.xml.DomExtensionsTest"}, {"methodBody": ["METHOD_START", "{", "final   DomExtenderEP   extenderEP    =    new   DomExtenderEP (  )  ;", "extenderEP . domClassName    =    domClass . getName (  )  ;", "extenderEP . extenderClassName    =    extenderClass . getName (  )  ;", "PlatformTestUtil . registerExtension (  . getRootArea (  )  ,    DomExtenderEP . EP _ NAME ,    extenderEP ,    getTestRootDisposable (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerDomExtender"], "fileName": "com.intellij.util.xml.DomExtensionsTest"}, {"methodBody": ["METHOD_START", "{", "registerDomExtender ( DomExtensionsTest . CollectionDomExtender . class )  ;", "final   DomExtensionsTest . MyElement   myElement    =    createElement (  \"  < a   attr =  \\  \" xxx \\  \"  >  <  / a >  \"  ,    DomExtensionsTest . MyElement . class )  ;", "final   DomCollectionChildDescription   description    =    myElement . getGenericInfo (  )  . getCollectionChildDescription (  \" xxx \"  )  ;", "final   DomElement   element 2     =    description . addValue ( myElement )  ;", "final   DomElement   element 0     =    description . addValue ( myElement ,     0  )  ;", "final   DomElement   element 3     =    description . addValue ( myElement ,    DomExtensionsTest . MyConcreteElement . class )  ;", "final   DomElement   element 1     =    description . addValue ( myElement ,    DomExtensionsTest . MyConcreteElement . class ,     1  )  ;", "assertSameElements ( DomExtensionsTest . getCustomChildren ( myElement )  ,    element 0  ,    element 1  ,    element 2  ,    element 3  )  ;", "}", "METHOD_END"], "methodName": ["testCollectionAdders"], "fileName": "com.intellij.util.xml.DomExtensionsTest"}, {"methodBody": ["METHOD_START", "{", "registerDomExtender ( DomExtensionsTest . CollectionDomExtender . class )  ;", "final   DomExtensionsTest . MyElement   myElement    =    createElement (  \"  < a   attr =  \\  \" xxx \\  \"  >  < xxx > zzz <  / xxx >  < xxx   attr =  \\  \" foo \\  \"  /  >  <  / a >  \"  ,    DomExtensionsTest . MyElement . class )  ;", "assertUnorderedCollection ( DomExtensionsTest . getCustomChildren ( myElement )  ,     (    element )     -  >     {", "assertEquals (  \" foo \"  ,     (  ( MyElement )     ( element )  )  . getAttr (  )  . getValue (  )  )  ;", "assertNull ( element . getAnnotation (  . class )  )  ;", "}  ,     (    element )     -  >     {", "assertNull (  (  ( MyElement )     ( element )  )  . getAttr (  )  . getValue (  )  )  ;", "assertNull ( element . getAnnotation (  . class )  )  ;", "}  )  ;", "assertNotNull ( myElement . getGenericInfo (  )  . getCollectionChildDescription (  \" xxx \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCollectionChildren"], "fileName": "com.intellij.util.xml.DomExtensionsTest"}, {"methodBody": ["METHOD_START", "{", "registerDomExtender ( DomExtensionsTest . AttrDomExtender 3  . class )  ;", "final   DomExtensionsTest . MyElement   element    =    createElement (  \"  < a   attr =  \\  \" xxx \\  \"  /  >  \"  ,    DomExtensionsTest . MyElement . class )  ;", "assertEquals (  \" xxx \"  ,    assertInstanceOf ( assertOneElement ( DomExtensionsTest . getCustomChildren ( element )  )  ,    DomExtensionsTest . MyAttribute . class )  . getXmlElementName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomAttributeChildClass"], "fileName": "com.intellij.util.xml.DomExtensionsTest"}, {"methodBody": ["METHOD_START", "{", "registerDomExtender ( DomExtensionsTest . MyCustomChildrenElement . class ,    DomExtensionsTest . CustomDomExtender . class )  ;", "final   DomExtensionsTest . MyCustomChildrenElement   myElement    =    createElement (  \"  < a >  < xx /  >  < yy /  >  < concrete - child /  >  < some - concrete - child /  >  <  / a >  \"  ,    DomExtensionsTest . MyCustomChildrenElement . class )  ;", "final   DomCollectionChildDescription   description    =    myElement . getGenericInfo (  )  . getCollectionChildDescription (  \" xx \"  )  ;", "assertNotNull ( description )  ;", "assertInstanceOf ( assertOneElement ( description . getValues ( myElement )  )  ,    DomExtensionsTest . MyDynamicElement . class )  ;", "assertInstanceOf ( assertOneElement ( myElement . getCustomChidren (  )  )  ,    DomExtensionsTest . MyCustomElement . class )  ;", "assertInstanceOf ( assertOneElement ( myElement . getConcreteChildren (  )  )  ,    DomExtensionsTest . MyConcreteElement . class )  ;", "assertNotNull ( assertInstanceOf ( myElement . getSomeConcreteChild (  )  ,    DomExtensionsTest . MyConcreteElement . class )  . getXmlTag (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomChildrenAccessFromExtender"], "fileName": "com.intellij.util.xml.DomExtensionsTest"}, {"methodBody": ["METHOD_START", "{", "registerDomExtender ( DomExtensionsTest . AttrDomExtender . class )  ;", "assertEmpty ( DomExtensionsTest . getCustomChildren ( createElement (  \"  < a   foo =  \\  \" xxx \\  \"  /  >  \"  ,    DomExtensionsTest . MyElement . class )  )  )  ;", "DomExtensionsTest . MyElement   element    =    createElement (  \"  < a   attr =  \\  \" foo \\  \"    foo =  \\  \" true \\  \"  /  >  \"  ,    DomExtensionsTest . MyElement . class )  ;", "final   GenericAttributeValue   child    =    assertInstanceOf ( assertOneElement ( DomExtensionsTest . getCustomChildren ( element )  )  ,    GenericAttributeValue . class )  ;", "assertEquals (  \" true \"  ,    child . getStringValue (  )  )  ;", "assertEquals ( Boolean . TRUE ,    child . getValue (  )  )  ;", "assertEquals ( Boolean . class ,    DomUtil . getGenericValueParameter ( child . getDomElementType (  )  )  )  ;", "assertSame ( element . getXmlTag (  )  . getAttribute (  \" foo \"  )  ,    child . getXmlElement (  )  )  ;", "child . setStringValue (  \" xxx \"  )  ;", "assertEquals (  \" xxx \"  ,    child . getStringValue (  )  )  ;", "assertEquals (  \" xxx \"  ,    element . getXmlTag (  )  . getAttributeValue (  \" foo \"  )  )  ;", "element    =    createElement (  \"  < a   attr =  \\  \" foo \\  \"    foo =  \\  \" true \\  \"  /  >  \"  ,    DomExtensionsTest . MyElement . class )  ;", "final   GenericAttributeValue   value    =    getDomManager (  )  . getDomElement ( element . getXmlTag (  )  . getAttribute (  \" foo \"  )  )  ;", "assertNotNull ( value )  ;", "assertEquals ( value ,    assertOneElement ( DomExtensionsTest . getCustomChildren ( element )  )  )  ;", "assertNotNull ( element . getGenericInfo (  )  . getAttributeChildDescription (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testExtendAttributes"], "fileName": "com.intellij.util.xml.DomExtensionsTest"}, {"methodBody": ["METHOD_START", "{", "registerDomExtender ( DomExtensionsTest . MyCustomChildrenElement . class ,    DomExtensionsTest . ModestDomExtender . class )  ;", "final   DomExtensionsTest . MyCustomChildrenElement   myElement    =    createElement (  \"  < a >  < concrete - child /  >  < concrete - child /  >  <  / a >  \"  ,    DomExtensionsTest . MyCustomChildrenElement . class )  ;", "final   List < DomExtensionsTest . MyConcreteElement >    list    =    myElement . getConcreteChildren (  )  ;", "final   List < DomExtensionsTest . MyConcreteElement >    list 2     =    myElement . getConcreteChildren (  )  ;", "assertSame ( list . get (  0  )  ,    list 2  . get (  0  )  )  ;", "assertSame ( list . get (  1  )  ,    list 2  . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["testFirstChildRedefinitionOnExtending"], "fileName": "com.intellij.util.xml.DomExtensionsTest"}, {"methodBody": ["METHOD_START", "{", "registerDomExtender ( DomExtensionsTest . FixedDomExtender . class )  ;", "final   DomExtensionsTest . MyElement   myElement    =    createElement (  \"  < a   attr =  \\  \" xxx \\  \"  >  < xxx > zzz <  / xxx >  < yyy   attr =  \\  \" foo \\  \"  /  >  < yyy   attr =  \\  \" bar \\  \"  /  >  <  / a >  \"  ,    DomExtensionsTest . MyElement . class )  ;", "assertUnorderedCollection ( DomExtensionsTest . getCustomChildren ( myElement )  ,     (    element )     -  >     {", "assertEquals (  . class ,    ReflectionUtil . getRawType ( element . getDomElementType (  )  )  )  ;", "final   StringBuffer   stringBuffer    =     (  ( GenericDomValue < StringBuffer >  )     ( element )  )  . getValue (  )  ;", "assertEquals (  \" zzz \"  ,    stringBuffer . toString (  )  )  ;", "assertInstanceOf (  (  ( GenericDomValue < StringBuffer >  )     ( element )  )  . getConverter (  )  ,     . class )  ;", "assertNotNull ( myElement . getGenericInfo (  )  . getFixedChildDescription (  \" xxx \"  )  )  ;", "Convert   convert    =    element . getAnnotation (  . class )  ;", "assertNotNull ( convert )  ;", "assertEquals (  . class ,    convert . value (  )  )  ;", "assertTrue ( convert . soft (  )  )  ;", "assertNotNull ( element . getGenericInfo (  )  . getAttributeChildDescription (  \" aaa \"  )  )  ;", "}  ,     (    element )     -  >     {", "assertEquals (  \" foo \"  ,     (  ( MyElement )     ( element )  )  . getAttr (  )  . getValue (  )  )  ;", "assertNull ( element . getAnnotation (  . class )  )  ;", "}  ,     (    element )     -  >     {", "assertEquals (  \" bar \"  ,     (  ( MyElement )     ( element )  )  . getAttr (  )  . getValue (  )  )  ;", "assertNull ( element . getAnnotation (  . class )  )  ;", "}  )  ;", "final   DomFixedChildDescription   description    =    myElement . getGenericInfo (  )  . getFixedChildDescription (  \" yyy \"  )  ;", "assertNotNull ( description )  ;", "assertEquals (  2  ,    description . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFixedChildren"], "fileName": "com.intellij.util.xml.DomExtensionsTest"}, {"methodBody": ["METHOD_START", "{", "registerDomExtender ( DomExtensionsTest . AttrDomExtender 2  . class )  ;", "final   DomExtensionsTest . MyElement   myElement    =    createElement (  \"  < a   attr =  \\  \" xxx \\  \"    xxx =  \\  \" zzz \\  \"    yyy =  \\  \" zzz \\  \"  /  >  \"  ,    DomExtensionsTest . MyElement . class )  ;", "assertUnorderedCollection ( DomExtensionsTest . getCustomChildren ( myElement )  ,     (    element )     -  >     {", "final   StringBuffer   stringBuffer    =     (  ( GenericAttributeValue < StringBuffer >  )     ( element )  )  . getValue (  )  ;", "assertEquals (  \" zzz \"  ,    stringBuffer . toString (  )  )  ;", "assertInstanceOf (  (  ( GenericAttributeValue < StringBuffer >  )     ( element )  )  . getConverter (  )  ,     . class )  ;", "assertNotNull ( myElement . getGenericInfo (  )  . getAttributeChildDescription (  \" xxx \"  )  )  ;", "Convert   convert    =    element . getAnnotation (  . class )  ;", "assertNotNull ( convert )  ;", "assertEquals (  . class ,    convert . value (  )  )  ;", "assertTrue ( convert . soft (  )  )  ;", "}  ,     (    element )     -  >     {", "final   StringBuffer   stringBuffer    =     (  ( GenericAttributeValue < StringBuffer >  )     ( element )  )  . getValue (  )  ;", "assertEquals (  \" zzz \"  ,    stringBuffer . toString (  )  )  ;", "assertInstanceOf (  (  ( GenericAttributeValue < StringBuffer >  )     ( element )  )  . getConverter (  )  ,     . class )  ;", "assertNotNull ( myElement . getGenericInfo (  )  . getAttributeChildDescription (  \" yyy \"  )  )  ;", "Convert   convert    =    element . getAnnotation (  . class )  ;", "assertNotNull ( convert )  ;", "assertEquals (  . class ,    convert . value (  )  )  ;", "assertFalse ( convert . soft (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testUseCustomConverter"], "fileName": "com.intellij.util.xml.DomExtensionsTest"}, {"methodBody": ["METHOD_START", "{", "registerDomExtender ( DomExtensionsTest . AttrDomExtender 3  . class )  ;", "final   DomExtensionsTest . MyElement   element    =    createElement (  \"  < a   attr =  \\  \" xxx \\  \"  /  >  \"  ,    DomExtensionsTest . MyElement . class )  ;", "final   DomAttributeChildDescription   description    =    element . getGenericInfo (  )  . getAttributeChildDescription (  \" xxx \"  )  ;", "assertNotNull ( description )  ;", "assertSame ( Boolean . TRUE ,    description . getUserData ( DomExtensionsTest . BOOL _ KEY )  )  ;", "}", "METHOD_END"], "methodName": ["testUserData"], "fileName": "com.intellij.util.xml.DomExtensionsTest"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["acceptsOtherRootTagNames"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["createAnnotator"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "return   myAllPossibleRootTagNamespaces ;", "}", "METHOD_END"], "methodName": ["getAllPossibleRootTagNamespaces"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "final   NotNullFunction < XmlTag ,    List < String >  >    function    =    myNamespacePolicies . get ( namespaceKey )  ;", "if    ( function   instanceof   ConstantFunction )     {", "return   function . fun ( null )  ;", "}", "if    ( function    !  =    null )     {", "final   XmlDocument   document    =    file . getDocument (  )  ;", "if    ( document    !  =    null )     {", "final   XmlTag   tag    =    document . getRootTag (  )  ;", "if    ( tag    !  =    null )     {", "return   function . fun ( tag )  ;", "}", "}", "} else    {", "return   Collections . singletonList ( namespaceKey )  ;", "}", "return   Collections . emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["getAllowedNamespaces"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "return   Collections . emptySet (  )  ;", "}", "METHOD_END"], "methodName": ["getDependencyItems"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getFileIcon"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "final   DomElement   annotation    =    getScopeFromAnnotation ( element )  ;", "if    ( annotation    !  =    null )", "return   annotation ;", "return   element . getParent (  )  ;", "}", "METHOD_END"], "methodName": ["getIdentityScope"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( myInitialized )  )     {", "initialize (  )  ;", "myInitialized    =    true ;", "}", "return   myImplementations ;", "}", "METHOD_END"], "methodName": ["getImplementations"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "return   myInjectors ;", "}", "METHOD_END"], "methodName": ["getReferenceInjectors"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "final   DomElement   annotation    =    getScopeFromAnnotation ( reference )  ;", "if    ( annotation    !  =    null )", "return   annotation ;", "return   DomUtil . getRoot ( reference )  ;", "}", "METHOD_END"], "methodName": ["getResolveScope"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "return   myRootElementClass ;", "}", "METHOD_END"], "methodName": ["getRootElementClass"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "return   myRootTagName ;", "}", "METHOD_END"], "methodName": ["getRootTagName"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "final   Scope   scope    =    element . getAnnotation ( Scope . class )  ;", "if    ( scope    !  =    null )     {", "return   myScopeProviders . get ( scope . value (  )  )  . getScope ( element )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getScopeFromAnnotation"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getStubVersion"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "return   myTypeChooserManager ;", "}", "METHOD_END"], "methodName": ["getTypeChooserManager"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "return   myRootTagName . hashCode (  )  ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["hasStubs"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isAutomaticHighlightingEnabled"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "final   Namespace   namespace    =    DomReflectionUtil . findAnnotationDFS ( myRootElementClass ,    Namespace . class )  ;", "if    ( namespace    !  =    null )     {", "final   String   key    =    namespace . value (  )  ;", "Set < String >    allNs    =    new   HashSet <  >  ( getAllowedNamespaces ( key ,    file )  )  ;", "if    ( allNs . isEmpty (  )  )     {", "return   false ;", "}", "XmlFileHeader   header    =    DomService . getInstance (  )  . getXmlFileHeader ( file )  ;", "return    (  ( allNs . contains ( header . getPublicId (  )  )  )     |  |     ( allNs . contains ( header . getSystemId (  )  )  )  )     |  |     ( allNs . contains ( header . getRootTagNamespace (  )  )  )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isMyFile"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "myImplementations . put ( domElementClass ,    implementationClass )  ;", "}", "METHOD_END"], "methodName": ["registerImplementation"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "myNamespacePolicies . put ( namespaceKey ,    policy )  ;", "}", "METHOD_END"], "methodName": ["registerNamespacePolicy"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "registerNamespacePolicy ( namespaceKey ,    new   com . intellij . util . ConstantFunction ( Arrays . asList ( namespaces )  )  )  ;", "}", "METHOD_END"], "methodName": ["registerNamespacePolicy"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "myInjectors . add ( injector )  ;", "}", "METHOD_END"], "methodName": ["registerReferenceInjector"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "myTypeChooserManager . registerTypeChooser ( aClass ,    typeChooser )  ;", "}", "METHOD_END"], "methodName": ["registerTypeChooser"], "fileName": "com.intellij.util.xml.DomFileDescription"}, {"methodBody": ["METHOD_START", "{", "getDomManager (  )  . registerFileDescription ( new   DomFileDescription < DomFileDescriptionTest . MyElement >  ( DomFileDescriptionTest . MyElement . class ,     \" xxx \"  )     {", "@ Override", "public   boolean   isMyFile (  @ NotNull", "final   XmlFile   file ,     @ Nullable", "final   Module   module )     {", "return   file . getText (  )  . contains (  \" foo \"  )  ;", "}", "}  ,    myDisposable )  ;", "final   XmlFile   file    =     (  ( XmlFile )     ( createFile (  \" xxx . xml \"  ,     \"  < xxx   zzz =  \\  \" foo \\  \"  >  < boy /  >  < boy /  >  < xxx /  >  \"  )  )  )  ;", "final   DomFileDescriptionTest . MyElement   boy    =    getDomManager (  )  . getFileElement ( file ,    DomFileDescriptionTest . MyElement . class )  . getRootElement (  )  . getBoys (  )  . get (  0  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "file . getDocument (  )  . getRootTag (  )  . setAttribute (  \" zzz \"  ,     \" bar \"  )  ;", "}  )  ;", "assertFalse ( getDomManager (  )  . isDomFile ( file )  )  ;", "assertFalse ( boy . isValid (  )  )  ;", "}", "METHOD_END"], "methodName": ["testChangeCustomDomness"], "fileName": "com.intellij.util.xml.DomFileDescriptionTest"}, {"methodBody": ["METHOD_START", "{", "getDomManager (  )  . registerFileDescription ( new   DomFileDescription < DomFileDescriptionTest . NamespacedElement >  ( DomFileDescriptionTest . NamespacedElement . class ,     \" xxx \"  ,     \" bar \"  )     {", "@ Override", "protected   void   initializeFileDescription (  )     {", "registerNamespacePolicy (  \" foo \"  ,     \" bar \"  )  ;", "}", "}  ,    myDisposable )  ;", "final   PsiFile   file    =    createFile (  \" xxx . xml \"  ,     \"  < xxx /  >  \"  )  ;", "assertFalse ( getDomManager (  )  . isDomFile ( file )  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "final   Document   document    =    getDocument ( file )  ;", "document . insertString (  0  ,     \"  <  ! DOCTYPE   xxx   PUBLIC    \\  \" bar \\  \"     \\  \" http :  /  / com / dtd / ejb - jar _  2  _  0  . dtd \\  \"  >  \\ n \"  )  ;", "commitDocument ( document )  ;", "}  )  ;", "assertTrue ( getDomManager (  )  . isDomFile ( file )  )  ;", "}", "METHOD_END"], "methodName": ["testCheckDtdPublicId"], "fileName": "com.intellij.util.xml.DomFileDescriptionTest"}, {"methodBody": ["METHOD_START", "{", "getDomManager (  )  . registerFileDescription ( new   DomFileDescription < DomFileDescriptionTest . NamespacedElement >  ( DomFileDescriptionTest . NamespacedElement . class ,     \" xxx \"  ,     \" bar \"  )     {", "@ Override", "protected   void   initializeFileDescription (  )     {", "registerNamespacePolicy (  \" foo \"  ,     \" bar \"  )  ;", "}", "}  ,    myDisposable )  ;", "final   PsiFile   file    =    createFile (  \" xxx . xml \"  ,     \"  < xxx /  >  \"  )  ;", "assertFalse ( getDomManager (  )  . isDomFile ( file )  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "(  ( XmlFile )     ( file )  )  . getDocument (  )  . getRootTag (  )  . setAttribute (  \" xmlns \"  ,     \" bar \"  )  ;", "}  )  ;", "assertTrue ( getDomManager (  )  . isDomFile ( file )  )  ;", "}", "METHOD_END"], "methodName": ["testCheckNamespace"], "fileName": "com.intellij.util.xml.DomFileDescriptionTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =     (  ( XmlFile )     ( createFile (  \" a . xml \"  ,     \"  < b >  4  2  <  / b >  \"  )  )  )  ;", "getDomManager (  )  . registerFileDescription ( new   impl . MockDomFileDescription ( DomFileDescriptionTest . MyElement . class ,     \" b \"  ,    file . getVirtualFile (  )  )  ,    myDisposable )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >     {", "file . setName (  \" b . xml \"  )  ;", "}  )  ;", "assertTrue ( getDomManager (  )  . isDomFile ( file )  )  ;", "final   XmlFile   copy    =     (  ( XmlFile )     ( file . copy (  )  )  )  ;", "assertTrue ( getDomManager (  )  . isDomFile ( copy )  )  ;", "assertFalse ( getDomManager (  )  . getFileElement ( file )  . equals ( getDomManager (  )  . getFileElement ( copy )  )  )  ;", "}", "METHOD_END"], "methodName": ["testCopyFileDescriptionFromOriginalFile"], "fileName": "com.intellij.util.xml.DomFileDescriptionTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   interestingFile    =     (  ( XmlFile )     ( createFile (  \" a . xml \"  ,     \"  < b >  4  2  <  / b >  \"  )  )  )  ;", "getDomManager (  )  . registerFileDescription ( new   MockDomFileDescription (  . MyElement . class ,     \" b \"  ,    null )  ,    myDisposable )  ;", "for    ( int   i    =     0  ;    i    <     2  3  9  ;    i +  +  )     {", "getDomManager (  )  . registerFileDescription ( new   MockDomFileDescription <  . AbstractElement >  (  . AbstractElement . class ,     \" b \"  ,    null )     {", "@ Override", "@ NotNull", "public   Set   getDependencyItems ( final   XmlFile   file )     {", "getDomManager (  )  . isDomFile ( interestingFile )  ;", "return   super . getDependencyItems ( file )  ;", "}", "}  ,    myDisposable )  ;", "}", "getDomManager (  )  . isDomFile ( interestingFile )  ;", "}", "METHOD_END"], "methodName": ["testDependantFileDescriptionCauseStackOverflow"], "fileName": "com.intellij.util.xml.DomFileDescriptionTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =     (  ( XmlFile )     ( createFile (  \" foo . xml \"  ,     \"  < a   b >  \"  )  )  )  ;", "DomFileDescription <  . FooElement >    description    =    new   DomFileDescription <  >  (  . FooElement . class ,     \" a \"  )  ;", "getDomManager (  )  . registerFileDescription ( description ,    myDisposable )  ;", "DomFileElementImpl <  . FooElement >    fileElement    =    getDomManager (  )  . getFileElement ( file ,     . FooElement . class )  ;", "assertNotNull ( fileElement )  ;", "assertEquals (  \" a \"  ,    fileElement . getFileDescription (  )  . myRootTagName )  ;", "}", "METHOD_END"], "methodName": ["testInvalidRootTag"], "fileName": "com.intellij.util.xml.DomFileDescriptionTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =     (  ( XmlFile )     ( createFile (  \" a . xml \"  ,     \"  < b >  4  2  <  / b >  \"  )  )  )  ;", "getDomManager (  )  . registerFileDescription ( new   DomFileDescription <  . MyElement >  (  . MyElement . class ,     \" b \"  )     {", "@ Override", "public   boolean   isMyFile (  @ NotNull", "final   XmlFile   file ,    final   Module   module )     {", "return   file . getText (  )  . contains (  \"  2  3  9  \"  )  ;", "}", "}  ,    myDisposable )  ;", "assertFalse ( getDomManager (  )  . isDomFile ( file )  )  ;", "assertNull ( getDomManager (  )  . getFileElement ( file )  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "file . getDocument (  )  . getRootTag (  )  . getValue (  )  . setText (  \"  2  3  9  \"  )  ;", "}  )  ;", "assertTrue ( getDomManager (  )  . isDomFile ( file )  )  ;", "final   DomFileElementImpl <  . MyElement >    root    =    getDomManager (  )  . getFileElement ( file )  ;", "assertNotNull ( root )  ;", "final    . MyElement   child    =    root . getRootElement (  )  . getChild (  )  ;", "assertTrue ( root . isValid (  )  )  ;", "assertTrue ( child . isValid (  )  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "file . getDocument (  )  . getRootTag (  )  . getValue (  )  . setText (  \"  5  7  1  2  1  \"  )  ;", "}  )  ;", "assertFalse ( getDomManager (  )  . isDomFile ( file )  )  ;", "assertNull ( getDomManager (  )  . getFileElement ( file )  )  ;", "assertFalse ( root . isValid (  )  )  ;", "assertFalse ( child . isValid (  )  )  ;", "}", "METHOD_END"], "methodName": ["testIsDomValue"], "fileName": "com.intellij.util.xml.DomFileDescriptionTest"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( getDomManager (  )  . isDomFile ( PsiManager . getInstance ( myProject )  . findFile ( myBarElementFile )  )  )  ;", "assertNull ( getDomManager (  )  . getFileElement (  (  ( XmlFile )     ( PsiManager . getInstance ( myProject )  . findFile ( myBarElementFile )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testNoInitialDomnessInB"], "fileName": "com.intellij.util.xml.DomFileDescriptionTest"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( myCallRegistry . toString (  )  ,    size ,    myCallRegistry . getSize (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertEventCount"], "fileName": "com.intellij.util.xml.DomHardCoreTestCase"}, {"methodBody": ["METHOD_START", "{", "return   assertReference ( value ,    value . getXmlTag (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertReference"], "fileName": "com.intellij.util.xml.DomHardCoreTestCase"}, {"methodBody": ["METHOD_START", "{", "al   XmlTagValue   tagValue    =    value . getXmlTag (  )  . getValue (  )  ;", "al   TextRange   textRange    =    tagValue . getTextRange (  )  ;", "al   Stg   s    =    value . getStgValue (  )  ;", "assertNotNull ( s )  ;", "alt   i    =    tagValue . getText (  ) dexOf ( s )  ;", "return   assertReference ( value ,    resolveTo ,     (  (  ( textRange . getStartOffset (  )  )     +    i )     +     ( s . length (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertReference"], "fileName": "com.intellij.util.xml.DomHardCoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    value . getXmlTag (  )  ;", "final   PsiReference   reference    =    tag . getContainingFile (  )  . findReferenceAt ( offset )  ;", "assertNotNull ( reference )  ;", "reference . getVariants (  )  ;", "assertEquals ( resolveTo ,    reference . resolve (  )  )  ;", "return   reference ;", "}", "METHOD_END"], "methodName": ["assertReference"], "fileName": "com.intellij.util.xml.DomHardCoreTestCase"}, {"methodBody": ["METHOD_START", "{", "myCallRegistry . assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["assertResultsAndClear"], "fileName": "com.intellij.util.xml.DomHardCoreTestCase"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    refVariants    =    reference . getVariants (  )  ;", "assertNotNull ( refVariants )  ;", "assertEquals ( refVariants . length ,    variants . length )  ;", "int   i    =     0  ;", "for    ( String   variant    :    variants )     {", "Object   refVariant    =    refVariants [  ( i +  +  )  ]  ;", "if    ( refVariant   instanceof   LookupElement )     {", "assertEquals ( variant ,     (  ( LookupElement )     ( refVariant )  )  . getLookupString (  )  )  ;", "} else", "if    ( refVariant   instanceof   codeInsight . lookup . PresentableLookupValue )     {", "assertEquals ( variant ,     (  ( codeInsight . lookup . PresentableLookupValue )     ( refVariant )  )  . getPresentation (  )  )  ;", "} else    {", "assertEquals ( variant ,    refVariant . toString (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["assertVariants"], "fileName": "com.intellij.util.xml.DomHardCoreTestCase"}, {"methodBody": ["METHOD_START", "{", "return   createElement ( xml ,    DomReferencesTest . MyElement . class )  ;", "}", "METHOD_END"], "methodName": ["createElement"], "fileName": "com.intellij.util.xml.DomHardCoreTestCase"}, {"methodBody": ["METHOD_START", "{", "return   DomTestCase . createElement ( getDomManager (  )  ,    xml ,    aClass )  ;", "}", "METHOD_END"], "methodName": ["createElement"], "fileName": "com.intellij.util.xml.DomHardCoreTestCase"}, {"methodBody": ["METHOD_START", "{", "return   DomManagerImpl . getDomManager ( getProject (  )  )  ;", "}", "METHOD_END"], "methodName": ["getDomManager"], "fileName": "com.intellij.util.xml.DomHardCoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   XmlAttributeValue   attributeValue    =    value . getXmlAttributeValue (  )  ;", "assertNotNull ( attributeValue )  ;", "final   PsiReference   reference    =    attributeValue . getContainingFile (  )  . findReferenceAt (  (  ( attributeValue . getTextRange (  )  . getStartOffset (  )  )     +     1  )  )  ;", "assertNotNull ( reference )  ;", "assertEquals ( attributeValue ,    reference . resolve (  )  )  ;", "return   reference ;", "}", "METHOD_END"], "methodName": ["getReference"], "fileName": "com.intellij.util.xml.DomHardCoreTestCase"}, {"methodBody": ["METHOD_START", "{", "myCallRegistry . putExpected ( event )  ;", "}", "METHOD_END"], "methodName": ["putExpected"], "fileName": "com.intellij.util.xml.DomHardCoreTestCase"}, {"methodBody": ["METHOD_START", "{", "assertFalse (  ( holder   instanceof   DomElementsProblemsHolderImpl )  )  ;", "assertEmpty ( holder . getAllProblems (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertEmptyHolder"], "fileName": "com.intellij.util.xml.DomHighlightingLiteTest"}, {"methodBody": ["METHOD_START", "{", "return   assertInstanceOf ( holder 1  ,    DomElementsProblemsHolderImpl . class )  ;", "}", "METHOD_END"], "methodName": ["assertNotEmptyHolder"], "fileName": "com.intellij.util.xml.DomHighlightingLiteTest"}, {"methodBody": ["METHOD_START", "{", "return   new   DomElementAnnotationHolderImpl ( true )  ;", "}", "METHOD_END"], "methodName": ["createHolder"], "fileName": "com.intellij.util.xml.DomHighlightingLiteTest"}, {"methodBody": ["METHOD_START", "{", "final   String   shortName    =    inspection . getShortName (  )  ;", "DisplayKey   key    =    DisplayKey . find ( shortName )  ;", "if    ( key    =  =    null )     {", "DisplayKey . register ( shortName )  ;", "}", "}", "METHOD_END"], "methodName": ["registerInspectionKey"], "fileName": "com.intellij.util.xml.DomHighlightingLiteTest"}, {"methodBody": ["METHOD_START", "{", "final   DefaultDomAnnotator   annotator    =    new   DefaultDomAnnotator (  )     {", "@ Override", "protected   DomElementAnnotationsManagerImpl   getAnnotationsManager ( final   DomElement   element )     {", "return   myAnnotationsManager ;", "}", "}  ;", "final   StringBuilder   s    =    new   StringBuilder (  )  ;", "final   ArrayList < Annotation >    toFill    =    new   ArrayList <  >  (  )  ;", "final    . MyDomElementsInspection   inspection    =    new    . MyDomElementsInspection (  )     {", "@ Override", "public   void   checkFileElement ( final   DomFileElement   fileElement ,    final   DomElementAnnotationHolder   holder )     {", "s . append (  \" visited \"  )  ;", "}", "}  ;", "annotator . runInspection ( inspection ,    myElement ,    toFill )  ;", "assertEquals (  \" visited \"  ,    s . toString (  )  )  ;", "final   DomElementsProblemsHolderImpl   holder    =     . assertNotEmptyHolder ( myAnnotationsManager . getProblemHolder ( myElement )  )  ;", "assertEmpty ( toFill )  ;", "annotator . runInspection ( inspection ,    myElement ,    toFill )  ;", "assertEquals (  \" visited \"  ,    s . toString (  )  )  ;", "assertSame ( holder ,     . assertNotEmptyHolder ( myAnnotationsManager . getProblemHolder ( myElement )  )  )  ;", "assertEmpty ( toFill )  ;", "}", "METHOD_END"], "methodName": ["testDefaultAnnotator"], "fileName": "com.intellij.util.xml.DomHighlightingLiteTest"}, {"methodBody": ["METHOD_START", "{", "DomHighlightingLiteTest . assertEmptyHolder ( myAnnotationsManager . getProblemHolder ( myElement )  )  ;", "}", "METHOD_END"], "methodName": ["testEmptyProblemDescriptorInTheBeginning"], "fileName": "com.intellij.util.xml.DomHighlightingLiteTest"}, {"methodBody": ["METHOD_START", "{", "myElement . setFileDescription ( new   DomFileDescription <  >  ( DomElement . class ,     \" a \"  )  )  ;", "myAnnotationsManager . appendProblems ( myElement ,     . createHolder (  )  ,    MockAnnotatingDomInspection . class )  ;", "assertEquals ( DomHighlightStatus . INSPECTIONS _ FINISHED ,    myAnnotationsManager . getHighlightStatus ( myElement )  )  ;", "}", "METHOD_END"], "methodName": ["testHighlightStatus_MockAnnotatingDomInspection"], "fileName": "com.intellij.util.xml.DomHighlightingLiteTest"}, {"methodBody": ["METHOD_START", "{", "myElement . setFileDescription ( new   DomHighlightingLiteTest . MyNonHighlightingDomFileDescription (  )  )  ;", "assertEquals ( DomHighlightStatus . NONE ,    myAnnotationsManager . getHighlightStatus ( myElement )  )  ;", "myAnnotationsManager . appendProblems ( myElement ,    DomHighlightingLiteTest . createHolder (  )  ,    MockDomInspection . class )  ;", "assertEquals ( DomHighlightStatus . INSPECTIONS _ FINISHED ,    myAnnotationsManager . getHighlightStatus ( myElement )  )  ;", "}", "METHOD_END"], "methodName": ["testHighlightStatus_MockDomInspection"], "fileName": "com.intellij.util.xml.DomHighlightingLiteTest"}, {"methodBody": ["METHOD_START", "{", "myElement . setFileDescription ( new   DomFileDescription <  >  ( DomElement . class ,     \" a \"  )  )  ;", "final    . MyDomElementsInspection   inspection    =    new    . MyDomElementsInspection (  )     {", "@ Override", "public   ProblemDescriptor [  ]    checkFile (  @ NotNull", "final   PsiFile   file ,     @ NotNull", "final   InspectionManager   manager ,    final   boolean   isOnTheFly )     {", "myAnnotationsManager . appendProblems ( myElement ,     . createHolder (  )  ,    this . getClass (  )  )  ;", "return   ProblemDescriptor . EMPTY _ ARRAY ;", "}", "@ Override", "public   void   checkFileElement ( final   DomFileElement   fileElement ,    final   DomElementAnnotationHolder   holder )     {", "}", "}  ;", ". registerInspectionKey ( inspection )  ;", "myInspectionProfile . setInspectionTools ( new   LocalInspectionToolWrapper ( inspection )  )  ;", "myAnnotationsManager . appendProblems ( myElement ,     . createHolder (  )  ,    MockAnnotatingDomInspection . class )  ;", "assertEquals ( DomHighlightStatus . ANNOTATORS _ FINISHED ,    myAnnotationsManager . getHighlightStatus ( myElement )  )  ;", "myAnnotationsManager . appendProblems ( myElement ,     . createHolder (  )  ,    inspection . getClass (  )  )  ;", "assertEquals ( DomHighlightStatus . INSPECTIONS _ FINISHED ,    myAnnotationsManager . getHighlightStatus ( myElement )  )  ;", "}", "METHOD_END"], "methodName": ["testHighlightStatus_OtherInspections"], "fileName": "com.intellij.util.xml.DomHighlightingLiteTest"}, {"methodBody": ["METHOD_START", "{", "myElement . setFileDescription ( new   DomFileDescription <  >  ( DomElement . class ,     \" a \"  )  )  ;", "final    . MyDomElementsInspection   inspection    =    new    . MyDomElementsInspection (  )     {", "@ Override", "public   ProblemDescriptor [  ]    checkFile (  @ NotNull", "final   PsiFile   file ,     @ NotNull", "final   InspectionManager   manager ,    final   boolean   isOnTheFly )     {", "myAnnotationsManager . appendProblems ( myElement ,     . createHolder (  )  ,    this . getClass (  )  )  ;", "return   ProblemDescriptor . EMPTY _ ARRAY ;", "}", "@ Override", "public   void   checkFileElement ( final   DomFileElement   fileElement ,    final   DomElementAnnotationHolder   holder )     {", "}", "}  ;", ". registerInspectionKey ( inspection )  ;", "LocalInspectionToolWrapper   toolWrapper    =    new   LocalInspectionToolWrapper ( inspection )  ;", "myInspectionProfile . setInspectionTools ( toolWrapper )  ;", "myInspectionProfile . setEnabled ( toolWrapper ,    false )  ;", "myAnnotationsManager . appendProblems ( myElement ,     . createHolder (  )  ,    MockAnnotatingDomInspection . class )  ;", "assertEquals ( DomHighlightStatus . INSPECTIONS _ FINISHED ,    myAnnotationsManager . getHighlightStatus ( myElement )  )  ;", "}", "METHOD_END"], "methodName": ["testHighlightStatus_OtherInspections2"], "fileName": "com.intellij.util.xml.DomHighlightingLiteTest"}, {"methodBody": ["METHOD_START", "{", "myAnnotationsManager . appendProblems ( myElement ,    DomHighlightingLiteTest . createHolder (  )  ,    DomHighlightingLiteTest . MyDomElementsInspection . class )  ;", "assertTrue ( DomElementAnnotationsManagerImpl . isHolderUpToDate ( myElement )  )  ;", "final   DomElementsProblemsHolder   holder    =    myAnnotationsManager . getProblemHolder ( myElement )  ;", "myElement . incModificationCount (  )  ;", "assertFalse ( DomElementAnnotationsManagerImpl . isHolderUpToDate ( myElement )  )  ;", "assertSame ( holder ,    myAnnotationsManager . getProblemHolder ( myElement )  )  ;", "myAnnotationsManager . appendProblems ( myElement ,    DomHighlightingLiteTest . createHolder (  )  ,    DomHighlightingLiteTest . MyDomElementsInspection . class )  ;", "assertNotSame ( holder ,    DomHighlightingLiteTest . assertNotEmptyHolder ( myAnnotationsManager . getProblemHolder ( myElement )  )  )  ;", "}", "METHOD_END"], "methodName": ["testHolderRecreationAfterChange"], "fileName": "com.intellij.util.xml.DomHighlightingLiteTest"}, {"methodBody": ["METHOD_START", "{", "myAnnotationsManager . appendProblems ( myElement ,    DomHighlightingLiteTest . createHolder (  )  ,    DomHighlightingLiteTest . MyDomElementsInspection . class )  ;", "final   DomElementsProblemsHolderImpl   holder    =     (  ( DomElementsProblemsHolderImpl )     ( myAnnotationsManager . getProblemHolder ( myElement )  )  )  ;", "assertTrue ( holder . isInspectionCompleted ( DomHighlightingLiteTest . MyDomElementsInspection . class )  )  ;", "assertFalse ( holder . isInspectionCompleted ( DomElementsInspection . class )  )  ;", "}", "METHOD_END"], "methodName": ["testInspectionMarkedAsPassedAfterAppend"], "fileName": "com.intellij.util.xml.DomHighlightingLiteTest"}, {"methodBody": ["METHOD_START", "{", "myElement . setFileDescription ( new   DomFileDescription <  >  ( DomElement . class ,     \" a \"  )  )  ;", "assertInstanceOf ( myAnnotationsManager . getMockInspection ( myElement )  ,    MockAnnotaDomInspection . class )  ;", "}", "METHOD_END"], "methodName": ["testMockAnnotatingDomInspection"], "fileName": "com.intellij.util.xml.DomHighlightingLiteTest"}, {"methodBody": ["METHOD_START", "{", "myElement . setFileDescription ( new   DomHighlightingLiteTest . MyNonHighlightingDomFileDescription (  )  )  ;", "assertInstanceOf ( myAnnotationsManager . getMockInspection ( myElement )  ,    MockDomInspection . class )  ;", "}", "METHOD_END"], "methodName": ["testMockDomInspection"], "fileName": "com.intellij.util.xml.DomHighlightingLiteTest"}, {"methodBody": ["METHOD_START", "{", "myElement . setFileDescription ( new   DomHighlightingLiteTest . MyNonHighlightingDomFileDescription (  )  )  ;", "myInspectionProfile . setInspectionTools ( new   LocalInspectionToolWrapper ( new   DomHighlightingLiteTest . MyDomElementsInspection (  )  )  )  ;", "assertNull ( myAnnotationsManager . getMockInspection ( myElement )  )  ;", "}", "METHOD_END"], "methodName": ["testNoMockInspection"], "fileName": "com.intellij.util.xml.DomHighlightingLiteTest"}, {"methodBody": ["METHOD_START", "{", "myAnnotationsManager . appendProblems ( myElement ,    DomHighlightingLiteTest . createHolder (  )  ,    DomHighlightingLiteTest . MyDomElementsInspection . class )  ;", "final   DomElementsProblemsHolderImpl   holder    =    DomHighlightingLiteTest . assertNotEmptyHolder ( myAnnotationsManager . getProblemHolder ( myElement )  )  ;", "assertEmpty ( holder . getAllProblems (  )  )  ;", "assertEmpty ( holder . getAllProblems ( new   DomHighlightingLiteTest . MyDomElementsInspection (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testProblemDescriptorIsCreated"], "fileName": "com.intellij.util.xml.DomHighlightingLiteTest"}, {"methodBody": ["METHOD_START", "{", "final   DomHighlightingLiteTest . MyElement   element    =    createElement (  \"  < a   id    /  >  \"  ,    DomHighlightingLiteTest . MyElement . class )  ;", "new   DomHighlightingLiteTest . MyBasicDomElementsInspection (  )  . checkDomElement ( element . getId (  )  ,    DomHighlightingLiteTest . createHolder (  )  ,    DomHighlightingHelperImpl . INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["testRequiredAttributeWithoutAttributeValue"], "fileName": "com.intellij.util.xml.DomHighlightingLiteTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   xmlFile    =     (  ( XmlFile )     ( createFile ( fileName ,    fileText )  )  )  ;", "final   DomFileElementImpl <  . MyElement >    element    =    getDomManager (  )  . getFileElement ( xmlFile ,     . MyElement . class ,    xmlFile . getDocument (  )  . getRootTag (  )  . getName (  )  )  ;", "return   element . getRootElement (  )  ;", "}", "METHOD_END"], "methodName": ["createDomFile"], "fileName": "com.intellij.util.xml.DomIncludesTest"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   file    =    myFixture . getTempDirFixture (  )  . createFile ( fileName ,    fileText )  ;", "PsiDocumentManager . getInstance ( getProject (  )  )  . mitAllDocuments (  )  ;", "return   myFixture . getPsiManager (  )  . findFile ( file )  ;", "}", "METHOD_END"], "methodName": ["createFile"], "fileName": "com.intellij.util.xml.DomIncludesTest"}, {"methodBody": ["METHOD_START", "{", "return   DomManagerImpl . getDomManager ( getProject (  )  )  ;", "}", "METHOD_END"], "methodName": ["getDomManager"], "fileName": "com.intellij.util.xml.DomIncludesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomIncludesTest . MyElement   rootElement    =    createDomFile (  \" a . xml \"  ,     (  \"  < root   xmlns : xi =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XInclude \\  \"  >  \"     +     (  \"  < xi : include   href =  \\  \" b . xml \\  \"    xpointer =  \\  \" xpointer (  / xxx /  *  )  \\  \"  /  >  \"     +     \"  <  / root >  \"  )  )  )  ;", "final   String   textB    =     \"  < xxx >  < boy /  >  < xi : include   href =  \\  \" c . xml \\  \"    xpointer =  \\  \" xpointer (  / xxx /  *  )  \\  \"  /  >  < child /  >  < xi : include   href =  \\  \" c . xml \\  \"    xpointer =  \\  \" xpointer (  / xxx /  *  )  \\  \"  /  >  <  / xxx >  \"  ;", "final   PsiFile   fileB    =    createFile (  \" b . xml \"  ,    textB )  ;", "final   String   textC    =     \"  < xxx >  < child /  >  < xi : include   href =  \\  \" d . xml \\  \"    xpointer =  \\  \" xpointer (  / xxx /  *  )  \\  \"  /  >  < boy /  >  < xi : include   href =  \\  \" d . xml \\  \"    xpointer =  \\  \" xpointer (  / xxx /  *  )  \\  \"  /  >  <  / xxx >  \"  ;", "final   PsiFile   fileC    =    createFile (  \" c . xml \"  ,    textC )  ;", "final   String   textD    =     \"  < xxx >  < boy /  >  < xi : include   href =  \\  \" e . xml \\  \"    xpointer =  \\  \" xpointer (  / xxx /  *  )  \\  \"  /  >  < child /  >  < xi : include   href =  \\  \" e . xml \\  \"    xpointer =  \\  \" xpointer (  / xxx /  *  )  \\  \"  /  >  <  / xxx >  \"  ;", "final   PsiFile   fileD    =    createFile (  \" d . xml \"  ,    textD )  ;", "final   String   textE    =     \"  < xxx >  < boy /  >  < child /  >  < boy /  >  < child /  >  < boy /  >  < child /  >  < boy /  >  < child /  >  < boy /  >  < child /  >  < boy /  >  < child /  >  <  / xxx >  \"  ;", "final   PsiFile   fileE    =    createFile (  \" e . xml \"  ,    textE )  ;", "final   int   threadCount    =     2  0  ;", "final   int   iterationCount    =    Timings . adjustAccordingToMySpeed (  1  0  0  ,    true )  ;", "System . out . println (  (  \" iterationCount    =     \"     +    iterationCount )  )  ;", "final   CountDownLatch   finished    =    new   CountDownLatch ( threadCount )  ;", "final   AtomicReference < Exception >    ex    =    new   AtomicReference <  >  (  )  ;", "for    ( int   j    =     0  ;    j    <    threadCount ;    j +  +  )     {", "ApplicationManager . getApplication (  )  . executeOnPooledThread (  (  )     -  >     {", "try    {", "for    ( int   k    =     0  ;    k    <    iterationCount ;    k +  +  )     {", "ApplicationManager . getApplication (  )  . runReadAction (  (  )     -  >     {", "final   List < Boy >    boys    =    rootElement . getBoys (  )  ;", "Thread . yield (  )  ;", "final   List < Child >    children    =    rootElement . getChildren (  )  ;", "Thread . yield (  )  ;", "assertEquals ( boys ,    rootElement . getBoys (  )  )  ;", "assertEquals ( children ,    rootElement . getChildren (  )  )  ;", "}  )  ;", "Thread . yield (  )  ;", "}", "}    catch    (    e )     {", "ex . set ( e )  ;", "}    finally    {", "finished . countDown (  )  ;", "}", "}  )  ;", "}", "for    ( int   i    =     0  ;    i    <    iterationCount ;    i +  +  )     {", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "fileB . getViewProvider (  )  . getDocument (  )  . insertString (  0  ,     \"     \"  )  ;", "fileD . getViewProvider (  )  . getDocument (  )  . insertString (  0  ,     \"     \"  )  ;", "PsiDocumentManager . getInstance ( getProject (  )  )  . commitAllDocuments (  )  ;", "}  )  ;", "Thread . sleep (  1  0  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "fileC . getViewProvider (  )  . getDocument (  )  . insertString (  0  ,     \"     \"  )  ;", "fileE . getViewProvider (  )  . getDocument (  )  . insertString (  0  ,     \"     \"  )  ;", "PsiDocumentManager . getInstance ( getProject (  )  )  . commitAllDocuments (  )  ;", "}  )  ;", "Thread . sleep (  1  0  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "fileB . getViewProvider (  )  . getDocument (  )  . setText ( textB )  ;", "fileC . getViewProvider (  )  . getDocument (  )  . setText ( textC )  ;", "fileD . getViewProvider (  )  . getDocument (  )  . setText ( textD )  ;", "fileE . getViewProvider (  )  . getDocument (  )  . setText ( textE )  ;", "PsiDocumentManager . getInstance ( getProject (  )  )  . commitAllDocuments (  )  ;", "}  )  ;", "}", "finished . await (  )  ;", "final   Exception   exception    =    ex . get (  )  ;", "if    ( exception    !  =    null )     {", "throw   exception ;", "}", "}", "METHOD_END"], "methodName": ["testEqualsWithMultiThreadedIncludes"], "fileName": "com.intellij.util.xml.DomIncludesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomIncludesTest . MyElement   rootElement    =    createDomFile (  \" a . xml \"  ,     (  \"  < root   xmlns : xi =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XInclude \\  \"  >  \"     +     (  (  \"  < xi : include   href =  \\  \" b . xml \\  \"    xpointer =  \\  \" xpointer (  / xxx /  *  )  \\  \"  /  >  \"     +     \"  < child   xxx =  \\  \" a \\  \"  /  >  \"  )     +     \"  <  / root >  \"  )  )  )  ;", "createFile (  \" b . xml \"  ,     \"  < xxx >  < child   xxx =  \\  \" b \\  \"  /  >  <  / xxx >  \"  )  ;", "final   List < DomIncludesTest . Child >    children    =    rootElement . getChildren (  )  ;", "Consumer < DomIncludesTest . MyElement >    consumer 1     =     (    element )     -  >     {", "assertFalse ( element . getXmlElement (  )  . isPhysical (  )  )  ;", "assertEquals ( rootElement ,    element . getParent (  )  )  ;", "assertEquals ( DomUtil . getFileElement ( rootElement )  ,    DomUtil . getFileElement ( element )  )  ;", "assertEquals (  \" b \"  ,    element . getXxx (  )  . getValue (  )  )  ;", "}  ;", "Consumer < DomIncludesTest . MyElement >    consumer 2     =     (    element )     -  >     {", "assertTrue ( element . getXmlElement (  )  . isPhysical (  )  )  ;", "assertEquals ( rootElement ,    element . getParent (  )  )  ;", "assertEquals ( DomUtil . getFileElement ( rootElement )  ,    DomUtil . getFileElement ( element )  )  ;", "assertEquals (  \" a \"  ,    element . getXxx (  )  . getValue (  )  )  ;", "}  ;", "assertOrderedCollection ( children ,    consumer 1  ,    consumer 2  )  ;", "}", "METHOD_END"], "methodName": ["testGetChildrenHonorsIncludes"], "fileName": "com.intellij.util.xml.DomIncludesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomIncludesTest . MyElement   rootElement    =    createDomFile (  \" a . xml \"  ,     (  \"  < root   xmlns : xi =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XInclude \\  \"    xmlns : foo =  \\  \" foo \\  \"  >  \"     +     (  (  \"  < xi : include   href =  \\  \" b . xml \\  \"    xpointer =  \\  \" xpointer (  / xxx /  *  )  \\  \"  /  >  \"     +     \"  < foo : boy   xxx =  \\  \" a \\  \"  /  >  \"  )     +     \"  <  / root >  \"  )  )  )  ;", "DomUtil . getFileElement ( rootElement )  . getFileDescription (  )  . registerNamespacePolicy (  \" foo \"  ,     \" foo \"  )  ;", "createFile (  \" b . xml \"  ,     \"  < xxx   xmlns : foo =  \\  \" foo \\  \"  >  < foo : boy   xxx =  \\  \" b \\  \"  /  >  <  / xxx >  \"  )  ;", "final   List < DomIncludesTest . Boy >    children    =    rootElement . getBoys (  )  ;", "assertOrderedCollection ( children ,     (    element )     -  >     {", "assertFalse ( element . getXmlElement (  )  . isPhysical (  )  )  ;", "assertEquals ( rootElement ,    element . getParent (  )  )  ;", "assertEquals ( DomUtil . getFileElement ( rootElement )  ,    DomUtil . getFileElement ( element )  )  ;", "assertEquals (  \" b \"  ,    element . getXxx (  )  . getValue (  )  )  ;", "}  ,     (    element )     -  >     {", "assertTrue ( element . getXmlElement (  )  . isPhysical (  )  )  ;", "assertEquals ( rootElement ,    element . getParent (  )  )  ;", "assertEquals ( DomUtil . getFileElement ( rootElement )  ,    DomUtil . getFileElement ( element )  )  ;", "assertEquals (  \" a \"  ,    element . getXxx (  )  . getValue (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testNamespaces"], "fileName": "com.intellij.util.xml.DomIncludesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomIncludesTest . MyElement   rootElement    =    createDomFile (  \" a . xml \"  ,     (  \"  < root   xmlns : xi =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XInclude \\  \"  >  \"     +     (  (  \"  < xi : include   href =  \\  \" b . xml \\  \"    xpointer =  \\  \" xpointer (  / xxx /  *  )  \\  \"  /  >  \"     +     \"  < child   ref =  \\  \" b \\  \"  /  >  \"  )     +     \"  <  / root >  \"  )  )  )  ;", "final   XmlFile   includedFile    =     (  ( XmlFile )     ( createFile (  \" b . xml \"  ,     \"  < xxx >  < child   xxx =  \\  \" b \\  \"  /  >  <  / xxx >  \"  )  )  )  ;", "final   List < DomIncludesTest . Child >    children    =    rootElement . getChildren (  )  ;", "final   DomIncludesTest . MyElement   domTarget    =    children . get (  0  )  ;", "final   GenericAttributeValue < DomIncludesTest . Child >    ref    =    children . get (  1  )  . getRef (  )  ;", "final   DomIncludesTest . MyElement   value    =    ref . getValue (  )  ;", "assertEquals ( domTarget ,    value )  ;", "myFixture . configureFromTempProjectFile (  \" a . xml \"  )  ;", "final   int   offset    =     ( ref . getXmlAttributeValue (  )  . getTextRange (  )  . getStartOffset (  )  )     +     1  ;", "myFixture . getEditor (  )  . getCaretModel (  )  . moveToOffset ( offset )  ;", "final   PsiElement   target    =    GotoDeclarationAction . findTargetElement ( getProject (  )  ,    myFixture . getEditor (  )  ,    offset )  ;", "PsiElement   element    =     (  ( DomTarget )     (  (  ( PomTargetPsiElement )     ( target )  )  . getTarget (  )  )  )  . getNavigationElement (  )  ;", "assertSame ( includedFile . getDocument (  )  . getRootTag (  )  . getSubTags (  )  [  0  ]  . getAttributes (  )  [  0  ]  . getValueElement (  )  ,    element )  ;", "}", "METHOD_END"], "methodName": ["testNavigationToIncluded"], "fileName": "com.intellij.util.xml.DomIncludesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomFileElement < DomElement >    element    =    getFileElement ( xmlFile )  ;", "return   element    !  =    null    ?    element . getFileDescription (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getDomFileDescription"], "fileName": "com.intellij.util.xml.DomManager"}, {"methodBody": ["METHOD_START", "{", "return   DomManager . INSTANCE _ CACHE . getValue ( project )  ;", "}", "METHOD_END"], "methodName": ["getDomManager"], "fileName": "com.intellij.util.xml.DomManager"}, {"methodBody": ["METHOD_START", "{", "return   myElement ;", "}", "METHOD_END"], "methodName": ["getElement"], "fileName": "com.intellij.util.xml.DomMetaData"}, {"methodBody": ["METHOD_START", "{", "return   myElement . getGenericInfo (  )  . getNameDomElement ( t )  ;", "}", "METHOD_END"], "methodName": ["getNameElement"], "fileName": "com.intellij.util.xml.DomMetaData"}, {"methodBody": ["METHOD_START", "{", "myElement    =    element ;", "}", "METHOD_END"], "methodName": ["setElement"], "fileName": "com.intellij.util.xml.DomMetaData"}, {"methodBody": ["METHOD_START", "{", "XmlFile   mergedFile    =    myMerger . mergeModels ( XmlFile . class ,    DomTestCase . createXmlFile (  \"  \"  )  ,    DomTestCase . createXmlFile (  \"  \"  )  )  ;", "assertNull ( DomManager . getDomManager ( ourProject )  . getFileElement ( mergedFile )  )  ;", "}", "METHOD_END"], "methodName": ["testFileMerging"], "fileName": "com.intellij.util.xml.DomModelMergingTest"}, {"methodBody": ["METHOD_START", "{", "WriteCommandAction . writeCommandAction ( getProject (  )  )  . run (  (  )     -  >     {", "final   MyElement   element    =    createElement (  \"  \"  ,     . class )  ;", "final   MyElement   bar 1     =    element . addBar (  )  ;", "final   MyElement   bar 2     =    element . addBar (  )  ;", "final   MyElement   merged    =    myMerger . merges (  . class ,    bar 1  ,    bar 2  )  ;", "assertTrue ( merged . isValid (  )  )  ;", "bar 2  . undefine (  )  ;", "assertFalse ( merged . isValid (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testValidity"], "fileName": "com.intellij.util.xml.DomModelMergingTest"}, {"methodBody": ["METHOD_START", "{", "final   DomModelMergingTest . MyElement   element 1     =    createElement (  \"  \"  ,    DomModelMergingTest . MyElement . class )  ;", "final   DomModelMergingTest . MyElement   foo 1     =    element 1  . getFoo (  )  ;", "final   DomModelMergingTest . MyElement   bar 1     =    element 1  . addBar (  )  ;", "final   DomModelMergingTest . MyElement   bar 2     =    element 1  . addBar (  )  ;", "final   DomModelMergingTest . MyElement   element 2     =    createElement (  \"  \"  ,    DomModelMergingTest . MyElement . class )  ;", "final   DomModelMergingTest . MyElement   foo 2     =    element 2  . getFoo (  )  ;", "final   DomModelMergingTest . MyElement   bar 3     =    element 2  . addBar (  )  ;", "final   DomModelMergingTest . MyElement   element    =    myMerger . mergeModels ( DomModelMergingTest . MyElement . class ,    element 1  ,    element 2  )  ;", "final   DomModelMergingTest . MyElement   foo    =    element . getFoo (  )  ;", "assertEquals ( foo ,    myMerger . mergeModels ( DomModelMergingTest . MyElement . class ,    foo 1  ,    foo 2  )  )  ;", "final   int [  ]    count    =    new   int [  ]  {     0     }  ;", "element . accept ( new   DomElementVisitor (  )     {", "@ Override", "public   void   visitDomElement ( DomElement    _ element )     {", "( count [  0  ]  )  +  +  ;", "assertEquals (  _ element ,    element )  ;", "}", "}  )  ;", "assertEquals (  1  ,    count [  0  ]  )  ;", "count [  0  ]     =     0  ;", "final   Set < DomElement >    result    =    new   HashSet <  >  (  )  ;", "element . acceptChildren ( new   DomElementVisitor (  )     {", "@ Override", "public   void   visitDomElement ( DomElement   element )     {", "( count [  0  ]  )  +  +  ;", "result . add ( element )  ;", "}", "}  )  ;", "assertEquals ( new   HashSet ( Arrays . asList ( foo ,    bar 1  ,    bar 2  ,    bar 3  )  )  . toString (  )  . replace (  \"  ,  \"  ,     \"  \\ n \"  )  ,    result . toString (  )  . replace (  \"  ,  \"  ,     \"  \\ n \"  )  )  ;", "assertEquals ( new   HashSet ( Arrays . asList ( foo ,    bar 1  ,    bar 2  ,    bar 3  )  )  ,    result )  ;", "assertEquals (  4  ,    count [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testVisitor"], "fileName": "com.intellij.util.xml.DomModelMergingTest"}, {"methodBody": ["METHOD_START", "{", "if    (  ( o    =  =    null )     |  |     ( o   instanceof   String )  )     {", "return    (  ( String )     ( o )  )  ;", "} else", "if    ( o   instanceof   GenericValue )     {", "final   GenericValue   value    =     (  ( GenericValue )     ( o )  )  ;", "if    (  ! local )     {", "final   Object   n    =    value . getValue (  )  ;", "if    ( n    !  =    null )     {", "return   String . valueOf ( n )  ;", "}", "}", "return   value . getStringValue (  )  ;", "} else    {", "return   String . valueOf ( o )  ;", "}", "}", "METHOD_END"], "methodName": ["getNameFromNameValue"], "fileName": "com.intellij.util.xml.DomNameSuggestionProvider"}, {"methodBody": ["METHOD_START", "{", "registerNamespacePolicies ( element ,     \" foo \"  ,     \" bar \"  )  ;", "}", "METHOD_END"], "methodName": ["registerNamespacePolicies"], "fileName": "com.intellij.util.xml.DomNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomFileDescription   description    =    getDomManager (  )  . getDomFileDescription ( element . getXmlElement (  )  )  ;", "description . registerPolicy (  \" foo \"  ,    foo )  ;", "description . registerPolicy (  \" bar \"  ,    bar )  ;", "}", "METHOD_END"], "methodName": ["registerNamespacePolicies"], "fileName": "com.intellij.util.xml.DomNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomNamespacesTest . MyElement   element    =    createElement (  \"  < a   xmlns =  \\  \" foo \\  \"    xmlns : bar =  \\  \" bar \\  \"  >  < foo - child   bar : my - attribute =  \\  \" xxx \\  \"  /  >  <  / a >  \"  ,    DomNamespacesTest . MyElement . class )  ;", "registerNamespacePolicies ( element )  ;", "final   DomNamespacesTest . MyFooElement   fooElement    =    element . getFooChild (  )  ;", "final   DomNamespacesTest . MyAttribute   myAttribute    =    fooElement . getMyAttribute (  )  ;", "assertNotNull ( myAttribute . getXmlAttribute (  )  )  ;", "assertEquals (  \" xxx \"  ,    myAttribute . getStringValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeWithAnotherNamespace"], "fileName": "com.intellij.util.xml.DomNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomNamespacesTest . MyElement   root    =    createElement (  \"  < a   xmlns =  \\  \" foo \\  \"  /  >  \"  ,    DomNamespacesTest . MyElement . class )  ;", "getDomManager (  )  . getDomFileDescription ( root . getXmlElement (  )  )  . registerNamespacePolicy (  \" foo \"  ,     \" bar \"  ,     \" foo \"  )  ;", "final   XmlTag   fooChildTag    =    root . getFooChild (  )  . ensureTagExists (  )  ;", "assertEquals (  \" foo - child \"  ,    fooChildTag . getName (  )  )  ;", "assertEquals (  \" foo \"  ,    fooChildTag . getNamespace (  )  )  ;", "assertEquals (  \"  \"  ,    fooChildTag . getNamespacePrefix (  )  )  ;", "assertEquals (  0  ,    fooChildTag . getAttributes (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testAutoChooseNamespaceIfPresent"], "fileName": "com.intellij.util.xml.DomNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomNamespacesTest . MyElement   element    =    createElement (  \"  < a   xmlns : foo =  \\  \" foo \\  \"  /  >  \"  ,    DomNamespacesTest . MyElement . class )  ;", "registerNamespacePolicies ( element )  ;", "final   XmlTag   fooChildTag    =    element . addFooElement (  )  . getXmlTag (  )  ;", "assertEquals (  \" foo : foo - element \"  ,    fooChildTag . getName (  )  )  ;", "assertEquals (  \" foo \"  ,    fooChildTag . getNamespace (  )  )  ;", "assertEquals (  \" foo \"  ,    fooChildTag . getNamespacePrefix (  )  )  ;", "assertNull ( fooChildTag . getAttributeValue (  \" xmlns \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCollectionChildNamespace"], "fileName": "com.intellij.util.xml.DomNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomNamespacesTest . MyElement   element    =    createElement (  \"  < a   xmlns =  \\  \" foo \\  \"    xmlns : bar =  \\  \" bar \\  \"  /  >  \"  ,    DomNamespacesTest . MyElement . class )  ;", "registerNamespacePolicies ( element )  ;", "final   DomNamespacesTest . MyElement   element 2     =    createElement (  (  \"  < f : a   xmlns : f =  \\  \" foo 1  \\  \"    xmlns : b =  \\  \" bar 1  \\  \"    xmlns =  \\  \" foo 1  \\  \"  >  \"     +     (  (  (  (  (  (  (  \"  < foo - child /  >  \"     +     \"  < b : bar - child /  >  \"  )     +     \"  < f : some - child /  >  \"  )     +     \"  < f : foo - element   attr -  2  =  \\  \"  2  3  9  \\  \"    attr =  \\  \"  4  2  \\  \"  /  >  \"  )     +     \"  < f : foo - element /  >  \"  )     +     \"  < f : bool /  >  \"  )     +     \"  < sys : aaa /  >  \"  )     +     \"  <  / f : a >  \"  )  )  ,    DomNamespacesTest . MyElement . class )  ;", "registerNamespacePolicies ( element 2  ,     \" foo 1  \"  ,     \" bar 1  \"  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "element . copyFrom ( element 2  )  ;", "}  )  ;", "assertEquals (  (  \"  < a   xmlns =  \\  \" foo \\  \"    xmlns : bar =  \\  \" bar \\  \"  >  \"     +     (  (  (  (  (  (  (  \"  < bar : bar - child /  >  \"     +     \"  < bool /  >  \"  )     +     \"  < foo - child /  >  \"  )     +     \"  < some - child /  >  \"  )     +     \"  < sys : aaa /  >  \"  )     +     \"  < foo - element   attr =  \\  \"  4  2  \\  \"    attr -  2  =  \\  \"  2  3  9  \\  \"  /  >  \"  )     +     \"  < foo - element /  >  \"  )     +     \"  <  / a >  \"  )  )  ,    element . getXmlTag (  )  . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCopyFromHonorsNamespaces"], "fileName": "com.intellij.util.xml.DomNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomNamespacesTest . MyElement   element    =    createElement (  \"  < a /  >  \"  ,    DomNamespacesTest . MyElement . class )  ;", "registerNamespacePolicies ( element )  ;", "final   XmlTag   fooChildTag    =    element . getFooChild (  )  . ensureTagExists (  )  ;", "assertEquals (  \" foo - child \"  ,    fooChildTag . getName (  )  )  ;", "assertEquals (  \" foo \"  ,    fooChildTag . getNamespace (  )  )  ;", "assertEquals (  \"  \"  ,    fooChildTag . getNamespacePrefix (  )  )  ;", "assertEquals (  \" foo \"  ,    fooChildTag . getAttributeValue (  \" xmlns \"  )  )  ;", "final   XmlTag   barChildTag    =    element . getBarChild (  )  . ensureTagExists (  )  ;", "assertEquals (  \" bar - child \"  ,    barChildTag . getName (  )  )  ;", "assertEquals (  \" bar \"  ,    barChildTag . getNamespace (  )  )  ;", "assertEquals (  \"  \"  ,    barChildTag . getNamespacePrefix (  )  )  ;", "assertEquals (  \" bar \"  ,    barChildTag . getAttributeValue (  \" xmlns \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testDefineNewNamespace"], "fileName": "com.intellij.util.xml.DomNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomGenericInfo   info    =    getDomManager (  )  . getGenericInfo ( DomNamespacesTest . MyListOrSet . class )  ;", "assertNotNull ( info . getAttributeChildDescription (  \" attr \"  )  )  ;", "assertNotNull ( info . getAttributeChildDescription (  \" attr \"  )  . getType (  )  )  ;", "assertNotNull ( info . getCollectionChildDescription (  \" child \"  )  )  ;", "assertNotNull ( info . getCollectionChildDescription (  \" child \"  )  . getType (  )  )  ;", "assertNotNull ( info . getFixedChildDescription (  \" ref \"  )  )  ;", "assertNotNull ( info . getFixedChildDescription (  \" ref \"  )  . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFindChildDescriptionWithoutNamespace"], "fileName": "com.intellij.util.xml.DomNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   xmlFile    =    DomTestCase . createXmlFile (  \"  < a   xmlns : sys =  \\  \"  \\  \"  /  >  \"  )  ;", "final    . MyElement   element    =    getDomManager (  )  . getFileElement ( xmlFile ,     . MyElement . class ,     \" a \"  )  . getRootElement (  )  ;", "final    . MyElement   hardcodedElement    =    element . getHardcodedElement (  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "hardcodedElement . ensureTagExists (  )  ;", "}  )  ;", "assertTrue ( element . isValid (  )  )  ;", "assertTrue ( hardcodedElement . isValid (  )  )  ;", "assertNotNull ( hardcodedElement . getXmlElement (  )  )  ;", "assertEquals (  \"  < sys : aaa /  >  \"  ,    hardcodedElement . getXmlElement (  )  . getText (  )  )  ;", "assertEquals (  \" sys : aaa \"  ,    hardcodedElement . getXmlTag (  )  . getName (  )  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "hardcodedElement . getHardcodedElement (  )  . getHardcodedElement (  )  . ensureTagExists (  )  ;", "}  )  ;", "assertTrue ( element . isValid (  )  )  ;", "assertTrue ( hardcodedElement . isValid (  )  )  ;", "assertNotNull ( hardcodedElement . getXmlElement (  )  )  ;", "assertEquals (  \" sys : aaa \"  ,    hardcodedElement . getHardcodedElement (  )  . getHardcodedElement (  )  . getXmlTag (  )  . getName (  )  )  ;", "assertEquals (  1  ,    element . getXmlTag (  )  . getSubTags (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testHardcodedNamespacePrefix"], "fileName": "com.intellij.util.xml.DomNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomNamespacesTest . MyElement   element    =    createElement (  \"  < a   xmlns =  \\  \" foo \\  \"  /  >  \"  ,    DomNamespacesTest . MyElement . class )  ;", "registerNamespacePolicies ( element )  ;", "final   XmlTag   childTag    =    element . addChild (  )  . getXmlTag (  )  ;", "assertEquals (  \" child \"  ,    childTag . getName (  )  )  ;", "assertEquals (  \" foo \"  ,    childTag . getNamespace (  )  )  ;", "assertEquals (  \"  \"  ,    childTag . getNamespacePrefix (  )  )  ;", "assertNull ( childTag . getAttributeValue (  \" xmlns \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testNamespaceEqualToParent"], "fileName": "com.intellij.util.xml.DomNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomNamespacesTest . MyElement   root    =    createElement (  \"  < a   xmlns =  \\  \" foo \\  \"  /  >  \"  ,    DomNamespacesTest . MyElement . class )  ;", "registerNamespacePolicies ( root )  ;", "final   DomNamespacesTest . MyFooElement   element    =    root . addFooElement (  )  ;", "final   DomNamespacesTest . MyElement   child    =    element . addChild (  )  ;", "final   XmlTag   childTag    =    child . getXmlTag (  )  ;", "assertEquals (  \" child \"  ,    childTag . getName (  )  )  ;", "assertEquals (  \" foo \"  ,    childTag . getNamespace (  )  )  ;", "assertEquals (  \"  \"  ,    childTag . getNamespacePrefix (  )  )  ;", "assertNull ( childTag . getAttributeValue (  \" xmlns \"  )  )  ;", "assertEquals (  \" foo \"  ,    element . getXmlElementNamespaceKey (  )  )  ;", "assertNull ( child . getXmlElementNamespaceKey (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNamespaceEqualToParent2"], "fileName": "com.intellij.util.xml.DomNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomNamespacesTest . MyElement   element    =    createElement (  \"  < a   xmlns : foo =  \\  \" foo \\  \"  /  >  \"  ,    DomNamespacesTest . MyElement . class )  ;", "registerNamespacePolicies ( element )  ;", "final   XmlTag   childTag    =    element . addChild (  )  . getXmlTag (  )  ;", "assertEquals (  \" child \"  ,    childTag . getName (  )  )  ;", "assertEquals (  \"  \"  ,    childTag . getNamespace (  )  )  ;", "assertEquals (  \"  \"  ,    childTag . getNamespacePrefix (  )  )  ;", "assertNull ( childTag . getAttributeValue (  \" xmlns \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testNoNamespaceForCollectionChild"], "fileName": "com.intellij.util.xml.DomNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomNamespacesTest . MyElement   element    =    createElement (  \"  < a   xmlns : foo =  \\  \" foo \\  \"  /  >  \"  ,    DomNamespacesTest . MyElement . class )  ;", "registerNamespacePolicies ( element )  ;", "final   XmlTag   childTag    =    element . getSomeChild (  )  . ensureTagExists (  )  ;", "assertEquals (  \" some - child \"  ,    childTag . getName (  )  )  ;", "assertEquals (  \"  \"  ,    childTag . getNamespace (  )  )  ;", "assertEquals (  \"  \"  ,    childTag . getNamespacePrefix (  )  )  ;", "assertNull ( childTag . getAttributeValue (  \" xmlns \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testNoNamespaceForFixedChild"], "fileName": "com.intellij.util.xml.DomNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "getDomManager (  )  . registerFileDescription ( new   DomFileDescription < DomNamespacesTest . MyFooElement >  ( DomNamespacesTest . MyFooElement . class ,     \" a \"  ,     \" foons \"  )     {", "@ Override", "protected   void   initializeFileDescription (  )     {", "super . initializeFileDescription (  )  ;", "registerNamespacePolicy (  \" foo \"  ,     \" foons \"  )  ;", "}", "}  ,    getTestRootDisposable (  )  )  ;", "final   XmlFile   psiFile    =    DomTestCase . createXmlFile (  \"  < f : a   xmlns : f =  \\  \" foons \\  \"  /  >  \"  )  ;", "final   DomFileElementImpl < DomNamespacesTest . MyFooElement >    element    =    getDomManager (  )  . getFileElement ( psiFile ,    DomNamespacesTest . MyFooElement . class )  ;", "assertNotNull ( element )  ;", "final   DomNamespacesTest . MyFooElement   root    =    element . getRootElement (  )  ;", "assertNotNull ( root )  ;", "assertSame ( psiFile . getDocument (  )  . getRootTag (  )  ,    root . getXmlElement (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNonemptyRootTagPrefix"], "fileName": "com.intellij.util.xml.DomNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "getDomManager (  )  . registerFileDescription ( new   DomFileDescription < DomNamespacesTest . MyBeans >  ( DomNamespacesTest . MyBeans . class ,     \" beans \"  ,     \" beans \"  ,     \" aop \"  )     {", "@ Override", "protected   void   initializeFileDescription (  )     {", "super . initializeFileDescription (  )  ;", "registerNamespacePolicy (  \" beans \"  ,     \" beans \"  )  ;", "registerNamespacePolicy (  \" aop \"  ,     \" aop \"  )  ;", "}", "}  ,    getTestRootDisposable (  )  )  ;", "final   XmlFile   psiFile    =    DomTestCase . createXmlFile (  (  \"  < beans   xmlns =  \\  \" beans \\  \"    xmlns : aop =  \\  \" aop \\  \"  >  \"     +     (  (  (  \"  < aop : config >  \"     +     \"  < aop : pointcut /  >  \"  )     +     \"  <  / aop : config >  \"  )     +     \"  <  / beans >  \"  )  )  )  ;", "final   DomNamespacesTest . MyBeans   beans    =    getDomManager (  )  . getFileElement ( psiFile ,    DomNamespacesTest . MyBeans . class )  . getRootElement (  )  ;", "final   DomElement   pointcut    =    getDomManager (  )  . getDomElement ( beans . getXmlTag (  )  . findFirstSubTag (  \" aop : config \"  )  . findFirstSubTag (  \" aop : pointcut \"  )  )  ;", "assertNotNull ( pointcut )  ;", "final   DomNamespacesTest . MyAopConfig   aopConfig    =    beans . getConfig (  )  ;", "assertEquals ( assertOneElement ( aopConfig . getPointcuts (  )  )  ,    pointcut )  ;", "}", "METHOD_END"], "methodName": ["testSpringAopLike"], "fileName": "com.intellij.util.xml.DomNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "getDomManager (  )  . registerFileDescription ( new   DomFileDescription < DomNamespacesTest . MyBeans >  ( DomNamespacesTest . MyBeans . class ,     \" beans \"  ,     \" beans \"  ,     \" util \"  )     {", "@ Override", "protected   void   initializeFileDescription (  )     {", "super . initializeFileDescription (  )  ;", "registerNamespacePolicy (  \" beans \"  ,     \" beans \"  )  ;", "registerNamespacePolicy (  \" util \"  ,     \" util \"  )  ;", "}", "}  ,    getTestRootDisposable (  )  )  ;", "final   XmlFile   psiFile    =    DomTestCase . createXmlFile (  (  \"  < beans   xmlns =  \\  \" beans \\  \"    xmlns : util =  \\  \" util \\  \"  >  \"     +     (  (  (  \"  < util : list >  \"     +     \"  < ref > aaa <  / ref >  \"  )     +     \"  < util : child > bbb <  / util : child >  \"  )     +     \"  <  / util : list >  <  / beans >  \"  )  )  )  ;", "final   DomNamespacesTest . MyList   listOrSet    =    assertInstanceOf ( getDomManager (  )  . getFileElement ( psiFile ,    DomNamespacesTest . MyBeans . class )  . getRootElement (  )  . getList (  )  ,    DomNamespacesTest . MyList . class )  ;", "assertNotNull ( listOrSet . getXmlTag (  )  )  ;", "final   XmlTag   listTag    =    psiFile . getDocument (  )  . getRootTag (  )  . findFirstSubTag (  \" util : list \"  )  ;", "assertNotNull ( getDomManager (  )  . getDomElement ( listTag . findFirstSubTag (  \" ref \"  )  )  )  ;", "assertNotNull ( getDomManager (  )  . getDomElement ( listTag . findFirstSubTag (  \" util : child \"  )  )  )  ;", "assertEquals (  \" aaa \"  ,    listOrSet . getRef (  )  . getValue (  )  )  ;", "assertEquals (  \" bbb \"  ,    listOrSet . getChild (  )  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpringUtilLike"], "fileName": "com.intellij.util.xml.DomNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomNamespacesTest . MyElement   element    =    createElement (  \"  < a   xmlns =  \\  \" foo \\  \"    xmlns : bar =  \\  \" bar \\  \"  /  >  \"  ,    DomNamespacesTest . MyElement . class )  ;", "registerNamespacePolicies ( element )  ;", "final   XmlTag   fooChildTag    =    element . getFooChild (  )  . ensureTagExists (  )  ;", "assertEquals (  \" foo - child \"  ,    fooChildTag . getName (  )  )  ;", "assertEquals (  \" foo \"  ,    fooChildTag . getNamespace (  )  )  ;", "assertEquals (  \"  \"  ,    fooChildTag . getNamespacePrefix (  )  )  ;", "final   XmlTag   barChildTag    =    element . getBarChild (  )  . ensureTagExists (  )  ;", "assertEquals (  \" bar : bar - child \"  ,    barChildTag . getName (  )  )  ;", "assertEquals (  \" bar \"  ,    barChildTag . getNamespace (  )  )  ;", "assertEquals (  \" bar \"  ,    barChildTag . getNamespacePrefix (  )  )  ;", "}", "METHOD_END"], "methodName": ["testUseExistingNamespace"], "fileName": "com.intellij.util.xml.DomNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "getDomManager (  )  . registerFileDescription ( new   DomFileDescription ( DomPerformanceTest . MyNamespacedElement . class ,     \" foo \"  )     {", "@ Override", "protected   void   initializeFileDescription (  )     {", "registerNamespacePolicy (  \" project \"  ,     \" project \"  )  ;", "}", "}  ,    getTestRootDisposable (  )  )  ;", "XmlFile   file    =     (  ( XmlFile )     ( createFile (  \" a . xml \"  ,     \"  < foo   xmlns =  \\  \" project \\  \"  /  >  \"  )  )  )  ;", "assertFalse ( file . getNode (  )  . isParsed (  )  )  ;", "assertNotNull ( DomManager . getDomManager ( getProject (  )  )  . getFileElement ( file ,    DomPerformanceTest . MyNamespacedElement . class )  )  ;", "file    =     (  ( XmlFile )     ( createFile (  \" a . xml \"  ,     \"  < foo   xmlns =  \\  \" project 2  \\  \"  /  >  \"  )  )  )  ;", "assertFalse ( file . getNode (  )  . isParsed (  )  )  ;", "assertNull ( DomManager . getDomManager ( getProject (  )  )  . getFileElement ( file ,    DomPerformanceTest . MyNamespacedElement . class )  )  ;", "}", "METHOD_END"], "methodName": ["testDontParseNamespacedDomFiles"], "fileName": "com.intellij.util.xml.DomPerformanceTest"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     4  2  0  ;    i +  +  )     {", "getDomManager (  )  . registerFileDescription ( new   DomFileDescription <  . MyChildElement >  (  . MyChildElement . class ,     \" foo \"  )     {", "@ Override", "public   boolean   isMyFile (  @ NotNull", "final   XmlFile   file ,    final   Module   module )     {", "fail (  )  ;", "return   super . isMyFile ( file ,    module )  ;", "}", "}  ,    getTestRootDisposable (  )  )  ;", "getDomManager (  )  . registerFileDescription ( new   DomFileDescription <  . MyChildElement >  (  . MyChildElement . class ,     \" bar \"  )     {", "@ Override", "public   boolean   isMyFile (  @ NotNull", "final   XmlFile   file ,    final   Module   module )     {", "fail (  )  ;", "return   super . isMyFile ( file ,    module )  ;", "}", "}  ,    getTestRootDisposable (  )  )  ;", "}", "getDomManager (  )  . createMockElement (  . MyChildElement . class ,    null ,    true )  ;", "VirtualFile   virtualFile    =    createFile (  \" a . xml \"  ,     \"  \"  )  . getVirtualFile (  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  ( ThrowableComputable < Void ,    IOException >  )     (  (  )     -  >     {", "VfsUtil . saveText ( virtualFile ,     (  (  \"  < root >  \\ n \"     +     ( StringUtil . repeat (  \"  < bar /  >  \\ n \"  ,     2  3  9  4  2  )  )  )     +     \"  <  / root >  \"  )  )  ;", "return   null ;", "}  )  )  )  ;", "(  ( PsiManagerImpl )     ( getPsiManager (  )  )  )  . cleanupForNextTest (  )  ;", "final   XmlFile   file    =     (  ( XmlFile )     ( getPsiManager (  )  . findFile ( virtualFile )  )  )  ;", "assertFalse ( file . getNode (  )  . isParsed (  )  )  ;", "assertTrue ( StringUtil . isNotEmpty ( file . getText (  )  )  )  ;", "PlatformTestUtil . startPerformanceTest (  \" DOM   parsing \"  ,     1  0  ,     (  )     -  >    assertNull ( getDomManager (  )  . getFileElement ( file )  )  )  . assertTiming (  )  ;", "}", "METHOD_END"], "methodName": ["testShouldntParseNonDomFiles"], "fileName": "com.intellij.util.xml.DomPerformanceTest"}, {"methodBody": ["METHOD_START", "{", "final   DomPerformanceTest . MyElement   element    =    createElement (  \"  < root   xmlns =  \\  \" adsf \\  \"    targetNamespace =  \\  \" adsf \\  \"  /  >  \"  ,    DomPerformanceTest . MyElement . class )  ;", "MetaRegistry . bindDataToElement ( DomUtil . getFile ( element )  . getDocument (  )  ,    new   XmlNSDescriptorImpl (  )  )  ;", "final   DomPerformanceTest . MyElement   child    =    element . addChildElement (  )  ;", "child . getAttr (  )  . setValue (  \"  2  3  9  \"  )  ;", "child . getChild 2  3  9  (  )  . getAttr (  )  . setValue (  \"  4  2  \"  )  ;", "child . getChild (  )  . getAttr (  )  . setValue (  \"  4  2 xx \"  )  ;", "child . getChild 2  (  )  . getAttr (  )  . setValue (  \"  4  2 yy \"  )  ;", "child . addChildElement (  )  . getChild (  )  . addFooChild (  )  . getAttr (  )  . setValue (  \" xxx \"  )  ;", "child . addChildElement (  )  . addFooChild (  )  . getAttr (  )  . setValue (  \" yyy \"  )  ;", "child . addChildElement (  )  . addFooChild (  )  . addBarChild (  )  . addBarChild (  )  . addChildElement (  )  . getChild (  )  . getAttr (  )  . setValue (  \" xxx \"  )  ;", "child . addChildElement (  )  . addBarComposite (  )  . setValue (  \" ssss \"  )  ;", "child . addBarChild (  )  . getChild 2  (  )  . getAttr (  )  . setValue (  \"  2  3  4  1  7  8  9  5  6  0  2  3  \"  )  ;", "PlatformTestUtil . startPerformanceTest ( getTestName ( false )  ,     8  0  0  0  0  ,     (  )     -  >    ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >     {", "for    ( int   i    =     0  ;    i    <     2  3  9  ;    i +  +  )     {", "element . addChildElement (  )  . copyFrom ( child )  ;", "}", "}  )  )  . attempts (  1  )  . assertTiming (  )  ;", "final   DomPerformanceTest . MyElement   newElement    =    createElement ( DomUtil . getFile ( element )  . getText (  )  ,    DomPerformanceTest . MyElement . class )  ;", "PlatformTestUtil . startPerformanceTest ( getTestName ( false )  ,     3  0  0  ,    new   ThrowableRunnable (  )     {", "@ Override", "public   void   run (  )     {", "newElement . acceptChildren ( new   DomElementVisitor (  )     {", "@ Override", "public   void   visitDomElement ( DomElement   element )     {", "element . acceptChildren ( this )  ;", "}", "}  )  ;", "}", "}  )  . assertTiming (  )  ;", "}", "METHOD_END"], "methodName": ["testVisitorPerformance"], "fileName": "com.intellij.util.xml.DomPerformanceTest"}, {"methodBody": ["METHOD_START", "{", "DomUtil . getFileElement ( element )  . getFileDescription (  )  . registerReferenceInjector ( new   DomReferenceInjectorTest . MyInjector ( targetElement )  )  ;", "}", "METHOD_END"], "methodName": ["registerInjectorFor"], "fileName": "com.intellij.util.xml.DomReferenceInjectorTest"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \"  < a   attr =  \\  \" abc $  { prop } def \\  \"  /  >  \"  ;", ". MyElement   element    =    createElement ( text ,     . MyElement . class )  ;", ". MyPsiElement   targetElement    =    new    . MyPsiElement (  )  ;", "registerInjectorFor ( element ,    targetElement )  ;", "assertEquals (  \" abcFOOdef \"  ,    element . getAttr (  )  . getStringValue (  )  )  ;", "assertEquals (  \" abcFOOdef \"  ,    element . getAttr (  )  . getValue (  )  )  ;", "assertReference ( element . getAttr (  )  ,    targetElement ,     (  ( text . indexOf (  \"  $  { prop }  \"  )  )     +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttribute"], "fileName": "com.intellij.util.xml.DomReferenceInjectorTest"}, {"methodBody": ["METHOD_START", "{", "DomReferenceInjectorTest . MyElement   element    =    createElement (  \"  < a >  < value > abc $  { prop } def <  / value >  <  / a >  \"  ,    DomReferenceInjectorTest . MyElement . class )  ;", "assertEquals (  \" abc $  { prop } def \"  ,    element . getValue (  )  . getStringValue (  )  )  ;", "assertEquals (  \" abc $  { prop } def \"  ,    element . getValue (  )  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBasic"], "fileName": "com.intellij.util.xml.DomReferenceInjectorTest"}, {"methodBody": ["METHOD_START", "{", "DomReferenceInjectorTest . MyElement   element    =    createElement (  \"  < a >  < value >          abc $  { prop } def          <  / value >  <  / a >  \"  ,    DomReferenceInjectorTest . MyElement . class )  ;", "registerInjectorFor ( element ,    null )  ;", "assertEquals (  \" abcFOOdef \"  ,    element . getValue (  )  . getStringValue (  )  )  ;", "assertEquals (  \" abcFOOdef \"  ,    element . getValue (  )  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCorrectlyCalculateOffsetWithInjector"], "fileName": "com.intellij.util.xml.DomReferenceInjectorTest"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \"  < a >  < value > abc $  { prop } def <  / value >  <  / a >  \"  ;", ". MyElement   element    =    createElement ( text ,     . MyElement . class )  ;", ". MyPsiElement   targetElement    =    new    . MyPsiElement (  )  ;", "registerInjectorFor ( element ,    targetElement )  ;", "assertEquals (  \" abcFOOdef \"  ,    element . getValue (  )  . getStringValue (  )  )  ;", "assertEquals (  \" abcFOOdef \"  ,    element . getValue (  )  . getValue (  )  )  ;", "assertReference ( element . getValue (  )  ,    targetElement ,     (  ( text . indexOf (  \"  $  { prop }  \"  )  )     +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["testReference"], "fileName": "com.intellij.util.xml.DomReferenceInjectorTest"}, {"methodBody": ["METHOD_START", "{", "DomReferenceInjectorTest . MyElement   element    =    createElement (  \"  < a >  < value > abc $  { prop } def <  / value >  <  / a >  \"  ,    DomReferenceInjectorTest . MyElement . class )  ;", "registerInjectorFor ( element ,    null )  ;", "assertEquals (  \" abcFOOdef \"  ,    element . getValue (  )  . getStringValue (  )  )  ;", "assertEquals (  \" abcFOOdef \"  ,    element . getValue (  )  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithInjector"], "fileName": "com.intellij.util.xml.DomReferenceInjectorTest"}, {"methodBody": ["METHOD_START", "{", "DomReferenceInjectorTest . MyElement   element    =    createElement (  \"  < a >  < converted - value > abc $  { prop } def <  / converted - value >  <  / a >  \"  ,    DomReferenceInjectorTest . MyElement . class )  ;", "registerInjectorFor ( element ,    null )  ;", "assertEquals (  \" abcFOOdef \"  ,    element . getConvertedValue (  )  . getStringValue (  )  )  ;", "assertEquals (  \" abcBARdef \"  ,    element . getConvertedValue (  )  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithInjectorAndConverter"], "fileName": "com.intellij.util.xml.DomReferenceInjectorTest"}, {"methodBody": ["METHOD_START", "{", "final   DomReferencesTest . MyElement   element    =    createElement (  \"  < a >  < string - buffer > zzz <  / string - buffer >  <  / a >  \"  )  ;", "final   XmlTag   tag    =    element . getStringBuffer (  )  . getXmlTag (  )  ;", "assertTrue ( tag . getContainingFile (  )  . findReferenceAt ( tag . getValue (  )  . getTextRange (  )  . getStartOffset (  )  )  . isSoft (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAdditionalValues"], "fileName": "com.intellij.util.xml.DomReferencesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomReferencesTest . MyElement   element    =    createElement (  \"  < a   boolean - attribute =  \\  \" true \\  \"  /  >  \"  )  ;", "final   PsiReference   reference    =    getReference ( element . getBooleanAttribute (  )  )  ;", "assertVariants ( reference ,     \" false \"  ,     \" true \"  )  ;", "final   XmlAttributeValue   xmlAttributeValue    =    element . getBooleanAttribute (  )  . getXmlAttributeValue (  )  ;", "final   PsiElement   psiElement    =    reference . getElement (  )  ;", "assertEquals ( xmlAttributeValue ,    psiElement )  ;", "assertEquals ( new   TextRange (  0  ,     \" true \"  . length (  )  )  . shiftRight (  1  )  ,    reference . getRangeInElement (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBooleanAttributeReference"], "fileName": "com.intellij.util.xml.DomReferencesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomReferencesTest . MyElement   element    =    createElement (  \"  < a >  < boolean > true <  / boolean >  <  / a >  \"  )  ;", "assertVariants ( assertReference ( element . getBoolean (  )  )  ,     \" false \"  ,     \" true \"  )  ;", "}", "METHOD_END"], "methodName": ["testBooleanReference"], "fileName": "com.intellij.util.xml.DomReferencesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomReferencesTest . MyElement   element    =    createElement (  \"  < a >  < string - buffer >  2  3  9  <  / string - buffer >  <  / a >  \"  )  ;", "assertVariants ( assertReference ( element . getStringBuffer (  )  )  ,     \"  2  3  9  \"  ,     \"  4  2  \"  ,     \" foo \"  ,     \" zzz \"  )  ;", "}", "METHOD_END"], "methodName": ["testCustomResolving"], "fileName": "com.intellij.util.xml.DomReferencesTest"}, {"methodBody": ["METHOD_START", "{", "assertVariants ( assertReference ( createElement (  \"  < a >  < enum >  2  3  9  <  / enum >  <  / a >  \"  )  . getEnum (  )  ,    null )  ,     \" A \"  ,     \" B \"  ,     \" C \"  )  ;", "assertVariants ( assertReference ( createElement (  \"  < a >  < enum > A <  / enum >  <  / a >  \"  )  . getEnum (  )  )  ,     \" A \"  ,     \" B \"  ,     \" C \"  )  ;", "}", "METHOD_END"], "methodName": ["testEnumReference"], "fileName": "com.intellij.util.xml.DomReferencesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomReferencesTest . MyElement   element    =    createElement (  \"  < a >  < psi - type >       Strin          <  / psi - type >  <  / a >  \"  )  ;", "final   PsiReference   psiReference    =    assertReference ( element . getPsiType (  )  ,    null )  ;", "assertEquals ( new   TextRange (  2  2  ,     (  2  2     +     (  \" Strin \"  . length (  )  )  )  )  ,    psiReference . getRangeInElement (  )  )  ;", "}", "METHOD_END"], "methodName": ["testIndentedPsiType"], "fileName": "com.intellij.util.xml.DomReferencesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomReferencesTest . MyElement   element    =    createElement (  \"  < a >  < jvm - psi - type >  [ LString ;  <  / jvm - psi - type >  <  / a >  \"  )  ;", "final   XmlTag   tag    =    element . getJvmPsiType (  )  . getXmlTag (  )  ;", "final   TextRange   valueRange    =    tag . getValue (  )  . getTextRange (  )  ;", "final   PsiReference   reference    =    tag . getContainingFile (  )  . findReferenceAt (  (  ( valueRange . getEndOffset (  )  )     -     1  )  )  ;", "assertNotNull ( reference )  ;", "assertEquals ( PsiType . getJavaLangString ( getPsiManager (  )  ,    GlobalSearchScope . allScope ( getProject (  )  )  )  . resolve (  )  ,    reference . resolve (  )  )  ;", "assertEquals (  \"  < jvm - psi - type >  [ L\"  . length (  )  ,    reference . getRangeInElement (  )  . getStartOffset (  )  )  ;", "assertEquals (  \" String \"  . length (  )  ,    reference . getRangeInElement (  )  . getLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["testJvmArrayType"], "fileName": "com.intellij.util.xml.DomReferencesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomReferencesTest . MyElement   element    =    createElement (  \"  \"  )  ;", "element . getName (  )  . setValue (  \" A \"  )  ;", "final   XmlTag   tag    =    element . getXmlTag (  )  ;", "final   DomMetaData   metaData    =    assertInstanceOf ( tag . getMetaData (  )  ,    DomMetaData . class )  ;", "assertEquals ( tag ,    metaData . getDeclaration (  )  )  ;", "assertOrderedEquals ( metaData . getDependences (  )  ,    DomUtil . getFileElement ( element )  ,    tag )  ;", "assertEquals (  \" A \"  ,    metaData . getName (  )  )  ;", "assertEquals (  \" A \"  ,    metaData . getName ( null )  )  ;", "metaData . setName (  \" B \"  )  ;", "assertEquals (  \" B \"  ,    element . getName (  )  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMetaData"], "fileName": "com.intellij.util.xml.DomReferencesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomReferencesTest . MyElement   element    =    createElement (  \"  < a >  < name > abc <  / name >  <  / a >  \"  )  ;", "final   DomTarget   target    =    DomTarget . getTarget ( element )  ;", "assertNotNull ( target )  ;", "final   XmlTag   tag    =    element . getName (  )  . getXmlTag (  )  ;", "assertNull ( tag . getContainingFile (  )  . findReferenceAt ( tag . getValue (  )  . getTextRange (  )  . getStartOffset (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testNameReference"], "fileName": "com.intellij.util.xml.DomReferencesTest"}, {"methodBody": ["METHOD_START", "{", "createElement (  \"  < a >  <  ? xml   version =  \\  \"  1  .  0  \\  \"  ?  >  <  / a >  \"  )  . getXmlTag (  )  . accept ( new   PsiRecursiveElementVisitor (  )     {", "@ Override", "public   void   visitElement ( PsiElement   element )     {", "super . visitElement ( element )  ;", "for    ( final   PsiReference   reference    :    element . get (  )  )     {", "assertFalse (  ( reference   instanceof   GenericDomValueReference )  )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testProcessingInstruction"], "fileName": "com.intellij.util.xml.DomReferencesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomReferencesTest . MyElement   element    =    createElement (  \"  < a >  < psi - type > String [  ]  <  / psi - type >  <  / a >  \"  )  ;", "final   XmlTag   tag    =    element . getPsiType (  )  . getXmlTag (  )  ;", "final   TextRange   valueRange    =    tag . getValue (  )  . getTextRange (  )  ;", "final   PsiReference   reference    =    tag . getContainingFile (  )  . findReferenceAt (  (  ( valueRange . getStartOffset (  )  )     +     (  \" \"  . length (  )  )  )  )  ;", "assertNotNull ( reference )  ;", "assertEquals ( PsiType . getJavaLangString ( getPsiManager (  )  ,    GlobalSearchScope . allScope ( getProject (  )  )  )  . resolve (  )  ,    reference . resolve (  )  )  ;", "assertEquals (  \"  < psi - type > \"  . length (  )  ,    reference . getRangeInElement (  )  . getStartOffset (  )  )  ;", "assertEquals (  \" String \"  . length (  )  ,    reference . getRangeInElement (  )  . getLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPsiArrayType"], "fileName": "com.intellij.util.xml.DomReferencesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomReferencesTest . MyElement   element    =    createElement (  \"  < a >  < psi - class > String <  / psi - class >  <  / a >  \"  )  ;", "assertReference ( element . getPsiClass (  )  ,    PsiType . getJavaLangString ( getPsiManager (  )  ,    GlobalSearchScope . allScope ( getProject (  )  )  )  . resolve (  )  ,     (  ( element . getPsiClass (  )  . getXmlTag (  )  . getValue (  )  . getTextRange (  )  . getEndOffset (  )  )     -     1  )  )  ;", "}", "METHOD_END"], "methodName": ["testPsiClass"], "fileName": "com.intellij.util.xml.DomReferencesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomReferencesTest . MyElement   element    =    createElement (  \"  < a >  < psi - type > int <  / psi - type >  <  / a >  \"  )  ;", "assertReference ( element . getPsiType (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPsiPrimitiveType"], "fileName": "com.intellij.util.xml.DomReferencesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomReferencesTest . MyElement   element    =    createElement (  \"  < a >  < psi - type > int [  ]  <  / psi - type >  <  / a >  \"  )  ;", "final   GenericDomValue   value    =    element . getPsiType (  )  ;", "final   XmlTagValue   tagValue    =    value . getXmlTag (  )  . getValue (  )  ;", "final   int   i    =    tagValue . getText (  )  . indexOf ( value . getStringValue (  )  )  ;", "assertReference ( value ,    value . getXmlTag (  )  ,     (  (  ( tagValue . getTextRange (  )  . getStartOffset (  )  )     +    i )     +     (  \" int \"  . length (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testPsiPrimitiveTypeArray"], "fileName": "com.intellij.util.xml.DomReferencesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomReferencesTest . MyElement   element    =    createElement (  \"  < a >  < psi - type > String <  / psi - type >  <  / a >  \"  )  ;", "assertReference ( element . getPsiType (  )  ,    PsiType . getJavaLangString ( getPsiManager (  )  ,    GlobalSearchScope . allScope ( getProject (  )  )  )  . resolve (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPsiType"], "fileName": "com.intellij.util.xml.DomReferencesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomReferencesTest . MyElement   element    =    createElement (  \"  < a >  < psi - type >  #  $  ^  %  *  $  <  / psi - type >  <  / a >  \"  )  ;", "assertReference ( element . getPsiType (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["testPsiUnknownType"], "fileName": "com.intellij.util.xml.DomReferencesTest"}, {"methodBody": ["METHOD_START", "{", "return    (  ( boolean . class . equals ( type )  )     |  |     ( Boolean . class . equals ( type )  )  )     |  |     ( Boolean . class . equals ( DomUtil . getGenericValueParameter ( type )  )  )  ;", "}", "METHOD_END"], "methodName": ["canHaveIsPropertyGetterPrefix"], "fileName": "com.intellij.util.xml.DomReflectionUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( returnType   instanceof   ParameterizedType )     {", "ParameterizedType   parameterizedType    =     (  ( ParameterizedType )     ( returnType )  )  ;", "final   Type   rawType    =    parameterizedType . getRawType (  )  ;", "if    ( rawType   instanceof   Class )     {", "final   Class <  ?  >    rawClass    =     (  ( Class <  ?  >  )     ( rawType )  )  ;", "if    (  ( List . class . equals ( rawClass )  )     |  |     ( Collection . class . equals ( rawClass )  )  )     {", "final   Type [  ]    arguments    =     . getActualTypeArguments ( parameterizedType )  ;", "if    (  ( arguments . length )     =  =     1  )     {", "final   Type   argument    =    arguments [  0  ]  ;", "if    ( argument   instanceof   WildcardType )     {", "final   Type [  ]    upperBounds    =     (  ( WildcardType )     ( argument )  )  . getUpperBounds (  )  ;", "if    (  ( upperBounds . length )     =  =     1  )     {", "return   upperBounds [  0  ]  ;", "}", "} else", "if    ( argument   instanceof   ParameterizedType )     {", "if    (  ( DomUtil . getGenericValueParameter ( argument )  )     !  =    null )     {", "return   argument ;", "}", "} else", "if    ( argument   instanceof   Class )     {", "return   argument ;", "}", "}", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["extractCollectionElementType"], "fileName": "com.intellij.util.xml.DomReflectionUtil"}, {"methodBody": ["METHOD_START", "{", "T   annotation    =    rawType . getAnnotation ( annotationType )  ;", "if    ( annotation    !  =    null )", "return   annotation ;", "for    ( Class   aClass    :    rawType . getInterfaces (  )  )     {", "annotation    =     . findAnnotationDFS ( aClass ,    annotationType )  ;", "if    ( annotation    !  =    null )     {", "return   annotation ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findAnnotationDFS"], "fileName": "com.intellij.util.xml.DomReflectionUtil"}, {"methodBody": ["METHOD_START", "{", "final   String   capitalized    =    StringUtil . capitalize ( propertyName )  ;", "Method   method    =    ReflectionUtil . getMethod ( aClass ,     (  \" get \"     +    capitalized )  )  ;", "if    ( method    !  =    null )", "return   JavaMethod . getMethod ( aClass ,    method )  ;", "method    =    ReflectionUtil . getMethod ( aClass ,     (  \" is \"     +    capitalized )  )  ;", "if    ( method    =  =    null )", "return   null ;", "final   JavaMethod   javaMethod    =    JavaMethod . getMethod ( aClass ,    method )  ;", "return    . canHaveIsPropertyGetterPrefix ( getGenericReturnType (  )  )     ?    javaMethod    :    null ;", "}", "METHOD_END"], "methodName": ["findGetter"], "fileName": "com.intellij.util.xml.DomReflectionUtil"}, {"methodBody": ["METHOD_START", "{", "final   JavaMethod [  ]    methods    =    new   JavaMethod [ path . length ]  ;", "Class   aClass    =    startClass ;", "for    ( int   i    =     0  ;    i    <     ( path . length )  ;    i +  +  )     {", "final   JavaMethod   getter    =     . findGetter ( aClass ,    path [ i ]  )  ;", "assert   getter    !  =    null    :     (  (  \" Couldn ' t   find   getter   for   property    \"     +     ( path [ i ]  )  )     +     \"    in   class    \"  )     +    aClass ;", "methods [ i ]     =    getter ;", "aClass    =    getter . getReturnType (  )  ;", "if    ( List . class . isAssignableFrom ( aClass )  )     {", "aClass    =    ReflectionUtil . getRawType (  . extractCollectionElementType ( getter . getGenericReturnType (  )  )  )  ;", "}", "}", "return   methods ;", "}", "METHOD_END"], "methodName": ["getGetterMethods"], "fileName": "com.intellij.util.xml.DomReflectionUtil"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   method . invoke ( object ,    args )  ;", "}    catch    ( IllegalArgumentException   e )     {", "throw   new   RuntimeException (  (  (  (  (  (  \" Calling   method    \"     +    method )     +     \"    on   object    \"  )     +    object )     +     \"    with   arguments    \"  )     +     ( Arrays . asList ( args )  )  )  ,    e )  ;", "}    catch    ( IllegalAccessException   e )     {", "throw   new   RuntimeException ( e )  ;", "}    catch    ( InvocationTargetException   e )     {", "final   Throwable   cause    =    e . getCause (  )  ;", "if    ( cause   instanceof   ProcessCanceledException )     {", "throw    (  ( ProcessCanceledException )     ( cause )  )  ;", "}", "Excep . rethrow ( cause )  ;", "return   null ;", "}    catch    ( ProcessCanceledException   e )     {", "throw   e ;", "}    catch    ( Throwable   throwable )     {", "throw   new   RuntimeException ( throwable )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeMethod"], "fileName": "com.intellij.util.xml.DomReflectionUtil"}, {"methodBody": ["METHOD_START", "{", "return   DomResolveConverter . ourCache . get ( aClass )  ;", "}", "METHOD_END"], "methodName": ["createConverter"], "fileName": "com.intellij.util.xml.DomResolveConverter"}, {"methodBody": ["METHOD_START", "{", "final   DomElement   invocationElement    =    context . getInvocationElement (  )  ;", "return   invocationElement . getManager (  )  . getingScope (  (  ( GenericDomValue )     ( invocationElement )  )  )  ;", "}", "METHOD_END"], "methodName": ["getResolvingScope"], "fileName": "com.intellij.util.xml.DomResolveConverter"}, {"methodBody": ["METHOD_START", "{", "XmlFileHeader   expected    =    new   XmlFileHeader ( localName ,    namespace ,    publicId ,    systemId )  ;", "XmlFile   file    =    createXmlFile ( start )  ;", "assert    !  ( file . getNode (  )  . isParsed (  )  )  ;", "assertEquals ( expected ,    DomService . getInstance (  )  . getXmlFileHeader ( file )  )  ;", ". ensureParsed ( file )  ;", "assert   file . getNode (  )  . isParsed (  )  ;", "assertEquals ( expected ,    DomService . getInstance (  )  . getXmlFileHeader ( file )  )  ;", "}", "METHOD_END"], "methodName": ["assertData"], "fileName": "com.intellij.util.xml.DomSaxParserTest"}, {"methodBody": ["METHOD_START", "{", "return    (  ( XmlFile )     ( PsiFileFactory . getInstance ( getProject (  )  )  . createFileFromText (  \" a . xml \"  ,    XMLLanguage . INSTANCE ,    text ,    false ,    false ,    false )  )  )  ;", "}", "METHOD_END"], "methodName": ["createXmlFile"], "fileName": "com.intellij.util.xml.DomSaxParserTest"}, {"methodBody": ["METHOD_START", "{", "file . getNode (  )  . getFirstChildNode (  )  ;", "}", "METHOD_END"], "methodName": ["ensureParsed"], "fileName": "com.intellij.util.xml.DomSaxParserTest"}, {"methodBody": ["METHOD_START", "{", "assertData (  \"  \"  ,    null ,    null ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["testEmptyFile"], "fileName": "com.intellij.util.xml.DomSaxParserTest"}, {"methodBody": ["METHOD_START", "{", "assertData (  (  \"  <  ! DOCTYPE   ejb - jar   PUBLIC \\ n \"     +     (  \"  \\  \"  -  /  / Sun   Microsystems ,    Inc .  /  / DTD   Enterprise   JavaBeans    2  .  0  /  / EN \\  \"  \\ n \"     +     \"  \\  \" http :  /  / com / dtd / ejb - jar _  2  _  0  . dtd \\  \"  >  < root >  \"  )  )  ,     \" root \"  ,    null ,     \"  -  /  / Sun   Microsystems ,    Inc .  /  / DTD   Enterprise   JavaBeans    2  .  0  /  / EN \"  ,     \" http :  /  / com / dtd / ejb - jar _  2  _  0  . dtd \"  )  ;", "}", "METHOD_END"], "methodName": ["testGetRootTagNameWithDtdNamespace"], "fileName": "com.intellij.util.xml.DomSaxParserTest"}, {"methodBody": ["METHOD_START", "{", "assertData (  (  \"  <  ? xml   version =  \\  \"  1  .  0  \\  \"    encoding =  \\  \" UTF -  8  \\  \"  ?  >  \\ n \"     +     (  (  \"  <  ! DOCTYPE   ejb - jar   PUBLIC \\ n \"     +     \"  \\  \"  -  /  / Sun   Microsystems ,    Inc .  /  / DTD   Enterprise   JavaBeans    2  .  0  /  / EN \\  \"  \\ n \"  )     +     \"  \\  \" http :  /  / com / dtd / ejb - jar _  2  _  0  . dtd \\  \"  >  < root >  \"  )  )  ,     \" root \"  ,    null ,     \"  -  /  / Sun   Microsystems ,    Inc .  /  / DTD   Enterprise   JavaBeans    2  .  0  /  / EN \"  ,     \" http :  /  / com / dtd / ejb - jar _  2  _  0  . dtd \"  )  ;", "}", "METHOD_END"], "methodName": ["testGetRootTagNameWithDtdNamespace2"], "fileName": "com.intellij.util.xml.DomSaxParserTest"}, {"methodBody": ["METHOD_START", "{", "assertData (  \"  < root   xmlns =  \\  \" foo \\  \"  >  \"  ,     \" root \"  ,     \" foo \"  ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["testGetRootTagNameWithNamespaceWithEmptyPrefix"], "fileName": "com.intellij.util.xml.DomSaxParserTest"}, {"methodBody": ["METHOD_START", "{", "assertData (  \"  < bar : root   xmlns =  \\  \" foo \\  \"    xmlns : bar =  \\  \" b \\  \"  >  \"  ,     \" root \"  ,     \" b \"  ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["testGetRootTagNameWithNamespaceWithNonEmptyPrefix"], "fileName": "com.intellij.util.xml.DomSaxParserTest"}, {"methodBody": ["METHOD_START", "{", "XmlFile   file    =    createXmlFile (  \"  < root   xmlns =  \\  \" foo \\  \"    aaa >  \"  )  ;", ". ensureParsed ( file )  ;", "final   XmlFileHeader   header    =    DomService . getInstance (  )  . getXmlFileHeader ( file )  ;", "assertEquals ( new   XmlFileHeader (  \" root \"  ,     \" foo \"  ,    null ,    null )  ,    header )  ;", "}", "METHOD_END"], "methodName": ["testGetRootTagNameWithUnfinishedAttribute"], "fileName": "com.intellij.util.xml.DomSaxParserTest"}, {"methodBody": ["METHOD_START", "{", "assertData (  \"  < root >  \"  ,     \" root \"  ,    null ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["testGetRootTagNameWithoutNamespace"], "fileName": "com.intellij.util.xml.DomSaxParserTest"}, {"methodBody": ["METHOD_START", "{", "assertData (  (  \"  <  ? xml   version =  \\  \"  1  .  0  \\  \"  ?  >  \\ n \"     +     (  (  (  (  (  (  \"  <  ! DOCTYPE    \\ n \"     +     \"                         hibernate - mapping   SYSTEM \\ n \"  )     +     \"  \\ t \\ t \\ t \\  \" http :  /  / hibernate . sourcefnet / hibernate - mapping -  3  .  0  . dtd \\  \"  \\ n \"  )     +     \"  [  \\ n \"  )     +     \"  <  ! ENTITY    %    globals   SYSTEM    \\  \" classpath :  /  / auction / persistence / globals . dtd \\  \"  >  \\ n \"  )     +     \"  % globals ;  \\ n \"  )     +     \"  ]  >  < a /  >  \"  )  )  ,     \" a \"  ,    null ,    null ,     \" http :  /  / hibernate . sourcefnet / hibernate - mapping -  3  .  0  . dtd \"  )  ;", "}", "METHOD_END"], "methodName": ["testInternalDtd"], "fileName": "com.intellij.util.xml.DomSaxParserTest"}, {"methodBody": ["METHOD_START", "{", "assertData (  \"  <  ? xmlmas 8 v 6  7  0  8  9  8  6  >  < OKHD   POH :  &  *  $  %  *  &  * I 8 yo 9  \"  ,    null ,    null ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["testInvalidContent"], "fileName": "com.intellij.util.xml.DomSaxParserTest"}, {"methodBody": ["METHOD_START", "{", "assertData (  \"  ? xmlmas 8 v 6  7  0  8  9  8  6  >  < OKHD   POH :  &  *  $  %  *  &  * I 8 yo 9  \"  ,    null ,    null ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["testInvalidContent2"], "fileName": "com.intellij.util.xml.DomSaxParserTest"}, {"methodBody": ["METHOD_START", "{", "assertData (  \"  <  ? xmlmas 8 v 6  7  0  8  9  \"  ,    null ,    null ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["testInvalidContent3"], "fileName": "com.intellij.util.xml.DomSaxParserTest"}, {"methodBody": ["METHOD_START", "{", "assertData (  \" aaaaaaaaaaaaaaaaaaaaa \"  ,    null ,    null ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["testNoTag"], "fileName": "com.intellij.util.xml.DomSaxParserTest"}, {"methodBody": ["METHOD_START", "{", "assertData (  (  \"  <  ? xml   version =  \\  \"  1  .  0  \\  \"    encoding =  \\  \" gbk \\  \"  ?  >  \\ n \"     +     (  (  (  (  (  (  (  (  (  \"  \\ n \"     +     \"  \\ n \"  )     +     \"  < beans   xmlns =  \\  \" http :  /  / www . springframework . org / schema / beans \\  \"  \\ n \"  )     +     \"                      xmlns : xsi =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema - instance \\  \"  \\ n \"  )     +     \"                      xmlns : aop =  \\  \" http :  /  / www . springframework . org / schema / aop \\  \"  \\ n \"  )     +     \"                      xmlns : tx =  \\  \" http :  /  / www . springframework . org / schema / tx \\  \"  \\ n \"  )     +     \"                      xsi : schemaLocation =  \\  \" http :  /  / www . springframework . org / schema / beans   http :  /  / www . springframework . org / schema / beans / spring - beans -  2  .  0  . xsd \\ n \"  )     +     \"                                  http :  /  / www . springframework . org / schema / aop   http :  /  / www . springframework . org / schema / aop / spring - aop -  2  .  0  . xsd \\ n \"  )     +     \"                                  http :  /  / www . springframework . org / schema / tx   http :  /  / www . springframework . org / schema / tx / spring - tx -  2  .  0  . xsd \\  \"  >  \\ n \"  )     +     \"  <  / beans >  \"  )  )  ,     \" beans \"  ,     \" http :  /  / www . springframework . org / schema / beans \"  ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["testSpring"], "fileName": "com.intellij.util.xml.DomSaxParserTest"}, {"methodBody": ["METHOD_START", "{", "assertData (  \"  < root >  < foo /  >  \"  ,     \" root \"  ,    null ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["testSubtag"], "fileName": "com.intellij.util.xml.DomSaxParserTest"}, {"methodBody": ["METHOD_START", "{", "if    (  ( DomService . ourCachedInstance )     =  =    null )     {", "DomService . ourCachedInstance    =    ServiceManager . getService ( DomService . class )  ;", "}", "return   DomService . ourCachedInstance ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "com.intellij.util.xml.DomService"}, {"methodBody": ["METHOD_START", "{", "final   DomSimpleValuesTest . MyElement   element    =    createElement (  \"  \"  )  ;", "element . setJvmPsiType ( type )  ;", "assertEquals ( expected ,    element . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertJvmPsiTypeToString"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "return   createElement ( xml ,    DomSimpleValuesTest . MyElement . class )  ;", "}", "METHOD_END"], "methodName": ["createElement"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomSimpleValuesTest . MyElement   element    =    createElement (  \"  < a >  < buffer >  2  3  9  <  / buffer >  <  / a >  \"  )  ;", "element . getGenericChild (  )  . getValue (  )  ;", "final   GenericDomValue < StringBuffer >    genericChild 2     =    element . getGenericChild 2  (  )  ;", "assertEquals (  \"  2  3  9  \"  ,    genericChild 2  . getValue (  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAnnotatedGenericValue"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomSimpleValuesTest . MyElement   element    =    createElement (  \"  < a   attra =  \\  \" foo \\  \"  /  >  \"  )  ;", "final   GenericAttributeValue < String >    attributeValue    =    element . getAttributeValue (  )  ;", "assertEquals (  \" attra \"  ,    attributeValue . getXmlElementName (  )  )  ;", "assertEquals (  \" foo \"  ,    attributeValue . getValue (  )  )  ;", "final   GenericAttributeValue < Integer >    attr    =    element . getAttr (  )  ;", "attr . setValue (  2  3  9  )  ;", "assertEquals (  2  3  9  ,     (  ( int )     ( attr . getValue (  )  )  )  )  ;", "assertEquals (  \"  2  3  9  \"  ,    element . getXmlTag (  )  . getAttributeValue (  \" attr \"  )  )  ;", "final   DomElement   element 1     =    attr ;", "myCallRegistry . putExpected ( new   DomEvent ( element 1  ,    true )  )  ;", "myCallRegistry . assertResultsAndClear (  )  ;", "attr . setValue (  4  2  )  ;", "myCallRegistry . putExpected ( new   DomEvent ( attr ,    false )  )  ;", "myCallRegistry . assertResultsAndClear (  )  ;", "attr . setValue ( null )  ;", "assertNull ( attr . getValue (  )  )  ;", "assertNull ( element . getXmlTag (  )  . getAttributeValue (  \" attr \"  )  )  ;", "assertNull ( element . getXmlTag (  )  . getAttribute (  \" attr \"  ,     \"  \"  )  )  ;", "myCallRegistry . putExpected ( new   DomEvent ( attr ,    false )  )  ;", "myCallRegistry . assertResultsAndClear (  )  ;", "assertEquals (  \" some - attribute \"  ,    element . getSomeAttribute (  )  . getXmlElementName (  )  )  ;", "assertNull ( createElement (  \"  < a   attra \\  \" attr \\  \"  /  >  \"  )  . getAttributeValue (  )  . getStringValue (  )  )  ;", "assertNull ( createElement (  \"  < a   attra \\  \"  \\  \"  /  >  \"  )  . getAttributeValue (  )  . getStringValue (  )  )  ;", "assertNull ( createElement (  \"  < a   attra \\  \"  /  >  \"  )  . getAttributeValue (  )  . getStringValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeValues"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  2  3  9  ,    createElement (  (  \"  < a >  \"     +     (  (  (  \"        <  !  -  -    some   comment -  -  >  \"     +     \"        2  3  9  \"  )     +     \"        <  !  -  -    some   another   comment -  -  >  \"  )     +     \"  <  / a >  \"  )  )  )  . getInt (  )  )  ;", "}", "METHOD_END"], "methodName": ["testComment"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomSimpleValuesTest . ConcreteGeneric   generic    =    createElement (  \"  \"  ,    DomSimpleValuesTest . ConcreteGeneric . class )  ;", "generic . setValue (  \" abc \"  )  ;", "assertEquals (  \" abc \"  ,    generic . getValue (  )  )  ;", "DomUIFactory . SET _ VALUE _ METHOD . invoke ( generic ,     \" def \"  )  ;", "assertEquals (  \" def \"  ,    DomUIFactory . GET _ VALUE _ METHOD . invoke ( generic )  )  ;", "}", "METHOD_END"], "methodName": ["testConcreteGenericValue"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomSimpleValuesTest . ConcreteGenericWithMethods   generic    =    createElement (  \"  \"  ,    DomSimpleValuesTest . ConcreteGenericWithMethods . class )  ;", "generic . setValue (  \" abc \"  )  ;", "assertEquals (  \" abc \"  ,    generic . getValue (  )  )  ;", "DomUIFactory . SET _ VALUE _ METHOD . invoke ( generic ,     \" def \"  )  ;", "assertEquals (  \" def \"  ,    DomUIFactory . GET _ VALUE _ METHOD . invoke ( generic )  )  ;", "}", "METHOD_END"], "methodName": ["testConcreteGenericValueWithMethods"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomSimpleValuesTest . MyElement   element    =    createElement (  (  \"  < a >  \"     +     (  (  \"  < my - generic - value > abc <  / my - generic - value >  \"     +     \"  < my - foo - generic - value > abc <  / my - foo - generic - value >  \"  )     +     \"  \"  )  )  )  ;", "assertEquals (  \" bar \"  ,    element . getMyGenericValue (  )  . getValue (  )  )  ;", "assertEquals (  \" foo \"  ,    element . getMyFooGenericValue (  )  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConvertAnnotationOnType"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomSimpleValuesTest . MyElement   element    =    getDomManager (  )  . getFileElement ( DomTestCase . createXmlFile (  \"  \"  )  ,    DomSimpleValuesTest . MyElement . class ,     \" root \"  )  . getRootElement (  )  ;", "myCallRegistry . clear (  )  ;", "assertNull ( element . getXmlTag (  )  )  ;", "element . setValue (  4  2  )  ;", "assertNotNull ( element . getXmlTag (  )  )  ;", "assertEquals (  \"  4  2  \"  ,    element . getXmlTag (  )  . getValue (  )  . getText (  )  )  ;", "final   DomElement   element 1     =    element ;", "myCallRegistry . putExpected ( new   DomEvent ( element 1  ,    true )  )  ;", "myCallRegistry . putExpected ( new   DomEvent ( element ,    false )  )  ;", "element . setValue (  (  ( Integer )     ( null )  )  )  ;", "assertNull ( element . getXmlTag (  )  )  ;", "assertEquals ( null ,    element . getValue (  )  )  ;", "myCallRegistry . putExpected ( new   DomEvent ( element ,    false )  )  ;", "myCallRegistry . assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["testDefineAndSet"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomSimpleValuesTest . MyElement   element    =    createElement (  (  \"  <  ! DOCTYPE   a   SYSTEM    \\  \" aaa \\  \"  \\ n \"     +     (  \"  [  <  ! ENTITY   idgenerator             \\  \" identity \\  \"  >  ]  >  \\ n \"     +     \"  < a   attra =  \\  \" a & lt ; b \\  \"    some - attribute =  \\  \"  & idgenerator ;  \\  \"  >  & xxx ;  +  & idgenerator ;  +  & amp ;  <  / a >  \"  )  )  )  ;", "assertEquals (  \" a < b \"  ,    element . getAttributeValue (  )  . getValue (  )  )  ;", "assertEquals (  \" identity \"  ,    element . getSomeAttribute (  )  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testEntities"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomSimpleValuesTest . MyElement   element    =    createElement (  \"  < a /  >  \"  ,    DomSimpleValuesTest . MyElement . class )  ;", "assertNull ( element . getEnum (  )  )  ;", "element . setEnum ( DomTestCase . MyEnum . BAR )  ;", "assertEquals ( DomTestCase . MyEnum . BAR ,    element . getEnum (  )  )  ;", "assertEquals ( DomTestCase . MyEnum . BAR . getValue (  )  ,    element . getXmlTag (  )  . getValue (  )  . getText (  )  )  ;", "element . setEnum ( null )  ;", "assertNull ( element . getEnum (  )  )  ;", "assertNull ( element . getXmlTag (  )  )  ;", "element . setValue (  2  3  9  )  ;", "assertNull ( element . getEnum (  )  )  ;", "}", "METHOD_END"], "methodName": ["testEnums"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomSimpleValuesTest . FieldGroup   group    =    createElement (  (  \"  < field - group >  \\ n \"     +     (  (  (  \"  < group - name > myGroup <  / load - group - name >  \\ n \"     +     \"  < field - name > myField 1  <  / field - name >  \\ n \"  )     +     \"  < field - name > myField 2  <  / field - name >  \\ n \"  )     +     \"  <  / field - group >  \"  )  )  ,    DomSimpleValuesTest . FieldGroup . class )  ;", "assertEquals (  2  ,    group . getFieldNames (  )  . size (  )  )  ;", "assertEquals (  \" myField 1  \"  ,    group . getFieldNames (  )  . get (  0  )  . getValue (  )  . getName (  )  . getValue (  )  )  ;", "assertEquals ( null ,    group . getFieldNames (  )  . get (  1  )  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFuhrer"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomSimpleValuesTest . MyElement   element    =    createElement (  \"  < a >  < generic - child >  2  3  9  <  / generic - child >  <  / a >  \"  )  ;", "final   GenericDomValue < Integer >    integerChild    =    element . getGenericChild (  )  ;", "assertEquals (  2  3  9  ,     (  ( int )     ( integerChild . getValue (  )  )  )  )  ;", "assertEquals (  \"  2  3  9  \"  ,    integerChild . getStringValue (  )  )  ;", "integerChild . setValue (  4  2  )  ;", "assertEquals (  4  2  ,     (  ( int )     ( integerChild . getValue (  )  )  )  )  ;", "assertEquals (  \"  4  2  \"  ,    integerChild . getStringValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericValue"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomSimpleValuesTest . MyElement   element    =    createElement (  \"  < a >  < string - buffer > abc <  / string - buffer >  <  / a >  \"  )  ;", "assertEquals (  \" abc \"  ,    element . getStringBuffers (  )  . get (  0  )  . getValue (  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericValueListConverter"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "final   String   text    =     \"  < a > foo <  / a >  \"  ;", "assertEquals (  \" foo \"  ,    createElement ( text )  . getTag (  )  )  ;", "assertEquals (  \" foo \"  ,    createElement ( text )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetValue"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomSimpleValuesTest . MyElement   element    =    createElement (  \"  < a >  < indicator /  >  <  / a >  \"  )  ;", "final   GenericDomValue < Boolean >    indicator    =    element . getIndicator (  )  ;", "assertTrue ( indicator . getValue (  )  )  ;", "indicator . setValue ( false )  ;", "assertFalse ( indicator . getValue (  )  )  ;", "assertNull ( indicator . getStringValue (  )  )  ;", "assertNull ( indicator . getXmlTag (  )  )  ;", "assertEquals (  0  ,    element . getXmlTag (  )  . getSubTags (  )  . length )  ;", "putExpected ( new   DomEvent ( indicator ,    false )  )  ;", "assertResultsAndClear (  )  ;", "indicator . setValue ( true )  ;", "assertTrue ( indicator . getValue (  )  )  ;", "assertEquals (  \"  \"  ,    indicator . getStringValue (  )  )  ;", "assertSame ( indicator . getXmlTag (  )  ,    element . getXmlTag (  )  . getSubTags (  )  [  0  ]  )  ;", "final   DomElement   element 1     =    indicator ;", "putExpected ( new   DomEvent ( element 1  ,    true )  )  ;", "assertResultsAndClear (  )  ;", "final   XmlTag   tag    =    element . getXmlTag (  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "tag . add ( createTag (  \"  < indicator /  >  \"  )  )  ;", "tag . add ( createTag (  \"  < indicator /  >  \"  )  )  ;", "}  )  ;", "assertTrue ( element . isValid (  )  )  ;", "assertTrue ( element . getIndicator (  )  . getValue (  )  )  ;", "element . getIndicator (  )  . setValue ( false )  ;", "assertFalse ( element . getIndicator (  )  . getValue (  )  )  ;", "assertEquals (  0  ,    element . getXmlTag (  )  . findSubTags (  \" indicator \"  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testIndicators"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "DomSimpleValuesTest . JavaStyledElement   element    =    createElement (  \"  < tag   javaStyledAttribute =  \\  \"  6  6  6  \\  \"  >  <  / tag >  \"  ,    DomSimpleValuesTest . JavaStyledElement . class )  ;", "assertEquals ( element . getJavaStyledAttribute (  )  . getXmlElementName (  )  ,     \" javaStyledAttribute \"  )  ;", "}", "METHOD_END"], "methodName": ["testJavaStyledElement"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "assertNull ( createElement (  \"  \"  )  . getJvmPsiType (  )  )  ;", "assertNotNull ( createElement (  \"  < a >  <  / a >  \"  )  . getJvmPsiType (  )  )  ;", "final   PsiClassType   string    =    PsiType . getJavaLangString ( getPsiManager (  )  ,    GlobalSearchScope . allScope ( getProject (  )  )  )  ;", "final   PsiType   psiType    =    createElement (  \"  < a > String <  / a >  \"  )  . getJvmPsiType (  )  ;", "assertEquals ( JAVA _ LANG _ STRING ,    assertInstanceOf ( psiType ,    PsiClassType . class )  . getCanonicalText (  )  )  ;", "final   PsiArrayType   Array    =    assertInstanceOf ( createElement (  \"  < a >  [ I <  / a >  \"  )  . getJvmPsiType (  )  ,    PsiArrayType . class )  ;", "final   PsiArrayType   stringArray    =    assertInstanceOf ( createElement (  \"  < a >  [ LString ;  <  / a >  \"  )  . getJvmPsiType (  )  ,    PsiArrayType . class )  ;", "assertSame ( INT ,    Array . getComponentType (  )  )  ;", "assertEquals ( JAVA _ LANG _ STRING ,    assertInstanceOf ( stringArray . getComponentType (  )  ,    PsiClassType . class )  . getCanonicalText (  )  )  ;", "assertJvmPsiTypeToString ( Array ,     \"  [ I \"  )  ;", "assertJvmPsiTypeToString ( stringArray ,     \"  [ LString ;  \"  )  ;", "assertJvmPsiTypeToString ( string ,     \" String \"  )  ;", "}", "METHOD_END"], "methodName": ["testJvmPsiTypeConverter"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomSimpleValuesTest . MyElement   element    =    createElement (  \"  \"  )  ;", "element . getAttr (  )  . setValue (  2  3  9  4  2  )  ;", "assertEquals (  \"  2  3  9  4  2  \"  ,    element . getPresentation (  )  . getElementName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNameValueInPresentation"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "assertNull ( createElement (  \"  \"  )  . getPsiType (  )  )  ;", "assertSame ( INT ,    createElement (  \"  < a >  <  / a >  \"  )  . getPsiType (  )  )  ;", "final   PsiType   psiType    =    createElement (  \"  < a > String <  / a >  \"  )  . getPsiType (  )  ;", "assertEquals ( JAVA _ LANG _ STRING ,    assertInstanceOf ( psiType ,    PsiClassType . class )  . getCanonicalText (  )  )  ;", "final   PsiType   arrayType    =    createElement (  \"  < a >  [  ]  <  / a >  \"  )  . getPsiType (  )  ;", "assertTrue (  ( arrayType   instanceof   PsiArrayType )  )  ;", "assertSame ( INT ,     (  ( PsiArrayType )     ( arrayType )  )  . getComponentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPlainPsiTypeConverter"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "final   String   className    =    Object . class . getName (  )  ;", "final   PsiClass   objectClass    =    getJavaFacade (  )  . findClass ( className ,    GlobalSearchScope . allScope ( getProject (  )  )  )  ;", "assertEquals ( objectClass ,    createElement (  (  (  \"  < a >  \"     +    className )     +     \"  <  / a >  \"  )  )  . getPsiClass (  )  )  ;", "assertNull ( createElement (  \"  < a > abcdef <  / a >  \"  )  . getPsiClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPsiClassConverter"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomSimpleValuesTest . RootInterface   element    =    createElement (  \"  \"  ,    DomSimpleValuesTest . RootInterface . class )  ;", "final   DomSimpleValuesTest . MyElement   child 1     =    element . addChild (  )  ;", "child 1  . getAttr (  )  . setValue (  5  5  5  )  ;", "final   DomSimpleValuesTest . MyElement   child 2     =    element . addChild (  )  ;", "child 2  . getAttr (  )  . setValue (  7  7  7  )  ;", "final   GenericDomValue < DomSimpleValuesTest . MyElement >    resolve    =    child 2  . getResolve (  )  ;", "resolve . setStringValue (  \"  7  7  7  \"  )  ;", "assertEquals ( child 2  ,    resolve . getValue (  )  )  ;", "resolve . setValue ( child 1  )  ;", "assertEquals (  \"  5  5  5  \"  ,    resolve . getStringValue (  )  )  ;", "assertEquals ( child 1  ,    resolve . getValue (  )  )  ;", "resolve . setStringValue (  \"  2  3  9  \"  )  ;", "assertNull ( resolve . getValue (  )  )  ;", "final   GenericDomValue < DomSimpleValuesTest . MyElement >    resolve 2     =    child 2  . getResolve 2  (  )  ;", "resolve 2  . setStringValue (  \"  7  7  7  \"  )  ;", "assertEquals ( child 2  ,    resolve 2  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testResolveToDomElement"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomSimpleValuesTest . MyElement   element    =    createElement (  \"  < a /  >  \"  )  ;", "assertEquals (  \"  \"  ,    element . getValue (  )  )  ;", "element . setValue (  2  3  9  )  ;", "assertEquals (  \"  2  3  9  \"  ,    element . getValue (  )  )  ;", "assertEquals (  \"  2  3  9  \"  ,    element . getXmlTag (  )  . getValue (  )  . getText (  )  )  ;", "myCallRegistry . putExpected ( new   DomEvent ( element ,    false )  )  ;", "myCallRegistry . assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["testSetValue"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  2  3  9  ,    createElement (  \"  < a >  2  3  9  <  / a >  \"  )  . getInt (  )  )  ;", "assertEquals ( true ,    createElement (  \"  < a > true <  / a >  \"  )  . getBoolean (  )  )  ;", "assertEquals (  \" true \"  ,    createElement (  \"  < a > true <  / a >  \"  )  . getBuffer (  )  . toString (  )  )  ;", "assertEquals (  (  ( short )     (  2  3  9  )  )  ,    createElement (  \"  < a >  2  3  9  <  / a >  \"  )  . getShort (  )  )  ;", "assertEquals ( new   Long (  \"  2  3  9  \"  )  ,    createElement (  \"  < a >  2  3  9  <  / a >  \"  )  . getLong (  )  )  ;", "assertEquals ( new   Float (  \"  2  3  9  .  4  2  \"  )  ,    createElement (  \"  < a >  2  3  9  .  4  2  <  / a >  \"  )  . getFloat (  )  )  ;", "assertEquals ( new   BigDecimal (  \"  2  3  9  .  4  2  \"  )  ,    createElement (  \"  < a >  2  3  9  .  4  2  <  / a >  \"  )  . getBigDecimal (  )  )  ;", "final    . MyElement   bigDecimalValue    =    createElement (  \"  < a >  2  3  9  .  4  2  <  / a >  \"  )  ;", "bigDecimalValue . setValue ( new   BigDecimal (  \"  1  1  1  .  2  3  4  \"  )  )  ;", "assertEquals (  \"  1  1  1  .  2  3  4  \"  ,    bigDecimalValue . getValue (  )  )  ;", "try    {", "createElement (  \"  < a > true <  / a >  \"  )  . getInt (  )  ;", "fail (  )  ;", "}    catch    ( NullPointerException   e )     {", "}", "try    {", "createElement (  \"  < a >  4  2  <  / a >  \"  )  . getBoolean (  )  ;", "fail (  )  ;", "}    catch    ( NullPointerException   e )     {", "}", "}", "METHOD_END"], "methodName": ["testSimpleConverters"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "final   DomSimpleValuesTest . MyElement   element    =    createElement (  \"  \"  )  ;", "element . setValue (  \"  <  \"  )  ;", "assertEquals (  \"  <  \"  ,    element . getValue (  )  )  ;", "assertEquals (  \"  <  !  [ CDATA [  <  ]  ]  >  \"  ,    element . getXmlTag (  )  . getValue (  )  . getText (  )  )  ;", "element . getAttributeValue (  )  . setValue (  \"  <  \"  )  ;", "assertEquals (  \"  <  \"  ,    element . getAttributeValue (  )  . getValue (  )  )  ;", "assertEquals (  \"  \\  \"  & lt ;  \\  \"  \"  ,    element . getXmlTag (  )  . getAttribute (  \" attra \"  ,    null )  . getValueElement (  )  . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpecialCharacters"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "final   GenericDomValue < String >    element    =    createElement (  \"  < a >  < cached - value /  >  <  / a >  \"  ,    DomSimpleValuesTest . MyElement . class )  . getCachedValue (  )  ;", "assertEquals (  0  ,     (  ( DomSimpleValuesTest . MyConverter )     ( element . getConverter (  )  )  )  . fromStringCalls )  ;", "assertEquals (  \"  \"  ,    element . getValue (  )  )  ;", "assertEquals (  1  ,     (  ( DomSimpleValuesTest . MyConverter )     ( element . getConverter (  )  )  )  . fromStringCalls )  ;", "assertEquals (  \"  \"  ,    element . getValue (  )  )  ;", "assertEquals (  1  ,     (  ( DomSimpleValuesTest . MyConverter )     ( element . getConverter (  )  )  )  . fromStringCalls )  ;", "element . setValue (  \"  1  \"  )  ;", "assertEquals (  1  ,     (  ( DomSimpleValuesTest . MyConverter )     ( element . getConverter (  )  )  )  . fromStringCalls )  ;", "assertEquals (  \"  1  \"  ,    element . getValue (  )  )  ;", "assertEquals (  2  ,     (  ( DomSimpleValuesTest . MyConverter )     ( element . getConverter (  )  )  )  . fromStringCalls )  ;", "}", "METHOD_END"], "methodName": ["testValueCaching"], "fileName": "com.intellij.util.xml.DomSimpleValuesTest"}, {"methodBody": ["METHOD_START", "{", "return   myDomElement ;", "}", "METHOD_END"], "methodName": ["getDomElement"], "fileName": "com.intellij.util.xml.DomTarget"}, {"methodBody": ["METHOD_START", "{", "final   GenericDomValue   nameElement    =    element . getGenericInfo (  )  . getNameDomElement ( element )  ;", "if    ( nameElement    =  =    null )     {", "return   null ;", "}", "return    . getTarget ( element ,    nameElement )  ;", "}", "METHOD_END"], "methodName": ["getTarget"], "fileName": "com.intellij.util.xml.DomTarget"}, {"methodBody": ["METHOD_START", "{", "if    ( nameElement   instanceof   GenericAttributeValue )     {", "final   GenericAttributeValue   genericAttributeValue    =     (  ( GenericAttributeValue )     ( nameElement )  )  ;", "final   XmlAttributeValue   attributeValue    =    genericAttributeValue . getXmlAttributeValue (  )  ;", "if    ( attributeValue    =  =    null )     {", "return   null ;", "}", "final   int   length    =    attributeValue . getTextLength (  )  ;", "if    ( length    >  =     2  )     {", "return   new    ( element ,    attributeValue ,    new   TextRange (  1  ,     ( length    -     1  )  )  ,    nameElement )  ;", "}", "}", "final   XmlTag   tag    =    nameElement . getXmlTag (  )  ;", "if    ( tag    =  =    null )     {", "return   null ;", "}", "XmlTagValue   tagValue    =    tag . getValue (  )  ;", "if    ( StringUtil . isEmpty ( tagValue . getTrimmedText (  )  )  )     {", "return   null ;", "}", "return   new    ( element ,    tag ,    XmlTagUtil . getTrimmedValueRange ( tag )  ,    nameElement )  ;", "}", "METHOD_END"], "methodName": ["getTarget"], "fileName": "com.intellij.util.xml.DomTarget"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    element . getXmlTag (  )  ;", "if    ( tag    !  =    null )     {", "for    ( XmlTag   Tag    :    tag . getSubTags (  )  )     {", "final   DomElement   childElement    =    element . getManager (  )  . getDomElement ( Tag )  ;", "if    ( childElement    !  =    null )     {", "childElement . accept ( visitor )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["acceptAvailableChildren"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "final   DomElement   parent    =    anchor . getParent (  )  ;", "final   DomCollectionChildDescription   childDescription    =     (  ( DomCollectionChildDescription )     ( anchor . getChildDescription (  )  )  )  ;", "assert   parent    !  =    null ;", "final   List <  ?    extends   DomElement >    list    =    childDescription . getValues ( parent )  ;", "final   int   i    =    list . indexOf ( anchor )  ;", "assert   i    >  =     0  ;", "return    (  ( T )     ( childDescription . addValue ( parent ,     ( i    +     1  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["addElementAfter"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  ( dom    !  =    null )     &  &     (  !  ( DomUtil . hasXml ( dom )  )  )  )     {", "DomUtil . LOG . error (  (  (  (  (  (  \" No   xml   for   dom    \"     +    dom )     +     \"  ;    attr =  \"  )     +    psi )     +     \"  ,    physical =  \"  )     +     ( psi . isPhysical (  )  )  )  )  ;", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["checkHasXml"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "return   DomUtil . getGenericValueParameter ( type )  ;", "}", "METHOD_END"], "methodName": ["extractParameterClassFromGenericType"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "for    ( T   element    :    list )     {", "String   elementName    =    element . getGenericInfo (  )  . getElementName ( element )  ;", "if    (  ( elementName    !  =    null )     &  &     ( elementName . equals ( name )  )  )     {", "return   element ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findByName"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "return   DomUtil . findDomElement ( element ,    beanClass ,    true )  ;", "}", "METHOD_END"], "methodName": ["findDomElement"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( element    =  =    null )", "return   null ;", "XmlTag   tag    =    PsiTreeUgetParentOfType ( element ,    XmlTag . class ,    strict )  ;", "DomElement   domElement ;", "while    ( tag    !  =    null )     {", "domElement    =    DomManager . getDomManager ( tag . getProject (  )  )  . getDomElement ( tag )  ;", "if    ( domElement    !  =    null )     {", "return   domElement . getParentOfType ( beanClass ,    false )  ;", "}", "tag    =    tag . getParentTag (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findDomElement"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "return   ElementPresentationManager . findByName ( DomUtil . getIdentitySiblings ( element )  ,    newName )  ;", "}", "METHOD_END"], "methodName": ["findDuplicateNamedValue"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "final   Class [  ]    interfaces    =    aClass . getInterfaces (  )  ;", "ContainerUtil . addAll ( result ,    interfaces )  ;", "if    (  ( aClass . getSuperclass (  )  )     !  =    null )     {", ". getAllInterfaces ( aClass . getSuperclass (  )  ,    result )  ;", "}", "for    ( Class   anInterface    :    interfaces )     {", ". getAllInterfaces ( anInterface ,    result )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getAllInterfaces"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "final   List < T >    list    =    new   com . intellij . util . SmartList (  )  ;", "List <  ?    extends   AbstractDomChildrenDescription >    descriptions    =    parent . getGenericInfo (  )  . getChildrenDescriptions (  )  ;", "for    ( int   i    =     0  ,    descriptionsSize    =    descriptions . size (  )  ;    i    <    descriptionsSize ;    i +  +  )     {", "AbstractDomChildrenDescription   description    =    descriptions . get ( i )  ;", "if    (  (  ( description . getType (  )  )    instanceof   Class )     &  &     ( type . isAssignableFrom (  (  ( Class <  ?  >  )     ( description . getType (  )  )  )  )  )  )     {", "List < T >    values    =     (  ( List < T >  )     ( description . getValues ( parent )  )  )  ;", "for    ( int   j    =     0  ,    valuesSize    =    values . size (  )  ;    j    <    valuesSize ;    j +  +  )     {", "T   value    =    values . get ( j )  ;", "if    ( value . exists (  )  )     {", "list . add ( value )  ;", "}", "}", "}", "}", "return   list ;", "}", "METHOD_END"], "methodName": ["getChildrenOf"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "final   List < T >    result    =    new   com . intellij . util . SmartList (  )  ;", "parent . acceptChildren ( new   DomElementVisitor (  )     {", "@ Override", "public   void   visitDomElement ( final   DomElement   element )     {", "if    ( type . isInstance ( element )  )     {", "result . add (  (  ( T )     ( element )  )  )  ;", "}", "}", "}  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getChildrenOfType"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( editor    =  =    null )", "return   null ;", "final   Project   project    =    editor . getProject (  )  ;", "if    ( project    =  =    null )", "return   null ;", "final   PsiFile   file    =    PsiDocumentManager . getInstance ( project )  . getPsiFile ( editor . getDocument (  )  )  ;", "if    (  !  ( file   instanceof   XmlFile )  )     {", "return   null ;", "}", "return    . getDomElement ( file . findElementAt ( editor . getCaretModel (  )  . getOffset (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getContextElement"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "final   DomElement   element    =    DomUtil . getContextElement ( editor )  ;", "return   DomUtil . getParentOfType ( element ,    clazz ,    false )  ;", "}", "METHOD_END"], "methodName": ["getContextElement"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( parent   instanceof   MergedObject )     {", "final   SmartList < DomElement >    result    =    new   SmartList (  )  ;", "parent . acceptChildren ( new   DomElementVisitor (  )     {", "@ Override", "public   void   visitDomElement ( final   DomElement   element )     {", "if    (  . hasXml ( element )  )     {", "result . add ( element )  ;", "}", "}", "}  )  ;", "return   result ;", "}", "ProgressManager . checkCanceled (  )  ;", "if    ( parent   instanceof   GenericAttributeValue )", "return   Collections . emptyList (  )  ;", "if    ( parent   instanceof   DomFileElement )     {", "final   DomFileElement   element    =     (  ( DomFileElement )     ( parent )  )  ;", "return   tags    ?    Arrays . asList ( element . getRootElement (  )  )     :    Collections . emptyList (  )  ;", "}", "final   XmlElement   xmlElement    =    parent . getXmlElement (  )  ;", "if    ( xmlElement   instanceof   XmlTag )     {", "XmlTag   tag    =     (  ( XmlTag )     ( xmlElement )  )  ;", "final   DomManager   domManager    =    parent . getManager (  )  ;", "final   SmartList < DomElement >    result    =    new   SmartList (  )  ;", "if    ( attributes )     {", "for    ( final   XmlAttribute   attribute    :    tag . getAttributes (  )  )     {", "if    (  !  ( attribute . isValid (  )  )  )     {", ". LOG . error (  (  \" Invalid   attr :    parent . valid =  \"     +     ( tag . isValid (  )  )  )  )  ;", "continue ;", "}", "GenericAttributeValue   element    =    domManager . getDomElement ( attribute )  ;", "if    (  . checkHasXml ( attribute ,    element )  )     {", "ContainerUtil . addIfNotNull ( result ,    element )  ;", "}", "}", "}", "if    ( tags )     {", "for    ( final   XmlTag   subTag    :    tag . getSubTags (  )  )     {", "if    (  !  ( subTag . isValid (  )  )  )     {", ". LOG . error (  (  \" Invalid   subtag :    parent . valid =  \"     +     ( tag . isValid (  )  )  )  )  ;", "continue ;", "}", "DomElement   element    =    domManager . getDomElement ( subTag )  ;", "if    (  . checkHasXml ( subTag ,    element )  )     {", "ContainerUtil . addIfNotNull ( result ,    element )  ;", "}", "}", "}", "return   result ;", "}", "return   Collections . emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["getDefinedChildren"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "return   DomUtil . getDefinedChildrenOfType ( parent ,    type ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["getDefinedChildrenOfType"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "return   ContainerUtil . findAll ( DomUtil . getDefinedChildren ( parent ,    tags ,    attributes )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["getDefinedChildrenOfType"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "return   DomUtil . getDomElement ( file . findElementAt ( editor . getCaretModel (  )  . getOffset (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getDomElement"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( element    =  =    null )", "return   null ;", "final   Project   project    =    element . getProject (  )  ;", "final   DomManager   domManager    =    DomManager . getDomManager ( project )  ;", "final   XmlAttribute   attr    =    PsiTreeUgetParentOfType ( element ,    XmlAttribute . class ,    false )  ;", "if    ( attr    !  =    null )     {", "final   GenericAttributeValue   value    =    domManager . getDomElement ( attr )  ;", "if    ( value    !  =    null )", "return   value ;", "}", "XmlTag   tag    =    PsiTreeUgetParentOfType ( element ,    XmlTag . class ,    false )  ;", "while    ( tag    !  =    null )     {", "final   DomElement   domElement    =    domManager . getDomElement ( tag )  ;", "if    ( domElement    !  =    null )", "return   domElement ;", "tag    =    tag . getParentTag (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDomElement"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "ArrayList < String >    result    =    new   ArrayList <  >  ( list . size (  )  )  ;", "if    (  ( list . size (  )  )     >     0  )     {", "for    ( DomElement   element    :    list )     {", "String   name    =    element . getGenericInfo (  )  . getElementName ( element )  ;", "if    ( name    !  =    null )     {", "result . add ( name )  ;", "}", "}", "}", "return   ArrayUtoStringArray ( result )  ;", "}", "METHOD_END"], "methodName": ["getElementNames"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "XmlTag [  ]    result    =    new   XmlTag [ list . length ]  ;", "i    =     0  ;", "for    ( DomElement   element    :    list )     {", "XmlTag   tag    =    element . getXmlTag (  )  ;", "if    ( tag    !  =    null )     {", "result [  ( i +  +  )  ]     =    tag ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getElementTags"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "ArrayList < XmlTag >    result    =    new   ArrayList <  >  ( list . size (  )  )  ;", "for    ( Element   element    :    list )     {", "XmlTag   tag    =    element . getXmlTag (  )  ;", "if    ( tag    !  =    null )     {", "result . add ( tag )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getElementTags"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "return   DomService . getInstance (  )  . getContainingFile ( element )  ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( element   instanceof   DomFileElement )     {", "return    (  ( DomFileElement )     ( element )  )  ;", "}", "DomFileElement   fileElement    =    element . getUserData (  . FILE _ ELEMENT _ KEY )  ;", "if    ( fileElement    =  =    null )     {", "DomElement   parent    =    element . getParent (  )  ;", "if    ( parent    !  =    null )     {", "fileElement    =     . getFileElement ( parent )  ;", "}", "element . putUserData (  . FILE _ ELEMENT _ KEY ,    fileElement )  ;", "}", "return   fileElement ;", "}", "METHOD_END"], "methodName": ["getFileElement"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "assert   element . isValid (  )  ;", "final   LinkedList < JavaMethod >    methods    =    new   LinkedList <  >  (  )  ;", "while    ( true )     {", "final   DomElement   parent    =    element . getParent (  )  ;", "if    ( parent   instanceof   DomFileElement )     {", "break ;", "}", "final   JavaMethod   method    =     . getGetterMethod ( element ,    parent )  ;", "if    ( method    =  =    null )     {", "return   null ;", "}", "methods . addFirst ( method )  ;", "element    =    element . getParent (  )  ;", "}", "return   methods ;", "}", "METHOD_END"], "methodName": ["getFixedPath"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "final   Class   aClass    =    DomUtil . ourTypeParameters . get ( type )  ;", "return   aClass    =  =     ( DomUtil . DUMMY )     ?    null    :    aClass ;", "}", "METHOD_END"], "methodName": ["getGenericValueParameter"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "final   String   xmlElementName    =    element . getXmlElementName (  )  ;", "final   String   namespace    =    element . getXmlElementNamespaceKey (  )  ;", "final   DomGenericInfo   genericInfo    =    parent . getGenericInfo (  )  ;", "if    ( element   instanceof   GenericAttributeValue )     {", "final   DomAttributeChildDescription   description    =    genericInfo . getAttributeChildDescription ( xmlElementName ,    namespace )  ;", "assert   description    !  =    null ;", "return   description . getGetterMethod (  )  ;", "}", "final   DomFixedChildDescription   description    =    genericInfo . getFixedChildDescription ( xmlElementName ,    namespace )  ;", "return   description    !  =    null    ?    description . getGetterMethod ( description . getValues ( parent )  . indexOf ( element )  )     :    null ;", "}", "METHOD_END"], "methodName": ["getGetterMethod"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "final   GenericDomValue   nameDomElement    =    element . getGenericInfo (  )  . getNameDomElement ( element )  ;", "if    ( nameDomElement    =  =    null )", "return   Collections . emptyList (  )  ;", "final   NameValue   nameValue    =    nameDomElement . getAnnotation ( NameValue . class )  ;", "if    (  ( nameValue    =  =    null )     |  |     (  !  ( nameValue . unique (  )  )  )  )", "return   Collections . emptyList (  )  ;", "final   String   stringValue    =    ElementPresentationManager . getElementName ( element )  ;", "if    ( stringValue    =  =    null )", "return   Collections . emptyList (  )  ;", "final   DomElement   scope    =    element . getManager (  )  . getIdentityScope ( element )  ;", "if    ( scope    =  =    null )", "return   Collections . emptyList (  )  ;", "final   DomGenericInfo   domGenericInfo    =    scope . getGenericInfo (  )  ;", "final   String   tagName    =    element . getXmlElementName (  )  ;", "final   DomCollectionChildDescription   childDescription    =    domGenericInfo . getCollectionChildDescription ( tagName ,    element . getXmlElementNamespaceKey (  )  )  ;", "if    ( childDescription    !  =    null )     {", "final   ArrayList < DomElement >    list    =    new   ArrayList <  >  ( childDescription . getValues ( scope )  )  ;", "list . remove ( element )  ;", "return   list ;", "}", "return   Collections . emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["getIdentitySiblings"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "final   XmlElement   psiElement    =    domElement . getXmlElement (  )  ;", "if    ( psiElement    =  =    null )", "return   domElement ;", "final   PsiFile   psiFile    =    psiElement . getContainingFile (  )  . getOriginalFile (  )  ;", "final   TextRange   range    =    psiElement . getTextRange (  )  ;", "final   PsiElement   element    =    psiFile . findElementAt ( range . getStartOffset (  )  )  ;", "final   int   maxLength    =    range . getLength (  )  ;", "final   boolean   isAttribute    =    psiElement   instanceof   XmlAttribute ;", "final   Class <  ?    extends   XmlElement >    clazz    =     ( isAttribute )     ?    XmlAttribute . class    :    XmlTag . class ;", "final   DomManager   domManager    =    domElement . getManager (  )  ;", "DomElement   current    =    null ;", "for    ( XmlElement   next    =    PsiTreeUgetParentOfType ( element ,    clazz ,    false )  ;     ( next    !  =    null )     &  &     (  ( next . getTextLength (  )  )     <  =    maxLength )  ;    next    =    PsiTreeUgetParentOfType ( next ,    clazz ,    true )  )     {", "current    =     ( isAttribute )     ?    domManager . getDomElement (  (  ( XmlAttribute )     ( next )  )  )     :    domManager . getDomElement (  (  ( XmlTag )     ( next )  )  )  ;", "if    (  ( current    !  =    null )     &  &     (  ( domElement . getClass (  )  )     !  =     ( current . getClass (  )  )  )  )", "current    =    null ;", "}", "return    (  ( T )     ( current )  )  ;", "}", "METHOD_END"], "methodName": ["getOriginalElement"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "for    ( DomElement   curElement    =     ( strict    &  &     ( element    !  =    null )  )     ?    element . getParent (  )     :    element ;    curElement    !  =    null ;    curElement    =    curElement . getParent (  )  )     {", "if    ( requiredClass . isInstance ( curElement )  )     {", "return    (  ( T )     ( curElement )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getParentOfType"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   startToken    =    XmlTagUtil . getStartTagNameElement ( tag )  ;", "if    ( startToken    =  =    null )     {", "return   Pair . create ( tag . getTextRange (  )  ,     (  ( PsiElement )     ( tag )  )  )  ;", "}", "return   Pair . create ( startToken . getTextRange (  )  . shiftRight (  (  -  ( tag . getTextRange (  )  . getStartOffset (  )  )  )  )  ,     (  ( PsiElement )     ( tag )  )  )  ;", "}", "METHOD_END"], "methodName": ["getProblemRange"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "while    ( true )     {", "final   Element   parent    =    domElement . getParent (  )  ;", "if    ( parent    =  =    null )     {", "return   domElement ;", "}", "domElement    =    parent ;", "}", "}", "METHOD_END"], "methodName": ["getRoot"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( domValue   instanceof   GenericAttributeValue )     {", "final   GenericAttributeValue   value    =     (  ( GenericAttributeValue )     ( domValue )  )  ;", "final   XmlAttributeValue   attributeValue    =    value . getXmlAttributeValue (  )  ;", "return   attributeValue    =  =    null    ?    value . getXmlAttribute (  )     :    attributeValue ;", "} else    {", "return   domValue . getXmlTag (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getValueElement"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "return   element . exists (  )  ;", "}", "METHOD_END"], "methodName": ["hasXml"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ! strict )     &  &     ( ancestor . equals ( descendant )  )  )", "return   true ;", "final   DomElement   parent    =    descendant . getParent (  )  ;", "return    ( parent    !  =    null )     &  &     (  . isAncestor ( ancestor ,    parent ,    false )  )  ;", "}", "METHOD_END"], "methodName": ["isAncestor"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "return    ( DomUtil . getGenericValueParameter ( type )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isGenericValueType"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "return   DomUtil . ourVariableSubstitutions . get ( Couple . of ( genericType ,    classType )  )  ;", "}", "METHOD_END"], "methodName": ["substituteGenericType"], "fileName": "com.intellij.util.xml.DomUtil"}, {"methodBody": ["METHOD_START", "{", "return   getDomManager (  )  . getFileElement (  (  ( XmlFile )     ( getPsiManager (  )  . findFile ( file )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getFileElement"], "fileName": "com.intellij.util.xml.DomVirtualFileEventsTest"}, {"methodBody": ["METHOD_START", "{", "WriteCommandAction . writeCommandAction ( myProject )  . run (  (  )     -  >     {", "final      dir    =    get ( createTempDirectory (  )  )  ;", "addSourceContentToRoots ( getModule (  )  ,    dir )  ;", "final      childData    =    dir . createChildData ( this ,     \" abc . xml \"  )  ;", "System . gc (  )  ;", "System . gc (  )  ;", "System . gc (  )  ;", "System . gc (  )  ;", "assertResultsAndClear (  )  ;", "setFileText ( childData ,     \"  < a /  >  \"  )  ;", "assertEventCount (  0  )  ;", "assertResultsAndClear (  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testCreateFile"], "fileName": "com.intellij.util.xml.DomVirtualFileEventsTest"}, {"methodBody": ["METHOD_START", "{", "WriteCommandAction . writeCommandAction ( getProject (  )  )  . run (  (  )     -  >     {", "final      dir    =    get ( createTempDirectory (  )  )  ;", "addSourceContentToRoots ( getModule (  )  ,    dir )  ;", "final      childData    =    dir . createChildData ( this ,     \" abc . xml \"  )  ;", "assertResultsAndClear (  )  ;", "setFileText ( childData ,     \"  < a /  >  \"  )  ;", "final   DomFileElementImpl < DomElement >    fileElement    =    getFileElement ( childData )  ;", "assertResultsAndClear (  )  ;", "childData . delete ( this )  ;", "assertEventCount (  1  )  ;", "putExpected ( new   DomEvent ( fileElement ,    false )  )  ;", "assertResultsAndClear (  )  ;", "assertFalse ( fileElement . isValid (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testDeleteFile"], "fileName": "com.intellij.util.xml.DomVirtualFileEventsTest"}, {"methodBody": ["METHOD_START", "{", "WriteCommandAction . writeCommandAction ( getProject (  )  )  . run (  (  )     -  >     {", "final      dir    =    get ( createTempDirectory (  )  )  ;", "addSourceContentToRoots ( getModule (  )  ,    dir )  ;", "final      data    =    dir . createChildData ( this ,     \" abc . xml \"  )  ;", "setFileText ( data ,     \"  < a /  >  \"  )  ;", "PsiDocumentManager . getInstance ( getProject (  )  )  . commitAllDocuments (  )  ;", "DomFileElementImpl < DomElement >    fileElement    =    getFileElement ( data )  ;", "assertEventCount (  0  )  ;", "assertResultsAndClear (  )  ;", "data . rename ( this ,     \" deaf . xml \"  )  ;", "assertEventCount (  1  )  ;", "putExpected ( new   DomEvent ( fileElement ,    false )  )  ;", "assertResultsAndClear (  )  ;", "assertEquals ( fileElement ,    getFileElement ( data )  )  ;", "assertTrue ( fileElement . isValid (  )  )  ;", "fileElement    =    getFileElement ( data )  ;", "data . rename ( this ,     \" fff . xml \"  )  ;", "assertEventCount (  1  )  ;", "putExpected ( new   DomEvent ( fileElement ,    false )  )  ;", "assertResultsAndClear (  )  ;", "assertNull ( getFileElement ( data )  )  ;", "assertFalse ( fileElement . isValid (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testRenameFile"], "fileName": "com.intellij.util.xml.DomVirtualFileEventsTest"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    o )", "return   true ;", "if    (  ( o    =  =    null )     |  |     (  ( getClass (  )  )     !  =     ( o . getClass (  )  )  )  )", "return   false ;", "final      that    =     (  (  )     ( o )  )  ;", "if    (  ( myNamespace )     !  =    null    ?     !  ( myNamespace . equals ( that . myNamespace )  )     :     ( that . myNamespace )     !  =    null )", "return   false ;", "if    (  ( myXmlName )     !  =    null    ?     !  ( myXmlName . equals ( that . myXmlName )  )     :     ( that . myXmlName )     !  =    null )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.intellij.util.xml.DummyEvaluatedXmlName"}, {"methodBody": ["METHOD_START", "{", "int   result ;", "result    =     (  ( my )     !  =    null )     ?    my . hashCode (  )     :     0  ;", "result    =     (  3  1     *    result )     +     (  ( myNamespace )     !  =    null    ?    myNamespace . hashCode (  )     :     0  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.intellij.util.xml.DummyEvaluatedXmlName"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getDocumentation"], "fileName": "com.intellij.util.xml.ElementPresentation"}, {"methodBody": ["METHOD_START", "{", "return    (    o )     -  >    getElementName ( o )  ;", "}", "METHOD_END"], "methodName": ["NAMER"], "fileName": "com.intellij.util.xml.ElementPresentationManager"}, {"methodBody": ["METHOD_START", "{", "return   createVariants ( elements ,     (  ( Function < T ,    String >  )     ( ElementPresentationManager . DEFAULT _ NAMER )  )  )  ;", "}", "METHOD_END"], "methodName": ["createVariants"], "fileName": "com.intellij.util.xml.ElementPresentationManager"}, {"methodBody": ["METHOD_START", "{", "return   createVariants ( elements ,    namer ,     0  )  ;", "}", "METHOD_END"], "methodName": ["createVariants"], "fileName": "com.intellij.util.xml.ElementPresentationManager"}, {"methodBody": ["METHOD_START", "{", "return   createVariants ( elements ,     (  ( Function < T ,    String >  )     ( ElementPresentationManager . DEFAULT _ NAMER )  )  ,    iconFlags )  ;", "}", "METHOD_END"], "methodName": ["createVariants"], "fileName": "com.intellij.util.xml.ElementPresentationManager"}, {"methodBody": ["METHOD_START", "{", "return   ContainerUtil . find ( collection ,     (    object )     -  >    Comparing . equal ( name ,    getElementName ( object )  ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["findByName"], "fileName": "com.intellij.util.xml.ElementPresentationManager"}, {"methodBody": ["METHOD_START", "{", "synchronized ( ElementPresentationManager . ourNameValueMethods )     {", "return   ElementPresentationManager . ourNameValueMethods . get ( aClass )  ;", "}", "}", "METHOD_END"], "methodName": ["findNameValueMethod"], "fileName": "com.intellij.util.xml.ElementPresentationManager"}, {"methodBody": ["METHOD_START", "{", "for    ( final   Function < Object ,    String >    function    :    ElementPresentationManager . ourDocumentationProviders )     {", "final   String   s    =    function . fun ( element )  ;", "if    ( s    !  =    null )     {", "return   s ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDocumentationForElement"], "fileName": "com.intellij.util.xml.ElementPresentationManager"}, {"methodBody": ["METHOD_START", "{", "for    ( final   Function < Object ,    String >    function    :    ElementPresentationManager . ourNameProviders )     {", "final   String   s    =    function . fun ( element )  ;", "if    ( s    !  =    null )     {", "return   s ;", "}", "}", "Object   o    =    ElementPresentationManager . invokeNameValueMethod ( element )  ;", "if    (  ( o    =  =    null )     |  |     ( o   instanceof   String )  )", "return    (  ( String )     ( o )  )  ;", "if    ( o   instanceof   GenericValue )     {", "final   GenericValue   gv    =     (  ( GenericValue )     ( o )  )  ;", "final   String   s    =    gv . getStringValue (  )  ;", "if    ( s    =  =    null )     {", "final   Object   value    =    gv . getValue (  )  ;", "if    ( value    !  =    null )     {", "return   String . valueOf ( value )  ;", "}", "}", "return   s ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getElementName"], "fileName": "com.intellij.util.xml.ElementPresentationManager"}, {"methodBody": ["METHOD_START", "{", "return    ( array    =  =    null )     |  |     (  ( array . length )     =  =     0  )     ?    null    :    array [  0  ]  ;", "}", "METHOD_END"], "methodName": ["getFirst"], "fileName": "com.intellij.util.xml.ElementPresentationManager"}, {"methodBody": ["METHOD_START", "{", "for    ( final   Function < Object ,    Icon >    function    :    ElementPresentationManager . ourIconProviders )     {", "final   Icon   icon    =    function . fun ( o )  ;", "if    ( icon    !  =    null )     {", "return   icon ;", "}", "}", "if    ( o   instanceof   DomElement )     {", "final   DomElement   domElement    =     (  ( DomElement )     ( o )  )  ;", "final   boolean   dumb    =    DumbService . getInstance ( domElement . getManager (  )  . getProject (  )  )  . isDumb (  )  ;", "for    ( final   IconProvider   provider    :    EXTENSION _ POINT _ NAME . getExtensions (  )  )     {", "if    ( provider   instanceof   DomIconProvider )     {", "if    ( dumb    &  &     (  !  ( DumbService . isDumbAware ( provider )  )  )  )     {", "continue ;", "}", "final   Icon   icon    =     (  ( DomIconProvider )     ( provider )  )  . getIcon ( domElement ,     0  )  ;", "if    ( icon    !  =    null )     {", "return   icon ;", "}", "}", "}", "}", "final   Icon [  ]    icons    =    ElementPresentationManager . getIconsForClass ( o . getClass (  )  ,    o )  ;", "if    (  ( icons    !  =    null )     &  &     (  ( icons . length )     >     0  )  )     {", "return   icons [  0  ]  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getIcon"], "fileName": "com.intellij.util.xml.ElementPresentationManager"}, {"methodBody": ["METHOD_START", "{", "return   ElementPresentationManager . getFirst ( ElementPresentationManager . getIconsForClass ( clazz ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["getIconForClass"], "fileName": "com.intellij.util.xml.ElementPresentationManager"}, {"methodBody": ["METHOD_START", "{", "for    ( final   Function < Object ,    Icon >    function    :    ElementPresentationManager . ourIconProviders )     {", "final   Icon   icon    =    function . fun ( o )  ;", "if    ( icon    !  =    null )     {", "return   icon ;", "}", "}", "final   Icon [  ]    icons    =    ElementPresentationManager . getIconsForClass ( o . getClass (  )  ,    o )  ;", "if    (  ( icons    !  =    null )     &  &     (  ( icons . length )     >     0  )  )     {", "return   icons [  0  ]  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getIconOld"], "fileName": "com.intellij.util.xml.ElementPresentationManager"}, {"methodBody": ["METHOD_START", "{", "TypePresentationService   service    =    TypePresentationService . getService (  )  ;", "final   Icon   icon    =     ( o    =  =    null )     ?    service . getTypeIcon ( clazz )     :    service . getIcon ( o )  ;", "if    ( icon    !  =    null )     {", "return   new   Icon [  ]  {    icon    }  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getIconsForClass"], "fileName": "com.intellij.util.xml.ElementPresentationManager"}, {"methodBody": ["METHOD_START", "{", "return   ServiceManager . getService ( ElementPresentationManager . class )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "com.intellij.util.xml.ElementPresentationManager"}, {"methodBody": ["METHOD_START", "{", "final   Object   firstImpl    =    ModelMergerUtil . getFirstImplementation ( o )  ;", "o    =     ( firstImpl    !  =    null )     ?    firstImpl    :    o ;", "String   typeName    =    TypeService . getService (  )  . getTypeName ( o )  ;", "if    ( typeName    !  =    null )", "return   typeName ;", "if    ( o   instanceof   DomElement )     {", "final   DomElement   element    =     (  ( DomElement )     ( o )  )  ;", "return   StringUtil . capitalizeWords ( element . getNameStrategy (  )  . splitIntoWords ( element . getXmlElementName (  )  )  ,    true )  ;", "}", "return   TypeService . getDefaultTypeName ( o . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTypeNameForObject"], "fileName": "com.intellij.util.xml.ElementPresentationManager"}, {"methodBody": ["METHOD_START", "{", "final   Method   nameValueMethod    =    ElementPresentationManager . findNameValueMethod ( element . getClass (  )  )  ;", "if    ( nameValueMethod    =  =    null )     {", "return   null ;", "}", "return   DomReflectionUtil . invokeMethod ( nameValueMethod ,    element )  ;", "}", "METHOD_END"], "methodName": ["invokeNameValueMethod"], "fileName": "com.intellij.util.xml.ElementPresentationManager"}, {"methodBody": ["METHOD_START", "{", "return    (  ( NullableFunction < T ,    String >  )     ( ElementPresentationManager . NAMER )  )  ;", "}", "METHOD_END"], "methodName": ["namer"], "fileName": "com.intellij.util.xml.ElementPresentationManager"}, {"methodBody": ["METHOD_START", "{", "ElementPresentationManager . ourDocumentationProviders . add ( function )  ;", "}", "METHOD_END"], "methodName": ["registerDocumentationProvider"], "fileName": "com.intellij.util.xml.ElementPresentationManager"}, {"methodBody": ["METHOD_START", "{", "ElementPresentationManager . ourNameProviders . add ( function )  ;", "}", "METHOD_END"], "methodName": ["registerNameProvider"], "fileName": "com.intellij.util.xml.ElementPresentationManager"}, {"methodBody": ["METHOD_START", "{", "return   EnumConverter . ourCache . get ( aClass )  ;", "}", "METHOD_END"], "methodName": ["createEnumConverter"], "fileName": "com.intellij.util.xml.EnumConverter"}, {"methodBody": ["METHOD_START", "{", "return   NamedEnumUtil . getEnumValueByElement ( anEnum )  ;", "}", "METHOD_END"], "methodName": ["getStringValue"], "fileName": "com.intellij.util.xml.EnumConverter"}, {"methodBody": ["METHOD_START", "{", "return    !  ( ReflectionUtil . isAssignable ( NonExhaustiveEnum . class ,    myType )  )  ;", "}", "METHOD_END"], "methodName": ["isExhaustive"], "fileName": "com.intellij.util.xml.EnumConverter"}, {"methodBody": ["METHOD_START", "{", "final   EvaluatedXmlNameImpl   name    =    new   EvaluatedXmlNameImpl ( xmlName ,    namespaceKey ,    equalToParent )  ;", "final   EvaluatedXmlNameImpl   interned    =    EvaluatedXmlNameImpl . ourInterned . get ( name )  ;", "if    ( interned    !  =    null )     {", "return   interned ;", "}", "EvaluatedXmlNameImpl . ourInterned . put ( name ,    name )  ;", "return   name ;", "}", "METHOD_END"], "methodName": ["createEvaluatedXmlName"], "fileName": "com.intellij.util.xml.EvaluatedXmlNameImpl"}, {"methodBody": ["METHOD_START", "{", "CachedValue < Map < String ,    List < String >  >  >    value    =    file . getUserData ( EvaluatedXmlNameImpl . NAMESPACE _ PROVIDER _ KEY )  ;", "if    ( value    =  =    null )     {", "file . putUserData ( EvaluatedXmlNameImpl . NAMESPACE _ PROVIDER _ KEY ,     ( value    =    CachedValuesManager . getManager ( file . getProject (  )  )  . createCachedValue (  (  )     -  >     {", "Map < String ,    List < String >  >    map    =    ConcurrentFactoryMap . createMap (  (    key )     -  >     {", "final   DomFileDescription <  ?  >    description    =    DomManager . getDomManager ( file . getProject (  )  )  . getDomFileDescription ( file )  ;", "if    ( description    =  =    null )", "return   emptyList (  )  ;", "return   description . getAllowedNamespaces ( key ,    file )  ;", "}  )  ;", "return   CachedValueProvider . Result . create ( map ,    file )  ;", "}  ,    false )  )  )  ;", "}", "final   List < String >    list    =    value . getValue (  )  . get ( myNamespaceKey )  ;", "assert   list    !  =    null ;", "return   list ;", "}", "METHOD_END"], "methodName": ["getAllowedNamespaces"], "fileName": "com.intellij.util.xml.EvaluatedXmlNameImpl"}, {"methodBody": ["METHOD_START", "{", "return   myXmlName . getLocalName (  )  ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "com.intellij.util.xml.EvaluatedXmlNameImpl"}, {"methodBody": ["METHOD_START", "{", "return   getAllowedNamespaces ( file )  ;", "}", "METHOD_END"], "methodName": ["getNamespaceList"], "fileName": "com.intellij.util.xml.EvaluatedXmlNameImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( parentElement   instanceof   XmlTag )     {", "return    (  ( XmlTag )     ( parentElement )  )  . getspace (  )  ;", "}", "if    ( parentElement   instanceof   XmlAttribute )     {", "return    (  ( XmlAttribute )     ( parentElement )  )  . getspace (  )  ;", "}", "if    ( parentElement   instanceof   XmlFile )     {", "final   XmlDocument   document    =     (  ( XmlFile )     ( parentElement )  )  . getDocument (  )  ;", "if    ( document    !  =    null )     {", "final   XmlTag   tag    =    document . getRootTag (  )  ;", "if    ( tag    !  =    null )     {", "return   tag . getspace (  )  ;", "}", "}", "return    \"  \"  ;", "}", "throw   new   AssertionError (  (  \" Can ' t   get   namespace   of    \"     +    parentElement )  )  ;", "}", "METHOD_END"], "methodName": ["getXmlElementNamespace"], "fileName": "com.intellij.util.xml.EvaluatedXmlNameImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( myNamespaceKey )     =  =    null )     |  |     ( myEqualToParent )  )", "return   true ;", "final   XmlFile   file    =    element . getFile (  )  ;", "return    . isNamespaceAllowed ( namespace ,    getAllowedNamespaces ( file )  )  ;", "}", "METHOD_END"], "methodName": ["isNamespaceAllowed"], "fileName": "com.intellij.util.xml.EvaluatedXmlNameImpl"}, {"methodBody": ["METHOD_START", "{", "return    ( list . contains ( namespace )  )     |  |     (  ( StringUtil . isEmpty ( namespace )  )     &  &     ( list . isEmpty (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isNamespaceAllowed"], "fileName": "com.intellij.util.xml.EvaluatedXmlNameImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( myNamespaceKey )     =  =    null    ?     \"  \"     :     ( myNamespaceKey )     +     \"     :     \"  )     +     ( myXmlName . getLocalName (  )  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.util.xml.EvaluatedXmlNameImpl"}, {"methodBody": ["METHOD_START", "{", "for    ( GenericValue <  ?  >    o    :    collection )     {", "if    ( Comparing . equal ( value ,    o . getStringValue (  )  )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsString"], "fileName": "com.intellij.util.xml.GenericValueUtil"}, {"methodBody": ["METHOD_START", "{", "for    ( GenericValue <  ?    extends   T >    o    :    collection )     {", "if    ( Comparing . equal ( value ,    o . getValue (  )  )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsValue"], "fileName": "com.intellij.util.xml.GenericValueUtil"}, {"methodBody": ["METHOD_START", "{", "for    ( GenericValue   o    :    collection )     {", "final   String   value    =    o . getStringValue (  )  ;", "if    ( value    !  =    null )     {", "result . add ( value . replace (  '  $  '  ,     '  .  '  )  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getClassStringCollection"], "fileName": "com.intellij.util.xml.GenericValueUtil"}, {"methodBody": ["METHOD_START", "{", "for    ( GenericValue   o    :    collection )     {", "ContainerUtil . addIfNotNull ( result ,    o . getStringValue (  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getStringCollection"], "fileName": "com.intellij.util.xml.GenericValueUtil"}, {"methodBody": ["METHOD_START", "{", "for    ( GenericValue <  ?    extends   T >    o    :    collection )     {", "ContainerUtil . addIfNotNull ( result ,    o . getValue (  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getValueCollection"], "fileName": "com.intellij.util.xml.GenericValueUtil"}, {"methodBody": ["METHOD_START", "{", "final   Annotation   annotation    =    mySignature . findAnnotation ( annotationClass ,    myDeclaringClass )  ;", "return   annotation    =  =    null    ?     . NONE    :    annotation ;", "}", "METHOD_END"], "methodName": ["findAnnotation"], "fileName": "com.intellij.util.xml.JavaMethod"}, {"methodBody": ["METHOD_START", "{", "return   myDeclaringClass ;", "}", "METHOD_END"], "methodName": ["getDeclaringClass"], "fileName": "com.intellij.util.xml.JavaMethod"}, {"methodBody": ["METHOD_START", "{", "return   myMethod . getGenericParameterTypes (  )  ;", "}", "METHOD_END"], "methodName": ["getGenericParameterTypes"], "fileName": "com.intellij.util.xml.JavaMethod"}, {"methodBody": ["METHOD_START", "{", "return   myMethod . getGenericReturnType (  )  ;", "}", "METHOD_END"], "methodName": ["getGenericReturnType"], "fileName": "com.intellij.util.xml.JavaMethod"}, {"methodBody": ["METHOD_START", "{", "return   mySignature . getAllMethods ( myDeclaringClass )  ;", "}", "METHOD_END"], "methodName": ["getHierarchy"], "fileName": "com.intellij.util.xml.JavaMethod"}, {"methodBody": ["METHOD_START", "{", "return   myMethod ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "com.intellij.util.xml.JavaMethod"}, {"methodBody": ["METHOD_START", "{", "return   new   JavaMethod ( declaringClass ,    signature )  ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "com.intellij.util.xml.JavaMethod"}, {"methodBody": ["METHOD_START", "{", "return   JavaMethod . getMethod ( declaringClass ,    new   JavaMethodSignature ( method )  )  ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "com.intellij.util.xml.JavaMethod"}, {"methodBody": ["METHOD_START", "{", "return   mySignature . getMethodName (  )  ;", "}", "METHOD_END"], "methodName": ["getMethodName"], "fileName": "com.intellij.util.xml.JavaMethod"}, {"methodBody": ["METHOD_START", "{", "return   myMethod . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.intellij.util.xml.JavaMethod"}, {"methodBody": ["METHOD_START", "{", "return   myMethod . getParameterTypes (  )  ;", "}", "METHOD_END"], "methodName": ["getParameterTypes"], "fileName": "com.intellij.util.xml.JavaMethod"}, {"methodBody": ["METHOD_START", "{", "return   myMethod . getReturnType (  )  ;", "}", "METHOD_END"], "methodName": ["getReturnType"], "fileName": "com.intellij.util.xml.JavaMethod"}, {"methodBody": ["METHOD_START", "{", "return   mySignature ;", "}", "METHOD_END"], "methodName": ["getSignature"], "fileName": "com.intellij.util.xml.JavaMethod"}, {"methodBody": ["METHOD_START", "{", "return   DomReflectionUtil . invokeMethod ( myMethod ,    o ,    args )  ;", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "com.intellij.util.xml.JavaMethod"}, {"methodBody": ["METHOD_START", "{", "return    \" JavaMethod :     \"     +     ( myMethod . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.util.xml.JavaMethod"}, {"methodBody": ["METHOD_START", "{", "CommonProcessors . FindProcessor < Method >    processor    =    new   CommonProcessors . FindProcessor < Method >  (  )     {", "@ Override", "protected   boolean   accept ( Method   method )     {", "final   T   annotation    =    method . getAnnotation ( annotationClass )  ;", "return    ( annotation    !  =    null )     &  &     ( ReflectionUtil . isAssignable ( method . getDeclaringClass (  )  ,    startFrom )  )  ;", "}", "}  ;", "processMethods ( startFrom ,    processor )  ;", "return   processor . getFoundValue (  )  ;", "}", "METHOD_END"], "methodName": ["findAnnotatedMethod"], "fileName": "com.intellij.util.xml.JavaMethodSignature"}, {"methodBody": ["METHOD_START", "{", "CommonProcessors . FindProcessor < Method >    processor    =    new   CommonProcessors . FindProcessor < Method >  (  )     {", "@ Override", "protected   boolean   accept ( Method   method )     {", "final   T   annotation    =    method . getAnnotation ( annotationClass )  ;", "return   annotation    !  =    null ;", "}", "}  ;", "processMethods ( startFrom ,    processor )  ;", "final   Method   foundMethod    =    processor . getFoundValue (  )  ;", "return   foundMethod    =  =    null    ?    null    :    foundMethod . getAnnotation ( annotationClass )  ;", "}", "METHOD_END"], "methodName": ["findAnnotation"], "fileName": "com.intellij.util.xml.JavaMethodSignature"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    getDeclaredMethod ( aClass )  ;", "if    (  ( method    =  =    null )     &  &     ( aClass . isInterface (  )  )  )     {", "method    =    getDeclaredMethod ( Object . class )  ;", "}", "return   method ;", "}", "METHOD_END"], "methodName": ["findMethod"], "fileName": "com.intellij.util.xml.JavaMethodSignature"}, {"methodBody": ["METHOD_START", "{", "final   List < Method >    result    =    new   ArrayList <  >  (  )  ;", "processMethods ( startFrom ,    Processors . cancelableCollectProcessor ( result )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getAllMethods"], "fileName": "com.intellij.util.xml.JavaMethodSignature"}, {"methodBody": ["METHOD_START", "{", "final   Method   method    =    ReflectionUtil . getMethod ( aClass ,    myMethodName ,    myMethodParameters )  ;", "return   method    =  =    null    ?    ReflectionUtil . getDeclaredMethod ( aClass ,    myMethodName ,    myMethodParameters )     :    method ;", "}", "METHOD_END"], "methodName": ["getDeclaredMethod"], "fileName": "com.intellij.util.xml.JavaMethodSignature"}, {"methodBody": ["METHOD_START", "{", "return   myMethodName ;", "}", "METHOD_END"], "methodName": ["getMethodName"], "fileName": "com.intellij.util.xml.JavaMethodSignature"}, {"methodBody": ["METHOD_START", "{", "if    ( method    !  =    null )     {", "if    (  !  ( processor . process ( method )  )  )", "return   false ;", "}", "final   Class   superClass    =    aClass . getSuperclass (  )  ;", "if    ( superClass    !  =    null )     {", "if    (  !  ( processs ( superClass ,    processor )  )  )", "return   false ;", "} else    {", "if    ( aClass . isInterface (  )  )     {", "if    (  !  ( processs ( Object . class ,    processor )  )  )", "return   false ;", "}", "}", "for    ( final   Class   anInterface    :    aClass . getInterfaces (  )  )     {", "if    (  !  ( processs ( anInterface ,    processor )  )  )", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["processMethodWithSupers"], "fileName": "com.intellij.util.xml.JavaMethodSignature"}, {"methodBody": ["METHOD_START", "{", "return   processMethodWithSupers ( aClass ,    findMethod ( aClass )  ,    processor )  ;", "}", "METHOD_END"], "methodName": ["processMethods"], "fileName": "com.intellij.util.xml.JavaMethodSignature"}, {"methodBody": ["METHOD_START", "{", "return    ( myMethodName )     +     ( Arrays . asList ( myMethodParameters )  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.util.xml.JavaMethodSignature"}, {"methodBody": ["METHOD_START", "{", "final   DomManager   domManager    =    element . getManager (  )  ;", "Xml   xml    =    element . get (  )  ;", "Set < Xml >    files    =    new   HashSet <  >  (  )  ;", "files . add ( xml )  ;", "final   Xml   original    =     (  ( Xml )     ( xml . getOriginal (  )  )  )  ;", "if    ( original    !  =    xml )     {", "final   DomElement   originalElement    =    domManager . getElement ( original )  ;", "if    ( originalElement    !  =    null )     {", "element    =    originalElement ;", "}", "}", "files . addAll ( getsToMerge ( element )  )  ;", "ArrayList < T >    roots    =    new   ArrayList <  >  ( files . size (  )  )  ;", "for    ( Xml   file    :    files )     {", "final   DomElement < T >    fileElement    =    domManager . getElement ( file )  ;", "if    ( fileElement    !  =    null )     {", "roots . add ( fileElement . getRootElement (  )  )  ;", "}", "}", "if    (  ( roots . size (  )  )     =  =     1  )     {", "return   roots . iterator (  )  . next (  )  ;", "}", "if    (  ( myMerger )     =  =    null )     {", "myMerger    =    DomService . getInstance (  )  . createModelMerger (  )  ;", "}", "return   myMerger . mergeModels ( getRootElementClass (  )  ,    roots )  ;", "}", "METHOD_END"], "methodName": ["getMergedRoot"], "fileName": "com.intellij.util.xml.MergingFileDescription"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  (  \" Method   getRoot   is   not   yet   implemented   in    \"     +     ( getClass (  )  . getName (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getRoot"], "fileName": "com.intellij.util.xml.MockDomElement"}, {"methodBody": ["METHOD_START", "{", "return    (  ( DomFileElement < T >  )     ( this )  )  ;", "}", "METHOD_END"], "methodName": ["getRoot"], "fileName": "com.intellij.util.xml.MockDomFileElement"}, {"methodBody": ["METHOD_START", "{", "( myModCount )  +  +  ;", "}", "METHOD_END"], "methodName": ["incModificationCount"], "fileName": "com.intellij.util.xml.MockDomFileElement"}, {"methodBody": ["METHOD_START", "{", "myFileDescription    =    fileDescription ;", "}", "METHOD_END"], "methodName": ["setFileDescription"], "fileName": "com.intellij.util.xml.MockDomFileElement"}, {"methodBody": ["METHOD_START", "{", "final   Set < Class >    commonClasses    =    ModelMergerImpl . getCommonClasses ( new   gnu . trove . THashSet (  )  ,     (  ( Object [  ]  )     ( implementations )  )  )  ;", "commonClasses . add ( ModelMergerImpl . MERGED _ OBJECT _ CLASS )  ;", "commonClasses . add ( aClass )  ;", "return   AdvancedProxy . createProxy ( handler ,    null ,    commonClasses . toArray ( EMPTY _ CLASS _ ARRAY )  )  ;", "}", "METHOD_END"], "methodName": ["_mergeModels"], "fileName": "com.intellij.util.xml.ModelMergerImpl"}, {"methodBody": ["METHOD_START", "{", "final   Object   primaryKey    =    ModelMergerImpl . getPrimaryKey ( o ,    singleValuedInvocation )  ;", "if    (  ( primaryKey    !  =    null )     |  |    singleValuedInvocation )     {", "final   List < Set < Object >  >    list    =    map . get ( primaryKey )  ;", "final   int [  ]    indices    =    counts . get ( primaryKey )  ;", "int   objIndex    =     ( intersect )     ?    indices [ index ]     :     ( indices [ index ]  )  +  +  ;", "if    (  ( list . size (  )  )     <  =    objIndex )     {", "list . add ( new   LinkedHashSet <  >  (  )  )  ;", "}", "list . get ( objIndex )  . add ( o )  ;", "return   false ;", "}", "results . add ( o )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["addToMaps"], "fileName": "com.intellij.util.xml.ModelMergerImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( method . getReturnType (  )  )     !  =     ( void . class )  )     &  &     (  ( method . getParameterTypes (  )  . length )     =  =     0  )     ?    new   JavaMethodSignature ( method )  . findAnnotatedMethod ( PrimaryKey . class ,    aClass )     :    null ;", "}", "METHOD_END"], "methodName": ["findPrimaryKeyAnnotatedMethod"], "fileName": "com.intellij.util.xml.ModelMergerImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( implementations . length )     >     0  )     {", "DomUgetAllInterfaces ( implementations [  0  ]  . getClass (  )  ,    result )  ;", "for    ( int   i    =     1  ;    i    <     ( implementations . length )  ;    i +  +  )     {", "final   ArrayList < Class >    list 1     =    new   ArrayList <  >  (  )  ;", "DomUgetAllInterfaces ( implementations [ i ]  . getClass (  )  ,    list 1  )  ;", "result . retainAll ( list 1  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getCommonClasses"], "fileName": "com.intellij.util.xml.ModelMergerImpl"}, {"methodBody": ["METHOD_START", "{", "final   List < Object >    results    =    new   ArrayList <  >  (  )  ;", "if    ( returnType . isInterface (  )  )     {", "final   List < Object >    orderedPrimaryKeys    =    new   SmartList (  )  ;", "final   Map < Object ,    List < Set < Object >  >  >    map    =    FactoryMap . create (  (    key )     -  >     {", "orderedPrimaryKeys . add ( key )  ;", "return   new   SmartList <  >  (  )  ;", "}  )  ;", "final   Map < Object ,    int [  ]  >    counts    =    FactoryMap . create (  (    key )     -  >    new   int [ implementations . size (  )  ]  )  ;", "for    ( int   i    =     0  ;    i    <     ( implementations . size (  )  )  ;    i +  +  )     {", "Object   t    =    implementations . get ( i )  ;", "final   Object   o    =    method . invoke ( t ,    args )  ;", "if    ( o   instanceof   Collection )     {", "for    ( final   Object   o 1     :     (  ( Collection )     ( o )  )  )     {", "addToMaps ( o 1  ,    counts ,    map ,    i ,    results ,    false ,    intersect )  ;", "}", "} else", "if    ( o    !  =    null )     {", "addToMaps ( o ,    counts ,    map ,    i ,    results ,    true ,    intersect )  ;", "}", "}", "for    ( final   Object   primaryKey    :    orderedPrimaryKeys )     {", "for    ( final   Set < Object >    objects    :    map . get ( primaryKey )  )     {", "results . add ( mergeImplementations ( returnType ,    new   ArrayList <  >  ( objects )  )  )  ;", "}", "}", "} else    {", "HashSet < Object >    map    =    new   HashSet <  >  (  )  ;", "for    ( final   Object   t    :    implementations )     {", "final   Object   o    =    method . invoke ( t ,    args )  ;", "if    ( o   instanceof   Collection )     {", "map . addAll (  (  ( Collection < Object >  )     ( o )  )  )  ;", "} else", "if    ( o    !  =    null )     {", "map . add ( o )  ;", "break ;", "}", "}", "results . addAll ( map )  ;", "}", "return   results ;", "}", "METHOD_END"], "methodName": ["getMergedImplementations"], "fileName": "com.intellij.util.xml.ModelMergerImpl"}, {"methodBody": ["METHOD_START", "{", "final   Method   method    =    ModelMergerImpl . getPrimaryKeyMethod ( implementation . getClass (  )  )  ;", "if    ( method    !  =    null )     {", "final   Object   o    =    DomReflectionUtil . invokeMethod ( method ,    implementation )  ;", "return   ReflectionUtil . isAssignable ( GenericValue . class ,    method . getReturnType (  )  )     ?     (  ( GenericValue )     ( o )  )  . getValue (  )     :    o ;", "} else    {", "if    ( implementation   instanceof   GenericValue )     {", "return   singleValuedInvocation    ?    Boolean . TRUE    :     (  ( GenericValue )     ( implementation )  )  . getValue (  )  ;", "} else    {", "return   null ;", "}", "}", "}", "METHOD_END"], "methodName": ["getPrimaryKey"], "fileName": "com.intellij.util.xml.ModelMergerImpl"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ModelMergerImpl . ourPrimaryKeyMethods . get ( aClass )  ;", "if    ( method    =  =    null )     {", "if    ( ModelMergerImpl . ourPrimaryKeyMethods . containsKey ( aClass )  )", "return   null ;", "for    ( final   Method   method 1     :    ReflectionUtil . getClassPublicMethods ( aClass )  )     {", "if    (  ( method    =    ModelMergerImpl . findPrimaryKeyAnnotatedMethod ( method 1  ,    aClass )  )     !  =    null )     {", "break ;", "}", "}", "ModelMergerImpl . ourPrimaryKeyMethods . put ( aClass ,    method )  ;", "}", "return   method ;", "}", "METHOD_END"], "methodName": ["getPrimaryKeyMethod"], "fileName": "com.intellij.util.xml.ModelMergerImpl"}, {"methodBody": ["METHOD_START", "{", "return    ( getMethod (  )  . getAnnotation ( Intersect . class )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isIntersectionMethod"], "fileName": "com.intellij.util.xml.ModelMergerImpl"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     ( myMergingStrategies . size (  )  )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "if    ( ReflectionUtil . isAssignable ( myMergingStrategyClasses . get ( i )  ,    returnType )  )     {", "final   Object   o    =    myMergingStrategies . get ( i )  . mergeChildren ( returnType ,    implementations )  ;", "if    ( o    !  =    null )     {", "return   o ;", "}", "}", "}", "if    (  ( implementations . size (  )  )     =  =     1  )     {", "return   implementations . get (  0  )  ;", "}", "return   merges ( returnType ,    implementations )  ;", "}", "METHOD_END"], "methodName": ["mergeImplementations"], "fileName": "com.intellij.util.xml.ModelMergerImpl"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelMergerUtil . ImplementationProcessor ( processor ,    false )  ;", "}", "METHOD_END"], "methodName": ["createFilteringProcessor"], "fileName": "com.intellij.util.xml.ModelMergerUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( element    =  =    null )", "return   emptyList (  )  ;", "List < T >    result    =    new   ArrayList <  >  (  )  ;", "Processor < T >    processor    =    Processors . cancelableCollectProcessor ( result )  ;", "new    . ImplementationProcessor ( processor ,    false )  . process ( element )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getFilteredImplementations"], "fileName": "com.intellij.util.xml.ModelMergerUtil"}, {"methodBody": ["METHOD_START", "{", "T   cur    =    t ;", "while    ( cur   instanceof   dObject )     {", "final   List < T >    implementations    =     (  ( dObject < T >  )     ( cur )  )  . getImplementations (  )  ;", "cur    =     ( implementations . isEmpty (  )  )     ?    null    :    implementations . get (  0  )  ;", "}", "return   cur ;", "}", "METHOD_END"], "methodName": ["getFirstImplementation"], "fileName": "com.intellij.util.xml.ModelMergerUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( element    =  =    null )", "return   null ;", "CommonProcessors . FindFirstProcessor < T >    processor    =    new   CommonProcessors . FindFirstProcessor < T >  (  )     {", "@ Override", "public   boolean   process ( final   T   t )     {", "return    (  !  ( ReflectionUtil . isAssignable ( clazz ,    t . getClass (  )  )  )  )     |  |     ( super . process ( t )  )  ;", "}", "}  ;", "new    . ImplementationProcessor ( processor ,    true )  . process ( element )  ;", "return    (  ( V )     ( processor . getFoundValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getImplementation"], "fileName": "com.intellij.util.xml.ModelMergerUtil"}, {"methodBody": ["METHOD_START", "{", "return   ModelMergerUtil . getImplementation ( clazz ,    Arrays . asList ( elements )  )  ;", "}", "METHOD_END"], "methodName": ["getImplementation"], "fileName": "com.intellij.util.xml.ModelMergerUtil"}, {"methodBody": ["METHOD_START", "{", "for    ( final   T   element    :    elements )     {", "final   V   implementation    =     . getImplementation ( element ,    clazz )  ;", "if    ( implementation    !  =    null )     {", "return   implementation ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getImplementation"], "fileName": "com.intellij.util.xml.ModelMergerUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( element   instanceof   MergedObject )     {", "final   MergedObject < T >    mergedObject    =     (  ( MergedObject < T >  )     ( element )  )  ;", "return   mergedObject . getImplementations (  )  ;", "} else", "if    ( element    !  =    null )     {", "return   singletonList ( element )  ;", "} else    {", "return   emptyList (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getImplementations"], "fileName": "com.intellij.util.xml.ModelMergerUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( element    =  =    null )", "return   emptyList (  )  ;", "CommonProcessors . CollectProcessor < T >    processor    =    new   CommonProcessors . CollectProcessor < T >  (  )     {", "@ Override", "public   boolean   process ( final   T   t )     {", "return    (  !  ( ReflectionUtil . isAssignable ( clazz ,    t . getClass (  )  )  )  )     |  |     ( super . process ( t )  )  ;", "}", "}  ;", "new    . ImplementationProcessor ( processor ,    true )  . process ( element )  ;", "return    (  ( Collection < V >  )     ( processor . getResults (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getImplementations"], "fileName": "com.intellij.util.xml.ModelMergerUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( context    =  =    null )", "return   Module . EMPTY _ ARRAY ;", "final   Set < Module >    modules    =    new   HashSet <  >  (  )  ;", "for    (    moduleContextProvider    :    Extensions . getExtensions (  . EP _ NAME )  )     {", "ContainerUtil . addAllNotNull ( modules ,    moduleContextProvider . getContextModules ( context )  )  ;", "}", "Module   module    =    ModuleUtilCore . findModuleForPsiElement ( context )  ;", "if    ( module    !  =    null )", "modules . add ( module )  ;", "return   modules . toArray ( EMPTY _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["getModules"], "fileName": "com.intellij.util.xml.ModuleContextProvider"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" aaa - bbb - ccc \"  ,    DomNameStrategy . HYPHEN _ STRATEGY . convertName (  \" aaaBbbCcc \"  )  )  ;", "assertEquals (  \" aaa - bbb - ccc \"  ,    DomNameStrategy . HYPHEN _ STRATEGY . convertName (  \" AaaBbbCcc \"  )  )  ;", "assertEquals (  \" aaa \"  ,    DomNameStrategy . HYPHEN _ STRATEGY . convertName (  \" Aaa \"  )  )  ;", "assertEquals (  \" aaa \"  ,    DomNameStrategy . HYPHEN _ STRATEGY . convertName (  \" aaa \"  )  )  ;", "assertEquals (  \" AAA - bbb \"  ,    DomNameStrategy . HYPHEN _ STRATEGY . convertName (  \" AAABbb \"  )  )  ;", "assertEquals (  \" aaa - BBB \"  ,    DomNameStrategy . HYPHEN _ STRATEGY . convertName (  \" AaaBBB \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testHyphenStrategy"], "fileName": "com.intellij.util.xml.NameStrategyTest"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" aaa   bbb   ccc \"  ,    DomNameStrategy . HYPHEN _ STRATEGY . splitIntoWords (  \" aaa - bbb - ccc \"  )  )  ;", "assertEquals (  \" Aaa \"  ,    DomNameStrategy . HYPHEN _ STRATEGY . splitIntoWords (  \" Aaa \"  )  )  ;", "assertEquals (  \" aaa \"  ,    DomNameStrategy . HYPHEN _ STRATEGY . splitIntoWords (  \" aaa \"  )  )  ;", "assertEquals (  \" AAA   bbb \"  ,    DomNameStrategy . HYPHEN _ STRATEGY . splitIntoWords (  \" AAA - bbb \"  )  )  ;", "assertEquals (  \" aaa   BBB \"  ,    DomNameStrategy . HYPHEN _ STRATEGY . splitIntoWords (  \" aaa - BBB \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testHyphenStrategySplit"], "fileName": "com.intellij.util.xml.NameStrategyTest"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" aaaBbbCcc \"  ,    DomNameStrategy . JAVA _ STRATEGY . convertName (  \" aaaBbbCcc \"  )  )  ;", "assertEquals (  \" aaaBbbCcc \"  ,    DomNameStrategy . JAVA _ STRATEGY . convertName (  \" AaaBbbCcc \"  )  )  ;", "assertEquals (  \" aaa \"  ,    DomNameStrategy . JAVA _ STRATEGY . convertName (  \" Aaa \"  )  )  ;", "assertEquals (  \" aaa \"  ,    DomNameStrategy . JAVA _ STRATEGY . convertName (  \" aaa \"  )  )  ;", "assertEquals (  \" AAABbb \"  ,    DomNameStrategy . JAVA _ STRATEGY . convertName (  \" AAABbb \"  )  )  ;", "assertEquals (  \" aaaBBB \"  ,    DomNameStrategy . JAVA _ STRATEGY . convertName (  \" AaaBBB \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testJavaStrategy"], "fileName": "com.intellij.util.xml.NameStrategyTest"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" aaa   bbb   ccc \"  ,    DomNameStrategy . JAVA _ STRATEGY . splitIntoWords (  \" aaaBbbCcc \"  )  )  ;", "assertEquals (  \" aaa \"  ,    DomNameStrategy . JAVA _ STRATEGY . splitIntoWords (  \" Aaa \"  )  )  ;", "assertEquals (  \" aaa \"  ,    DomNameStrategy . JAVA _ STRATEGY . splitIntoWords (  \" aaa \"  )  )  ;", "assertEquals (  \" AAA   bbb \"  ,    DomNameStrategy . JAVA _ STRATEGY . splitIntoWords (  \" AAABbb \"  )  )  ;", "assertEquals (  \" aaa   BBB \"  ,    DomNameStrategy . JAVA _ STRATEGY . splitIntoWords (  \" aaaBBB \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testJavaStrategySplit"], "fileName": "com.intellij.util.xml.NameStrategyTest"}, {"methodBody": ["METHOD_START", "{", "return   NamedEnumUtil . getEnumElementByValue ( enumClass ,    value ,    NamedEnumUtil . getShow ( enumClass )  )  ;", "}", "METHOD_END"], "methodName": ["getEnumElementByValue"], "fileName": "com.intellij.util.xml.NamedEnumUtil"}, {"methodBody": ["METHOD_START", "{", "for    ( final   T   t    :    enumClass . getEnumConstants (  )  )     {", "if    ( Comparing . equal ( value ,    show . fun ( t )  )  )     {", "return   t ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getEnumElementByValue"], "fileName": "com.intellij.util.xml.NamedEnumUtil"}, {"methodBody": ["METHOD_START", "{", "return   element    =  =    null    ?    null    :    NamedEnumUtil . getShow ( element . getClass (  )  )  . fun ( element )  ;", "}", "METHOD_END"], "methodName": ["getEnumValueByElement"], "fileName": "com.intellij.util.xml.NamedEnumUtil"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionUtil . isAssignable ( NamedEnum . class ,    enumClass )     ?    NamedEnumUtil . NAMED _ SHOW    :    NamedEnumUtil . SIMPLE _ SHOW ;", "}", "METHOD_END"], "methodName": ["getShow"], "fileName": "com.intellij.util.xml.NamedEnumUtil"}, {"methodBody": ["METHOD_START", "{", "final   ProxyTest . BaseImpl   proxy    =    AdvancedProxy . createProxy ( ProxyTest . BaseImpl . class ,    ProxyTest . BaseIEx . class )  ;", "assertEquals ( proxy . sayA (  )  ,     \" a \"  )  ;", "assertEquals (  (  ( ProxyTest . BaseI )     ( proxy )  )  . sayA (  )  ,     \" a \"  )  ;", "assertEquals (  (  ( ProxyTest . BaseIEx )     ( proxy )  )  . sayA (  )  ,     \" a \"  )  ;", "}", "METHOD_END"], "methodName": ["testAddInterfaces"], "fileName": "com.intellij.util.xml.ProxyTest"}, {"methodBody": ["METHOD_START", "{", "final   ProxyTest . CovariantFromBaseClassTest . Impl   proxy    =    AdvancedProxy . createProxy ( ProxyTest . CovariantFromBaseClassTest . Impl . class ,    EMPTY _ CLASS _ ARRAY ,    new   InvocationHandler (  )     {", "@ Override", "public   Object   invoke ( Object   proxy ,    Method   method ,    Object [  ]    args )     {", "return    \" a \"  ;", "}", "}  ,    false ,    new   Object [  0  ]  )  ;", "assertEquals ( proxy . sayA (  )  ,     \" a \"  )  ;", "assertEquals (  (  ( ProxyTest . CovariantFromBaseClassTest . Base )     ( proxy )  )  . sayA (  )  ,     \" a \"  )  ;", "assertEquals (  (  ( ProxyTest . CovariantFromBaseClassTest . Intf )     ( proxy )  )  . sayA (  )  ,     \" a \"  )  ;", "}", "METHOD_END"], "methodName": ["testCovariantFromBaseClass"], "fileName": "com.intellij.util.xml.ProxyTest"}, {"methodBody": ["METHOD_START", "{", "final   ProxyTest . AbstractBase . AbstractBaseImpl   proxy    =    AdvancedProxy . createProxy ( ProxyTest . AbstractBase . AbstractBaseImpl . class ,    EMPTY _ CLASS _ ARRAY ,    new   InvocationHandler (  )     {", "@ Override", "public   Object   invoke ( Object   proxy ,    Method   method ,    Object [  ]    args )     {", "return    \" a \"  ;", "}", "}  ,    false ,    new   Object [  0  ]  )  ;", "assertEquals ( proxy . sayA (  )  ,     \" a \"  )  ;", "assertEquals (  (  ( ProxyTest . AbstractBase )     ( proxy )  )  . sayA (  )  ,     \" a \"  )  ;", "assertEquals (  (  ( ProxyTest . BaseI )     ( proxy )  )  . sayA (  )  ,     \" a \"  )  ;", "}", "METHOD_END"], "methodName": ["testCovariantFromInterface"], "fileName": "com.intellij.util.xml.ProxyTest"}, {"methodBody": ["METHOD_START", "{", "final   List < String >    invocations    =    new   ArrayList <  >  (  )  ;", ". Implementation   implementation    =    AdvancedProxy . createProxy (  . Implementation . class ,    new   Class [  ]  {     . Interface 3  . class    }  ,    new   InvocationHandler (  )     {", "@ Override", "public   Object   invoke ( Object   proxy ,    Method   method ,    Object [  ]    args )    throws   Throwable    {", "invocations . add ( method . getName (  )  )  ;", "if    ( Object . class . equals ( method . getDeclaringClass (  )  )  )     {", "return   method . invoke ( this ,    args )  ;", "}", "return    . Implementation . class . getMethod (  \" getField \"  )  . invoke ( proxy )  ;", "}", "}  ,     \"  2  3  9  \"  )  ;", "implementation . hashCode (  )  ;", "implementation . method (  )  ;", "assertEquals (  \"  2  3  9  \"  ,    implementation . getFoo (  )  )  ;", "implementation . setField (  \"  4  2  \"  )  ;", "assertEquals (  \"  4  2  \"  ,    implementation . getBar (  )  )  ;", "assertEquals (  \"  4  2  \"  ,    implementation . toString (  )  )  ;", "assertEquals ( Arrays . asList (  \" hashCode \"  ,     \" getFoo \"  ,     \" getFoo \"  ,     \" getBar \"  )  ,    invocations )  ;", "assertEquals (  \"  4  2  \"  ,     . Interface 1  . class . getMethod (  \" getFoo \"  )  . invoke ( implementation )  )  ;", "assertEquals (  \"  4  2  \"  ,     . Interface 3  . class . getMethod (  \" bar \"  )  . invoke ( implementation )  )  ;", "assertEquals (  \"  4  2  \"  ,     . Interface 1  . class . getMethod (  \" foo \"  )  . invoke ( implementation )  )  ;", "assertEquals (  \"  4  2  \"  ,     . Interface 2  . class . getMethod (  \" foo \"  )  . invoke ( implementation )  )  ;", "assertEquals (  \"  4  2  \"  ,     . Interface 2  . class . getMethod (  \" foo \"  )  . invoke ( implementation )  )  ;", "assertEquals (  \"  4  2  \"  ,     . Implementation . class . getMethod (  \" foo \"  )  . invoke ( implementation )  )  ;", "}", "METHOD_END"], "methodName": ["testExtendClass"], "fileName": "com.intellij.util.xml.ProxyTest"}, {"methodBody": ["METHOD_START", "{", "ProxyTest . ConcreteInterface   proxy    =    AdvancedProxy . createProxy ( new   InvocationHandler (  )     {", "@ Override", "public   Object   invoke ( Object   proxy ,    Method   method ,    Object [  ]    args )     {", "return    4  2  ;", "}", "}  ,    null ,    ProxyTest . ConcreteInterface . class )  ;", "Method   foo    =    DomUIFactory . findMethod ( ProxyTest . GenericInterface . class ,     \" foo \"  )  ;", "assert   foo    !  =    null ;", "assertEquals (  4  2  ,    proxy . foo (  \" a \"  )  )  ;", "assertEquals (  4  2  ,    foo . invoke ( proxy ,     \" a \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMethodInvocationJava8"], "fileName": "com.intellij.util.xml.ProxyTest"}, {"methodBody": ["METHOD_START", "{", "if    ( newTarget   instanceof   XmlTag )     {", "DomElement   domElement    =    genericValue . getManager (  )  . getDomElement (  (  ( XmlTag )     ( newTarget )  )  )  ;", "if    ( domElement    !  =    null )     {", "genericValue . setStrValue ( ElementPresentationManager . getElementName ( domElement )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["bindReference"], "fileName": "com.intellij.util.xml.ResolvingConverter"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["createLookupElement"], "fileName": "com.intellij.util.xml.ResolvingConverter"}, {"methodBody": ["METHOD_START", "{", "return   Collections . emptySet (  )  ;", "}", "METHOD_END"], "methodName": ["getAdditionalVariants"], "fileName": "com.intellij.util.xml.ResolvingConverter"}, {"methodBody": ["METHOD_START", "{", "return   getAdditionalVariants (  )  ;", "}", "METHOD_END"], "methodName": ["getAdditionalVariants"], "fileName": "com.intellij.util.xml.ResolvingConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( resolvedValue   instanceof   PsiElement )     {", "return    (  ( PsiElement )     ( resolvedValue )  )  ;", "}", "if    ( resolvedValue   instanceof   DomElement )     {", "return    (  ( DomElement )     ( resolvedValue )  )  . getXmlElement (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getPsiElement"], "fileName": "com.intellij.util.xml.ResolvingConverter"}, {"methodBody": ["METHOD_START", "{", "return   LocalQuickFix . EMPTY _ ARRAY ;", "}", "METHOD_END"], "methodName": ["getQuickFixes"], "fileName": "com.intellij.util.xml.ResolvingConverter"}, {"methodBody": ["METHOD_START", "{", "genericValue . setStringValue ( newElementName )  ;", "}", "METHOD_END"], "methodName": ["handleElementRename"], "fileName": "com.intellij.util.xml.ResolvingConverter"}, {"methodBody": ["METHOD_START", "{", "return    ( resolveResult    !  =    null )     &  &     ( element . getManager (  )  . areElementsEquivalent ( element ,    getPsiElement ( resolveResult )  )  )  ;", "}", "METHOD_END"], "methodName": ["isReferenceTo"], "fileName": "com.intellij.util.xml.ResolvingConverter"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   psiElement    =    getPsiElement ( o )  ;", "return    ( psiElement    =  =    null )     &  &     ( o    !  =    null )     ?    DomUgetValueElement (  (  ( GenericDomValue )     ( context . getInvocationElement (  )  )  )  )     :    psiElement ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "com.intellij.util.xml.ResolvingConverter"}, {"methodBody": ["METHOD_START", "{", "return   createElement ( xml ,    SimpleValuesIncrementalUpdateTest . MyElement . class )  ;", "}", "METHOD_END"], "methodName": ["createElement"], "fileName": "com.intellij.util.xml.SimpleValuesIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "final   SimpleValuesIncrementalUpdateTest . MyElement   element    =    createElement (  \"  < a   xmlns =  \\  \" foo \\  \"  >  < ns - child   attr =  \\  \"  2  3  9  \\  \"  /  >  <  / a >  \"  ,    SimpleValuesIncrementalUpdateTest . MyElement . class )  ;", "getDomManager (  )  . getDomFileDescription ( element . getXmlElement (  )  )  . registerNamespacePolicy (  \" foo \"  ,     \" foo \"  )  ;", "final   GenericAttributeValue < String >    attr    =    element . getNsChild (  )  . getAttr (  )  ;", "attr . getXmlTag (  )  . setAttribute (  \" attr \"  ,     \"  4  2  \"  )  ;", "putExpected ( new   DomEvent ( element . getNsChild (  )  ,    false )  )  ;", "assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["testAttrXmlEmptyUri"], "fileName": "com.intellij.util.xml.SimpleValuesIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "final   SimpleValuesIncrementalUpdateTest . MyElement   element    =    createElement (  \"  < a /  >  \"  )  ;", "element . getXmlTag (  )  . setAttribute (  \" attr \"  ,     \" foo \"  )  ;", "putExpected ( new   DomEvent ( element ,    false )  )  ;", "assertResultsAndClear (  )  ;", "assertTrue ( element . getAttr (  )  . isValid (  )  )  ;", "element . getXmlTag (  )  . setAttribute (  \" bttr \"  ,     \" foo \"  )  ;", "element . getXmlTag (  )  . setAttribute (  \" attr \"  ,     \" bar \"  )  ;", "putExpected ( new   DomEvent ( element ,    false )  )  ;", "putExpected ( new   DomEvent ( element ,    false )  )  ;", "assertResultsAndClear (  )  ;", "assertTrue ( element . getAttr (  )  . isValid (  )  )  ;", "element . getXmlTag (  )  . setAttribute (  \" attr \"  ,    null )  ;", "putExpected ( new   DomEvent ( element ,    false )  )  ;", "assertResultsAndClear (  )  ;", "assertTrue ( element . getAttr (  )  . isValid (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeChange"], "fileName": "com.intellij.util.xml.SimpleValuesIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "final   SimpleValuesIncrementalUpdateTest . MyElement   element    =    createElement (  \"  < a   attr =  \\  \" foo \\  \"  /  >  \"  )  ;", "final   GenericAttributeValue < String >    attr    =    element . getAttr (  )  ;", "attr . getXmlAttributeValue (  )  . getFirstChild (  )  . replace ( createTag (  \"  < a   attr =  \\  \" bar \\  \"  /  >  \"  )  . getAttribute (  \" attr \"  ,    null )  . getValueElement (  )  . getFirstChild (  )  )  ;", "putExpected ( new   DomEvent ( element ,    false )  )  ;", "assertResultsAndClear (  )  ;", "assertTrue ( attr . isValid (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeValueChangeAsXmlElementChange"], "fileName": "com.intellij.util.xml.SimpleValuesIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "final   SimpleValuesIncrementalUpdateTest . MyElement   element    =    createElement (  \"  < a >  < child >     <  / child >  <  / a >  \"  )  . getChild (  )  ;", "element . getXmlTag (  )  . getValue (  )  . setText (  \" abc \"  )  ;", "putExpected ( new   DomEvent ( element ,    false )  )  ;", "assertResultsAndClear (  )  ;", "element . getXmlTag (  )  . getValue (  )  . setText ( null )  ;", "putExpected ( new   DomEvent ( element ,    false )  )  ;", "assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["testTagValueChange"], "fileName": "com.intellij.util.xml.SimpleValuesIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "myClassChoosers . putAll ( manager . myClassChoosers )  ;", "}", "METHOD_END"], "methodName": ["copyFrom"], "fileName": "com.intellij.util.xml.TypeChooserManager"}, {"methodBody": ["METHOD_START", "{", "final   TypeChooser   typeChooser    =    myClassChoosers . get ( type )  ;", "return   typeChooser    !  =    null    ?    typeChooser    :    new   TypeChooser (  )     {", "@ Override", "public   Type   chooseType ( final   XmlTag   tag )     {", "return   type ;", "}", "@ Override", "public   void   distinguishTag ( final   XmlTag   tag ,    final   Type   aClass )     {", "}", "@ Override", "public   Type [  ]    getChooserTypes (  )     {", "return   new   Type [  ]  {    type    }  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getTypeChooser"], "fileName": "com.intellij.util.xml.TypeChooserManager"}, {"methodBody": ["METHOD_START", "{", "myClassChoosers . put ( aClass ,    typeChooser )  ;", "}", "METHOD_END"], "methodName": ["registerTypeChooser"], "fileName": "com.intellij.util.xml.TypeChooserManager"}, {"methodBody": ["METHOD_START", "{", "myClassChoosers . remove ( aClass )  ;", "}", "METHOD_END"], "methodName": ["unregisterTypeChooser"], "fileName": "com.intellij.util.xml.TypeChooserManager"}, {"methodBody": ["METHOD_START", "{", "final   Converter   converter    =    getConverter ( domElement )  ;", "return   converter    =  =    null    ?    Collections . emptyList (  )     :    Collections . singletonList ( converter )  ;", "}", "METHOD_END"], "methodName": ["getConverters"], "fileName": "com.intellij.util.xml.WrappingConverter"}, {"methodBody": ["METHOD_START", "{", "Converter   cur    =    converter ;", "Converter   next ;", "int   guard    =     0  ;", "while    ( cur   instanceof    )     {", "next    =     (  (  )     ( cur )  )  . getConverter ( domValue )  ;", "if    ( next    =  =    null )", "break ;", "cur    =    next ;", "if    (  ( guard +  +  )     >     1  0  )     {", "throw   new   RuntimeException (  (  \" Too   deep   wrapping   for    \"     +    converter )  )  ;", "}", "}", "return   cur ;", "}", "METHOD_END"], "methodName": ["getDeepestConverter"], "fileName": "com.intellij.util.xml.WrappingConverter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    o )", "return   true ;", "if    (  ( o    =  =    null )     |  |     (  ( getClass (  )  )     !  =     ( o . getClass (  )  )  )  )", "return   false ;", "final      xmlName    =     (  (  )     ( o )  )  ;", "if    (  !  ( myLocalName . equals ( xmlName . myLocalName )  )  )", "return   false ;", "return   Comparing . equal ( myNamespaceKey ,    xmlName . myNamespaceKey )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.intellij.util.xml.XmlName"}, {"methodBody": ["METHOD_START", "{", "return   myLocalName ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "com.intellij.util.xml.XmlName"}, {"methodBody": ["METHOD_START", "{", "return   myNamespaceKey ;", "}", "METHOD_END"], "methodName": ["getNamespaceKey"], "fileName": "com.intellij.util.xml.XmlName"}, {"methodBody": ["METHOD_START", "{", "return   myHashCode ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.intellij.util.xml.XmlName"}, {"methodBody": ["METHOD_START", "{", "return    (  ( myNamespaceKey )     +     \"     :     \"  )     +     ( myLocalName )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.util.xml.XmlName"}, {"methodBody": ["METHOD_START", "{", "if    ( domElement    !  =    null )     {", "XmlTag   tag    =    domElement . getXmlTag (  )  ;", "if    ( tag    !  =    null )     {", "String   namespacePrefix    =    tag . getNamespacePrefix (  )  ;", "if    (  !  ( StringUtil . isEmptyOrSpaces ( namespacePrefix )  )  )     {", "vars . put (  . NAMESPACE _ PREFIX _ VAR ,     ( namespacePrefix    +     \"  :  \"  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["addNamespacePrefix"], "fileName": "com.intellij.util.xml.actions.generate.AbstractDomGenerateProvider"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    vars    =    new   HashMap <  >  (  )  ;", ". addNamespacePrefix ( domElement ,    vars )  ;", "return   vars ;", "}", "METHOD_END"], "methodName": ["createNamespacePrefixMap"], "fileName": "com.intellij.util.xml.actions.generate.AbstractDomGenerateProvider"}, {"methodBody": ["METHOD_START", "{", "return   StringUtil . join ( Arrays . asList ( NameUtil . nameToWords ( aClass . getSimpleName (  )  )  )  ,     \"     \"  )  ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "com.intellij.util.xml.actions.generate.AbstractDomGenerateProvider"}, {"methodBody": ["METHOD_START", "{", "return   t ;", "}", "METHOD_END"], "methodName": ["getElementToNavigate"], "fileName": "com.intellij.util.xml.actions.generate.AbstractDomGenerateProvider"}, {"methodBody": ["METHOD_START", "{", "return   myMappingId ;", "}", "METHOD_END"], "methodName": ["getMappingId"], "fileName": "com.intellij.util.xml.actions.generate.AbstractDomGenerateProvider"}, {"methodBody": ["METHOD_START", "{", "return   AbstractDomGenerateProvider . createNamespacePrefixMap ( parentDomElement )  ;", "}", "METHOD_END"], "methodName": ["getPredefinedVars"], "fileName": "com.intellij.util.xml.actions.generate.AbstractDomGenerateProvider"}, {"methodBody": ["METHOD_START", "{", "DomTemplateRunner . getInstance ( file . getProject (  )  )  . runTemplate ( t ,    myMappingId ,    editor ,    predefinedVars )  ;", "}", "METHOD_END"], "methodName": ["runTemplate"], "fileName": "com.intellij.util.xml.actions.generate.AbstractDomGenerateProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( parent    =  =    null )     {", "return   null ;", "}", "final   List <  ?    extends   DomCollectionChildDescription >    list    =    parent . getGenericInfo (  )  . getCollectionChildrenDescriptions (  )  ;", "for    ( DomCollectionChildDescription   childDescription    :    list )     {", "if    ( ReflectionUtil . getRawType ( childDescription . getType (  )  )  . isAssignableFrom ( myChildElementClass )  )     {", "XmlTag   parentTag    =    parent . getXmlTag (  )  ;", "if    (  ( editor    !  =    null )     &  &     ( parentTag    !  =    null )  )     {", "int   offset    =    editor . getCaretModel (  )  . getOffset (  )  ;", "PsiFile   file    =    parentTag . getContainingFile (  )  ;", "PsiElement   psiElement    =    file . findElementAt ( offset )  ;", "if    (  ( psiElement   instanceof   PsiWhiteSpace )     &  &     ( PsiTreeUtil . isAncestor ( parentTag ,    psiElement ,    false )  )  )     {", "Document   document    =    editor . getDocument (  )  ;", "XmlTag   childTag    =    parentTag . createChildTag ( childDescription . getXmlElementName (  )  ,    null ,    null ,    true )  ;", "String   text    =    childTag . getText (  )  ;", "document . insertString ( offset ,    text )  ;", "Project   project    =    editor . getProject (  )  ;", "assert   project    !  =    null ;", "PsiDocumentManager   documentManager    =    PsiDocumentManager . getInstance ( project )  ;", "documentManager . commitDocument ( document )  ;", "PsiElement   element    =    file . findElementAt (  ( offset    +     1  )  )  ;", "T   domElement    =    DomUtil . findDomElement ( element ,    myChildElementClass )  ;", "if    ( domElement    !  =    null )", "return   domElement ;", "document . deleteString ( offset ,     ( offset    +     ( text . length (  )  )  )  )  ;", "documentManager . commitDocument ( document )  ;", "}", "}", "int   index    =     . getCollectionIndex ( parent ,    childDescription ,    editor )  ;", "return   index    <     0     ?     (  ( T )     ( childDescription . addValue ( parent ,    myChildElementClass )  )  )     :     (  ( T )     ( childDescription . addValue ( parent ,    myChildElementClass ,    index )  )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "com.intellij.util.xml.actions.generate.DefaultGenerateElementProvider"}, {"methodBody": ["METHOD_START", "{", "int   offset    =    editor . getCaretModel (  )  . getOffset (  )  ;", "for    ( int   i    =     0  ;    i    <     ( childDescription . getValues ( parent )  . size (  )  )  ;    i +  +  )     {", "Dom   element    =    childDescription . getValues ( parent )  . get ( i )  ;", "Xml   xml    =    element . getXml (  )  ;", "if    (  ( xml    !  =    null )     &  &     (  ( xml . getTextRange (  )  . getStartOffset (  )  )     >  =    offset )  )     {", "return   i ;", "}", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["getCollectionIndex"], "fileName": "com.intellij.util.xml.actions.generate.DefaultGenerateElementProvider"}, {"methodBody": ["METHOD_START", "{", "return   ServiceManager . getService ( project ,    DomTemplateRunner . class )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "com.intellij.util.xml.actions.generate.DomTemplateRunner"}, {"methodBody": ["METHOD_START", "{", "return   new   MyPsiReference ( element ,    getTextRange ( genericDomValue ,    start ,    end )  ,    context ,    genericDomValue ,    delimitersOnly )  ;", "}", "METHOD_END"], "methodName": ["createPsiReference"], "fileName": "com.intellij.util.xml.converters.DelimitedListConverter"}, {"methodBody": ["METHOD_START", "{", "final   List < T >    list    =    genericDomValue . getValue (  )  ;", "if    ( list    !  =    null )     {", "for    ( Iterator < T >    i    =    variants . iterator (  )  ;    i . hasNext (  )  ;  )     {", "final   T   variant    =    i . next (  )  ;", "for    ( T   existing    :    list )     {", "if    ( existing . equals ( variant )  )     {", "i . remove (  )  ;", "break ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["filterVariants"], "fileName": "com.intellij.util.xml.converters.DelimitedListConverter"}, {"methodBody": ["METHOD_START", "{", "return   myDelimiters . charAt (  0  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultDelimiter"], "fileName": "com.intellij.util.xml.converters.DelimitedListConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( value   instanceof   GenericAttributeValue )     {", "return   new   TextRange ( start ,    end )  ;", "}", "TextRange   tagRange    =    XmlTagUgetTrimmedValueRange ( value . getXmlTag (  )  )  ;", "return   new   TextRange (  (  (  ( tagRange . getStartOffset (  )  )     +    start )     -     1  )  ,     (  (  ( tagRange . getStartOffset (  )  )     +    end )     -     1  )  )  ;", "}", "METHOD_END"], "methodName": ["getTextRange"], "fileName": "com.intellij.util.xml.converters.DelimitedListConverter"}, {"methodBody": ["METHOD_START", "{", "return   superBindToElementFunction . fun ( element )  ;", "}", "METHOD_END"], "methodName": ["referenceBindToElement"], "fileName": "com.intellij.util.xml.converters.DelimitedListConverter"}, {"methodBody": ["METHOD_START", "{", "return   superHandleElementRename . fun ( newName )  ;", "}", "METHOD_END"], "methodName": ["referenceHandleElementRename"], "fileName": "com.intellij.util.xml.converters.DelimitedListConverter"}, {"methodBody": ["METHOD_START", "{", "return   PathReferenceManager . getInstance (  )  . createReferences ( psiElement ,    soft )  ;", "}", "METHOD_END"], "methodName": ["createReferences"], "fileName": "com.intellij.util.xml.converters.PathReferenceConverter"}, {"methodBody": ["METHOD_START", "{", "return   new   MyPsiReference ( element ,    new   TextRange ( start ,    end )  ,    isSoft ,    context ,    genericDomValue ,    badQuotation )  ;", "}", "METHOD_END"], "methodName": ["createPsiReference"], "fileName": "com.intellij.util.xml.converters.QuotedValueConverter"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getQuoteSign"], "fileName": "com.intellij.util.xml.converters.QuotedValueConverter"}, {"methodBody": ["METHOD_START", "{", "return   QuotedValueConverter . QUOTE _ SIGNS ;", "}", "METHOD_END"], "methodName": ["getQuoteSigns"], "fileName": "com.intellij.util.xml.converters.QuotedValueConverter"}, {"methodBody": ["METHOD_START", "{", "return    ( StringUtil . isNotEmpty ( str )  )     &  &     (  ( str . charAt (  0  )  )     !  =     ( str . charAt (  (  ( str . length (  )  )     -     1  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["quotationIsNotClosed"], "fileName": "com.intellij.util.xml.converters.QuotedValueConverter"}, {"methodBody": ["METHOD_START", "{", "return   QuotedValueConverter . unquote ( str ,    QuotedValueConverter . QUOTE _ SIGNS )  ;", "}", "METHOD_END"], "methodName": ["unquote"], "fileName": "com.intellij.util.xml.converters.QuotedValueConverter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( str    !  =    null )     &  &     (  ( str . length (  )  )     >     2  )  )     {", "final   char   c    =    str . charAt (  0  )  ;", "for    ( char   q    :    qSigns )     {", "if    ( q    =  =    c )     {", "return   str . substring (  1  ,     ( c    =  =     ( str . charAt (  (  ( str . length (  )  )     -     1  )  )  )     ?     ( str . length (  )  )     -     1     :    str . length (  )  )  )  ;", "}", "}", "}", "return   str ;", "}", "METHOD_END"], "methodName": ["unquote"], "fileName": "com.intellij.util.xml.converters.QuotedValueConverter"}, {"methodBody": ["METHOD_START", "{", "final   String [  ]    strings    =    ArrayUtil . mergeArrays ( getTrueValues (  )  ,    getFalseValues (  )  )  ;", "Arrays . sort ( strings )  ;", "return   strings ;", "}", "METHOD_END"], "methodName": ["getAllValues"], "fileName": "com.intellij.util.xml.converters.values.BooleanValueConverter"}, {"methodBody": ["METHOD_START", "{", "return   new   String [  ]  {     \" false \"     }  ;", "}", "METHOD_END"], "methodName": ["getFalseValues"], "fileName": "com.intellij.util.xml.converters.values.BooleanValueConverter"}, {"methodBody": ["METHOD_START", "{", "return   new   BooleanValueConverter ( allowEmpty )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "com.intellij.util.xml.converters.values.BooleanValueConverter"}, {"methodBody": ["METHOD_START", "{", "return   new   String [  ]  {     \" true \"     }  ;", "}", "METHOD_END"], "methodName": ["getTrueValues"], "fileName": "com.intellij.util.xml.converters.values.BooleanValueConverter"}, {"methodBody": ["METHOD_START", "{", "return    ( Arrays . binarySearch ( getTrueValues (  )  ,    s )  )     >  =     0  ;", "}", "METHOD_END"], "methodName": ["isTrue"], "fileName": "com.intellij.util.xml.converters.values.BooleanValueConverter"}, {"methodBody": ["METHOD_START", "{", "return    ( sequence . startsWith ( CharacterValueConverter . UNICODE _ PREFIX )  )     &  &     (  ( sequence . length (  )  )     =  =     ( CharacterValueConverter . UNICODE _ LENGTH )  )  ;", "}", "METHOD_END"], "methodName": ["isUnicodeCharacterSequence"], "fileName": "com.intellij.util.xml.converters.values.CharacterValueConverter"}, {"methodBody": ["METHOD_START", "{", "int   radix    =     1  0  ;", "int   index    =     0  ;", "boolean   negative    =    false ;", "if    (  . startsWith (  \"  -  \"  )  )     {", "negative    =    true ;", "index +  +  ;", "}", "if    (  (  . startsWith (  \"  0 x \"  ,    index )  )     |  |     (  . startsWith (  \"  0 X \"  ,    index )  )  )     {", "index    +  =     2  ;", "radix    =     1  6  ;", "} else", "if    (  . startsWith (  \"  #  \"  ,    index )  )     {", "index +  +  ;", "radix    =     1  6  ;", "} else", "if    (  (  . startsWith (  \"  0  \"  ,    index )  )     &  &     (  (  . length (  )  )     >     (  1     +    index )  )  )     {", "index +  +  ;", "radix    =     8  ;", "}", "BigInteger   result    =    new   BigInteger (  . substring ( index )  ,    radix )  ;", "return   negative    ?    result . negate (  )     :    result ;", "}", "METHOD_END"], "methodName": ["decodeBigInteger"], "fileName": "com.intellij.util.xml.converters.values.NumberValueConverter"}, {"methodBody": ["METHOD_START", "{", "try    {", "String   trimmed    =    text . trim (  )  ;", "if    (  ( targetClass . equals ( Byte . class )  )     |  |     ( targetClass . equals ( byte . class )  )  )     {", "return   Byte . decode ( trimmed )  ;", "}", "if    (  ( targetClass . equals ( Short . class )  )     |  |     ( targetClass . equals ( short . class )  )  )     {", "return   Short . decode ( trimmed )  ;", "}", "if    (  ( targetClass . equals ( Integer . class )  )     |  |     ( targetClass . equals ( int . class )  )  )     {", "return   Integer . decode ( trimmed )  ;", "}", "if    (  ( targetClass . equals ( Long . class )  )     |  |     ( targetClass . equals ( long . class )  )  )     {", "return   Long . decode ( trimmed )  ;", "}", "if    ( targetClass . equals ( BigInteger . class )  )     {", "return    . decodeBigInteger ( trimmed )  ;", "}", "if    (  ( targetClass . equals ( Float . class )  )     |  |     ( targetClass . equals ( float . class )  )  )     {", "return   Float . valueOf ( trimmed )  ;", "}", "if    (  ( targetClass . equals ( Double . class )  )     |  |     ( targetClass . equals ( double . class )  )  )     {", "return   Double . valueOf ( trimmed )  ;", "}", "if    (  ( targetClass . equals ( BigDecimal . class )  )     |  |     ( targetClass . equals ( Number . class )  )  )     {", "return   new   BigDecimal ( trimmed )  ;", "}", "}    catch    ( NumberFormatException   ex )     {", "return   null ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["parseNumber"], "fileName": "com.intellij.util.xml.converters.values.NumberValueConverter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( targetClass . equals ( Byte . class )  )     |  |     ( targetClass . equals ( byte . class )  )  )     {", "return   Byte . toString (  (  ( Byte )     ( value )  )  )  ;", "}", "if    (  ( targetClass . equals ( Short . class )  )     |  |     ( targetClass . equals ( short . class )  )  )     {", "return   Short . toString (  (  ( Short )     ( value )  )  )  ;", "}", "if    (  ( targetClass . equals ( Integer . class )  )     |  |     ( targetClass . equals ( int . class )  )  )     {", "return   Integer . toString (  (  ( Integer )     ( value )  )  )  ;", "}", "if    (  ( targetClass . equals ( Long . class )  )     |  |     ( targetClass . equals ( long . class )  )  )     {", "return   Long . toString (  (  ( Long )     ( value )  )  )  ;", "}", "if    ( targetClass . equals ( BigInteger . class )  )     {", "return   value . toString (  )  ;", "}", "if    (  ( targetClass . equals ( Float . class )  )     |  |     ( targetClass . equals ( float . class )  )  )     {", "return   Float . toString (  (  ( Float )     ( value )  )  )  ;", "}", "if    (  ( targetClass . equals ( Double . class )  )     |  |     ( targetClass . equals ( double . class )  )  )     {", "return   Double . toString (  (  ( Double )     ( value )  )  )  ;", "}", "if    (  ( targetClass . equals ( BigDecimal . class )  )     |  |     ( targetClass . equals (  . class )  )  )     {", "return    (  ( BigDecimal )     ( value )  )  . toPlainString (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["parseText"], "fileName": "com.intellij.util.xml.converters.values.NumberValueConverter"}, {"methodBody": ["METHOD_START", "{", "return   myElement ;", "}", "METHOD_END"], "methodName": ["getElement"], "fileName": "com.intellij.util.xml.events.DomEvent"}, {"methodBody": ["METHOD_START", "{", "return   myDefined ;", "}", "METHOD_END"], "methodName": ["isDefined"], "fileName": "com.intellij.util.xml.events.DomEvent"}, {"methodBody": ["METHOD_START", "{", "return    ( myDefined    ?     \" Defined    \"     :     \" Changed    \"  )     +     ( myElement )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.util.xml.events.DomEvent"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    myElement . getXmlElementName (  )  ;", "return   DomBundle . message (  ( isTag (  )     ?     \" add . element . fix . name \"     :     \" add . attribute . fix . name \"  )  ,    name )  ;", "}", "METHOD_END"], "methodName": ["computeName"], "fileName": "com.intellij.util.xml.highlighting.AddDomElementQuickFix"}, {"methodBody": ["METHOD_START", "{", "return    ( myElement . getXmlElement (  )  )    instanceof   XmlTag ;", "}", "METHOD_END"], "methodName": ["isTag"], "fileName": "com.intellij.util.xml.highlighting.AddDomElementQuickFix"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["shouldCheckResolveProblems"], "fileName": "com.intellij.util.xml.highlighting.BasicDomElementsInspection"}, {"methodBody": ["METHOD_START", "{", "XmlTag   tag    =     (  ( XmlTag )     ( descriptor . getPsiElement (  )  )  )  ;", "XmlAttribute   attribute    =    tag . setAttribute ( myAttrName ,    myNamespace ,     \"  \"  )  ;", "new   openapi . fileEditor . OpenFileDescriptor ( project ,    tag . getContainingFile (  )  . getVirtualFile (  )  ,     (  ( attribute . getValueElement (  )  . getTextRange (  )  . getStartOffset (  )  )     +     1  )  )  . navigate ( true )  ;", "}", "METHOD_END"], "methodName": ["applyFix"], "fileName": "com.intellij.util.xml.highlighting.DefineAttributeQuickFix"}, {"methodBody": ["METHOD_START", "{", "return    \" Define   attribute \"  ;", "}", "METHOD_END"], "methodName": ["getFamilyName"], "fileName": "com.intellij.util.xml.highlighting.DefineAttributeQuickFix"}, {"methodBody": ["METHOD_START", "{", "return    (  \" Define    \"     +     ( myAttrName )  )     +     \"    attribute \"  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.intellij.util.xml.highlighting.DefineAttributeQuickFix"}, {"methodBody": ["METHOD_START", "{", "return    (  ( super . toString (  )  )     +     \"  ;     \"  )     +     ( myChildDescription )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.util.xml.highlighting.DomCollectionProblemDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "add ( problemDescriptor )  ;", "return   problemDescriptor ;", "}", "METHOD_END"], "methodName": ["addProblem"], "fileName": "com.intellij.util.xml.highlighting.DomElementAnnotationHolderImpl"}, {"methodBody": ["METHOD_START", "{", "return   myAnnotations ;", "}", "METHOD_END"], "methodName": ["getAnnotations"], "fileName": "com.intellij.util.xml.highlighting.DomElementAnnotationHolderImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( myOnTheFly )  )", "return   LocalQuickFix . EMPTY _ ARRAY ;", "final   List < LocalQuickFix >    result    =    new   SmartList (  )  ;", "final   Converter   converter    =    WrappingConverter . getDeepestConverter ( element . getConverter (  )  ,    element )  ;", "if    ( converter   instanceof   ResolvingConverter )     {", "final   ResolvingConverter   resolvingConverter    =     (  ( ResolvingConverter )     ( converter )  )  ;", "ContainerUtil . addAll ( result ,    resolvingConverter . getQuickFixes ( ConvertContextFactory . createConvertContext ( DomManagerImpl . getDomInvocationHandler ( element )  )  )  )  ;", "}", "if    ( reference   instanceof   LocalQuickFixProvider )     {", "final   LocalQuickFix [  ]    localQuickFixes    =     (  ( LocalQuickFixProvider )     ( reference )  )  . getQuickFixes (  )  ;", "if    ( localQuickFixes    !  =    null )     {", "ContainerUtil . addAll ( result ,    localQuickFixes )  ;", "}", "}", "return   result . isEmpty (  )     ?    LocalQuickFix . EMPTY _ ARRAY    :    result . toArray ( EMPTY _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["getQuickFixes"], "fileName": "com.intellij.util.xml.highlighting.DomElementAnnotationHolderImpl"}, {"methodBody": ["METHOD_START", "{", "return   ServiceManager . getService ( project ,    DomElementAnnotationsManager . class )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "com.intellij.util.xml.highlighting.DomElementAnnotationsManager"}, {"methodBody": ["METHOD_START", "{", "DomElementsProblemsHolderImpl   holder ;", "final   DomElement   rootElement    =    element . getRootElement (  )  ;", "final   XmlTag   rootTag    =    rootElement . getXmlTag (  )  ;", "if    ( rootTag    =  =    null )", "return   new   DomElementsProblemsHolderImpl ( element )  ;", "holder    =    rootTag . getUserData (  . DOM _ PROBLEM _ HOLDER _ KEY )  ;", "if    (  (  . isHolderOutdated ( element . getFile (  )  )  )     |  |     ( holder    =  =    null )  )     {", "holder    =    new   DomElementsProblemsHolderImpl ( element )  ;", "rootTag . putUserData (  . DOM _ PROBLEM _ HOLDER _ KEY ,    holder )  ;", "final   CachedValue < Boolean >    cachedValue    =    CachedValuesManager . getManager ( myProject )  . createCachedValue (  (  )     -  >    new   CachedValueProvider . Result <  >  ( Boolean . FALSE ,    element ,    PsiModificationTracker . OUT _ OF _ CODE _ BLOCK _ MODIFICATION _ COUNT ,    this ,    ProjectRootManager . getInstance ( myProject )  )  ,    false )  ;", "cachedValue . getValue (  )  ;", "element . getFile (  )  . putUserData (  . CACHED _ VALUE _ KEY ,    cachedValue )  ;", "}", "return   holder ;", "}", "METHOD_END"], "methodName": ["_getOrCreateProblemsHolder"], "fileName": "com.intellij.util.xml.highlighting.DomElementAnnotationsManagerImpl"}, {"methodBody": ["METHOD_START", "{", "final   DomElementAnnotationHolderImpl   holderImpl    =     (  ( DomElementAnnotationHolderImpl )     ( annotationHolder )  )  ;", "synchronized (  . LOCK )     {", "final   DomElementsProblemsHolderImpl   holder    =     _ getOrCreateProblemsHolder ( element )  ;", "holder . appendProblems ( holderImpl ,    inspectionClass )  ;", "}", "myDispatcher . getMulticaster (  )  . highlightingFinished ( element )  ;", "return   Collections . unmodifiableList ( holderImpl )  ;", "}", "METHOD_END"], "methodName": ["appendProblems"], "fileName": "com.intellij.util.xml.highlighting.DomElementAnnotationsManagerImpl"}, {"methodBody": ["METHOD_START", "{", "for    ( final   DomElementsInspection   inspection    :    suitableInspections )     {", "if    (  !  ( holder . isInspectionCompleted ( inspection )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["areInspectionsFinished"], "fileName": "com.intellij.util.xml.highlighting.DomElementAnnotationsManagerImpl"}, {"methodBody": ["METHOD_START", "{", "synchronized ( DomElementAnnotationsManagerImpl . LOCK )     {", "final   DomFileElement < DomElement >    root    =    DomUtil . getFileElement ( element )  ;", "if    (  !  ( DomElementAnnotationsManagerImpl . isHolderOutdated ( root . getFile (  )  )  )  )     {", "final   DomElementsProblemsHolder   holder    =    getProblemHolder ( element )  ;", "if    ( holder   instanceof   DomElementsProblemsHolderImpl )     {", "DomElementsProblemsHolderImpl   holderImpl    =     (  ( DomElementsProblemsHolderImpl )     ( holder )  )  ;", "final   List < DomElementsInspection >    suitableInspections    =    getSuitableDomInspections ( root ,    true )  ;", "final   DomElementsInspection   mockInspection    =    getMockInspection ( root )  ;", "final   boolean   annotatorsFinished    =     ( mockInspection    =  =    null )     |  |     ( holderImpl . isInspectionCompleted ( mockInspection )  )  ;", "final   boolean   inspectionsFinished    =    DomElementAnnotationsManagerImpl . areInspectionsFinished ( holderImpl ,    suitableInspections )  ;", "if    ( annotatorsFinished )     {", "if    (  ( suitableInspections . isEmpty (  )  )     |  |    inspectionsFinished )", "return   DomHighlightStatus . INSPECTIONS _ FINISHED ;", "return   DomHighlightStatus . ANNOTATORS _ FINISHED ;", "}", "}", "}", "return   DomHighlightStatus . NONE ;", "}", "}", "METHOD_END"], "methodName": ["getHighlightStatus"], "fileName": "com.intellij.util.xml.highlighting.DomElementAnnotationsManagerImpl"}, {"methodBody": ["METHOD_START", "{", "return   InspectionProjectProfileManager . getInstance ( fileElement . getManager (  )  . getProject (  )  )  . getCurrentProfile (  )  ;", "}", "METHOD_END"], "methodName": ["getInspectionProfile"], "fileName": "com.intellij.util.xml.highlighting.DomElementAnnotationsManagerImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( root . getFileDescription (  )  . isAutomaticHighlightingEnabled (  )  )     {", "return   new   MockAnnotatingDomInspection <  >  ( root . getRootElementClass (  )  )  ;", "}", "if    ( getSuitableDomInspections ( root ,    false )  . isEmpty (  )  )     {", "return   new   MockDomInspection <  >  ( root . getRootElementClass (  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getMockInspection"], "fileName": "com.intellij.util.xml.highlighting.DomElementAnnotationsManagerImpl"}, {"methodBody": ["METHOD_START", "{", "Class   rootType    =    fileElement . getRootElementClass (  )  ;", "final   InspectionProfile   profile    =    getInspectionProfile ( fileElement )  ;", "final   List < DomElementsInspection >    inspections    =    new   com . intellij . util . SmartList (  )  ;", "for    ( final   InspectionToolWrapper   toolWrapper    :    profile . getInspectionTools ( fileElement . getFile (  )  )  )     {", "if    (  (  ! enabledOnly )     |  |     ( profile . isToolEnabled ( HighlightDisplayKey . find ( toolWrapper . getShortName (  )  )  ,    fileElement . getFile (  )  )  )  )     {", "ContainerUtil . addIfNotNull ( inspections ,     . getSuitableInspection ( toolWrapper . getTool (  )  ,    rootType )  )  ;", "}", "}", "return   inspections ;", "}", "METHOD_END"], "methodName": ["getSuitableDomInspections"], "fileName": "com.intellij.util.xml.highlighting.DomElementAnnotationsManagerImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( entry   instanceof   DomElementsInspection )     {", "if    (  (  ( DomElementsInspection )     ( entry )  )  . getDomClasses (  )  . contains ( rootType )  )     {", "return    (  ( DomElementsInspection )     ( entry )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getSuitableInspection"], "fileName": "com.intellij.util.xml.highlighting.DomElementAnnotationsManagerImpl"}, {"methodBody": ["METHOD_START", "{", "final   CachedValue < Boolean >    cachedValue    =    file . getUserData ( DomElementAnnotationsManagerImpl . CACHED _ VALUE _ KEY )  ;", "return    ( cachedValue    =  =    null )     |  |     (  !  ( cachedValue . hasUpToDateValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isHolderOutdated"], "fileName": "com.intellij.util.xml.highlighting.DomElementAnnotationsManagerImpl"}, {"methodBody": ["METHOD_START", "{", "synchronized ( DomElementAnnotationsManagerImpl . LOCK )     {", "return    !  ( DomElementAnnotationsManagerImpl . isHolderOutdated ( DomUtil . getFile ( element )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["isHolderUpToDate"], "fileName": "com.intellij.util.xml.highlighting.DomElementAnnotationsManagerImpl"}, {"methodBody": ["METHOD_START", "{", "synchronized ( DomElementAnnotationsManagerImpl . LOCK )     {", "DomUtil . getFile ( element )  . putUserData ( DomElementAnnotationsManagerImpl . CACHED _ VALUE _ KEY ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["outdateProblemHolder"], "fileName": "com.intellij.util.xml.highlighting.DomElementAnnotationsManagerImpl"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   element    =    getPsiElement (  )  ;", "if    ( element    !  =    null )     {", "assert   element . isValid (  )     :    element ;", "if    ( element   instanceof   XmlTag )     {", "return   DomUtil . getProblemRange (  (  ( XmlTag )     ( element )  )  )  ;", "}", "int   length    =    element . getTextRange (  )  . getLength (  )  ;", "TextRange   range    =    TextRange . from (  0  ,    length )  ;", "if    ( element   instanceof   XmlAttributeValue )     {", "final   String   value    =     (  ( XmlAttributeValue )     ( element )  )  . getValue (  )  ;", "if    ( StringUtil . isNotEmpty ( value )  )     {", "range    =    TextRange . from ( element . getText (  )  . indexOf ( value )  ,    value . length (  )  )  ;", "}", "}", "return   Pair . create ( range ,    element )  ;", "}", "final   XmlTag   tag    =    getParentXmlTag (  )  ;", "if    ( tag    !  =    null )     {", "return   DomUtil . getProblemRange ( tag )  ;", "}", "return    . NO _ PROBLEM ;", "}", "METHOD_END"], "methodName": ["computeProblemRange"], "fileName": "com.intellij.util.xml.highlighting.DomElementProblemDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    o )", "return   true ;", "if    (  ( o    =  =    null )     |  |     (  ( getClass (  )  )     !  =     ( o . getClass (  )  )  )  )", "return   false ;", "final      that    =     (  (  )     ( o )  )  ;", "if    (  ( myDomElement )     !  =    null    ?     !  ( myDomElement . equals ( that . myDomElement )  )     :     ( that . myDomElement )     !  =    null )", "return   false ;", "if    (  !  ( myMessage . equals ( that . myMessage )  )  )", "return   false ;", "if    (  !  ( mySeverity . equals ( that . mySeverity )  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.intellij.util.xml.highlighting.DomElementProblemDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "DomElement   parent    =    myDomElement . getParent (  )  ;", "while    ( parent    !  =    null )     {", "if    (  ( parent . getXmlTag (  )  )     !  =    null )", "return   parent . getXmlTag (  )  ;", "parent    =    parent . getParent (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getParentXmlTag"], "fileName": "com.intellij.util.xml.highlighting.DomElementProblemDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myPair )     =  =    null )     {", "myPair    =    computeRange (  )  ;", "}", "PsiElement   element    =    myPair . second ;", "if    ( element    !  =    null )     {", "PsiUtilCore . ensureValid ( element )  ;", "}", "return   myPair ;", "}", "METHOD_END"], "methodName": ["getProblemRange"], "fileName": "com.intellij.util.xml.highlighting.DomElementProblemDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myDomElement )    instanceof   DomFileElement )     {", "return    (  ( DomFileElement )     ( myDomElement )  )  . getFile (  )  ;", "}", "if    (  ( myDomElement )    instanceof   GenericAttributeValue )     {", "final   GenericAttributeValue   attributeValue    =     (  ( GenericAttributeValue )     ( myDomElement )  )  ;", "final   XmlAttributeValue   value    =    attributeValue . getXmlAttributeValue (  )  ;", "return    ( value    !  =    null )     &  &     ( StringUtil . isNotEmpty ( value . getText (  )  )  )     ?    value    :    attributeValue . getXmlElement (  )  ;", "}", "final   XmlTag   tag    =    myDomElement . getXmlTag (  )  ;", "if    (  (  ( myDomElement )    instanceof   GenericValue )     &  &     ( tag    !  =    null )  )     {", "final   XmlText [  ]    textElements    =    tag . getValue (  )  . getTextElements (  )  ;", "if    (  ( textElements . length )     >     0  )     {", "return   textElements [  0  ]  ;", "}", "}", "return   tag ;", "}", "METHOD_END"], "methodName": ["getPsiElement"], "fileName": "com.intellij.util.xml.highlighting.DomElementProblemDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "int   result ;", "result    =     (  ( my )     !  =    null )     ?    my . hashCode (  )     :     0  ;", "result    =     (  3  1     *    result )     +     ( mySeverity . hashCode (  )  )  ;", "result    =     (  3  1     *    result )     +     ( myMessage . hashCode (  )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.intellij.util.xml.highlighting.DomElementProblemDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( myDomElement )     +     \"  ;     \"  )     +     ( myMessage )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.util.xml.highlighting.DomElementProblemDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "ApplicationManager . getApplication (  )  . invokeLater (  (  )     -  >    myAlarm . addRequest (  (  )     -  >     {", "if    (  ( myProject . isOpen (  )  )     &  &     (  !  ( myProject . isDisposed (  )  )  )  )     {", "updatePanel (  )  ;", "}", "}  ,     . ALARM _ PERIOD )  )  ;", "}", "METHOD_END"], "methodName": ["addUpdateRequest"], "fileName": "com.intellij.util.xml.highlighting.DomElementsErrorPanel"}, {"methodBody": ["METHOD_START", "{", "for    ( final   DomElement   domElement    :    myDomElements )     {", "if    (  !  ( domElement . isValid (  )  )  )", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["areValid"], "fileName": "com.intellij.util.xml.highlighting.DomElementsErrorPanel"}, {"methodBody": ["METHOD_START", "{", "return   new   Dimension (  (  ( ErrorsInProgress . getIconWidth (  )  )     +     2  )  ,     (  ( ErrorsInProgress . getIconHeight (  )  )     +     2  )  )  ;", "}", "METHOD_END"], "methodName": ["getDimension"], "fileName": "com.intellij.util.xml.highlighting.DomElementsErrorPanel"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( areValid (  )  )  )     |  |     ( myAnnotationsManager . isHighlightingFinished ( myDomElements )  )  ;", "}", "METHOD_END"], "methodName": ["isHighlightingFinished"], "fileName": "com.intellij.util.xml.highlighting.DomElementsErrorPanel"}, {"methodBody": ["METHOD_START", "{", "myAlarm . cancelAllRequests (  )  ;", "if    (  !  ( areValid (  )  )  )", "return ;", "repaint (  )  ;", "setToolTipText ( myErrorStripeRenderer . getTooltipMessage (  )  )  ;", "if    (  !  ( isHFinished (  )  )  )     {", "addUpdateRequest (  )  ;", "}", "}", "METHOD_END"], "methodName": ["updatePanel"], "fileName": "com.intellij.util.xml.highlighting.DomElementsErrorPanel"}, {"methodBody": ["METHOD_START", "{", "String   tooltip    =     ( text    =  =    null )     ?    null    :    XmlStringUtil . wrapInHtml ( XmlStringUtil . escapeString ( text )  )  ;", "return   new   lang . annotation . Annotation ( range . getStartOffset (  )  ,    range . getEndOffset (  )  ,    severity ,    text ,    tooltip )  ;", "}", "METHOD_END"], "methodName": ["createAnnotation"], "fileName": "com.intellij.util.xml.highlighting.DomElementsHighlightingUtil"}, {"methodBody": ["METHOD_START", "{", "return   DomElementsHighlightingUtil . createProblemDescriptors ( problemDescriptor ,     (    s )     -  >     {", "String   text    =    problemDescriptor . getDescriptionTemplate (  )  ;", "if    ( StringUtil . isEmpty ( text )  )", "text    =    null ;", "final   HighlightSeverity   severity    =    problemDescriptor . getHighlightSeverity (  )  ;", "TextRange   range    =    s . first ;", "if    ( text    =  =    null )", "range    =    TextRange . from ( range . getStartOffset (  )  ,     0  )  ;", "range    =    range . shiftRight ( s . second . getTextRange (  )  . getStartOffset (  )  )  ;", "final   Annotation   annotation    =    createAnnotation ( severity ,    range ,    text )  ;", "if    ( problemDescriptor   instanceof   DomElementResolveProblemDescriptor )     {", "annotation . setTextAttributes ( CodeInsightColors . WRONG _ REFERENCES _ ATTRIBUTES )  ;", "}", "for    ( LocalQuickFix   fix    :    problemDescriptor . getFixes (  )  )     {", "if    ( fix   instanceof   IntentionAction )", "annotation . registerFix (  (  ( IntentionAction )     ( fix )  )  )  ;", "}", "return   annotation ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["createAnnotation"], "fileName": "com.intellij.util.xml.highlighting.DomElementsHighlightingUtil"}, {"methodBody": ["METHOD_START", "{", "final   ProblemHighlightType   type    =    DomElementsHighlightingUtil . getProblemHighlightType ( problemDescriptor )  ;", "return   DomElementsHighlightingUtil . createProblemDescriptors ( problemDescriptor ,     (    s )     -  >    manager . createProblemDescriptor ( s . second ,    s . first ,    problemDescriptor . getDescriptionTemplate (  )  ,    type ,    true ,    problemDescriptor . getFixes (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createProblemDescriptors"], "fileName": "com.intellij.util.xml.highlighting.DomElementsHighlightingUtil"}, {"methodBody": ["METHOD_START", "{", "final   Pair < TextRange ,    PsiElement >    range    =     (  ( DomElementProblemDescriptorImpl )     ( problemDescriptor )  )  . getProblemRange (  )  ;", "return    ( range    =  =     ( DomElementProblemDescriptorImpl . NO _ PROBLEM )  )     |  |     (  !  ( range . second . isPhysical (  )  )  )     ?    null    :    creator . fun ( range )  ;", "}", "METHOD_END"], "methodName": ["createProblemDescriptors"], "fileName": "com.intellij.util.xml.highlighting.DomElementsHighlightingUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  ( problemDescriptor . getHighlightType (  )  )     !  =    null )     {", "return   problemDescriptor . getHighlightType (  )  ;", "}", "if    ( problemDescriptor   instanceof   ResolveProblemDescriptor )     {", "final   TextRange   range    =     (  ( ResolveProblemDescriptor )     ( problemDescriptor )  )  . getPsiReference (  )  . getRangeInElement (  )  ;", "if    (  ( range . getStartOffset (  )  )     !  =     ( range . getEndOffset (  )  )  )     {", "return   ProblemHighlightType . LIKE _ UNKNOWN _ SYMBOL ;", "}", "}", "return   ProblemHighlightType . GENERIC _ ERROR _ OR _ WARNING ;", "}", "METHOD_END"], "methodName": ["getProblemHighlightType"], "fileName": "com.intellij.util.xml.highlighting.DomElementsHighlightingUtil"}, {"methodBody": ["METHOD_START", "{", "final   XmlElement   xmlElement    =    element . getXmlElement (  )  ;", "if    ( xmlElement   instanceof   XmlTag )     {", "for    ( final   DomElement   child    :    DomUtil . getDefinedChildren ( element ,    true ,    true )  )     {", "final   XmlElement   element 1     =    child . getXmlElement (  )  ;", "if    ( element 1     =  =    null )     {", ". LOG . error (  (  (  (  (  (  \" child =  \"     +    child )     +     \"    of   class    \"  )     +     ( child . getClass (  )  )  )     +     \"  ;    parent =  \"  )     +    element )  )  ;", "}", "if    ( element 1  . isPhysical (  )  )     {", "visitor . consume ( child )  ;", "}", "}", "for    ( final   AbstractDomChildrenDescription   description    :    element . getGenericInfo (  )  . getChildrenDescriptions (  )  )     {", "if    (  ( description . getAnnotation ( Required . class )  )     !  =    null )     {", "for    ( final   DomElement   child    :    description . getValues ( element )  )     {", "if    (  !  ( DomUtil . hasXml ( child )  )  )     {", "visitor . consume ( child )  ;", "}", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["checkChildren"], "fileName": "com.intellij.util.xml.highlighting.DomElementsInspection"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  (  \" checkDomElement (  )    is   not   implemented   in    \"     +     ( getClass (  )  . getName (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["checkDomElement"], "fileName": "com.intellij.util.xml.highlighting.DomElementsInspection"}, {"methodBody": ["METHOD_START", "{", "final   DomElementAnnotationsManager   annotationsManager    =    DomElementAnnotationsManager . getInstance ( manager . getProject (  )  )  ;", "final   List < DomElementProblemDescriptor >    list    =    annotationsManager . checkFileElement ( domFileElement ,    this ,    isOnTheFly )  ;", "if    ( list . isEmpty (  )  )", "return   ProblemDescriptor . EMPTY _ ARRAY ;", "List < ProblemDescriptor >    problems    =    ContainerUtil . concat ( list ,     (    s )     -  >    annotationsManager . createProblemDescriptors ( manager ,    s )  )  ;", "return   problems . toArray ( EMPTY _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["checkDomFile"], "fileName": "com.intellij.util.xml.highlighting.DomElementsInspection"}, {"methodBody": ["METHOD_START", "{", "final   DomHighlightingHelper   helper    =    DomElementAnnotationsManager . getInstance ( domFileElement . getManager (  )  . getProject (  )  )  . getHighlightingHelper (  )  ;", "final   Consumer < DomElement >    consumer    =    new   Consumer < DomElement >  (  )     {", "@ Override", "public   void   consume ( final   DomElement   element )     {", "checkChildren ( element ,    this )  ;", "checkDomElement ( element ,    holder ,    helper )  ;", "}", "}  ;", "consumer . consume ( domFileElement . getRootElement (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkFileElement"], "fileName": "com.intellij.util.xml.highlighting.DomElementsInspection"}, {"methodBody": ["METHOD_START", "{", "return   myDomClasses ;", "}", "METHOD_END"], "methodName": ["getDomClasses"], "fileName": "com.intellij.util.xml.highlighting.DomElementsInspection"}, {"methodBody": ["METHOD_START", "{", "ContainerUtil . getOrCreate ( ContainerUtil . getOrCreate ( myCachedErrors ,    descriptor . getDomElement (  )  ,    DomElementsProblemsHolderImpl . CONCURRENT _ HASH _ MAP _ FACTORY )  ,    inspection ,    DomElementsProblemsHolderImpl . SMART _ LIST _ FACTORY )  . add ( descriptor )  ;", "myCachedChildrenErrors . clear (  )  ;", "}", "METHOD_END"], "methodName": ["addProblem"], "fileName": "com.intellij.util.xml.highlighting.DomElementsProblemsHolderImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( isInspectionCompleted ( inspectionClass )  )", "return ;", "for    ( final   ProblemDescriptor   descriptor    :    holder )     {", "addProblem ( descriptor ,    inspectionClass )  ;", "}", "myAnnotations . addAll ( holder . getAnnotations (  )  )  ;", "myPassedInspections . add ( inspectionClass )  ;", "}", "METHOD_END"], "methodName": ["appendProblems"], "fileName": "com.intellij.util.xml.highlighting.DomElementsProblemsHolderImpl"}, {"methodBody": ["METHOD_START", "{", "return   myAnnotations ;", "}", "METHOD_END"], "methodName": ["getAnnotations"], "fileName": "com.intellij.util.xml.highlighting.DomElementsProblemsHolderImpl"}, {"methodBody": ["METHOD_START", "{", "final   Map < Class <  ?    extends   DomElementsInspection >  ,    List < DomElementProblemDescriptor >  >    map    =    myCachedChildrenErrors . get ( domElement )  ;", "if    ( map    !  =    null )     {", "return   map ;", "}", "final   Map < Class <  ?    extends   DomElementsInspection >  ,    List < DomElementProblemDescriptor >  >    problems    =    new   gnu . trove . THashMap (  )  ;", "if    ( domElement    =  =     ( myElement )  )     {", "for    ( Map < Class <  ?    extends   DomElementsInspection >  ,    List < DomElementProblemDescriptor >  >    listMap    :    myCachedErrors . values (  )  )     {", ". mergeMaps ( problems ,    listMap )  ;", "}", "} else    {", ". mergeMaps ( problems ,    myCachedErrors . get ( domElement )  )  ;", "if    ( DomUtil . hasXml ( domElement )  )     {", "domElement . acceptChildren ( new   DomElementVisitor (  )     {", "@ Override", "public   void   visitDomElement ( DomElement   element )     {", ". mergeMaps ( problems ,    getProblemsMap ( element )  )  ;", "}", "}  )  ;", "}", "}", "myCachedChildrenErrors . put ( domElement ,    problems )  ;", "return   problems ;", "}", "METHOD_END"], "methodName": ["getProblemsMap"], "fileName": "com.intellij.util.xml.highlighting.DomElementsProblemsHolderImpl"}, {"methodBody": ["METHOD_START", "{", "synchronized ( DomElementAnnotationsManagerImpl . LOCK )     {", "return   myPassedInspections . contains ( inspectionClass )  ;", "}", "}", "METHOD_END"], "methodName": ["isInspectionCompleted"], "fileName": "com.intellij.util.xml.highlighting.DomElementsProblemsHolderImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( toAdd    =  =    null )", "return ;", "for    ( final   Map . Entry < T ,    List < DomElementProblemDescriptor >  >    entry    :    toAdd . entrySet (  )  )     {", "ContainerUtil . getOrCreate ( accumulator ,    entry . getKey (  )  ,     . SMART _ LIST _ FACTORY )  . addAll ( entry . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["mergeMaps"], "fileName": "com.intellij.util.xml.highlighting.DomElementsProblemsHolderImpl"}, {"methodBody": ["METHOD_START", "{", "final   T   annotation    =    element . getAnnotation ( checker . getAnnotationClass (  )  )  ;", "return   annotation    !  =    null    ?    checker . checkForProblems ( annotation ,    element ,    holder ,    this )     :    Collections . emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["checkAnno"], "fileName": "com.intellij.util.xml.highlighting.DomHighlightingHelper"}, {"methodBody": ["METHOD_START", "{", "List < DomElementProblemDescriptor >    result    =    null ;", "for    ( final   DomCustomAnnotationChecker <  ?  >    checker    :    myCustomCheckers )     {", "final   List < DomElementProblemDescriptor >    list    =    checkAnno ( element ,    checker ,    holder )  ;", "if    (  !  ( list . isEmpty (  )  )  )     {", "if    ( result    =  =    null )", "result    =    new   SmartList (  )  ;", "result . addAll ( list )  ;", "}", "}", "return   result    =  =    null    ?    Collections . emptyList (  )     :    result ;", "}", "METHOD_END"], "methodName": ["checkCustomAnnotations"], "fileName": "com.intellij.util.xml.highlighting.DomHighlightingHelper"}, {"methodBody": ["METHOD_START", "{", "final   String   stringValue    =    child . getStringValue (  )  ;", "if    ( stringValue    =  =    null )", "return   null ;", "if    (  ( required . nonEmpty (  )  )     &  &     (  . isEmpty ( child ,    stringValue )  )  )     {", "return   annotator . createProblem ( child ,    IdeBundle . message (  \" value . must . not . be . empty \"  )  )  ;", "}", "if    (  ( required . identifier (  )  )     &  &     (  !  (  . isIdentifier ( stringValue )  )  )  )     {", "return   annotator . createProblem ( child ,    IdeBundle . message (  \" value . must . be . identifier \"  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["checkRequiredGenericValue"], "fileName": "com.intellij.util.xml.highlighting.DomHighlightingHelperImpl"}, {"methodBody": ["METHOD_START", "{", "return   XmlHighlightVisitor . hasBadResolve ( reference ,    true )  ;", "}", "METHOD_END"], "methodName": ["hasBadResolve"], "fileName": "com.intellij.util.xml.highlighting.DomHighlightingHelperImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( DomHighlightingHelperImpl . hasBadResolve ( domReference )  )  )     |  |     (  ( converter   instanceof   ResolvingConverter )     &  &     (  (  ( ResolvingConverter )     ( converter )  )  . getAdditionalVariants ( domReference . getConvertContext (  )  )  . contains ( element . getStringValue (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isDomResolveOK"], "fileName": "com.intellij.util.xml.highlighting.DomHighlightingHelperImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stringValue . trim (  )  . length (  )  )     !  =     0  )     {", "return   false ;", "}", "if    ( child   instanceof   GenericAttributeValue )     {", "final   XmlAttributeValue   value    =     (  ( GenericAttributeValue )     ( child )  )  . getXmlAttributeValue (  )  ;", "if    (  ( value    !  =    null )     &  &     ( value . getTextRange (  )  . isEmpty (  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "com.intellij.util.xml.highlighting.DomHighlightingHelperImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtil . isEmptyOrSpaces ( s )  )", "return   false ;", "if    (  !  ( Character . isJavaIdentifierStart ( s . charAt (  0  )  )  )  )", "return   false ;", "for    ( int   i    =     1  ;    i    <     ( s . length (  )  )  ;    i +  +  )     {", "if    (  !  ( Character . isJavaIdentifierPart ( s . charAt ( i )  )  )  )", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isIdentifier"], "fileName": "com.intellij.util.xml.highlighting.DomHighlightingHelperImpl"}, {"methodBody": ["METHOD_START", "{", "final   Resolve   resolve    =    value . getAnnotation ( Resolve . class )  ;", "if    (  ( resolve    !  =    null )     &  &     ( resolve . soft (  )  )  )", "return   true ;", "final   Convert   convert    =    value . getAnnotation ( Convert . class )  ;", "if    (  ( convert    !  =    null )     &  &     ( convert . soft (  )  )  )", "return   true ;", "final   Referencreferenc =    value . getAnnotation ( Referencclass )  ;", "return    ( referenc !  =    null )     &  &     ( referencsoft (  )  )  ;", "}", "METHOD_END"], "methodName": ["isSoftReference"], "fileName": "com.intellij.util.xml.highlighting.DomHighlightingHelperImpl"}, {"methodBody": ["METHOD_START", "{", "ResolvingElementQuickFix . chooseParent ( myParents ,     (    parent )     -  >    WriteCommandAction . writeCommandAction ( parent . getManager (  )  . getProject (  )  ,    DomUtil . getFile ( parent )  )  . run (  (  )     -  >     {", "doFix ( parent ,    myChildDescription ,    myNewName )  ;", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["applyFix"], "fileName": "com.intellij.util.xml.highlighting.ResolvingElementQuickFix"}, {"methodBody": ["METHOD_START", "{", "switch    ( files . size (  )  )     {", "case    0     :", "return ;", "case    1     :", "onChoose . consume ( files . iterator (  )  . next (  )  )  ;", "return ;", "default    :", "JBPopupFactory . getInstance (  )  . createListPopup ( new   openapi . ui . popup . util . BaseListPopupStep < DomElement >  ( DomBundle . message (  \" choose . file \"  )  ,    files )     {", "@ Override", "public   PopupStep   onChosen ( final   DomElement   selectedValue ,    final   boolean   finalChoice )     {", "onChoose . consume ( selectedValue )  ;", "return   super . onChosen ( selectedValue ,    finalChoice )  ;", "}", "@ Override", "public   Icon   getIconFor ( final   DomElement   aValue )     {", "return   DomUtil . getFile ( aValue )  . getIcon (  0  )  ;", "}", "@ Override", "@ NotNull", "public   String   getTextFor ( final   DomElement   value )     {", "final   String   name    =    DomUtil . getFile ( value )  . getName (  )  ;", "assert   name    !  =    null ;", "return   name ;", "}", "}  )  . showInBestPositionFor ( DataManager . getInstance (  )  . getDataContext (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["chooseParent"], "fileName": "com.intellij.util.xml.highlighting.ResolvingElementQuickFix"}, {"methodBody": ["METHOD_START", "{", "final   List < DomElement >    parents    =    ModelMergerUtil . getImplementations ( scope )  ;", "return    . createFix ( newName ,    clazz ,    parents )  ;", "}", "METHOD_END"], "methodName": ["createFix"], "fileName": "com.intellij.util.xml.highlighting.ResolvingElementQuickFix"}, {"methodBody": ["METHOD_START", "{", "final   DomCollectionChildDescription   childDescription    =    ResolvingElementQuickFix . getChildDescription ( parents ,    clazz )  ;", "if    (  (  ( newName . length (  )  )     >     0  )     &  &     ( childDescription    !  =    null )  )     {", "return   new   ResolvingElementQuickFix ( clazz ,    newName ,    parents ,    childDescription )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["createFix"], "fileName": "com.intellij.util.xml.highlighting.ResolvingElementQuickFix"}, {"methodBody": ["METHOD_START", "{", "final   LocalQuickFix   fix    =    ResolvingElementQuickFix . createFix ( newName ,    clazz ,    scope )  ;", "return   fix    !  =    null    ?    new   LocalQuickFix [  ]  {    fix    }     :    LocalQuickFix . EMPTY _ ARRAY ;", "}", "METHOD_END"], "methodName": ["createFixes"], "fileName": "com.intellij.util.xml.highlighting.ResolvingElementQuickFix"}, {"methodBody": ["METHOD_START", "{", "final   DomElement   domElement    =    childDescription . addValue ( parent )  ;", "final   GenericDomValue   nameDomElement    =    domElement . getGenericInfo (  )  . getNameDomElement ( domElement )  ;", "assert   nameDomElement    !  =    null ;", "nameDomElement . setStringValue ( newName )  ;", "return   domElement ;", "}", "METHOD_END"], "methodName": ["doFix"], "fileName": "com.intellij.util.xml.highlighting.ResolvingElementQuickFix"}, {"methodBody": ["METHOD_START", "{", "if    (  ( contexts . size (  )  )     =  =     0  )     {", "return   null ;", "}", "final   Dom   context    =    contexts . get (  0  )  ;", "final   DomGenericInfo   genericInfo    =    context . getGenericInfo (  )  ;", "final   List <  ?    extends   DomCollectionChildDescription >    descriptions    =    genericInfo . getCollectionChildrenDescriptions (  )  ;", "for    ( DomCollectionChildDescription   description    :    descriptions )     {", "final   Type   type    =    description . getType (  )  ;", "if    ( type . equals ( clazz )  )     {", "return   description ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getChildDescription"], "fileName": "com.intellij.util.xml.highlighting.ResolvingElementQuickFix"}, {"methodBody": ["METHOD_START", "{", "myTypeName    =    typeName ;", "}", "METHOD_END"], "methodName": ["setTypeName"], "fileName": "com.intellij.util.xml.highlighting.ResolvingElementQuickFix"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myCustomAnnotations )     =  =    null )", "myCustomAnnotations    =    new   gnu . trove . THashMap (  )  ;", "myCustomAnnotations . put ( annotation . annotationType (  )  ,    annotation )  ;", "}", "METHOD_END"], "methodName": ["addCustomAnnotation"], "fileName": "com.intellij.util.xml.impl.AbstractDomChildDescriptionImpl"}, {"methodBody": ["METHOD_START", "{", "Class   clazz    =    ReflectionUtil . getRawType ( getType (  )  )  ;", "Presentation   presentation    =    DomApplicationComponent . getInstance (  )  . getInvocationCache ( clazz )  . getClassAnnotation ( Presentation . class )  ;", "return   presentation    =  =    null    ?    null    :    new   ElementPresentationTemplateImpl ( presentation ,    clazz )  ;", "}", "METHOD_END"], "methodName": ["calcPresentationTemplate"], "fileName": "com.intellij.util.xml.impl.AbstractDomChildDescriptionImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( myType )    instanceof   Class )     &  &     (  ( DomReflectionUtil . findAnnotationDFS (  (  ( Class )     ( myType )  )  ,    Stubbed . class )  )     !  =    null )  )     |  |     (  ( getAnnotation ( Stubbed . class )  )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["calcStubbed"], "fileName": "com.intellij.util.xml.impl.AbstractDomChildDescriptionImpl"}, {"methodBody": ["METHOD_START", "{", "myUserMap    =    userMap ;", "}", "METHOD_END"], "methodName": ["setUserMap"], "fileName": "com.intellij.util.xml.impl.AbstractDomChildDescriptionImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    o )", "return   true ;", "if    (  ( o    =  =    null )     |  |     (  ( getClass (  )  )     !  =     ( o . getClass (  )  )  )  )", "return   false ;", "if    (  !  ( super . equals ( o )  )  )", "return   false ;", "final      that    =     (  (  )     ( o )  )  ;", "if    (  ( myGetterMethod )     !  =    null    ?     !  ( myGetterMethod . equals ( that . myGetterMethod )  )     :     ( that . myGetterMethod )     !  =    null )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.intellij.util.xml.impl.AttributeChildDescriptionImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( GenericAttributeValue )     ( handler . getAttributeChild ( this )  . getProxy (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getDomAttributeValue"], "fileName": "com.intellij.util.xml.impl.AttributeChildDescriptionImpl"}, {"methodBody": ["METHOD_START", "{", "int   result    =    super . hashCode (  )  ;", "result    =     (  2  9     *    result )     +     (  ( myGetterMethod )     !  =    null    ?    myGetterMethod . hashCode (  )     :     0  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.intellij.util.xml.impl.AttributeChildDescriptionImpl"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    parent . getXmlTag (  )  ;", "if    ( tag    =  =    null )     {", "return   null ;", "}", "Sng   ns    =    getXmlName (  )  . getNamespace ( tag ,    parent . getFile (  )  )  ;", "return   tag . getNamespace (  )  . equals ( ns )     ?    null    :    ns ;", "}", "METHOD_END"], "methodName": ["getXmlApiCompatibleNamespace"], "fileName": "com.intellij.util.xml.impl.AttributeChildInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "myMap . put ( t . getXmlName (  )  ,    t )  ;", "myCached    =    null ;", "return   t ;", "}", "METHOD_END"], "methodName": ["addDescription"], "fileName": "com.intellij.util.xml.impl.ChildrenDescriptionsHolder"}, {"methodBody": ["METHOD_START", "{", "for    ( final   T   t    :    collection )     {", "add ( t )  ;", "}", "}", "METHOD_END"], "methodName": ["addDescriptions"], "fileName": "com.intellij.util.xml.impl.ChildrenDescriptionsHolder"}, {"methodBody": ["METHOD_START", "{", "to . addAll ( getSortedDescriptions (  )  )  ;", "if    (  ( myDelegate )     !  =    null )     {", "myDelegate . dumpDescriptions ( to )  ;", "}", "}", "METHOD_END"], "methodName": ["dumpDescriptions"], "fileName": "com.intellij.util.xml.impl.ChildrenDescriptionsHolder"}, {"methodBody": ["METHOD_START", "{", "for    ( final   XmlName   xmlName    :    myMap . keySet (  )  )     {", "if    ( xmlName . getLocalName (  )  . equals ( localName )  )", "return   myMap . get ( xmlName )  ;", "}", "return    ( myDelegate )     !  =    null    ?    myDelegate . find ( localName )     :    null ;", "}", "METHOD_END"], "methodName": ["findDescription"], "fileName": "com.intellij.util.xml.impl.ChildrenDescriptionsHolder"}, {"methodBody": ["METHOD_START", "{", "final   T   t    =    myMap . get ( name )  ;", "if    ( t    !  =    null )", "return   t ;", "return    ( myDelegate )     !  =    null    ?    myDelegate . get ( name )     :    null ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "com.intellij.util.xml.impl.ChildrenDescriptionsHolder"}, {"methodBody": ["METHOD_START", "{", "return   getDescription ( new   XmlName ( localName ,    namespaceKey )  )  ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "com.intellij.util.xml.impl.ChildrenDescriptionsHolder"}, {"methodBody": ["METHOD_START", "{", "final   ArrayList < T >    result    =    new   ArrayList <  >  (  )  ;", "dump ( result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getDescriptions"], "fileName": "com.intellij.util.xml.impl.ChildrenDescriptionsHolder"}, {"methodBody": ["METHOD_START", "{", "List < T >    cached    =    myCached ;", "if    ( cached    !  =    null )     {", "return   cached ;", "}", "if    (  !  ( myMap . isEmpty (  )  )  )     {", "cached    =    new   SmartList ( myMap . values (  )  )  ;", "Collections . sort ( cached )  ;", "} else    {", "cached    =    Collections . emptyList (  )  ;", "}", "myCached    =    cached ;", "return   cached ;", "}", "METHOD_END"], "methodName": ["getSortedDescriptions"], "fileName": "com.intellij.util.xml.impl.ChildrenDescriptionsHolder"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   DomInvocationHandler   handler    =    DomManagerImpl . getDomInvocationHandler ( element )  ;", "assert   handler    !  =    null ;", "return   handler . add ( this ,    type ,    index )  ;", "}    catch    ( IncorrectOperationException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["addChild"], "fileName": "com.intellij.util.xml.impl.CollectionChildDescriptionImpl"}, {"methodBody": ["METHOD_START", "{", "return   DomImplUtil . findSubTags ( tag ,    handler . createEvaluatedXmlName ( getXmlName (  )  )  ,    handler . getFile (  )  )  ;", "}", "METHOD_END"], "methodName": ["getCollectionSubTags"], "fileName": "com.intellij.util.xml.impl.CollectionChildDescriptionImpl"}, {"methodBody": ["METHOD_START", "{", "return   myConverter ;", "}", "METHOD_END"], "methodName": ["getConverter"], "fileName": "com.intellij.util.xml.impl.ConvertAnnotationImpl"}, {"methodBody": ["METHOD_START", "{", "return   new   ConvertContextImpl ( DomManagerImpl . getDomInvocationHandler ( element )  )     {", "@ NotNull", "@ Override", "public   DomElement   getInvocationElement (  )     {", "return   element ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createConvertContext"], "fileName": "com.intellij.util.xml.impl.ConvertContextFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   ConvertContextImpl ( element )  ;", "}", "METHOD_END"], "methodName": ["createConvertContext"], "fileName": "com.intellij.util.xml.impl.ConvertContextFactory"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( myConverterInstances . get ( clazz )  )  )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "com.intellij.util.xml.impl.ConverterManagerImpl"}, {"methodBody": ["METHOD_START", "{", "return   myGetter ;", "}", "METHOD_END"], "methodName": ["getGetterMethod"], "fileName": "com.intellij.util.xml.impl.CustomDomChildrenDescriptionImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( parent . getGenericInfo (  )  . checkInitialized (  )  )  )     {", "return   Collections . emptyList (  )  ;", "}", "return   parent . getCollection ( this )  ;", "}", "METHOD_END"], "methodName": ["getValues"], "fileName": "com.intellij.util.xml.impl.CustomDomChildrenDescriptionImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( DomElementAnnotationsManagerImpl )     ( DomElementAnnotationsManager . getInstance ( element . getManager (  )  . getProject (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getAnnotationsManager"], "fileName": "com.intellij.util.xml.impl.DefaultDomAnnotator"}, {"methodBody": ["METHOD_START", "{", "if    ( psiElement   instanceof   XmlTag )     {", "return   myDomManager . geElement (  (  ( XmlTag )     ( psiElement )  )  )  ;", "}", "if    ( psiElement   instanceof   XmlAttribute )     {", "return   myDomManager . geElement (  (  ( XmlAttribute )     ( psiElement )  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDomElement"], "fileName": "com.intellij.util.xml.impl.DefaultDomAnnotator"}, {"methodBody": ["METHOD_START", "{", "if    ( inspection    =  =    null )", "return ;", "DomElementionsManagerImpl   annotationsManager    =    getionsManager ( fileElement )  ;", "if    (  ( DomElementionsManagerImpl . isHolderUpToDate ( fileElement )  )     &  &     ( annotationsManager . getProblemHolder ( fileElement )  . isInspectionCompleted ( inspection )  )  )", "return ;", "final   DomElementionHolderImpl   annotationHolder    =    new   DomElementionHolderImpl ( true )  ;", "inspection . checkFileElement ( fileElement ,    annotationHolder )  ;", "annotationsManager . appendProblems ( fileElement ,    annotationHolder ,    inspection . getClass (  )  )  ;", "for    ( final   DomElementProblemDescriptor   descriptor    :    annotationHolder )     {", "toFill . addAll ( descriptor . getions (  )  )  ;", "}", "toFill . addAll ( annotationHolder . getions (  )  )  ;", "}", "METHOD_END"], "methodName": ["runInspection"], "fileName": "com.intellij.util.xml.impl.DefaultDomAnnotator"}, {"methodBody": ["METHOD_START", "{", "return   DomAnchorImpl . createAnchor ( t ,    true )  ;", "}", "METHOD_END"], "methodName": ["createAnchor"], "fileName": "com.intellij.util.xml.impl.DomAnchorImpl"}, {"methodBody": ["METHOD_START", "{", "DomInvocationHandler   handler    =    DomManagerImpl . getNotNullHandler ( t )  ;", "if    (  ( handler . getStub (  )  )     !  =    null )     {", "return   new    . StubAnchor <  >  ( handler )  ;", "}", "if    ( usePsi )     {", "final   XmlElement   element    =    t . getXmlElement (  )  ;", "if    ( element    !  =    null )     {", "return   new    . PsiBasedDomAnchor ( PsiAnchor . create ( element )  ,    element . getProject (  )  )  ;", "}", "}", "final   DomElement   parent    =    t . getParent (  )  ;", "if    ( parent    =  =    null )     {", ". LOG . error (  (  \" Parent   null :     \"     +    t )  )  ;", "}", "if    ( parent   instanceof   DomFileElementImpl )     {", "final   DomFileElementImpl   fileElement    =     (  ( DomFileElementImpl )     ( parent )  )  ;", "return   new    . RootAnchor ( fileElement . getFile (  )  ,    fileElement . getRootElementClass (  )  )  ;", "}", "final   DomAnchor < DomElement >    parentAnchor    =     . createAnchor ( parent )  ;", "final   String   name    =    t . getGenericInfo (  )  . getElementName ( t )  ;", "final   AbstractDomChildrenDescription   description    =    t . getChildDescription (  )  ;", "final   List <  ?    extends   DomElement >    values    =    description . getValues ( parent )  ;", "if    ( name    !  =    null )     {", "int   i    =     0  ;", "for    ( DomElement   value    :    values )     {", "if    ( value . equals ( t )  )     {", "return   new    . NamedAnchor <  >  ( parentAnchor ,    description ,    name ,    i )  ;", "}", "if    ( name . equals ( value . getGenericInfo (  )  . getElementName ( value )  )  )     {", "i +  +  ;", "}", "}", "}", "final   int   index    =    values . indexOf ( t )  ;", "if    ( index    <     0  )     {", ". diagnoseNegativeIndex 2  ( t ,    parent ,    description ,    values )  ;", "}", "return   new    . IndexedAnchor <  >  ( parentAnchor ,    description ,    index )  ;", "}", "METHOD_END"], "methodName": ["createAnchor"], "fileName": "com.intellij.util.xml.impl.DomAnchorImpl"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   parentTag    =    parent . getXmlTag (  )  ;", "StringBuilder   diag    =    new   StringBuilder (  (  (  (  (  (  (  (  (  \" Index <  0  :    description =  \"     +    description )     +     \"  \\ nparent =  \"  )     +    parent )     +     \"  \\ nt =  \"  )     +    t )     +     \"  \\ nvalues =  \"  )     +    values )     +     \"  \\ n \"  )  )  ;", "for    ( int   i    =     0  ,    size    =    values . size (  )  ;    i    <    size ;    i +  +  )     {", "DomElement   value    =    values . get ( i )  ;", "if    ( value . toString (  )  . equals ( t . toString (  )  )  )     {", "final   XmlElement   tElement    =    t . getXmlElement (  )  ;", "final   XmlElement   valElement    =    value . getXmlElement (  )  ;", "diag . append (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"    hasSame ,    i =  \"     +    i )     +     \"  ;    same =  \"  )     +     ( value    =  =    t )  )     +     \"  ,    equal =  \"  )     +     ( value . equals ( t )  )  )     +     \"  ,    equal 2  =  \"  )     +     ( t . equals ( value )  )  )     +     \"  ,    t . physical =  \"  )     +     ( tElement    =  =    null    ?     \" null \"     :    String . valueOf ( tElement . isPhysical (  )  )  )  )     +     \"  ,    value . physical =  \"  )     +     ( valElement    =  =    null    ?     \" null \"     :    String . valueOf ( valElement . isPhysical (  )  )  )  )     +     \"  ,    sameElements =  \"  )     +     ( tElement    =  =     ( value . getXmlElement (  )  )  )  )     +     \"  \\ n \"  )  )  ;", "if    (  ( tElement    !  =    null )     &  &     ( valElement    !  =    null )  )     {", "diag . append (  (  (  (  (  \"       sameFile =  \"     +     (  ( tElement . getContainingFile (  )  )     =  =     ( valElement . getContainingFile (  )  )  )  )     +     \"  ,    sameParent =  \"  )     +     (  ( tElement . getParent (  )  )     =  =     ( valElement . getParent (  )  )  )  )     +     \"  \\ n \"  )  )  ;", "}", "}", "}", "if    ( parentTag    !  =    null )     {", "diag . append (  \" Parent   tag :     \"  )  . append ( parentTag . getName (  )  )  . append (  \"  \\ n \"  )  ;", "if    ( t   instanceof   GenericAttributeValue )     {", "for    ( XmlAttribute   attribute    :    parentTag . getAttributes (  )  )     {", "diag . append (  \"  ,    attr :     \"  )  . append ( attribute . getName (  )  )  ;", "}", "diag . append (  \"  \\ n \"  )  ;", "} else    {", "for    ( XmlTag   tag    :    parentTag . getSubTags (  )  )     {", "diag . append (  \"  \\ n   subtag :     \"  )  . append ( tag . getName (  )  )  ;", "}", "diag . append (  \"  \\ n \"  )  ;", "}", "}", "diag . append (  \" Child   name :     \"  )  . append ( t . getXmlElementName (  )  )  . append (  \"  ;  \"  )  . append ( t . getXmlElementNamespaceKey (  )  )  ;", ". LOG . error ( diag )  ;", "}", "METHOD_END"], "methodName": ["diagnoseNegativeIndex2"], "fileName": "com.intellij.util.xml.impl.DomAnchorImpl"}, {"methodBody": ["METHOD_START", "{", "for    ( Set < DomFileDescription >    descriptions    :    myRootTagName 2 FileDescription . values (  )  )     {", "for    ( DomFileDescription   description    :    descriptions )     {", "if    (  ( description . getRootElementClass (  )  )     =  =    rootElementClass )     {", "return   description ;", "}", "}", "}", "for    ( DomFileDescription   description    :    myAcceptingOtherRootTagNamesDescriptions )     {", "if    (  ( description . getRootElementClass (  )  )     =  =    rootElementClass )     {", "return   description ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findFileDescription"], "fileName": "com.intellij.util.xml.impl.DomApplicationComponent"}, {"methodBody": ["METHOD_START", "{", "return   myAcceptingOtherRootTagNamesDescriptions ;", "}", "METHOD_END"], "methodName": ["getAcceptingOtherRootTagNameDescriptions"], "fileName": "com.intellij.util.xml.impl.DomApplicationComponent"}, {"methodBody": ["METHOD_START", "{", "final   List < DomFileDescription >    result    =    newArrayList (  )  ;", "for    ( Set < DomFileDescription >    descriptions    :    myRootTagName 2 FileDescription . values (  )  )     {", "result . addAll ( descriptions )  ;", "}", "result . addAll ( myAcceptingOtherRootTagNamesDescriptions )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getAllFileDescriptions"], "fileName": "com.intellij.util.xml.impl.DomApplicationComponent"}, {"methodBody": ["METHOD_START", "{", "return   myClass 2 Annotator . get ( rootElementClass )  ;", "}", "METHOD_END"], "methodName": ["getAnnotator"], "fileName": "com.intellij.util.xml.impl.DomApplicationComponent"}, {"methodBody": ["METHOD_START", "{", "int   result    =     0  ;", "for    ( DomFileDescrip   descrip    :    getAllFileDescrips (  )  )     {", "if    ( forStubs )     {", "if    ( descrip . hasStubs (  )  )     {", "result    +  =    descrip . getStubVersion (  )  ;", "result    +  =    descrip . getRootTagName (  )  . hashCode (  )  ;", "}", "} else    {", "result    +  =    descrip . getVersion (  )  ;", "result    +  =    descrip . getRootTagName (  )  . hashCode (  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getCumulativeVersion"], "fileName": "com.intellij.util.xml.impl.DomApplicationComponent"}, {"methodBody": ["METHOD_START", "{", "return   myRootTagName 2 FileDescription . get ( rootTagName )  ;", "}", "METHOD_END"], "methodName": ["getFileDescriptions"], "fileName": "com.intellij.util.xml.impl.DomApplicationComponent"}, {"methodBody": ["METHOD_START", "{", "return   myCachedImplementationClasses . get ( concreteInterface )  ;", "}", "METHOD_END"], "methodName": ["getImplementation"], "fileName": "com.intellij.util.xml.impl.DomApplicationComponent"}, {"methodBody": ["METHOD_START", "{", "return   ServiceManager . getService ( DomApplicationComponent . class )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "com.intellij.util.xml.impl.DomApplicationComponent"}, {"methodBody": ["METHOD_START", "{", "return   myInvocationCaches . get ( type )  ;", "}", "METHOD_END"], "methodName": ["getInvocationCache"], "fileName": "com.intellij.util.xml.impl.DomApplicationComponent"}, {"methodBody": ["METHOD_START", "{", "return   myGenericInfos . get ( ReflectionUtil . getRawType ( type )  )  ;", "}", "METHOD_END"], "methodName": ["getStaticGenericInfo"], "fileName": "com.intellij.util.xml.impl.DomApplicationComponent"}, {"methodBody": ["METHOD_START", "{", "return   myTypeChooserManager ;", "}", "METHOD_END"], "methodName": ["getTypeChooserManager"], "fileName": "com.intellij.util.xml.impl.DomApplicationComponent"}, {"methodBody": ["METHOD_START", "{", "return   myVisitorDescriptions . get ( aClass )  ;", "}", "METHOD_END"], "methodName": ["getVisitorDescription"], "fileName": "com.intellij.util.xml.impl.DomApplicationComponent"}, {"methodBody": ["METHOD_START", "{", "myRootTagName 2 FileDescription . get ( description . getRootTagName (  )  )  . add ( description )  ;", "if    ( description . acceptsOtherRootTagNames (  )  )     {", "myAcceptingOtherRootTagNamesDescriptions . add ( description )  ;", "}", "final   Map < Class <  ?    extends   DomElement >  ,    Class <  ?    extends   DomElement >  >    implements    =    description . getImplements (  )  ;", "for    ( final   Map . Entry < Class <  ?    extends   DomElement >  ,    Class <  ?    extends   DomElement >  >    entry    :    implements . entrySet (  )  )     {", "registerImplement ( entry . getKey (  )  ,    entry . getValue (  )  ,    null )  ;", "}", "myTypeChooserManager . copyFrom ( description . getTypeChooserManager (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerFileDescription"], "fileName": "com.intellij.util.xml.impl.DomApplicationComponent"}, {"methodBody": ["METHOD_START", "{", "myCachedImplementationClasses . registerImplementation ( domElementClass ,    implementationClass ,    parentDisposable )  ;", "}", "METHOD_END"], "methodName": ["registerImplementation"], "fileName": "com.intellij.util.xml.impl.DomApplicationComponent"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    o )", "return   true ;", "if    (  !  ( super . equals ( o )  )  )", "return   false ;", "final      that    =     (  (  )     ( o )  )  ;", "if    (  ( myTagName )     !  =    null    ?     !  ( myTagName . equals ( that . myTagName )  )     :     ( that . myTagName )     !  =    null )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.intellij.util.xml.impl.DomChildDescriptionImpl"}, {"methodBody": ["METHOD_START", "{", "int   result    =    super . hashCode (  )  ;", "result    =     (  3  1     *    result )     +     (  ( myTagName )     !  =    null    ?    myTagName . hashCode (  )     :     0  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.intellij.util.xml.impl.DomChildDescriptionImpl"}, {"methodBody": ["METHOD_START", "{", "final   XmlAttributeValue   element    =    PsiTreeUtil . getParentOfType ( parameters . getPosition (  )  ,    XmlAttributeValue . class )  ;", "if    ( element    =  =    null )     {", "return   false ;", "}", "if    (  . isSchemaEnumerated ( element )  )     {", "return   false ;", "}", "final   PsiElement   parent    =    element . getParent (  )  ;", "if    ( parent   instanceof   XmlAttribute )     {", "XmlAttributeDescriptor   descriptor    =     (  ( XmlAttribute )     ( parent )  )  . getDescriptor (  )  ;", "if    (  ( descriptor    !  =    null )     &  &     (  ( descriptor . getDefaultValue (  )  )     !  =    null )  )     {", "final   PsiReference [  ]    references    =    myProvider . getReferencesByElement ( element ,    new   ProcessingContext (  )  )  ;", "if    (  ( references . length )     >     0  )     {", "return   LegacyCompletionContributor . completeReference ( parameters ,    result )  ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["domKnowsBetter"], "fileName": "com.intellij.util.xml.impl.DomCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "if    ( element   instanceof   XmlTag )     {", "final   XmlTag   simpleContent    =    XmlUtil . getSchemaSimpleContent (  (  ( XmlTag )     ( element )  )  )  ;", "if    (  ( simpleContent    !  =    null )     &  &     ( XmlUtil . collectEnumerationValues ( simpleContent ,    new   HashSet <  >  (  )  )  )  )     {", "return   true ;", "}", "}", "if    ( element   instanceof   XmlAteValue )     {", "final   PsiElement   parent    =    element . getParent (  )  ;", "if    ( parent   instanceof   XmlAte )     {", "final   XmlAteDescriptor   descriptor    =     (  ( XmlAte )     ( parent )  )  . getDescriptor (  )  ;", "if    (  ( descriptor    !  =    null )     &  &     ( descriptor . isEnumerated (  )  )  )     {", "return   true ;", "}", "String [  ]    enumeratedValues    =    XmlAteValueGetter . getEnumeratedValues (  (  ( XmlAte )     ( parent )  )  )  ;", "if    (  ( enumeratedValues . length )     >     0  )     {", "String   value    =     ( descriptor    =  =    null )     ?    null    :    descriptor . getDefaultValue (  )  ;", "if    (  (  ( value    =  =    null )     |  |     (  ( enumeratedValues . length )     !  =     1  )  )     |  |     (  !  ( value . equals ( enumeratedValues [  0  ]  )  )  )  )     {", "return   true ;", "}", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isSchemaEnumerated"], "fileName": "com.intellij.util.xml.impl.DomCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( myFile . isValid (  )  )  )     {", "return    \" Invalid   file \"  ;", "}", "final    < DomElement >    fileElement    =    myManager . getFileElement ( myFile )  ;", "if    (  !  ( equals ( fileElement )  )  )     {", "return    (  (  \" file   element   changed :     \"     +    fileElement )     +     \"  ;    fileType =  \"  )     +     ( myFile . getFileType (  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["checkValidity"], "fileName": "com.intellij.util.xml.impl.DomFileElementImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    o )", "return   true ;", "if    (  !  ( o   instanceof    )  )", "return   false ;", "final      that    =     (  (  )     ( o )  )  ;", "if    (  ( myFile )     !  =    null    ?     !  ( myFile . equals ( that . myFile )  )     :     ( that . myFile )     !  =    null )", "return   false ;", "if    (  ( myRootElementClass )     !  =    null    ?     !  ( myRootElementClass . equals ( that . myRootElementClass )  )     :     ( that . myRootElementClass )     !  =    null )", "return   false ;", "if    (  ( myRootTagName )     !  =    null    ?     !  ( myRootTagName . equals ( that . myRootTagName )  )     :     ( that . myRootTagName )     !  =    null )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.intellij.util.xml.impl.DomFileElementImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( DomFileElementImpl < T >  )     ( this )  )  ;", "}", "METHOD_END"], "methodName": ["getRoot"], "fileName": "com.intellij.util.xml.impl.DomFileElementImpl"}, {"methodBody": ["METHOD_START", "{", "return   myRootHandler ;", "}", "METHOD_END"], "methodName": ["getRootHandler"], "fileName": "com.intellij.util.xml.impl.DomFileElementImpl"}, {"methodBody": ["METHOD_START", "{", "int   result ;", "result    =     (  ( myFile )     !  =    null )     ?    myFile . hashCode (  )     :     0  ;", "result    =     (  3  1     *    result )     +     (  ( myRootClass )     !  =    null    ?    myRootClass . hashCode (  )     :     0  )  ;", "result    =     (  3  1     *    result )     +     (  ( myRootTagName )     !  =    null    ?    myRootTagName . hashCode (  )     :     0  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.intellij.util.xml.impl.DomFileElementImpl"}, {"methodBody": ["METHOD_START", "{", "return    \" File    \"     +     ( myFile . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.util.xml.impl.DomFileElementImpl"}, {"methodBody": ["METHOD_START", "{", "for    ( final   AbstractDomChildrenDescription   description    :    getChildrenDescriptions (  )  )     {", "if    (  ( description   instanceof   DomChildDescriptionImpl )     &  &     (  ( description   instanceof   AttributeChildDescriptionImpl )     =  =    attribute )  )     {", "final   XmlName   xmlName    =     (  ( DomChildDescriptionImpl )     ( description )  )  . getXmlName (  )  ;", "if    (  ( attribute    &  &     ( StringUisEmpty ( namespace )  )  )     &  &     ( xmlName . getLocalName (  )  . equals ( localName )  )  )", "return   description ;", "final   EvaluatedXmlName   evaluatedXmlName    =    handler . createEvaluatedXmlName ( xmlName )  ;", "if    ( DomImplUisNameSuitable ( evaluatedXmlName ,    localName ,    qName ,    namespace ,    handler . getFile (  )  )  )     {", "return   description ;", "}", "}", "}", "List <  ?    extends   CustomDomChildrenDescription >    list    =    getCustomNameChildrenDescription (  )  ;", "for    ( CustomDomChildrenDescription   description    :    list )     {", "if    ( attribute )     {", "} else", "if    (  ( description . getTagNameDescriptor (  )  )     !  =    null )     {", "return   description ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findChildrenDescription"], "fileName": "com.intellij.util.xml.impl.DomGenericInfoEx"}, {"methodBody": ["METHOD_START", "{", "if    ( element   instanceof   DomFileElementImpl )     {", "final   String   s    =     (  ( DomFileElementImpl )     ( element )  )  . checkValidity (  )  ;", "if    ( s    !  =    null )     {", "throw   new   AssertionError ( s )  ;", "}", "return ;", "}", "final   DomInvocationHandler   handler    =    DomManagerImpl . getDomInvocationHandler ( element )  ;", "assert   handler    !  =    null ;", "try    {", "handler . assertValid (  )  ;", "}    catch    ( AssertionError   e )     {", "throw   new   AssertionError (  ( msg    +     ( e . getMessage (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertValidity"], "fileName": "com.intellij.util.xml.impl.DomImplUtil"}, {"methodBody": ["METHOD_START", "{", "return   DomImplUtil . createXmlName ( name ,    method . getGenericReturnType (  )  ,    method )  ;", "}", "METHOD_END"], "methodName": ["createXmlName"], "fileName": "com.intellij.util.xml.impl.DomImplUtil"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >    aClass    =    DomImplUtil . getErasure ( type )  ;", "if    ( aClass    =  =    null )", "return   null ;", "String   key    =    DomImplUtil . getNamespaceKey ( aClass )  ;", "if    (  ( key    =  =    null )     &  &     ( javaMethod    !  =    null )  )     {", "for    ( final   Method   method    :    getHierarchy (  )  )     {", "final   String   key 1     =    DomImplUtil . getNamespaceKey ( method . getDeclaringClass (  )  )  ;", "if    ( key 1     !  =    null )     {", "return   new   XmlName ( name ,    key 1  )  ;", "}", "}", "}", "return   new   XmlName ( name ,    key )  ;", "}", "METHOD_END"], "methodName": ["createXmlName"], "fileName": "com.intellij.util.xml.impl.DomImplUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( tag . isValid (  )  )  )     {", "throw   new   AssertionError (  \" Invalid   tag \"  )  ;", "}", "final   XmlTag [  ]    tags    =    tag . getSubTags (  )  ;", "if    (  ( tags . length )     =  =     0  )     {", "return   Collections . emptyList (  )  ;", "}", "return   ContainerUtil . findAll ( tags ,     (    childTag )     -  >     {", "try    {", "return   isNameSuitable ( name ,    childTag . getLocalName (  )  ,    childTag . getName (  )  ,    childTag . getNamespace (  )  ,    file )  ;", "}    catch    (    e )     {", "if    (  !  ( childTag . isValid (  )  )  )     {", ". LOG . error (  (  (  (  (  (  (  (  \" tag . getSubTags (  )    returned   invalid ,     \"     +     \" tag =  \"  )     +    tag )     +     \"  ,     \"  )     +     \" containing   file :     \"  )     +     ( tag . getContainingFile (  )  )  )     +     \" subTag . parent =  \"  )     +     ( childTag . getNode (  )  . getTreeParent (  )  )  )  )  ;", "return   false ;", "}", "throw   e ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["findSubTags"], "fileName": "com.intellij.util.xml.impl.DomImplUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  ( tags . length )     =  =     0  )     {", "return   Collections . emptyList (  )  ;", "}", "return   ContainerUfindAll ( tags ,     (    childTag )     -  >    isNameSuitable ( name ,    childTag ,    file )  )  ;", "}", "METHOD_END"], "methodName": ["findSubTags"], "fileName": "com.intellij.util.xml.impl.DomImplUtil"}, {"methodBody": ["METHOD_START", "{", "while    ( true )     {", "final   PsiElement   parentTag    =    PhysicalParentStrategy . getParentTagCandidate ( tag )  ;", "if    (  !  ( parentTag   instanceof   XmlTag )  )     {", "return    (  ( XmlFile )     ( tag . getContainingFile (  )  )  )  ;", "}", "tag    =     (  ( XmlTag )     ( parentTag )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getContainingFile"], "fileName": "com.intellij.util.xml.impl.DomImplUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  ( subTags . length )     =  =     0  )     {", "return   Collections . emptyList (  )  ;", "}", "final   DomGenericInfoEx   info    =    handler . getGenericInfo (  )  ;", "final   Set < XmlName >    usedNames    =    new   gnu . trove . THashSet (  )  ;", "List <  ?    extends   DomCollectionChildDescription >    collectionChildrenDescriptions    =    info . getCollectionChildrenDescriptions (  )  ;", "for    ( int   i    =     0  ,    size    =    collectionChildrenDescriptions . size (  )  ;    i    <    size ;    i +  +  )     {", "DomCollectionChildDescription   description    =    collectionChildrenDescriptions . get ( i )  ;", "usedNames . add ( description . getXmlName (  )  )  ;", "}", "List <  ?    extends   DomFixedChildDescription >    fixedChildrenDescriptions    =    info . getFixedChildrenDescriptions (  )  ;", "for    ( int   i    =     0  ,    size    =    fixedChildrenDescriptions . size (  )  ;    i    <    size ;    i +  +  )     {", "DomFixedChildDescription   description    =    fixedChildrenDescriptions . get ( i )  ;", "usedNames . add ( description . getXmlName (  )  )  ;", "}", "return   ContainerUfindAll ( subTags ,     (    tag )     -  >     {", "if    ( StringUisEmpty ( tag . getName (  )  )  )", "return   false ;", "for    ( final   XmlName   name    :    usedNames )     {", "if    ( isNameSuitable ( name ,    tag ,    handler ,    file )  )     {", "return   false ;", "}", "}", "return   true ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["getCustomSubTags"], "fileName": "com.intellij.util.xml.impl.DomImplUtil"}, {"methodBody": ["METHOD_START", "{", "Class   aClass    =    null ;", "if    ( isAttribute )     {", "NameStrategyForAttributes   annotation    =    DomReflectionUtil . findAnnotationDFS ( rawType ,    NameStrategyForAttributes . class )  ;", "if    ( annotation    !  =    null )     {", "aClass    =    annotation . value (  )  ;", "}", "}", "if    ( aClass    =  =    null )     {", "NameStrategy   annotation    =    DomReflectionUtil . findAnnotationDFS ( rawType ,    NameStrategy . class )  ;", "if    ( annotation    !  =    null )     {", "aClass    =    annotation . value (  )  ;", "}", "}", "if    ( aClass    !  =    null )     {", "if    ( HyphenNameStrategy . class . equals ( aClass )  )", "return   DomNameStrategy . HYPHEN _ STRATEGY ;", "if    ( JavaNameStrategy . class . equals ( aClass )  )", "return   DomNameStrategy . JAVA _ STRATEGY ;", "try    {", "return    (  ( DomNameStrategy )     ( aClass . newInstance (  )  )  )  ;", "}    catch    ( InstantiationException    |    IllegalAccessException   e )     {", ". LOG . error ( e )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDomNameStrategy"], "fileName": "com.intellij.util.xml.impl.DomImplUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( type   instanceof   Class )     {", "return    (  ( Class )     ( type )  )  ;", "}", "if    ( type   instanceof   ParameterizedType )     {", "return    . getErasure (  (  ( ParameterizedType )     ( type )  )  . getRawType (  )  )  ;", "}", "if    ( type   instanceof   TypeVariable )     {", "for    ( final   Type   bound    :     (  ( TypeVariable )     ( type )  )  . getBounds (  )  )     {", "final   Class <  ?  >    aClass    =     . getErasure ( bound )  ;", "if    ( aClass    !  =    null )     {", "return   aClass ;", "}", "}", "}", "if    ( type   instanceof   WildcardType )     {", "final   WildcardType   wildcardType    =     (  ( WildcardType )     ( type )  )  ;", "for    ( final   Type   bound    :    wildcardType . getUpperBounds (  )  )     {", "final   Class <  ?  >    aClass    =     . getErasure ( bound )  ;", "if    ( aClass    !  =    null )     {", "return   aClass ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getErasure"], "fileName": "com.intellij.util.xml.impl.DomImplUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( domElement   instanceof   DomFileElement )     {", "return    (  ( DomFileElement )     ( domElement )  )  . getFile (  )  ;", "}", "DomInvocationHandler   handler    =    DomManagerImpl . getDomInvocationHandler ( domElement )  ;", "assert   handler    !  =    null    :    domElement ;", "while    ( true )     {", "if    ( handler   instanceof   DomRootInvocationHandler )     {", "return    (  ( DomRootInvocationHandler )     ( handler )  )  . getParent (  )  . getFile (  )  ;", "}", "XmlTag   tag    =    handler . getXmlTag (  )  ;", "if    ( tag    !  =    null )     {", "return    . getContainingFile ( tag )  ;", "}", "DomInvocationHandler   parent    =    handler . getParentHandler (  )  ;", "if    ( parent    =  =    null )     {", "throw   new   AssertionError (  (  \" No   parent   for    \"     +     ( handler . toStringEx (  )  )  )  )  ;", "}", "handler    =    parent ;", "}", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "com.intellij.util.xml.impl.DomImplUtil"}, {"methodBody": ["METHOD_START", "{", "final   Namespace   namespace    =    DomReflectionUtil . findAnnotationDFS ( type ,    Namespace . class )  ;", "return   namespace    !  =    null    ?    namespace . value (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getNamespaceKey"], "fileName": "com.intellij.util.xml.impl.DomImplUtil"}, {"methodBody": ["METHOD_START", "{", "return    ( method . getAnnotation ( TagValue . class )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasTagValueAnnotation"], "fileName": "com.intellij.util.xml.impl.DomImplUtil"}, {"methodBody": ["METHOD_START", "{", "@ NonNls", "final   String   name    =    method . getName (  )  ;", "final   boolean   isGet    =    name . startsWith (  \" get \"  )  ;", "final   boolean   isIs    =     (  ! isGet )     &  &     ( name . startsWith (  \" is \"  )  )  ;", "if    (  (  ! isGet )     &  &     (  ! isIs )  )     {", "return   false ;", "}", "if    (  ( method . getGenericParameterTypes (  )  . length )     !  =     0  )     {", "return   false ;", "}", "final   Type   returnType    =    method . getGenericReturnType (  )  ;", "if    ( isGet )     {", "return   returnType    !  =     ( void . class )  ;", "}", "return   DomReflectionUcanHaveIsPropertyGetterPrefix ( returnType )  ;", "}", "METHOD_END"], "methodName": ["isGetter"], "fileName": "com.intellij.util.xml.impl.DomImplUtil"}, {"methodBody": ["METHOD_START", "{", "return   DomImplUtil . isNameSuitable ( evaluatedXmlName ,    tag . getLocalName (  )  ,    tag . getName (  )  ,    tag . getNamespace (  )  ,    file )  ;", "}", "METHOD_END"], "methodName": ["isNameSuitable"], "fileName": "com.intellij.util.xml.impl.DomImplUtil"}, {"methodBody": ["METHOD_START", "{", "final   String   localName 1     =    evaluatedXmlName . getXmlName (  )  . getLocalName (  )  ;", "return    (  ( localName 1  . equals ( localName )  )     |  |     ( localName 1  . equals ( qName )  )  )     &  &     ( evaluatedXmlName . isNamespaceAllowed ( namespace ,    file ,     (  !  ( localName 1  . equals ( qName )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isNameSuitable"], "fileName": "com.intellij.util.xml.impl.DomImplUtil"}, {"methodBody": ["METHOD_START", "{", "return   DomImplUtil . isNameSuitable ( handler . createEvaluatedXmlName ( name )  ,    tag ,    file )  ;", "}", "METHOD_END"], "methodName": ["isNameSuitable"], "fileName": "com.intellij.util.xml.impl.DomImplUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( DomImplUtil . isGetter ( method )  )  )     {", "return   false ;", "}", "if    ( DomImplUtil . hasTagValueAnnotation ( method )  )     {", "return   true ;", "}", "if    (  \" getValue \"  . equals ( method . getName (  )  )  )     {", "if    (  ( method . getAnnotation ( SubTag . class )  )     !  =    null )", "return   false ;", "if    (  ( method . getAnnotation ( SubTagList . class )  )     !  =    null )", "return   false ;", "if    (  (  ( method . getAnnotation ( Convert . class )  )     !  =    null )     |  |     (  ( method . getAnnotation ( Resolve . class )  )     !  =    null )  )     {", "return    !  ( ReflectionUtil . isAssignable ( GenericDomValue . class ,    method . getReturnType (  )  )  )  ;", "}", "if    ( ReflectionUtil . isAssignable ( DomElement . class ,    method . getReturnType (  )  )  )", "return   false ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isTagValueGetter"], "fileName": "com.intellij.util.xml.impl.DomImplUtil"}, {"methodBody": ["METHOD_START", "{", "boolean   setter    =     (  ( method . getName (  )  . startsWith (  \" set \"  )  )     &  &     (  ( method . getGenericParameterTypes (  )  . length )     =  =     1  )  )     &  &     (  ( method . getReturnType (  )  )     =  =     ( void . class )  )  ;", "return   setter    &  &     (  (  . hasTagValueAnnotation ( method )  )     |  |     (  \" setValue \"  . equals ( method . getName (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isTagValueSetter"], "fileName": "com.intellij.util.xml.impl.DomImplUtil"}, {"methodBody": ["METHOD_START", "{", "return   findClassNoExceptions ( implementationName )  ;", "}", "METHOD_END"], "methodName": ["getImplementationClass"], "fileName": "com.intellij.util.xml.impl.DomImplementationClassEP"}, {"methodBody": ["METHOD_START", "{", "return   findClassNoExceptions ( interfaceName )  ;", "}", "METHOD_END"], "methodName": ["getInterfaceClass"], "fileName": "com.intellij.util.xml.impl.DomImplementationClassEP"}, {"methodBody": ["METHOD_START", "{", "while    (  ( element    !  =    null )     &  &     (  !  ( requiredClass . isInstance ( element )  )  )  )     {", "element    =    element . getParent (  )  ;", "}", "return    (  ( T )     ( element )  )  ;", "}", "METHOD_END"], "methodName": ["_getParentOfType"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "final   EvaluatedXmlName   name    =    createEvaluatedXmlName ( description . getXmlName (  )  )  ;", "final   XmlTag   tag    =    addEmptyTag ( name ,    index )  ;", "final   CollectionElement   handler    =    new   CollectionElement ( type ,    tag ,    description ,    this ,    null )  ;", "myManager . fireEvent ( new   DomEvent ( getProxy (  )  ,    false )  )  ;", "getManager (  )  . getTypeChooserManager (  )  . getTypeChooser ( description . getType (  )  )  . distinguishTag ( tag ,    type )  ;", "handler . addRequiredChildren (  )  ;", "return   handler . getProxy (  )  ;", "}", "METHOD_END"], "methodName": ["addCollectionChild"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    ensureTagExists (  )  ;", "final   List < XmlTag >    subTags    =    DomImplUfindSubTags ( tag ,    tagName ,    getFile (  )  )  ;", "if    (  ( subTags . size (  )  )     <    index )     {", "index    =    subTags . size (  )  ;", "}", "final   boolean   changing    =    myManager . setChanging ( true )  ;", "try    {", "XmlTag   newTag    =    createChildTag ( tagName )  ;", "if    ( index    =  =     0  )     {", "if    ( subTags . isEmpty (  )  )     {", "return    (  ( XmlTag )     ( tag . add ( newTag )  )  )  ;", "}", "return    (  ( XmlTag )     ( tag . addBefore ( newTag ,    subTags . get (  0  )  )  )  )  ;", "}", "return    (  ( XmlTag )     ( tag . addAfter ( newTag ,    subTags . get (  ( index    -     1  )  )  )  )  )  ;", "}    finally    {", "myManager . setChanging ( changing )  ;", "}", "}", "METHOD_END"], "methodName": ["addEmptyTag"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "for    ( final   AbstractDomChildrenDescription   description    :    getGenericInfo (  )  . getChildrenDescriptions (  )  )     {", "if    ( description   instanceof   DomAttributeChildDescription )     {", "final   Required   required    =    description . getAnnotation ( Required . class )  ;", "if    (  ( required    !  =    null )     &  &     ( required . value (  )  )  )     {", "description . getValues ( getProxy (  )  )  . get (  0  )  . ensureXmlElementExists (  )  ;", "}", "} else", "if    ( description   instanceof   reflect . DomFixedChildDescription )     {", "final   reflect . DomFixedChildDescription   childDescription    =     (  ( reflect . DomFixedChildDescription )     ( description )  )  ;", "List <  ?    extends   DomElement >    values    =    null ;", "final   int   count    =    childDescription . getCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "final   Required   required    =    childDescription . getAnnotation ( i ,    Required . class )  ;", "if    (  ( required    !  =    null )     &  &     ( required . value (  )  )  )     {", "if    ( values    =  =    null )     {", "values    =    description . getValues ( getProxy (  )  )  ;", "}", "values . get ( i )  . ensureTagExists (  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["addRequiredChildren"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "final   String   s    =    checkValidity (  )  ;", "if    ( s    !  =    null )     {", "throw   new   AsserError (  (  (  (  (  (  (  (  (  ( myType . toString (  )  )     +     \"     @  \"  )     +     ( hashCode (  )  )  )     +     \"  \\ nclass =  \"  )     +     ( getClass (  )  )  )     +     \"  \\ nxml =  \"  )     +     ( getXmlElement (  )  )  )     +     \"  ;     \"  )     +    s )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertValid"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "ProgressManager . checkCanceled (  )  ;", "final   DomParentStrategy   parentStrategy    =    getParentStrategy (  )  ;", "String   error    =    parentStrategy . checkValidity (  )  ;", "if    ( error    !  =    null )     {", "return    \" Strategy :     \"     +    error ;", "}", "final   long   modCount    =    myManager . getPsiModificationCount (  )  ;", "if    (  ( myLastModCount )     =  =    modCount )     {", "return   null ;", "}", "final   XmlElement   xmlElement    =    parentStrategy . getXmlElement (  )  ;", "if    ( xmlElement    !  =    null )     {", "final      actual    =    myManager . getDomHandler ( xmlElement )  ;", "if    (  !  ( equals ( actual )  )  )     {", "return    (  (  \" element   changed :     \"     +     ( this . toStringEx (  )  )  )     +     \"  !  =  \"  )     +     ( actual    =  =    null    ?    null    :    actual . toStringEx (  )  )  ;", "}", "myLastModCount    =    modCount ;", "return   null ;", "}", "final      parent    =    getParentHandler (  )  ;", "if    ( parent    =  =    null )     {", "return    \" no   parent :     \"     +     ( getDomElementType (  )  )  ;", "}", "error    =    parent . checkValidity (  )  ;", "if    ( error    !  =    null )     {", "return    \" parent :     \"     +    error ;", "}", "myLastModCount    =    modCount ;", "return   null ;", "}", "METHOD_END"], "methodName": ["checkValidity"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "final   String   localName    =    tagName . getXmlName (  )  . getLocalName (  )  ;", "if    ( localName . contains (  \"  :  \"  )  )     {", "try    {", "return   XmlElementFactory . getInstance ( myManager . getProject (  )  )  . createTagFromText (  (  (  \"  <  \"     +    localName )     +     \"  /  >  \"  )  )  ;", "}    catch    ( IncorrectOperationException   e )     {", ". LOG . error ( e )  ;", "}", "}", "final   XmlElement   element    =    getXmlElement (  )  ;", "assert   element    !  =    null ;", "return   getXmlTag (  )  . createChildTag ( localName ,    tagName . getNamespace ( element ,    getFile (  )  )  ,    null ,    false )  ;", "}", "METHOD_END"], "methodName": ["createChildTag"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "final   Type   returnType    =    method . getGenericReturnType (  )  ;", "final   Type   type    =     ( returnType    =  =     ( void . class )  )     ?    method . getGenericParameterTypes (  )  [  0  ]     :    returnType ;", "final   Class   parameter    =    DomUtil . substituteGenericType ( type ,    myType )  ;", "if    ( parameter    =  =    null )     {", ". LOG . error (  (  ( type    +     \"     \"  )     +     ( myType )  )  )  ;", "}", "Converter   converter    =    getConverter ( new   AnnotatedElement (  )     {", "@ Override", "public    < T   extends   Annotation >    T   getAnnotation ( Class < T >    annotationClass )     {", "return   myInvocationCache . getMethodAnnotation ( method ,    annotationClass )  ;", "}", "}  ,    parameter )  ;", "if    (  ( converter    =  =    null )     &  &     ( type   instanceof   TypeVariable )  )     {", "converter    =    getConverter ( this ,    DomUtil . getGenericValueParameter ( myType )  )  ;", "}", "if    ( converter    =  =    null )     {", "converter    =    myManager . getConverterManager (  )  . getConverterByClass ( parameter )  ;", "}", "if    ( converter    =  =    null )     {", "throw   new   AssertionError (  (  (  (  (  (  \" No   converter   specified :    String <  -  >  \"     +     ( parameter . getName (  )  )  )     +     \"  ;    method =  \"  )     +    method )     +     \"  ;    place =  \"  )     +     ( myChildDescription )  )  )  ;", "}", "return   converter ;", "}", "METHOD_END"], "methodName": ["createConverter"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "return   getXmlName (  )  . evaluateChildName ( xmlName )  ;", "}", "METHOD_END"], "methodName": ["createEvaluatedXmlName"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    ensureTagExists (  )  ;", "final   List < XmlTag >    subTags    =    DomImplUfindSubTags ( tag ,    tagName ,    getFile (  )  )  ;", "if    (  ( subTags . size (  )  )     <    count )     {", "getFixedChild ( Pair . create ( description ,     ( count    -     1  )  )  )  . ensureTagExists (  )  ;", "}", "}", "METHOD_END"], "methodName": ["createFixedChildrenTags"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["createPathStableCopy"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "final   boolean   changing    =    myManager . setChanging ( true )  ;", "try    {", "tag . delete (  )  ;", "}    catch    ( IncorrectOperationException   e )     {", ". LOG . error ( e )  ;", "}    finally    {", "myManager . setChanging ( changing )  ;", "}", "}", "METHOD_END"], "methodName": ["deleteTag"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "setXmlElement ( null )  ;", "}", "METHOD_END"], "methodName": ["detach"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    o )", "return   true ;", "if    (  ( o    =  =    null )     |  |     (  !  ( o . getClass (  )  . equals ( getClass (  )  )  )  )  )", "return   false ;", "final      that    =     (  (  )     ( o )  )  ;", "if    (  !  ( myChildDescription . equals ( that . myChildDescription )  )  )", "return   false ;", "if    (  !  ( getParentStrategy (  )  . equals ( that . getParentStrategy (  )  )  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "Invocation   invocation    =    myAccessorInvocations . get ( method )  ;", "if    ( invocation    !  =    null )", "return   invocation ;", "invocation    =    myInvocationCache . getInvocation ( method )  ;", "if    ( invocation    !  =    null )", "return   invocation ;", "JavaMethod   javaMethod    =    myInvocationCache . getInternedMethod ( method )  ;", "invocation    =    myGenericInfo . createInvocation ( javaMethod )  ;", "if    ( invocation    !  =    null )     {", "myInvocationCache . putInvocation ( method ,    invocation )  ;", "return   invocation ;", "}", "if    ( myInvocationCache . isTagValueGetter ( javaMethod )  )     {", "invocation    =    new   GetInvocation ( createConverter ( javaMethod )  )  ;", "} else", "if    ( myInvocationCache . isTagValueSetter ( javaMethod )  )     {", "invocation    =    new   SetInvocation ( createConverter ( javaMethod )  )  ;", "} else    {", "throw   new   RuntimeException (  (  (  (  \" No   implementation   for   method    \"     +     ( method . toString (  )  )  )     +     \"    in   class    \"  )     +     ( myType )  )  )  ;", "}", "myAccessorInvocations    =    myAccessorInvocations . plus ( method ,    invocation )  ;", "return   invocation ;", "}", "METHOD_END"], "methodName": ["findInvocation"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "myManager . fireEvent ( new   DomEvent ( getProxy (  )  ,    false )  )  ;", "}", "METHOD_END"], "methodName": ["fireUndefinedEvent"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "final   EvaluatedXmlName   evaluatedXmlName    =    createEvaluatedXmlName ( description . getXmlName (  )  )  ;", "if    (  (  ( myStub )     !  =    null )     &  &     ( description . isStubbed (  )  )  )     {", "AttributeStub   stub    =    myStub . getAttributeStub ( description . getXmlName (  )  )  ;", "StubParentStrategy   strategy    =    StubParentStrategy . createAttributeStrategy ( stub ,    myStub )  ;", "return   new   AttributeChild ( evaluatedXmlName ,    description ,    myManager ,    strategy ,    stub )  ;", "}", "final   XmlTag   tag    =    getXmlTag (  )  ;", "if    ( tag    !  =    null )     {", "String   ns    =    evaluatedXmlName . getNamespace ( tag ,    getFile (  )  )  ;", "final   XmlAttribute   attribute    =    tag . getAttribute ( description . getXmlName (  )  . getLocalName (  )  ,     ( ns . equals ( tag . getNamespace (  )  )     ?    null    :    ns )  )  ;", "if    ( attribute    !  =    null )     {", "PsiUtilCore . ensureValid ( attribute )  ;", "AttributeChild   semElement    =    myManager . getSemService (  )  . getSemElement ( DomManagerImpl . DOM _ ATTRIBUTE _ HANDLER _ KEY ,    attribute )  ;", "if    ( semElement    =  =    null )     {", "final   AttributeChild   take 2     =    myManager . getSemService (  )  . getSemElement ( DomManagerImpl . DOM _ ATTRIBUTE _ HANDLER _ KEY ,    attribute )  ;", "throw   new   AssertionError (  (  (  (  (  (  \" No   DOM   at   XML .    Parent =  \"     +    tag )     +     \"  ;    attribute =  \"  )     +    attribute )     +     \"  ;    second   attempt =  \"  )     +    take 2  )  )  ;", "}", "return   semElement ;", "}", "}", "return   new   AttributeChild ( evaluatedXmlName ,    description ,    myManager ,    new   VirtualDomParentStrategy ( this )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["getAttributeChild"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )    instanceof   AttributeChildInvocationHandler )     {", "return   DomManagerImpl . DOM _ ATTRIBUTE _ HANDLER _ KEY ;", "}", "if    (  ( this )    instanceof   DomRootInvocationHandler )     {", "return   DomManagerImpl . DOM _ HANDLER _ KEY ;", "}", "if    (  ( this )    instanceof   IndexedElementInvocationHandler )     {", "return   DomManagerImpl . DOM _ INDEXED _ HANDLER _ KEY ;", "}", "if    (  ( getChildDescription (  )  )    instanceof   CustomDomChildrenDescription )     {", "return   DomManagerImpl . DOM _ CUSTOM _ HANDLER _ KEY ;", "}", "return   DomManagerImpl . DOM _ COLLECTION _ HANDLER _ KEY ;", "}", "METHOD_END"], "methodName": ["getCacheKey"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "return   myInvocationCache . getClassAnnotation ( annotationClass )  ;", "}", "METHOD_END"], "methodName": ["getClassAnnotation"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( myStub )     !  =    null )     &  &     ( description . isStubbed (  )  )  )     {", "if    ( description   instanceof   DomChildDescriptionImpl )     {", "XmlName   xmlName    =     (  ( DomChildDescriptionImpl )     ( description )  )  . getXmlName (  )  ;", "List < DomStub >    stubs    =    myStub . getChildrenByName ( xmlName . getLocalName (  )  ,    xmlName . getNamespaceKey (  )  )  ;", "return   ContainerUtil . map ( stubs ,     (    stub )     -  >    stub . getOrCreateHandler (  (  ( DomChildDescriptionImpl )     ( description )  )  ,    myManager )  . getProxy (  )  )  ;", "} else", "if    ( description   instanceof   CustomDomChildrenDescriptionImpl )     {", "List < DomStub >    stubs    =    myStub . getChildrenStubs (  )  ;", "return   ContainerUtil . mapNotNull ( stubs ,     (  ( NullableFunction < DomStub ,    DomElement >  )     (  (    stub )     -  >     {", "if    (  ( stub   instanceof   stubs . ElementStub )     &  &     ( stub . isCustom (  )  )  )     {", "EvaluatedXmlName   name    =    new   DummyEvaluatedXmlName ( stub . getName (  )  ,     \"  \"  )  ;", "return   new   CollectionElementInvocationHandler ( name ,     (  ( CustomDomChildrenDescriptionImpl )     ( description )  )  ,    myManager ,     (  ( stubs . ElementStub )     ( stub )  )  )  . getProxy (  )  ;", "}", "return   null ;", "}  )  )  )  ;", "}", "}", "XmlTag   tag    =    getXmlTag (  )  ;", "if    ( tag    =  =    null )", "return   Collections . emptyList (  )  ;", "final   List < XmlTag >    subTags    =    getCollectionSubTags ( description ,    tag )  ;", "if    ( subTags . isEmpty (  )  )", "return   Collections . emptyList (  )  ;", "List < DomElement >    elements    =    new   ArrayList <  >  ( subTags . size (  )  )  ;", "for    ( XmlTag   subTag    :    subTags )     {", "final   SemKey <  ?    extends   DomInvocationHandler >    key    =     ( description   instanceof   CustomDomChildrenDescription )     ?    DomManagerImpl . DOM _ CUSTOM _ HANDLER _ KEY    :    DomManagerImpl . DOM _ COLLECTION _ HANDLER _ KEY ;", "final   DomInvocationHandler   semElement    =    myManager . getSemService (  )  . getSemElement ( key ,    subTag )  ;", "if    ( semElement    =  =    null )     {", "String   msg    =     (  (  (  (  (  (  \" No   child   for   subTag    '  \"     +     ( subTag . getName (  )  )  )     +     \"  '    in   tag    '  \"  )     +     ( tag . getName (  )  )  )     +     \"  '    using   key    \"  )     +    key )     +     \"  ;    subtag   count =  \"  )     +     ( subTags . size (  )  )  ;", "DomInvocationHandler   anyDom    =    myManager . getDomHandler ( subTag )  ;", "if    ( anyDom    !  =    null )     {", "msg    +  =     (  (  \"  \\ n   sub - dom =  \"     +    anyDom )     +     \"    with    \"  )     +     ( anyDom . getChildDescription (  )  )  ;", "}", "throw   new   AssertionError ( msg )  ;", "} else    {", "elements . add ( semElement . getProxy (  )  )  ;", "}", "}", "return   Collections . unmodifiableList ( elements )  ;", "}", "METHOD_END"], "methodName": ["getCollectionChildren"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( description   instanceof   CollectionChildDescriptionImpl )     {", "return    (  ( CollectionChildDescriptionImpl )     ( description )  )  . getCollectionSubTags ( this ,    tag )  ;", "}", "return   DomImplUtil . getCustomSubTags ( this ,    tag . getSubTags (  )  ,    getFile (  )  )  ;", "}", "METHOD_END"], "methodName": ["getCollectionSubTags"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "final   Resolve   resolveAnnotation    =    annotationProvider . getAnnotation ( Resolve . class )  ;", "if    ( resolveAnnotation    !  =    null )     {", "final   Class <  ?    extends   DomElement >    aClass    =    resolveAnnotation . value (  )  ;", "if    (  !  ( DomElement . class . equals ( aClass )  )  )     {", "return   DomResolveConverter . createConverter ( aClass )  ;", "} else    {", ". LOG . assertTrue (  ( parameter    !  =    null )  ,     \" You   should   specify    @ Resolve # value (  )    parameter \"  )  ;", "return   DomResolveConverter . createConverter ( parameter )  ;", "}", "}", "final   ConverterManager   converterManager    =    myManager . getConverterManager (  )  ;", "Convert   convertAnnotation    =    annotationProvider . getAnnotation ( Convert . class )  ;", "if    ( convertAnnotation    !  =    null )     {", "if    ( convertAnnotation   instanceof   ConvertAnnotationImpl )     {", "return    (  ( ConvertAnnotationImpl )     ( convertAnnotation )  )  . getConverter (  )  ;", "}", "return   converterManager . getConverterInstance ( convertAnnotation . value (  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getConverter"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "return   getParentStrategy (  )  . getContainingFile ( this )  ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "final   FixedChildDescriptionImpl   description    =    info . first ;", "XmlName   xmlName    =    description . getXmlName (  )  ;", "final   EvaluatedXmlName   evaluatedXmlName    =    createEvaluatedXmlName ( xmlName )  ;", "if    (  (  ( myStub )     !  =    null )     &  &     ( description . isStubbed (  )  )  )     {", "List < DomStub >    stubs    =    myStub . getChildrenByName ( xmlName . getLocalName (  )  ,    xmlName . getNamespaceKey (  )  )  ;", "DomStub   stub    =     ( stubs . isEmpty (  )  )     ?    null    :    stubs . get (  0  )  ;", "DomParentStrategy   strategy    =     ( stub    =  =    null )     ?    new   StubParentStrategy . Empty ( myStub )     :    new   StubParentStrategy ( stub )  ;", "return   new   IndexedElement ( evaluatedXmlName ,    description ,     0  ,    strategy ,    myManager ,     (  ( ElementStub )     ( stub )  )  )  ;", "}", "final   XmlTag   tag    =    getXmlTag (  )  ;", "final   int   index    =    info . second ;", "if    ( tag    !  =    null )     {", "if    (  !  ( tag . isValid (  )  )  )     {", "throw   new   PsiInvalidElementAccessException ( tag )  ;", "}", "final   XmlTag [  ]    subTags    =    tag . getSubTags (  )  ;", "for    ( int   i    =     0  ,    subTagsLength    =    subTags . length ;    i    <    subTagsLength ;    i +  +  )     {", "XmlTag   xmlTag    =    subTags [ i ]  ;", "if    (  !  ( xmlTag . isValid (  )  )  )     {", "throw   new   PsiInvalidElementAccessException ( xmlTag ,     (  (  (  (  (  \" invalid   children   of   valid   tag :     \"     +     ( tag . getText (  )  )  )     +     \"  ;    subtag =  \"  )     +    xmlTag )     +     \"  ;    index =  \"  )     +    i )  )  ;", "}", "}", "final   List < XmlTag >    tags    =    DomImplUtil . findSubTags ( subTags ,    evaluatedXmlName ,    getFile (  )  )  ;", "if    (  ( tags . size (  )  )     >    index )     {", "final   XmlTag   child    =    tags . get ( index )  ;", "final   IndexedElement   semElement    =    myManager . getSemService (  )  . getSemElement ( DomManagerImpl . DOM _ INDEXED _ HANDLER _ KEY ,    child )  ;", "if    ( semElement    =  =    null )     {", "final   IndexedElement   take 2     =    myManager . getSemService (  )  . getSemElement ( DomManagerImpl . DOM _ INDEXED _ HANDLER _ KEY ,    child )  ;", "throw   new   AssertionError (  (  (  (  (  (  (  (  \" No   DOM   at   XML .    Parent =  \"     +    tag )     +     \"  ;    child =  \"  )     +    child )     +     \"  ;    index =  \"  )     +    index )     +     \"  ;    second   attempt =  \"  )     +    take 2  )  )  ;", "}", "return   semElement ;", "}", "}", "return   new   IndexedElement ( evaluatedXmlName ,    description ,    index ,    new   VirtualDomParentStrategy ( this )  ,    myManager ,    null )  ;", "}", "METHOD_END"], "methodName": ["getFixedChild"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "return   getParentStrategy (  )  . getParentHandler (  )  ;", "}", "METHOD_END"], "methodName": ["getParentHandler"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "myParentStrategy    =    myParentStrategy . refreshStrategy ( this )  ;", "return   myParentStrategy ;", "}", "METHOD_END"], "methodName": ["getParentStrategy"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "DomElement   proxy    =    myProxy ;", "if    ( proxy    =  =    null )     {", "Class <  ?  >    rawType    =    getRawType (  )  ;", "Class <  ?    extends   DomElement >    implementation    =    myManager . getAppliComponent (  )  . getImplementation ( rawType )  ;", "final   boolean   isInterface    =    rawType . isInterface (  )  ;", "if    (  ( implementation    =  =    null )     &  &     (  ! isInterface )  )     {", "implementation    =     (  ( Class <  ?    extends   DomElement >  )     ( rawType )  )  ;", "}", "myProxy    =    proxy    =    AdvancedProxy . createProxy ( this ,    implementation ,     ( isInterface    ?    new   Class [  ]  {    rawType    }     :    ArrayUtil . EMPTY _ CLASS _ ARRAY )  )  ;", "}", "return   proxy ;", "}", "METHOD_END"], "methodName": ["getProxy"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionUtil . getRawType ( myType )  ;", "}", "METHOD_END"], "methodName": ["getRawType"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "Converter   converter    =    myScalarConverter ;", "if    ( converter    =  =    null )     {", "myScalarConverter    =    converter    =    createConverter (  . ourGetValue )  ;", "}", "return   converter ;", "}", "METHOD_END"], "methodName": ["getScalarConverter"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "return   myStub ;", "}", "METHOD_END"], "methodName": ["getStub"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "return   tag . getValue (  )  . getTrimmedText (  )  ;", "}", "METHOD_END"], "methodName": ["getTagValue"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    getXmlTag (  )  ;", "return   tag    =  =    null    ?    null    :     . getTagValue ( tag )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "return   myTagName ;", "}", "METHOD_END"], "methodName": ["getXmlName"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "return   myChildDescription . hashCode (  )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isAttribute"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "return   nominalType ;", "}", "METHOD_END"], "methodName": ["narrowType"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["recomputeXmlElement"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "final   StaticGenericInfo   staticInfo    =    myManager . getApplicationComponent (  )  . getStaticGenericInfo ( myType )  ;", "myGenericInfo    =     ( dynamic )     ?    new   DynamicGenericInfo ( this ,    staticInfo )     :    staticInfo ;", "}", "METHOD_END"], "methodName": ["refreshGenericInfo"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "tag . getValue (  )  . setText ( value )  ;", "}", "METHOD_END"], "methodName": ["setTagValue"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    ensureTagExists (  )  ;", "myManager . runChange (  (  )     -  >     . setTagValue ( tag ,    value )  )  ;", "myManager . fireEvent ( new   DomEvent ( getProxy (  )  ,    false )  )  ;", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "refreshGenericInfo (  (  ( element    !  =    null )     &  &     (  !  ( isAttribute (  )  )  )  )  )  ;", "myStub    =    null ;", "myParentStrategy    =     ( element    =  =    null )     ?    myParentStrategy . clearXmlElement (  )     :    myParentStrategy . setXmlElement ( element )  ;", "}", "METHOD_END"], "methodName": ["setXmlElement"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( ReflectionUtil . isAssignable ( GenericValue . class ,    getRawType (  )  )  )     {", "return    (  ( GenericValue )     ( getProxy (  )  )  )  . getStringValue (  )  ;", "}", "return    (  ( myType . toString (  )  )     +     \"     @  \"  )     +     ( hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  (  (  ( myType . toString (  )  )     +     \"     @  \"  )     +     ( hashCode (  )  )  )     +     \"  & handler =  \"  )     +     ( super . toString (  )  )  )     +     \"  & cd =  \"  )     +     ( myChildDescription )  )     +     \"  & ps =  \"  )     +     ( myParentStrategy )  ;", "}", "METHOD_END"], "methodName": ["toStringEx"], "fileName": "com.intellij.util.xml.impl.DomInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "mySemService . setCachedSemElement ( key ,    element ,    handler )  ;", "}", "METHOD_END"], "methodName": ["cacheHandler"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( file   instanceof   NewVirtualFile )  )     |  |     ( myProject . isDisposed (  )  )  )     {", "return   Collections . emptyList (  )  ;", "}", "final   List < DomEvent >    events    =    ContainerUtil . newArrayList (  )  ;", "VfsUtilCore . visitChildrenRecursively ( file ,    new   VirtualFileVisitor (  )     {", "@ Override", "public   boolean   visitFile (  @ NotNull", "VirtualFile   file )     {", "if    (  ( myProject . isDisposed (  )  )     |  |     (  !  ( SERVICE . getInstance ( myProject )  . isInContent ( file )  )  )  )     {", "return   false ;", "}", "if    (  (  !  ( file . isDirectory (  )  )  )     &  &     (  ( StdFileTypes . XML )     =  =     ( file . getFileType (  )  )  )  )     {", "final   PsiFile   psiFile    =    getCachedPsiFile ( file )  ;", "if    (  (  ( psiFile    !  =    null )     &  &     ( XML . equals ( psiFile . getFileType (  )  )  )  )     &  &     ( psiFile   instanceof   XmlFile )  )     {", "final   DomFileElementImpl   domElement    =     . getCachedFileElement (  (  ( XmlFile )     ( psiFile )  )  )  ;", "if    ( domElement    !  =    null )     {", "events . add ( new   DomEvent ( domElement ,    false )  )  ;", "}", "}", "}", "return   true ;", "}", "@ Nullable", "@ Override", "public   Iterable < VirtualFile >    getChildrenIterable (  @ NotNull", "VirtualFile   file )     {", "return    (  ( NewVirtualFile )     ( file )  )  . getCachedChildren (  )  ;", "}", "}  )  ;", "return   events ;", "}", "METHOD_END"], "methodName": ["calcDomChangeEvents"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "final   DomGenericInfoEx   info    =    parent . getGenericInfo (  )  ;", "return   info . findChildrenDescription ( parent ,    tag . getLocalName (  )  ,    tag . getNamespace (  )  ,    false ,    tag . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["findChildrenDescription"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( mySemService . isInsideAtomicChange (  )  )", "return ;", "incModificationCount (  )  ;", "myListeners . getMulticaster (  )  . eventOccured ( event )  ;", "}", "METHOD_END"], "methodName": ["fireEvent"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "for    ( DomEvent   event    :    events )     {", "fireEvent ( event )  ;", "}", "}", "METHOD_END"], "methodName": ["fireEvents"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "return   myApplicationComponent . getAcceptingOtherRootTagNameDescriptions (  )  ;", "}", "METHOD_END"], "methodName": ["getAcceptingOtherRootTagNameDescriptions"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "return   myApplicationComponent ;", "}", "METHOD_END"], "methodName": ["getApplicationComponent"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "return   SoftReference . dereference ( file . getUserData ( DomManagerImpl . CACHED _ FILE _ ELEMENT )  )  ;", "}", "METHOD_END"], "methodName": ["getCachedFileElement"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "return   PsiManagerEx . getInstanceEx ( myProject )  . getFileManager (  )  . getCachedPsiFile ( file )  ;", "}", "METHOD_END"], "methodName": ["getCachedPsiFile"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "return   getClass (  )  . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getComponentName"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( element   instanceof   XmlElement )     {", "final   PsiFile   psiFile    =    element . getContainingFile (  )  ;", "if    ( psiFile   instanceof   XmlFile )     {", "return   getFileDescription (  (  ( XmlFile )     ( psiFile )  )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDomFileDescription"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( tag    =  =    null )", "return   null ;", "List < DomInvocationHandler >    cached    =    mySemService . getCachedSemElements (  . DOM _ HANDLER _ KEY ,    tag )  ;", "if    (  ( cached    !  =    null )     &  &     (  !  ( cached . isEmpty (  )  )  )  )     {", "return   cached . get (  0  )  ;", "}", "return   mySemService . getSemElement (  . DOM _ HANDLER _ KEY ,    tag )  ;", "}", "METHOD_END"], "methodName": ["getDomHandler"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( proxy   instanceof   DomFileElement )     {", "return   null ;", "}", "if    ( proxy   instanceof   DomInvocationHandler )     {", "return    (  ( DomInvocationHandler )     ( proxy )  )  ;", "}", "final   InvocationHandler   handler    =    AdvancedProxy . getInvocationHandler ( proxy )  ;", "if    ( handler   instanceof   StableInvocationHandler )     {", "final   DomElement   element    =     (  ( StableInvocationHandler < DomElement >  )     ( handler )  )  . getWrappedElement (  )  ;", "return   element    =  =    null    ?    null    :     . getDomInvocationHandler ( element )  ;", "}", "if    ( handler   instanceof   DomInvocationHandler )     {", "return    (  ( DomInvocationHandler )     ( handler )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDomInvocationHandler"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( DomManagerImpl )     ( DomManager . getDomManager ( project )  )  )  ;", "}", "METHOD_END"], "methodName": ["getDomManager"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "return   myApplicationComponent . getFileDescriptions ( rootTagName )  ;", "}", "METHOD_END"], "methodName": ["getFileDescriptions"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "DomInvocationHandler   handler    =    DomManagerImpl . getDomInvocationHandler ( proxy )  ;", "if    ( handler    =  =    null )     {", "throw   new   AssertionError (  (  \" null   handler   for    \"     +    proxy )  )  ;", "}", "return   handler ;", "}", "METHOD_END"], "methodName": ["getNotNullHandler"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "return   mySemService . getSemElement ( DomManagerImpl . FILE _ DESCRIPTION _ KEY ,    xmlFile )  ;", "}", "METHOD_END"], "methodName": ["getOrCreateCachedValueProvider"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "return   PsiManager . getInstance ( getProject (  )  )  . getModificationTracker (  )  . getModificationCount (  )  ;", "}", "METHOD_END"], "methodName": ["getPsiModificationCount"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "return   mySemService ;", "}", "METHOD_END"], "methodName": ["getSemService"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( StableInvocationHandler )     ( AdvancedProxy . getInvocationHandler ( proxy )  )  )  ;", "}", "METHOD_END"], "methodName": ["getStableInvocationHandler"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "return    ( file   instanceof   XmlFile )     &  &     (  ( getFileElement (  (  ( XmlFile )     ( file )  )  )  )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["isDomFile"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "mySemService . performAtomicChange ( change )  ;", "if    (  !  ( mySemService . isInsideAtomicChange (  )  )  )     {", "incModificationCount (  )  ;", "}", "}", "METHOD_END"], "methodName": ["performAtomicChange"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "registerFileDescription ( description )  ;", "Disposer . register ( parentDisposable ,    new   Disposable (  )     {", "@ Override", "public   void   dispose (  )     {", "getFileDescriptions ( description . getRootTagName (  )  )  . remove ( description )  ;", "getAcceptingOtherRootTagNameDescriptions (  )  . remove ( description )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["registerFileDescription"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "final   boolean   b    =    setChanging ( true )  ;", "try    {", "change . run (  )  ;", "}    finally    {", "setChanging ( b )  ;", "}", "}", "METHOD_END"], "methodName": ["runChange"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "boolean   oldChanging    =    myChanging ;", "if    ( changing )     {", "assert    ! oldChanging ;", "}", "myChanging    =    changing ;", "return   oldChanging ;", "}", "METHOD_END"], "methodName": ["setChanging"], "fileName": "com.intellij.util.xml.impl.DomManagerImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( obj   instanceof   DomRootInvocationHandler )  )", "return   false ;", "final   DomRootInvocationHandler   handler    =     (  ( DomRootInvocationHandler )     ( obj )  )  ;", "return   myParent . equals ( handler . myParent )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.intellij.util.xml.impl.DomRootInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "return   myParent . hashCode (  )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.intellij.util.xml.impl.DomRootInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "final   String   localName    =    tag . getLocalName (  )  ;", "String   namespace    =    null ;", "final   String   qName    =    tag . getName (  )  ;", "final   XmlFile   file    =    parent . getFile (  )  ;", "for    ( int   i    =     0  ,    size    =    descriptions . size (  )  ;    i    <    size ;    i +  +  )     {", "final   T   description    =    descriptions . get ( i )  ;", "final   XmlName   xmlName    =    description . getXmlName (  )  ;", "if    (  ( localName . equals ( xmlName . getLocalName (  )  )  )     |  |     ( qName . equals ( xmlName . getLocalName (  )  )  )  )     {", "final   EvaluatedXmlName   evaluatedXmlName    =    parent . createEvaluatedXmlName ( xmlName )  ;", "if    ( DomImplUisNameSuitable ( evaluatedXmlName ,    localName ,    qName ,     ( namespace    =  =    null    ?    namespace    =    tag . getNamespace (  )     :    namespace )  ,    file )  )     {", "return   description ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findChildrenDescription"], "fileName": "com.intellij.util.xml.impl.DomSemContributor"}, {"methodBody": ["METHOD_START", "{", "LinkedHashSet < XmlTag >    allParents    =    new   LinkedHashSet <  >  (  )  ;", "PsiElement   each    =    tag ;", "while    (  ( each   instanceof   XmlTag )     &  &     ( allParents . add (  (  ( XmlTag )     ( each )  )  )  )  )     {", "each    =    PhysicalDomParentStrategy . getParentTagCandidate (  (  ( XmlTag )     ( each )  )  )  ;", "}", "ArrayList < XmlTag >    list    =    new   ArrayList <  >  ( allParents )  ;", "Collections . reverse ( list )  ;", "DomManagerImanager    =    DomManagerIgetDomManager ( tag . getProject (  )  )  ;", "for    ( XmlTag   xmlTag    :    list )     {", "manager . getDomHandler ( xmlTag )  ;", "}", "return   manager . getDomHandler ( tag )  ;", "}", "METHOD_END"], "methodName": ["getParentDom"], "fileName": "com.intellij.util.xml.impl.DomSemContributor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( file   instanceof   PsiFileEx )     &  &     (  (  ( PsiFileEx )     ( file )  )  . isContentsLoaded (  )  )  )     &  &     ( file . getNode (  )  . isParsed (  )  )  )     {", "return    . computeHeaderByPsi ( file )  ;", "}", "if    (  (  !  ( XmlUtil . isStubBuilding (  )  )  )     &  &     (  ( file . getFileType (  )  )     =  =     ( XmlFileType . INSTANCE )  )  )     {", "VirtualFile   virtualFile    =    file . getVirtualFile (  )  ;", "if    ( virtualFile   instanceof   VirtualFileWithId )     {", "ObjectStubTree   tree    =    StubTreeLoader . getInstance (  )  . readFromVFile ( file . getProject (  )  ,    virtualFile )  ;", "if    ( tree    !  =    null )     {", "Stub   root    =    tree . getRoot (  )  ;", "if    ( root   instanceof   FileStub )     {", "return    (  ( FileStub )     ( root )  )  . getHeader (  )  ;", "}", "}", "}", "}", "if    (  !  ( file . isValid (  )  )  )", "return   XmlFileHeader . EMPTY ;", "XmlFileHeader   header    =    NanoXmlUtil . parseHeader ( file )  ;", "if    (  ( header . getRootTagLocalName (  )  )     =  =    null )     {", "return    . computeHeaderByPsi ( file )  ;", "}", "return   header ;", "}", "METHOD_END"], "methodName": ["calcXmlFileHeader"], "fileName": "com.intellij.util.xml.impl.DomServiceImpl"}, {"methodBody": ["METHOD_START", "{", "final   XmlDocument   document    =    file . getDocument (  )  ;", "if    ( document    =  =    null )     {", "return   XmlFileHeader . EMPTY ;", "}", "String   publicId    =    null ;", "String   systemId    =    null ;", "final   XmlProlog   prolog    =    document . getProlog (  )  ;", "if    ( prolog    !  =    null )     {", "final   XmlDoctype   doctype    =    prolog . getDoctype (  )  ;", "if    ( doctype    !  =    null )     {", "publicId    =    doctype . getPublicId (  )  ;", "systemId    =    doctype . getSystemId (  )  ;", "if    ( systemId    =  =    null )     {", "systemId    =    doctype . getDtdUri (  )  ;", "}", "}", "}", "final   XmlTag   tag    =    document . getRootTag (  )  ;", "if    ( tag    =  =    null )     {", "return   XmlFileHeader . EMPTY ;", "}", "String   localName    =    tag . getLocalName (  )  ;", "if    ( StringUisNotEmpty ( localName )  )     {", "if    (  ( tag . getPrevSibling (  )  )    instanceof   PsiErrorElement )     {", "return   XmlFileHeader . EMPTY ;", "}", "String   psiNs    =    tag . getNamespace (  )  ;", "return   new   XmlFileHeader ( localName ,     (  ( psiNs    =  =     ( XmlUEMPTY _ URI )  )     |  |     ( Comparing . equal ( psiNs ,    systemId )  )     ?    null    :    psiNs )  ,    publicId ,    systemId )  ;", "}", "return   XmlFileHeader . EMPTY ;", "}", "METHOD_END"], "methodName": ["computeHeaderByPsi"], "fileName": "com.intellij.util.xml.impl.DomServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   mappingId    !  =    null    ?    TemplateSettings . getInstance (  )  . getTemplateById ( mappingId )     :    null ;", "}", "METHOD_END"], "methodName": ["getTemplate"], "fileName": "com.intellij.util.xml.impl.DomTemplateRunnerImpl"}, {"methodBody": ["METHOD_START", "{", "runTemplate ( t ,    editor ,    template ,    new   HashMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["runTemplate"], "fileName": "com.intellij.util.xml.impl.DomTemplateRunnerImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( template    !  =    null )     &  &     ( t    !  =    null )  )     {", "DomElement   copy    =    t . createStableCopy (  )  ;", "PsiDocumentManager . getInstance ( myProject )  . doPostponedOperationsAndUnblockDocument ( editor . getDocument (  )  )  ;", "XmlTag   tag    =    copy . getXmlTag (  )  ;", "assert   tag    !  =    null ;", "editor . getCaretModel (  )  . moveToOffset ( tag . getTextRange (  )  . getStartOffset (  )  )  ;", "copy . undefine (  )  ;", "PsiDocumentManager . getInstance ( myProject )  . doPostponedOperationsAndUnblockDocument ( editor . getDocument (  )  )  ;", "template . setToReformat ( true )  ;", "Manager . getInstance ( myProject )  . start ( editor ,    template ,    true ,    predefinedVars ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["runTemplate"], "fileName": "com.intellij.util.xml.impl.DomTemplateRunnerImpl"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( xmlElement )  ;", "assertSame ( element . getXmlTag (  )  ,    xmlElement )  ;", "final   DomInvocationHandler   cachedElement    =    getCachedHandler ( xmlElement )  ;", "assertNotNull ( cachedElement )  ;", "assertEquals ( element ,    cachedElement . getProxy (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertCached"], "fileName": "com.intellij.util.xml.impl.DomTestCase"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( file )  ;", "assertEquals ( element ,    getManager (  )  . getFileElement ( file )  )  ;", "}", "METHOD_END"], "methodName": ["assertCached"], "fileName": "com.intellij.util.xml.impl.DomTestCase"}, {"methodBody": ["METHOD_START", "{", "myCallRegistry . assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["assertResultsAndClear"], "fileName": "com.intellij.util.xml.impl.DomTestCase"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =     \" a . xml \"  ;", "final   XmlFile   file    =     (  ( XmlFile )     ( PsiFileFactory . getInstance ( domManager . getProject (  )  )  . createFileFromText ( name ,    xml )  )  )  ;", "final   XmlTag   tag    =    file . getDocument (  )  . getRootTag (  )  ;", "final   String   rootTagName    =     ( tag    !  =    null )     ?    tag . getName (  )     :     \" root \"  ;", "final   T   element    =    domManager . getFileElement ( file ,    aClass ,    rootTagName )  . getRootElement (  )  ;", "assertNotNull ( element )  ;", "assertSame ( tag ,    element . getXmlTag (  )  )  ;", "return   element ;", "}", "METHOD_END"], "methodName": ["createElement"], "fileName": "com.intellij.util.xml.impl.DomTestCase"}, {"methodBody": ["METHOD_START", "{", "final   DomManagerImpl   domManager    =    getDomManager (  )  ;", "T   element    =     . createElement ( domManager ,    xml ,    aClass )  ;", "myCallRegistry . clear (  )  ;", "return   element ;", "}", "METHOD_END"], "methodName": ["createElement"], "fileName": "com.intellij.util.xml.impl.DomTestCase"}, {"methodBody": ["METHOD_START", "{", "return   XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText ( text )  ;", "}", "METHOD_END"], "methodName": ["createTag"], "fileName": "com.intellij.util.xml.impl.DomTestCase"}, {"methodBody": ["METHOD_START", "{", "return    (  ( XmlFile )     ( createLightFile (  \" a . xml \"  ,    text )  )  )  ;", "}", "METHOD_END"], "methodName": ["createXmlFile"], "fileName": "com.intellij.util.xml.impl.DomTestCase"}, {"methodBody": ["METHOD_START", "{", "final   List < DomInvocationHandler >    option    =    getDomManager (  )  . getSemService (  )  . getCachedSemElements ( DomManagerImpl . DOM _ HANDLER _ KEY ,    element )  ;", "return    ( option    =  =    null )     |  |     ( option . isEmpty (  )  )     ?    null    :    option . get (  0  )  ;", "}", "METHOD_END"], "methodName": ["getCachedHandler"], "fileName": "com.intellij.util.xml.impl.DomTestCase"}, {"methodBody": ["METHOD_START", "{", "return    (  ( DomManagerImpl )     ( DomManager . getDomManager ( getProject (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getDomManager"], "fileName": "com.intellij.util.xml.impl.DomTestCase"}, {"methodBody": ["METHOD_START", "{", "return   getDomManager (  )  . getTypeChooserManager (  )  ;", "}", "METHOD_END"], "methodName": ["getTypeChooserManager"], "fileName": "com.intellij.util.xml.impl.DomTestCase"}, {"methodBody": ["METHOD_START", "{", "getPsiManager (  )  . dropPsiCaches (  )  ;", "}", "METHOD_END"], "methodName": ["incModCount"], "fileName": "com.intellij.util.xml.impl.DomTestCase"}, {"methodBody": ["METHOD_START", "{", "myCallRegistry . putExpected ( event )  ;", "}", "METHOD_END"], "methodName": ["putExpected"], "fileName": "com.intellij.util.xml.impl.DomTestCase"}, {"methodBody": ["METHOD_START", "{", "XmlFile   file    =    myInvocationHandler . getFile (  )  ;", "final   List < DomExtensionImpl >    fixeds    =    registrar . getFixeds (  )  ;", "final   List < DomExtensionImpl >    collections    =    registrar . getCollections (  )  ;", "final   List < DomExtensionImpl >    attributes    =    registrar . getAttributes (  )  ;", "if    (  !  ( attributes . isEmpty (  )  )  )     {", "ChildrenDescriptionsHolder < AttributeChildDescriptionImpl >    newAttributes    =    new   ChildrenDescriptionsHolder <  >  ( myStaticGenericInfo . getAttributes (  )  )  ;", "for    ( final   DomExtensionImpl   extension    :    attributes )     {", "newAttributes . addDescription ( extension . addAnnotations ( new   AttributeChildDescriptionImpl ( extension . getXmlName (  )  ,    extension . getType (  )  )  )  )  ;", "}", "myAttributes    =     . internChildrenHolder ( file ,    newAttributes )  ;", "}", "if    (  !  ( fixeds . isEmpty (  )  )  )     {", "ChildrenDescriptionsHolder < FixedChildDescriptionImpl >    newFixeds    =    new   ChildrenDescriptionsHolder <  >  ( myStaticGenericInfo . getFixed (  )  )  ;", "for    ( final   DomExtensionImpl   extension    :    fixeds )     {", "newFixeds . addDescription ( extension . addAnnotations ( new   FixedChildDescriptionImpl ( extension . getXmlName (  )  ,    extension . getType (  )  ,    extension . getCount (  )  ,    ArrayUtil . EMPTY _ COLLECTION _ ARRAY )  )  )  ;", "}", "myFixeds    =     . internChildrenHolder ( file ,    newFixeds )  ;", "}", "if    (  !  ( collections . isEmpty (  )  )  )     {", "ChildrenDescriptionsHolder < CollectionChildDescriptionImpl >    newCollections    =    new   ChildrenDescriptionsHolder <  >  ( myStaticGenericInfo . getCollections (  )  )  ;", "for    ( final   DomExtensionImpl   extension    :    collections )     {", "newCollections . addDescription ( extension . addAnnotations ( new   CollectionChildDescriptionImpl ( extension . getXmlName (  )  ,    extension . getType (  )  ,    Collections . emptyList (  )  )  )  )  ;", "}", "myCollections    =     . internChildrenHolder ( file ,    newCollections )  ;", "}", "final   List < DomExtensionImpl >    customs    =    registrar . getCustoms (  )  ;", "myCustomChildren    =     ( customs . isEmpty (  )  )     ?    null    :    ContainerUtil . map ( customs ,     (    extension )     -  >    new   CustomDomChildrenDescriptionImpl ( extension )  )  ;", "}", "METHOD_END"], "methodName": ["applyExtensions"], "fileName": "com.intellij.util.xml.impl.DynamicGenericInfo"}, {"methodBody": ["METHOD_START", "{", "SoftReference < WeakInterner < ChildrenDescriptionsHolder >  >    ref    =    file . getUserData ( DynamicGenericInfo . HOLDERS _ CACHE )  ;", "WeakInterner < ChildrenDescriptionsHolder >    cache    =    SoftReference . dereference ( ref )  ;", "if    ( cache    =  =    null )     {", "cache    =    new   WeakInterner (  )  ;", "file . putUserData ( DynamicGenericInfo . HOLDERS _ CACHE ,    new   SoftReference ( cache )  )  ;", "}", "return   cache . intern ( holder )  ;", "}", "METHOD_END"], "methodName": ["internChildrenHolder"], "fileName": "com.intellij.util.xml.impl.DynamicGenericInfo"}, {"methodBody": ["METHOD_START", "{", "DomExtensionsRegistrarImpl   registrar    =    null ;", "final   Project   project    =    myInvocationHandler . getManager (  )  . getProject (  )  ;", "DomExtenderEP [  ]    extenders    =    Extensions . getExtensions ( DomExtenderEP . EP _ NAME )  ;", "if    (  ( extenders . length )     >     0  )     {", "for    ( final   DomExtenderEP   extenderEP    :    extenders )     {", "registrar    =    extenderEP . extend ( project ,    myInvocationHandler ,    registrar )  ;", "}", "}", "final   AbstractDomChildDescriptionImpl   description    =    myInvocationHandler . getChildDescription (  )  ;", "if    ( description    !  =    null )     {", "final   List < DomExtender >    extendersFromParent    =    description . getUserData ( DomExtensionIOM _ EXTENDER _ KEY )  ;", "if    ( extendersFromParent    !  =    null )     {", "if    ( registrar    =  =    null )", "registrar    =    new   DomExtensionsRegistrarImpl (  )  ;", "for    ( final   DomExtender   extender    :    extendersFromParent )     {", "extender . registerExtensions ( myInvocationHandler . getProxy (  )  ,    registrar )  ;", "}", "}", "}", "return   registrar ;", "}", "METHOD_END"], "methodName": ["runDomExtenders"], "fileName": "com.intellij.util.xml.impl.DynamicGenericInfo"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( myXmlFile . isValid (  )  )  )     {", "return   null ;", "}", "if    ( sb    !  =    null )     {", "sb . append (  \" File   is   valid \\ n \"  )  ;", "}", "VirtualFile   file    =    myXmlFile . getVirtualFile (  )  ;", "if    (  (  !  (  ( myXmlFile . getFileType (  )  )    instanceof   DomSupportEnabled )  )     |  |     (  ( file    !  =    null )     &  &     ( ProjectCoreUtil . isProjectOrWorkspaceFile ( file )  )  )  )     {", "return   null ;", "}", "XmlFileHeader   rootTagName    =    myDomService . getXmlFileHeader ( myXmlFile )  ;", "if    ( sb    !  =    null )     {", "sb . append ( rootTagName )  . append (  \"  ,    file   is   of   dom   file   type \\ n \"  )  ;", "}", "final   Dom < T >    description    =    find ( rootTagName ,    sb )  ;", "final   DomFileElementImpl   oldValue    =    getLastValue (  )  ;", "if    ( sb    !  =    null )     {", "sb . append (  (  (  \" last    \"     +    oldValue )     +     \"  \\ n \"  )  )  ;", "}", "if    ( description    =  =    null )     {", "return   null ;", "}", "final   Class < T >    rootElementClass    =    description . getRootElementClass (  )  ;", "final   XmlName   xmlName    =    DomImplUtil . createXmlName ( description . getRootTagName (  )  ,    rootElementClass ,    null )  ;", "assert   xmlName    !  =    null ;", "final   EvaluatedXmlNameImpl   rootTagName 1     =    EvaluatedXmlNameImpl . createEvaluatedXmlName ( xmlName ,    xmlName . getNamespaceKey (  )  ,    false )  ;", "FileStub   stub    =    null ;", "if    (  (  ( description . hasStubs (  )  )     &  &     ( file   instanceof   VirtualFileWithId )  )     &  &     (  !  ( isFileParsed (  )  )  )  )     {", "ApplicationManager . getApplication (  )  . assertReadAccessAllowed (  )  ;", "if    (  !  ( XmlUtil . isStubBuilding (  )  )  )     {", "ObjectStubTree   stubTree    =    StubTreeLoader . getInstance (  )  . readOrBuild ( myXmlFile . getProject (  )  ,    file ,    myXmlFile )  ;", "if    ( stubTree    !  =    null )     {", "stub    =     (  ( FileStub )     ( stubTree . getRoot (  )  )  )  ;", "}", "}", "}", "DomFileElementImpl < T >    result    =    new   DomFileElementImpl <  >  ( myXmlFile ,    rootElementClass ,    rootTagName 1  ,    myDomManager ,    description ,    stub )  ;", "if    ( sb    !  =    null )     {", "sb . append (  (  (  \" success    \"     +    result )     +     \"  \\ n \"  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["_computeFileElement"], "fileName": "com.intellij.util.xml.impl.FileDescriptionCachedValueProvider"}, {"methodBody": ["METHOD_START", "{", "final   DomFileDescription < T >    mockDescription    =    myXmlFile . getUserData ( DomManagerImpl . MOCK _ DESCRIPTION )  ;", "if    ( mockDescription    !  =    null )", "return   mockDescription ;", "if    ( sb    !  =    null )     {", "sb . append (  \" no   mock \\ n \"  )  ;", "}", "final   XmlFile   originalFile    =     (  ( XmlFile )     ( myXmlFile . getOriginalFile (  )  )  )  ;", "if    ( sb    !  =    null )     {", "sb . append (  (  (  \" original :     \"     +    originalFile )     +     \"  \\ n \"  )  )  ;", "}", "if    (  !  ( originalFile . equals ( myXmlFile )  )  )     {", "final    < T >    provider    =    myDomManager . getOrCreateCachedValueProvider ( originalFile )  ;", "final   DomFileElementImpl < T >    element    =    provider . getFileElement (  )  ;", "if    ( sb    !  =    null )     {", "sb . append (  (  (  \" originalDom    \"     +    element )     +     \"  \\ n \"  )  )  ;", "}", "return   element    =  =    null    ?    null    :    element . getFileDescription (  )  ;", "}", "final   Set < DomFileDescription >    namedDescriptions    =    myDomManager . getFileDescriptions ( xmlFileHeader . getRootTagLocalName (  )  )  ;", "if    ( sb    !  =    null )     {", "sb . append (  (  (  \" named    \"     +     ( new   HashSet <  >  ( namedDescriptions )  )  )     +     \"  \\ n \"  )  )  ;", "}", "DomFileDescription < T >    description    =    ContainerUtil . find ( namedDescriptions ,    myCondition )  ;", "if    ( description    =  =    null )     {", "final   Set < DomFileDescription >    unnamed    =    myDomManager . getAcceptingOtherRootTagNameDescriptions (  )  ;", "description    =    ContainerUtil . find ( unnamed ,    myCondition )  ;", "}", "if    ( sb    !  =    null )     {", "sb . append (  (  (  \" found    \"     +    description )     +     \"  \\ n \"  )  )  ;", "}", "return   description ;", "}", "METHOD_END"], "methodName": ["findFileDescription"], "fileName": "com.intellij.util.xml.impl.FileDescriptionCachedValueProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( myComputed )", "return   myLastResult ;", "DomElementImpl < T >    result    =     _ computeElement ( null )  ;", "synchronized ( myCondition )     {", "if    ( myComputed )", "return   myLastResult ;", "myLastResult    =    result ;", "WeakReference < DomElementImpl >    ref    =     ( result    !  =    null )     ?    new   WeakReference <  >  ( result )     :    null ;", "myXml . putUserData ( DomManagerImpl . CACHED _ FILE _ ELEMENT ,    ref )  ;", "myComputed    =    true ;", "return   result ;", "}", "}", "METHOD_END"], "methodName": ["getFileElement"], "fileName": "com.intellij.util.xml.impl.FileDescriptionCachedValueProvider"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   log    =    new   StringBuilder (  )  ;", "myLastResult    =     _ computeElement ( log )  ;", "return   log . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getFileElementWithLogging"], "fileName": "com.intellij.util.xml.impl.FileDescriptionCachedValueProvider"}, {"methodBody": ["METHOD_START", "{", "return   myLastResult ;", "}", "METHOD_END"], "methodName": ["getLastValue"], "fileName": "com.intellij.util.xml.impl.FileDescriptionCachedValueProvider"}, {"methodBody": ["METHOD_START", "{", "return    (  ( myXmlFile )    instanceof   PsiFileEx )     &  &     (  (  ( PsiFileEx )     ( myXmlFile )  )  . isContentsLoaded (  )  )  ;", "}", "METHOD_END"], "methodName": ["isFileParsed"], "fileName": "com.intellij.util.xml.impl.FileDescriptionCachedValueProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    o )", "return   true ;", "if    (  ( o    =  =    null )     |  |     (  ( getClass (  )  )     !  =     ( o . getClass (  )  )  )  )", "return   false ;", "if    (  !  ( super . equals ( o )  )  )", "return   false ;", "final      that    =     (  (  )     ( o )  )  ;", "if    (  ( myCount )     !  =     ( that . myCount )  )", "return   false ;", "if    (  !  ( Arrays . equals ( myGetterMethods ,    that . myGetterMethods )  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.intellij.util.xml.impl.FixedChildDescriptionImpl"}, {"methodBody": ["METHOD_START", "{", "int   result    =    super . hashCode (  )  ;", "result    =     (  2  9     *    result )     +     ( myCount )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.intellij.util.xml.impl.FixedChildDescriptionImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( getXmlElementName (  )  )     +     \"     \"  )     +     ( getGetterMethod (  0  )  )  )     +     \"     \"  )     +     ( getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.util.xml.impl.FixedChildDescriptionImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myGenericValue )    instanceof   GenericAttributeValue )     {", "final   GenericAttributeValue   genericAttributeValue    =     (  ( GenericAttributeValue )     ( myGenericValue )  )  ;", "final   XmlAttributeValue   attributeValue    =    genericAttributeValue . getXmlAttributeValue (  )  ;", "if    ( attributeValue    =  =    null )     {", "return   TextRange . from (  0  ,    genericAttributeValue . getXmlAttribute (  )  . getTextLength (  )  )  ;", "}", "final   int   length    =    attributeValue . getTextLength (  )  ;", "return   length    <     2     ?    TextRange . from (  0  ,    length )     :    new   TextRange (  1  ,     ( length    -     1  )  )  ;", "}", "final   XmlTag   tag    =    myGenericValue . getXmlTag (  )  ;", "assert   tag    !  =    null ;", "return   XmlTagUtil . getTrimmedValueRange ( tag )  ;", "}", "METHOD_END"], "methodName": ["createTextRange"], "fileName": "com.intellij.util.xml.impl.GenericDomValueReference"}, {"methodBody": ["METHOD_START", "{", "return   ConvertContextFactory . createConvertContext ( DomManagerImpl . getDomInvocationHandler ( myGenericValue )  )  ;", "}", "METHOD_END"], "methodName": ["getConvertContext"], "fileName": "com.intellij.util.xml.impl.GenericDomValueReference"}, {"methodBody": ["METHOD_START", "{", "return   WrappingConverter . getDeepestConverter ( myGenericValue . getConverter (  )  ,    myGenericValue )  ;", "}", "METHOD_END"], "methodName": ["getConverter"], "fileName": "com.intellij.util.xml.impl.GenericDomValueReference"}, {"methodBody": ["METHOD_START", "{", "return   myGenericValue ;", "}", "METHOD_END"], "methodName": ["getGenericValue"], "fileName": "com.intellij.util.xml.impl.GenericDomValueReference"}, {"methodBody": ["METHOD_START", "{", "return   PsiManager . getInstance ( myGenericValue . getManager (  )  . getProject (  )  )  ;", "}", "METHOD_END"], "methodName": ["getPsiManager"], "fileName": "com.intellij.util.xml.impl.GenericDomValueReference"}, {"methodBody": ["METHOD_START", "{", "return   myGenericValue . getStringValue (  )  ;", "}", "METHOD_END"], "methodName": ["getStringValue"], "fileName": "com.intellij.util.xml.impl.GenericDomValueReference"}, {"methodBody": ["METHOD_START", "{", "final   Converter < T >    converter    =    getConverter (  )  ;", "if    ( converter   instanceof   ResolvingConverter )     {", "return    (  ( ResolvingConverter < T >  )     ( converter )  )  . resolve ( o ,    getConvertContext (  )  )  ;", "}", "if    ( o   instanceof   PsiElement )     {", "return    (  ( PsiElement )     ( o )  )  ;", "}", "if    ( o   instanceof   DomElement )     {", "DomTarget   target    =    DomTarget . getTarget (  (  ( DomElement )     ( o )  )  )  ;", "return   target    =  =    null    ?    null    :    PomService . convertToPsi ( target )  ;", "}", "if    ( o   instanceof   MergedObject )     {", "final   List < T >    list    =     (  ( MergedObject < T >  )     ( o )  )  . getImplementations (  )  ;", "for    ( final   T   o 1     :    list )     {", "final   PsiElement   psiElement    =    resolveInner ( o 1  )  ;", "if    ( psiElement    !  =    null )     {", "return   psiElement ;", "}", "}", "}", "return   o    !  =    null    ?     . getElement (  )     :    null ;", "}", "METHOD_END"], "methodName": ["resolveInner"], "fileName": "com.intellij.util.xml.impl.GenericDomValueReference"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =    handler . getFile (  )  ;", "final   DomFileDescription <  ?  >    description    =    domManager . getDomFileDescription ( file )  ;", "if    ( description    =  =    null )     {", "return   PsiReference . EMPTY _ ARRAY ;", "}", "List < PsiReference >    result    =    new   ArrayList <  >  (  )  ;", "ConvertContext   context    =    ConvertContextFactory . createConvertContext ( domValue )  ;", "final   List < DomReferenceInjector >    injectors    =    description . getReferenceInjectors (  )  ;", "if    (  !  ( injectors . isEmpty (  )  )  )     {", "String   unresolvedText    =    ElementManipulators . getValueText ( psiElement )  ;", "for    ( DomReferenceInjector   each    :    injectors )     {", "Collections . addAll ( result ,    each . inject ( unresolvedText ,    psiElement ,    context )  )  ;", "}", "}", "Collections . addAll ( result ,     . doCreateReferences ( domValue ,    psiElement ,    converter ,    context )  )  ;", "return   result . toArray ( EMPTY _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["createReferences"], "fileName": "com.intellij.util.xml.impl.GenericValueReferenceProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( converter   instanceof   CustomReferenceConverter )     {", "final   PsiReference [  ]    references    =     (  ( CustomReferenceConverter )     ( converter )  )  . createReferences ( domValue ,    psiElement ,    context )  ;", "if    (  (  ( references . length )     !  =     0  )     |  |     (  !  ( converter   instanceof   ResolvingConverter )  )  )     {", "return   references ;", "}", "}", "if    ( converter   instanceof   ResolvingConverter )     {", "return   new   PsiReference [  ]  {    new   GenericDom ( domValue )     }  ;", "}", "return   PsiReference . EMPTY _ ARRAY ;", "}", "METHOD_END"], "methodName": ["doCreateReferences"], "fileName": "com.intellij.util.xml.impl.GenericValueReferenceProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( list . isEmpty (  )  )  )     {", "for    ( int   i    =     0  ;    i    <     ( list . size (  )  )  ;    i +  +  )     {", "Pair < Converter ,    Object >    pair    =    list . get ( i )  ;", "if    (  ( pair . first )     =  =     ( myConverter )  )", "return   pair . second ;", "}", "}", "final   Object   returnValue    =     . getValueInner ( handler ,    myConverter )  ;", "list . add ( Pair . create ( myConverter ,    returnValue )  )  ;", "return   returnValue ;", "}", "METHOD_END"], "methodName": ["getOrCalcValue"], "fileName": "com.intellij.util.xml.impl.GetInvocation"}, {"methodBody": ["METHOD_START", "{", "final   SubTag   annotation    =    handler . getAnnotation ( SubTag . class )  ;", "if    (  ( annotation    !  =    null )     &  &     ( annotation . indicator (  )  )  )     {", "final   boolean   tagNotNull    =     ( handler . getXmlTag (  )  )     !  =    null ;", "if    ( converter    =  =     ( Converter . EMPTY _ CONVERTER )  )     {", "return   tagNotNull    ?     \"  \"     :    null ;", "} else    {", "return   tagNotNull ;", "}", "}", "String   tagValue    =    handler . getValue (  )  ;", "ConvertContext   context    =    ConvertContextFactory . createConvertContext ( handler )  ;", "for    ( DomReferenceInjector   each    :    DomUtil . getFileElement ( handler )  . getFileDescription (  )  . getReferenceInjectors (  )  )     {", "tagValue    =    each . resolveString ( tagValue ,    context )  ;", "}", "return   converter . fromString ( tagValue ,    context )  ;", "}", "METHOD_END"], "methodName": ["getValueInner"], "fileName": "com.intellij.util.xml.impl.GetInvocation"}, {"methodBody": ["METHOD_START", "{", "final   TreeSet < Class >    set    =    new   TreeSet <  >  ( ImplementationClassCache . CLASS _ COMPARATOR )  ;", "findImplementationClassDFS ( concreteInterface ,    set )  ;", "if    (  !  ( set . isEmpty (  )  )  )     {", "return   set . first (  )  ;", "}", "final   Implementation   implementation    =    DomReflectionUtil . findAnnotationDFS ( concreteInterface ,    Implementation . class )  ;", "return   implementation    =  =    null    ?    concreteInterface    :    implementation . value (  )  ;", "}", "METHOD_END"], "methodName": ["calcImplementationClass"], "fileName": "com.intellij.util.xml.impl.ImplementationClassCache"}, {"methodBody": ["METHOD_START", "{", "final   Collection < DomImplementationClassEP >    values    =    myImplementationClasses . get ( concreteInterface . getName (  )  )  ;", "for    ( DomImplementationClassEP   value    :    values )     {", "if    (  ( value . getInterfaceClass (  )  )     =  =    concreteInterface )     {", "results . add ( value . getImplementationClass (  )  )  ;", "return ;", "}", "}", "for    ( final   Class   aClass 1     :    concreteInterface . getInterfaces (  )  )     {", "findImplementationClassDFS ( aClass 1  ,    results )  ;", "}", "}", "METHOD_END"], "methodName": ["findImplementationClassDFS"], "fileName": "com.intellij.util.xml.impl.ImplementationClassCache"}, {"methodBody": ["METHOD_START", "{", "Class   impl    =    myCache . getCachedValue ( key )  ;", "return   impl    =  =    key    ?    null    :    impl ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.intellij.util.xml.impl.ImplementationClassCache"}, {"methodBody": ["METHOD_START", "{", "final   DomImplementationClassEP   ep    =    new   DomImplementationClassEP (  )     {", "@ Override", "public   Class   getInterfaceClass (  )     {", "return   domElementClass ;", "}", "@ Override", "public   Class   getImplementationClass (  )     {", "return   implementationClass ;", "}", "}  ;", "myImplementationClasses . putValue ( domElementClass . getName (  )  ,    ep )  ;", "if    ( parentDisposable    !  =    null )     {", "Disposer . register ( parentDisposable ,    new   Disposable (  )     {", "@ Override", "public   void   dispose (  )     {", "myImplementationClasses . remove ( domElementClass . getName (  )  )  ;", "}", "}  )  ;", "}", "myCache . clearCache (  )  ;", "}", "METHOD_END"], "methodName": ["registerImplementation"], "fileName": "com.intellij.util.xml.impl.ImplementationClassCache"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    myElement . getXmlTag (  )  ;", "tag . addBefore ( createTag (  \"  < child - element /  >  \"  )  ,    tag . getSubTags (  )  [ index ]  )  ;", "}", "METHOD_END"], "methodName": ["addChildElementTag"], "fileName": "com.intellij.util.xml.impl.IncrementalUpdateEventsTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    myElement . getXmlTag (  )  ;", "tag . addBefore ( createTag (  \"  < child /  >  \"  )  ,    tag . getSubTags (  )  [ index ]  )  ;", "}", "METHOD_END"], "methodName": ["addChildTag"], "fileName": "com.intellij.util.xml.impl.IncrementalUpdateEventsTest"}, {"methodBody": ["METHOD_START", "{", "return   createElement ( xml ,    IncrementalUpdateEventsTest . MyElement . class )  ;", "}", "METHOD_END"], "methodName": ["createElement"], "fileName": "com.intellij.util.xml.impl.IncrementalUpdateEventsTest"}, {"methodBody": ["METHOD_START", "{", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >    myElement . getXmlTag (  )  . getSubTags (  )  [ index ]  . delete (  )  )  ;", "}", "METHOD_END"], "methodName": ["deleteTag"], "fileName": "com.intellij.util.xml.impl.IncrementalUpdateEventsTest"}, {"methodBody": ["METHOD_START", "{", "return   myElement . getChildElements (  )  . get ( index )  ;", "}", "METHOD_END"], "methodName": ["getChild"], "fileName": "com.intellij.util.xml.impl.IncrementalUpdateEventsTest"}, {"methodBody": ["METHOD_START", "{", "addChildTag (  0  )  ;", "putExpected ( new   Dom ( myElement ,    false )  )  ;", "assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["testAdd0"], "fileName": "com.intellij.util.xml.impl.IncrementalUpdateEventsTest"}, {"methodBody": ["METHOD_START", "{", "addChildTag (  1  )  ;", "putExpected ( new   Dom ( myElement ,    false )  )  ;", "assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["testAdd1"], "fileName": "com.intellij.util.xml.impl.IncrementalUpdateEventsTest"}, {"methodBody": ["METHOD_START", "{", "addChildElementTag (  2  )  ;", "putExpected ( new   DomEvent ( myElement ,    false )  )  ;", "assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["testAdd2"], "fileName": "com.intellij.util.xml.impl.IncrementalUpdateEventsTest"}, {"methodBody": ["METHOD_START", "{", "addChildElementTag (  3  )  ;", "putExpected ( new   DomEvent ( myElement ,    false )  )  ;", "assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["testAdd3"], "fileName": "com.intellij.util.xml.impl.IncrementalUpdateEventsTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    myElement . getXmlTag (  )  ;", "tag . addAfter ( createTag (  \"  < child - element /  >  \"  )  ,    tag . getSubTags (  )  [  3  ]  )  ;", "putExpected ( new   DomEvent ( myElement ,    false )  )  ;", "assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["testAdd4"], "fileName": "com.intellij.util.xml.impl.IncrementalUpdateEventsTest"}, {"methodBody": ["METHOD_START", "{", "deleteTag (  0  )  ;", "putExpected ( new   Dom ( myElement ,    false )  )  ;", "assertResultsAndClear (  )  ;", "deleteTag (  0  )  ;", "putExpected ( new   Dom ( myElement ,    false )  )  ;", "assertResultsAndClear (  )  ;", "deleteTag (  0  )  ;", "putExpected ( new   Dom ( myElement ,    false )  )  ;", "assertResultsAndClear (  )  ;", "deleteTag (  0  )  ;", "putExpected ( new   Dom ( myElement ,    false )  )  ;", "assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["testRemove0"], "fileName": "com.intellij.util.xml.impl.IncrementalUpdateEventsTest"}, {"methodBody": ["METHOD_START", "{", "deleteTag (  1  )  ;", "putExpected ( new   Dom ( myElement ,    false )  )  ;", "assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["testRemove1"], "fileName": "com.intellij.util.xml.impl.IncrementalUpdateEventsTest"}, {"methodBody": ["METHOD_START", "{", "deleteTag (  2  )  ;", "putExpected ( new   Dom ( myElement ,    false )  )  ;", "assertResultsAndClear (  )  ;", "deleteTag (  2  )  ;", "putExpected ( new   Dom ( myElement ,    false )  )  ;", "assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["testRemove2"], "fileName": "com.intellij.util.xml.impl.IncrementalUpdateEventsTest"}, {"methodBody": ["METHOD_START", "{", "deleteTag (  3  )  ;", "putExpected ( new   Dom ( myElement ,    false )  )  ;", "assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["testRemove3"], "fileName": "com.intellij.util.xml.impl.IncrementalUpdateEventsTest"}, {"methodBody": ["METHOD_START", "{", "return    ( super . equals ( obj )  )     &  &     (  ( myIndex )     =  =     (  (  ( IndexedElementInvocationHandler )     ( obj )  )  . myIndex )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.intellij.util.xml.impl.IndexedElementInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "return    (  ( super . hashCode (  )  )     *     2  3  9  )     +     ( myIndex )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.intellij.util.xml.impl.IndexedElementInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "for    ( final   Method   method    :    ReflectionUtil . getClassDeclaredMethods ( aClass )  )     {", "if    (  \" equals \"  . equals ( method . getName (  )  )  )     {", ". ourCoreInvocations . put ( new   JavaMethodSignature ( method )  ,    new   Invocation (  )     {", "@ Override", "public   Object   invoke ( DomInvocationHandler <  ?  ,     ?  >    handler ,    Object [  ]    args )    throws   Throwable    {", "final   DomElement   proxy    =    handler . getProxy (  )  ;", "final   Object   arg    =    args [  0  ]  ;", "if    ( proxy    =  =    arg )", "return   true ;", "if    ( arg    =  =    null )", "return   false ;", "if    ( arg   instanceof   DomElement )     {", "final   DomInvocationHandler   handler 1     =    DomManagerImpl . getDomInvocationHandler ( proxy )  ;", "return    ( handler 1     !  =    null )     &  &     ( handler 1  . equals ( DomManagerImpl . getDomInvocationHandler (  (  ( DomElement )     ( arg )  )  )  )  )  ;", "}", "return   false ;", "}", "}  )  ;", "} else", "if    (  \" hashCode \"  . equals ( method . getName (  )  )  )     {", ". ourCoreInvocations . put ( new   JavaMethodSignature ( method )  ,    new   Invocation (  )     {", "@ Override", "public   Object   invoke ( DomInvocationHandler <  ?  ,     ?  >    handler ,    Object [  ]    args )    throws   Throwable    {", "return   handler . hashCode (  )  ;", "}", "}  )  ;", "} else    {", ". ourCoreInvocations . put ( new   JavaMethodSignature ( method )  ,    new   Invocation (  )     {", "@ Override", "public   Object   invoke ( DomInvocationHandler <  ?  ,     ?  >    handler ,    Object [  ]    args )    throws   Throwable    {", "return   method . invoke ( handler ,    args )  ;", "}", "}  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addCoreInvocations"], "fileName": "com.intellij.util.xml.impl.InvocationCache"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( myClassAnnotations . get ( annoClass )  )  )  ;", "}", "METHOD_END"], "methodName": ["getClassAnnotation"], "fileName": "com.intellij.util.xml.impl.InvocationCache"}, {"methodBody": ["METHOD_START", "{", "return   myJavaMethods . get ( method )  ;", "}", "METHOD_END"], "methodName": ["getInternedMethod"], "fileName": "com.intellij.util.xml.impl.InvocationCache"}, {"methodBody": ["METHOD_START", "{", "return   myInvocations . get ( method )  ;", "}", "METHOD_END"], "methodName": ["getInvocation"], "fileName": "com.intellij.util.xml.impl.InvocationCache"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( myMethodAnnotations . get ( method )  . get ( annoClass )  )  )  ;", "}", "METHOD_END"], "methodName": ["getMethodAnnotation"], "fileName": "com.intellij.util.xml.impl.InvocationCache"}, {"methodBody": ["METHOD_START", "{", "return   myGetters . get ( method )  ;", "}", "METHOD_END"], "methodName": ["isTagValueGetter"], "fileName": "com.intellij.util.xml.impl.InvocationCache"}, {"methodBody": ["METHOD_START", "{", "return   mySetters . get ( method )  ;", "}", "METHOD_END"], "methodName": ["isTagValueSetter"], "fileName": "com.intellij.util.xml.impl.InvocationCache"}, {"methodBody": ["METHOD_START", "{", "myInvocations . put ( method ,    invocation )  ;", "}", "METHOD_END"], "methodName": ["putInvocation"], "fileName": "com.intellij.util.xml.impl.InvocationCache"}, {"methodBody": ["METHOD_START", "{", "return   PhysicalDomParentStrategy . strategyEquals ( this ,    o )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.intellij.util.xml.impl.PhysicalDomParentStrategy"}, {"methodBody": ["METHOD_START", "{", "while    (  ( cur    !  =    null )     &  &     (  !  ( cur . isPhysical (  )  )  )  )     {", "cur    =    cur . getParent (  )  ;", "}", "return   cur ;", "}", "METHOD_END"], "methodName": ["findIncluder"], "fileName": "com.intellij.util.xml.impl.PhysicalDomParentStrategy"}, {"methodBody": ["METHOD_START", "{", "return    (  ( XmlTag )     ( PhysicalDomParentStrategy . getParentTagCandidate ( xmlElement )  )  )  ;", "}", "METHOD_END"], "methodName": ["getParentTag"], "fileName": "com.intellij.util.xml.impl.PhysicalDomParentStrategy"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   parent    =    xmlElement . getParent (  )  ;", "return   parent   instanceof   XmlEntityRef    ?    parent . getParent (  )     :    parent ;", "}", "METHOD_END"], "methodName": ["getParentTagCandidate"], "fileName": "com.intellij.util.xml.impl.PhysicalDomParentStrategy"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( myElement . isPhysical (  )  )  )     {", "return   myElement . getNavigationElement (  )  . hashCode (  )  ;", "}", "return   myElement . hashCode (  )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.intellij.util.xml.impl.PhysicalDomParentStrategy"}, {"methodBody": ["METHOD_START", "{", "if    ( strategy    =  =    o )", "return   true ;", "if    (  !  ( o   instanceof   DomParentStrategy )  )", "return   false ;", "final   XmlElement   thatElement    =     (  ( DomParentStrategy )     ( o )  )  . getXmlElement (  )  ;", "if    ( thatElement    =  =    null )", "return   false ;", "XmlElement   element    =    strategy . getXmlElement (  )  ;", "if    ( element    =  =    null )", "return   false ;", "if    (  . xmlElementsEqual ( element ,    thatElement )  )     {", "if    ( element    !  =    thatElement )     {", "final   PsiElement   nav 1     =    element . getNavigationElement (  )  ;", "final   PsiElement   nav 2     =    thatElement . getNavigationElement (  )  ;", "if    ( nav 1     !  =    nav 2  )     {", "PsiElement   curContext    =     . findIncluder ( element )  ;", "PsiElement   navContext    =     . findIncluder ( nav 1  )  ;", ". LOG . error ( LogMessageEx . createEvent (  \" x : include   processing   error \"  ,     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \" nav 1  , nav 2  =  \"     +    nav 1  )     +     \"  ,     \"  )     +    nav 2  )     +     \"  ;  \\ n \"  )     +     ( nav 1  . getContainingFile (  )  )  )     +     \"  :  \"  )     +     ( nav 1  . getTextRange (  )  . getStartOffset (  )  )  )     +     \"  !  =  \"  )     +     ( nav 2  . getContainingFile (  )  )  )     +     \"  :  \"  )     +     ( nav 2  . getTextRange (  )  . getStartOffset (  )  )  )     +     \"  ;  \\ n \"  )     +     ( nav 1     =  =    element )  )     +     \"  ;  \"  )     +     ( nav 2     =  =    thatElement )  )     +     \"  ;  \\ n \"  )     +     \" contexts   equal :     \"  )     +     ( curContext    =  =    navContext )  )     +     \"  ;  \\ n \"  )     +     \" curContext ?  . physical =  \"  )     +     (  ( curContext    !  =    null )     &  &     ( curContext . isPhysical (  )  )  )  )     +     \"  ;  \\ n \"  )     +     \" navContext ?  . physical =  \"  )     +     (  ( navContext    !  =    null )     &  &     ( navContext . isPhysical (  )  )  )  )     +     \"  ;  \\ n \"  )     +     \" myElement . physical =  \"  )     +     ( element . isPhysical (  )  )  )     +     \"  ;  \\ n \"  )     +     \" thatElement . physical =  \"  )     +     ( thatElement . isPhysical (  )  )  )     +     \"  \\ n \"  )     +     ( DebugUtil . currentStackTrace (  )  )  )  ,    new   com . intellij . openapi . diagnostic . Attachment (  \" Including   tag   text    1  . xml \"  ,     ( curContext    =  =    null    ?     \" null \"     :    curContext . getText (  )  )  )  ,    new   com . intellij . openapi . diagnostic . Attachment (  \" Including   tag   text    2  . xml \"  ,     ( navContext    =  =    null    ?     \" null \"     :    navContext . getText (  )  )  )  )  )  ;", "throw   new   AssertionError (  )  ;", "}", "}", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["strategyEquals"], "fileName": "com.intellij.util.xml.impl.PhysicalDomParentStrategy"}, {"methodBody": ["METHOD_START", "{", "if    ( fst . equals ( snd )  )", "return   true ;", "if    (  (  ( fst . isValid (  )  )     &  &     ( fst . is (  )  )  )     |  |     (  ( snd . isValid (  )  )     &  &     ( snd . is (  )  )  )  )", "return   false ;", "if    (  ( fst . getTextLength (  )  )     !  =     ( snd . getTextLength (  )  )  )", "return   false ;", "if    (  ( fst . getStartOffsetInParent (  )  )     !  =     ( snd . getStartOffsetInParent (  )  )  )", "return   false ;", "PsiElement   nav 1     =    fst . getNavigationElement (  )  ;", "PsiElement   nav 2     =    snd . getNavigationElement (  )  ;", "return    ( nav 1     !  =    null )     &  &     ( nav 1  . equals ( nav 2  )  )  ;", "}", "METHOD_END"], "methodName": ["xmlElementsEqual"], "fileName": "com.intellij.util.xml.impl.PhysicalDomParentStrategy"}, {"methodBody": ["METHOD_START", "{", "final   Object   o    =    myMethods [ i ]  . invoke ( object ,    EMPTY _ OBJECT _ ARRAY )  ;", "if    ( i    =  =     ( myLastElement )  )", "return   o ;", "if    ( o   instanceof   List )     {", "List < Object >    result    =    new   ArrayList <  >  (  )  ;", "for    ( Object   o 1     :     (  ( List )     ( o )  )  )     {", "result . add ( invoke (  ( i    +     1  )  ,    o 1  )  )  ;", "}", "return   result ;", "}", "return   invoke (  ( i    +     1  )  ,    o )  ;", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "com.intellij.util.xml.impl.PropertyAccessorInvocation"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    o )", "return   true ;", "if    (  !  ( o   instanceof    )  )", "return   false ;", "final      that    =     (  (  )     ( o )  )  ;", "if    (  !  ( myFileElement . equals ( that . myFileElement )  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.intellij.util.xml.impl.RootDomParentStrategy"}, {"methodBody": ["METHOD_START", "{", "return   myFileElement . hashCode (  )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.intellij.util.xml.impl.RootDomParentStrategy"}, {"methodBody": ["METHOD_START", "{", "myCache    =    null ;", "}", "METHOD_END"], "methodName": ["clearCache"], "fileName": "com.intellij.util.xml.impl.SofterCache"}, {"methodBody": ["METHOD_START", "{", "return   new   SofterCache ( valueProvider )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.intellij.util.xml.impl.SofterCache"}, {"methodBody": ["METHOD_START", "{", "SofterReference < ConcurrentMap < T ,    V >  >    ref    =    myCache ;", "ConcurrentMap < T ,    V >    map    =     ( ref    =  =    null )     ?    null    :    ref . get (  )  ;", "if    ( map    =  =    null )     {", "myCache    =    new   SofterReference (  ( map    =    ContainerUtil . newConcurrentMap (  )  )  )  ;", "}", "V   value    =    map . get ( key )  ;", "if    ( value    =  =    null )     {", "map . put ( key ,     ( value    =    myValueProvider . fun ( key )  )  )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["getCachedValue"], "fileName": "com.intellij.util.xml.impl.SofterCache"}, {"methodBody": ["METHOD_START", "{", "return   myOldValue ;", "}", "METHOD_END"], "methodName": ["getOldValue"], "fileName": "com.intellij.util.xml.impl.StableInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( t    =  =    null )     |  |     (  !  ( myValidator . value ( t )  )  )  )", "return   true ;", "for    ( final   Class   aClass    :    myClasses )     {", "if    (  !  ( aClass . isInstance ( t )  )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isNotValid"], "fileName": "com.intellij.util.xml.impl.StableInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( methods    !  =    null )     {", "for    ( final   JavaMethod   method    :    methods )     {", "myCollectionChildrenAdditionMethods . put ( method . getSignature (  )  ,    description )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addAdders"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfo"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( myInitialized )  )     {", "final   Builder   builder    =    new   Builder ( myClass )  ;", "final   JavaMethod   customChildrenGetter    =    builder . getCustomChildrenGetter (  )  ;", "if    ( customChildrenGetter    !  =    null )     {", "myCustomDescription    =    new   CustomDomChildrenDescriptionImpl ( customChildrenGetter )  ;", "}", "myAttributeChildrenMethods    =    builder . getAttributes (  )  ;", "myAttributes . addDescriptions ( myAttributeChildrenMethods . values (  )  )  ;", "myFixedChildrenMethods    =    builder . getFixedGetters (  )  ;", "for    ( final   Pair < FixedChildDescriptionImpl ,    Integer >    pair    :    myFixedChildrenMethods . values (  )  )     {", "myFixed . addDescription ( pair . first )  ;", "}", "myCollectionChildrenGetterMethods    =    builder . getCollectionGetters (  )  ;", "myCollections . addDescriptions ( myCollectionChildrenGetterMethods . values (  )  )  ;", "for    ( final   CollectionChildDescriptionImpl   description    :    myCollectionChildrenGetterMethods . values (  )  )     {", "final   XmlName   name    =    description . getXmlName (  )  ;", "addAdders ( description ,    builder . collectionAdders . get ( name )  )  ;", "addAdders ( description ,    builder . collectionIndexAdders . get ( name )  )  ;", "addAdders ( description ,    builder . collectionIndexClassAdders . get ( name )  )  ;", "addAdders ( description ,    builder . collectionClassIndexAdders . get ( name )  )  ;", "addAdders ( description ,    builder . collectionClassAdders . get ( name )  )  ;", "}", "final   NotNullFunction < String ,    CollectionChildDescriptionImpl >    mapper    =     (    xmlName )     -  >    ObjectUtils . assertNotNull ( myCollections . findDescription ( xmlName )  )  ;", "final   Map < JavaMethodSignature ,    String [  ]  >    getters    =    builder . getCompositeCollectionGetters (  )  ;", "for    ( final   JavaMethodSignature   signature    :    getters . keySet (  )  )     {", "myCompositeChildrenMethods . put ( signature ,    ContainerUtil . map 2 Set ( getters . get ( signature )  ,    mapper )  )  ;", "}", "final   Map < JavaMethodSignature ,    Pair < String ,    String [  ]  >  >    adders    =    builder . getCompositeCollectionAdders (  )  ;", "for    ( final   JavaMethodSignature   signature    :    adders . keySet (  )  )     {", "final   Pair < String ,    String [  ]  >    pair    =    adders . get ( signature )  ;", "myCompositeCollectionAdditionMethods . put ( signature ,    Pair . create ( myCollections . findDescription ( pair . first )  ,    ContainerUtil . map 2 Set ( pair . second ,    mapper )  )  )  ;", "}", "myNameValueGetter    =    builder . getNameValueGetter (  )  ;", "myValueElement    =    builder . isValueElement (  )  ;", "myInitialized    =    true ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["buildMethodMaps"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfo"}, {"methodBody": ["METHOD_START", "{", "return   myAttributes ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfo"}, {"methodBody": ["METHOD_START", "{", "return   myCollections ;", "}", "METHOD_END"], "methodName": ["getCollections"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfo"}, {"methodBody": ["METHOD_START", "{", "return   myFixed ;", "}", "METHOD_END"], "methodName": ["getFixed"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfo"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >  [  ]    parameterTypes    =    method . getParameterTypes (  )  ;", "if    (  (  ( parameterTypes . length )     >  =     1  )     &  &     ( parameterTypes [  0  ]  . equals (  . class )  )  )     {", "return   new   Function . First <  >  (  )  ;", "}", "if    (  (  ( parameterTypes . length )     =  =     2  )     &  &     ( parameterTypes [  1  ]  . equals (  . class )  )  )     {", "return    (    s )     -  >     (  ( Integer )     ( s [  1  ]  )  )  ;", "}", "return   new   ConstantFunction ( Integer . MAX _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["getIndexGetter"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfo"}, {"methodBody": ["METHOD_START", "{", "return    ( myNameValueGetter )     =  =    null    ?    null    :    myNameValueGetter . invoke ( element )  ;", "}", "METHOD_END"], "methodName": ["getNameObject"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfo"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >  [  ]    parameterTypes    =    method . getParameterTypes (  )  ;", "if    (  (  ( parameterTypes . length )     >  =     1  )     &  &     ( parameterTypes [  0  ]  . equals ( Class . class )  )  )     {", "return   new   Function . First <  >  (  )  ;", "}", "if    (  (  ( parameterTypes . length )     =  =     2  )     &  &     ( parameterTypes [  1  ]  . equals ( Class . class )  )  )     {", "return    (    s )     -  >     (  ( Type )     ( s [  1  ]  )  )  ;", "}", "return    (    s )     -  >    method . getReturnType (  )  ;", "}", "METHOD_END"], "methodName": ["getTypeGetter"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfo"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    method . getName (  )  ;", "if    (  !  ( name . startsWith ( prefix )  )  )", "return   null ;", "final   SubTagList   subTagAnnoon    =    method . getAnnoon ( SubTagList . class )  ;", "if    (  ( subTagAnnoon    !  =    null )     &  &     (  !  ( StringUtil . isEmpty ( subTagAnnoon . value (  )  )  )  )  )     {", "return   DomImplUtil . createXmlName ( subTagAnnoon . value (  )  ,    method )  ;", "}", "final   String   tagName    =    getNameStrategy ( false )  . convertName ( name . substring ( prefix . length (  )  )  )  ;", "return   StringUtil . isEmpty ( tagName )     ?    null    :    DomImplUtil . createXmlName ( tagName ,    method )  ;", "}", "METHOD_END"], "methodName": ["extractTagName"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >  [  ]    parameterTypes    =    method . getParameterTypes (  )  ;", "switch    ( parameterTypes . length )     {", "case    0     :", "return   collectionAdders ;", "case    1     :", "if    ( Class . class . equals ( parameterTypes [  0  ]  )  )", "return   collectionClassAdders ;", "if    (  . isInt ( parameterTypes [  0  ]  )  )", "return   collectionIndexAdders ;", "break ;", "case    2     :", "if    (  . isIndexClassAdder ( parameterTypes [  0  ]  ,    parameterTypes [  1  ]  )  )", "return   collectionIndexClassAdders ;", "if    (  . isIndexClassAdder ( parameterTypes [  1  ]  ,    parameterTypes [  0  ]  )  )", "return   collectionClassIndexAdders ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAddersMap"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "return   myAttributes ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "final   Map < JavaMethodSignature ,    CollectionChildDescriptionImpl >    getters    =    new   gnu . trove . THashMap (  )  ;", "for    ( final   XmlName   xmlName    :    myCollectionGetters . keySet (  )  )     {", "final   Collection < JavaMethod >    collGetters    =    myCollectionGetters . get ( xmlName )  ;", "final   JavaMethod   method    =    collGetters . iterator (  )  . next (  )  ;", "final   CollectionChildDescriptionImpl   description    =    new   CollectionChildDescriptionImpl ( xmlName ,    DomReflectionUtil . extractCollectionElementType ( method . getReturnType (  )  )  ,    collGetters )  ;", "for    ( final   JavaMethod   getter    :    collGetters )     {", "getters . put ( getter . getSignature (  )  ,    description )  ;", "}", "}", "return   getters ;", "}", "METHOD_END"], "methodName": ["getCollectionGetters"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "return   myCompositeCollectionAdders ;", "}", "METHOD_END"], "methodName": ["getCompositeCollectionAdders"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "return   myCompositeCollectionGetters ;", "}", "METHOD_END"], "methodName": ["getCompositeCollectionGetters"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "return   myCustomChildrenGetter ;", "}", "METHOD_END"], "methodName": ["getCustomChildrenGetter"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "final   Map < JavaMethodSignature ,    Pair < FixedChildDescriptionImpl ,    Integer >  >    map    =    new   gnu . trove . THashMap (  )  ;", "final   Set < XmlName >    names    =    myFixedChildrenGetters . keySet (  )  ;", "for    ( final   XmlName   name    :    names )     {", "final   TIntObjectHashMap < Collection < JavaMethod >  >    map 1     =    myFixedChildrenGetters . get ( name )  ;", "int   max    =     0  ;", "final   int [  ]    ints    =    map 1  . keys (  )  ;", "for    ( final   int   i    :    ints )     {", "max    =    Math . max ( max ,    i )  ;", "}", "int   count    =    max    +     1  ;", "final   Collection < JavaMethod >  [  ]    getters    =    new   Collection [ count ]  ;", "for    ( final   int   i    :    ints )     {", "getters [ i ]     =    map 1  . get ( i )  ;", "}", "final   FixedChildDescriptionImpl   description    =    new   FixedChildDescriptionImpl ( name ,    map 1  . get (  0  )  . iterator (  )  . next (  )  . getReturnType (  )  ,    count ,    getters )  ;", "for    ( int   i    =     0  ;    i    <     ( getters . length )  ;    i +  +  )     {", "final   Collection < JavaMethod >    collection    =    getters [ i ]  ;", "for    ( final   JavaMethod   method    :    collection )     {", "map . put ( method . getSignature (  )  ,    Pair . create ( description ,    i )  )  ;", "}", "}", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["getFixedGetters"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "final   String   propertyName    =    StaticGenericInfoBuilder . getPropertyName ( method )  ;", "return   propertyName    =  =    null    ?    null    :    getNameStrategy ( isAttribute )  . convertName ( propertyName )  ;", "}", "METHOD_END"], "methodName": ["getNameFromMethod"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "final   DomNameStrategy   strategy    =    DomImplUtil . getDomNameStrategy ( ReflectionUtil . getRawType ( myClass )  ,    isAttribute )  ;", "return   strategy    !  =    null    ?    strategy    :    DomNameStrategy . HYPHEN _ STRATEGY ;", "}", "METHOD_END"], "methodName": ["getNameStrategy"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "return   myNameValueGetter ;", "}", "METHOD_END"], "methodName": ["getNameValueGetter"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "return   StringUtil . getPropertyName ( method . getMethodName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getPropertyName"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "final   SubTag   subTagAnnotation    =    method . getAnnotation ( SubTag . class )  ;", "if    (  ( subTagAnnotation    =  =    null )     |  |     ( StringUtil . isEmpty ( subTagAnnotation . value (  )  )  )  )     {", "return   getNameFromMethod ( method ,    false )  ;", "}", "return   subTagAnnotation . value (  )  ;", "}", "METHOD_END"], "methodName": ["getSubTagName"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "final   SubTagList   subTagList    =    method . getAnnotation ( SubTagList . class )  ;", "if    (  ( subTagList    =  =    null )     |  |     ( StringUtil . isEmpty ( subTagList . value (  )  )  )  )     {", "final   String   propertyName    =     . getPropertyName ( method )  ;", "if    ( propertyName    !  =    null )     {", "final   String   singular    =    StringUtil . unpluralize ( propertyName )  ;", "assert   singular    !  =    null    :     \" Can ' t   unpluralize :     \"     +    propertyName ;", "return   getNameStrategy ( false )  . convertName ( singular )  ;", "} else    {", "return   null ;", "}", "}", "return   subTagList . value (  )  ;", "}", "METHOD_END"], "methodName": ["getSubTagNameForCollection"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "final   XmlName   tagName    =    extractTagName ( method ,     \" add \"  )  ;", "if    ( tagName    =  =    null )", "return   false ;", "final   Type   type    =    myCollectionChildrenTypes . get ( tagName )  ;", "if    (  ( type    =  =    null )     |  |     (  !  ( ReflectionUtil . getRawType ( type )  . isAssignableFrom ( method . getReturnType (  )  )  )  )  )", "return   false ;", "return    . ADDER _ PARAMETER _ TYPES . containsAll ( Arrays . asList ( method . getParameterTypes (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAddMethod"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( method . getSignature (  )  . findMethod ( DomElement . class )  )     !  =    null )", "return   true ;", "final   Class <  ?  >    aClass    =    method . getDeclaringClass (  )  ;", "return    ( aClass . equals ( AttributeValue . class )  )     |  |     (  ( aClass . equals ( DomValue . class )  )     &  &     (  \" getConverter \"  . equals ( method . getName (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isCoreMethod"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "return    ( type    !  =    null )     &  &     ( DomElement . class . isAssignableFrom ( ReflectionUtil . getRawType ( type )  )  )  ;", "}", "METHOD_END"], "methodName": ["isDomElement"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "return    ( StaticGenericInfoBuilder . isInt ( first )  )     &  &     ( second . equals ( Class . class )  )  ;", "}", "METHOD_END"], "methodName": ["isIndexClassAdder"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "return    ( aClass . equals ( int . class )  )     |  |     ( aClass . equals ( Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["isInt"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "return   myValueElement ;", "}", "METHOD_END"], "methodName": ["isValueElement"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( DomImplUtil . isTagValueGetter ( method )  )     {", "myValueElement    =    true ;", "return   true ;", "}", "final   Class   returnType    =    method . getReturnType (  )  ;", "final   boolean   isAttributeValueMethod    =    GenericAttributeValue . class . isAssignableFrom ( returnType )  ;", "final   JavaMethodSignature   signature    =    method . getSignature (  )  ;", "final   Attribute   annotation    =    method . getAnnotation ( Attribute . class )  ;", "final   boolean   isAttributeMethod    =     ( annotation    !  =    null )     |  |    isAttributeValueMethod ;", "if    ( annotation    !  =    null )     {", "assert   isAttributeValueMethod    |  |     ( GenericAttributeValue . class . isAssignableFrom ( returnType )  )     :    method    +     \"    should   return   GenericAttributeValue \"  ;", "}", "if    ( isAttributeMethod )     {", "final   String   s    =     ( annotation    =  =    null )     ?    null    :    annotation . value (  )  ;", "String   attributeName    =     ( StringUtil . isEmpty ( s )  )     ?    getNameFromMethod ( method ,    true )     :    s ;", "assert    ( attributeName    !  =    null )     &  &     ( StringUtil . isNotEmpty ( attributeName )  )     :     \" Can ' t   guess   attribute   name   from   method   name :     \"     +     ( method . getName (  )  )  ;", "final   XmlName   attrName    =    DomImplUtil . createXmlName ( attributeName ,    method )  ;", "myAttributes . put ( signature ,    new   AttributeChildDescriptionImpl ( attrName ,    method )  )  ;", "return   true ;", "}", "if    (  . isDomElement ( returnType )  )     {", "final   String   qname    =    getSubTagName ( method )  ;", "if    ( qname    !  =    null )     {", "final   XmlName   xmlName    =    DomImplUtil . createXmlName ( qname ,    method )  ;", "Type   collectionType    =    myCollectionChildrenTypes . get ( xmlName )  ;", "if    ( collectionType    !  =    null )     {", ". LOG . error (  (  (  (  (  (  \" Collection    (  \"     +    collectionType )     +     \"  )    and   fixed   children   cannot   intersect :     \"  )     +    qname )     +     \"    for    \"  )     +     ( myClass )  )  )  ;", "}", "int   index    =     0  ;", "final   SubTag   subTagAnnotation    =    method . getAnnotation ( SubTag . class )  ;", "if    (  ( subTagAnnotation    !  =    null )     &  &     (  ( subTagAnnotation . index (  )  )     !  =     0  )  )     {", "index    =    subTagAnnotation . index (  )  ;", "}", "final   TIntObjectHashMap < Collection < JavaMethod >  >    map    =    myFixedChildrenGetters . get ( xmlName )  ;", "Collection < JavaMethod >    methods    =    map . get ( index )  ;", "if    ( methods    =  =    null )     {", "map . put ( index ,     ( methods    =    new   com . intellij . util . SmartList (  )  )  )  ;", "}", "methods . add ( method )  ;", "return   true ;", "}", "}", "final   Type   type    =    DomReflectionUtil . extractCollectionElementType ( method . getGenericReturnType (  )  )  ;", "if    (  . isDomElement ( type )  )     {", "final   CustomChildren   customChildren    =    method . getAnnotation ( CustomChildren . class )  ;", "if    ( customChildren    !  =    null )     {", "myCustomChildrenGetter    =    method ;", "return   true ;", "}", "final   SubTagsList   subTagsList    =    method . getAnnotation ( SubTagsList . class )  ;", "if    ( subTagsList    !  =    null )     {", "myCompositeCollectionGetters . put ( signature ,    subTagsList . value (  )  )  ;", "return   true ;", "}", "final   String   qname    =    getSubTagNameForCollection ( method )  ;", "if    ( qname    !  =    null )     {", "XmlName   xmlName    =    DomImplUtil . createXmlName ( qname ,    type ,    method )  ;", "assert    !  ( myFixedChildrenGetters . containsKey ( xmlName )  )     :     \" Collection   and   fixed   children   cannot   intersect :     \"     +    qname ;", "myCollectionChildrenTypes . put ( xmlName ,    type )  ;", "myCollectionGetters . put ( xmlName ,    method )  ;", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["processGetterMethod"], "fileName": "com.intellij.util.xml.impl.StaticGenericInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "assertNull ( tag . getText (  )  ,    getCachedHandler ( tag )  )  ;", "if    ( tag . isValid (  )  )     {", "for    ( XmlTag   Tag    :    tag . getSubTags (  )  )     {", "assertNoCache ( Tag )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["assertNoCache"], "fileName": "com.intellij.util.xml.impl.TreeIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "return   new   TypeChooser (  )     {", "@ Override", "public   Type   chooseType ( final   XmlTag   tag )     {", "return    ( tag    !  =    null )     &  &     (  ( tag . findFirstSubTag (  \" foo \"  )  )     !  =    null )     ?     . FooInterface . class    :     . BarInterface . class ;", "}", "@ Override", "public   void   distinguishTag ( final   XmlTag   tag ,    final   Type   aClass )    throws   IncorrectOperationException    {", "if    (  (  . FooInterface . class . equals ( aClass )  )     &  &     (  ( tag . findFirstSubTag (  \" foo \"  )  )     =  =    null )  )     {", "tag . add ( XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < foo /  >  \"  )  )  ;", "}", "}", "@ Override", "public   Type [  ]    getChooserTypes (  )     {", "return   new   Class [  ]  {     . FooInterface . class ,     . BarInterface . class    }  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createClassChooser"], "fileName": "com.intellij.util.xml.impl.TreeIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "return   createElement ( xml ,    TreeIncrementalUpdateTest . MyElement . class )  ;", "}", "METHOD_END"], "methodName": ["createElement"], "fileName": "com.intellij.util.xml.impl.TreeIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =     (  ( XmlFile )     ( createFile (  \" file . xml \"  ,    text )  )  )  ;", "final   DomFileElementImpl <  . MyElement >    fileElement    =    getDomManager (  )  . getFileElement ( file ,     . MyElement . class ,     \" a \"  )  ;", "final    . MyElement   rootElement    =    fileElement . getRootElement (  )  ;", "return   rootElement ;", "}", "METHOD_END"], "methodName": ["createPhysicalElement"], "fileName": "com.intellij.util.xml.impl.TreeIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "final   TreeIncrementalUpdateTest . MyElement   element    =    createElement (  \"  < a >  < child - element >  < child /  >  <  / child - element >  < child - element /  >  <  / a >  \"  )  ;", "final   TreeIncrementalUpdateTest . MyElement   child    =    element . getChild (  )  ;", "final   TreeIncrementalUpdateTest . MyElement   child 2     =    element . getChild 2  (  )  ;", "final   TreeIncrementalUpdateTest . MyElement   firstChild    =    element . getChildElements (  )  . get (  0  )  ;", "final   TreeIncrementalUpdateTest . MyElement   lastChild    =    element . getChildElements (  )  . get (  1  )  ;", "final   XmlTag   tag    =    element . getXmlTag (  )  ;", "final   XmlTag   childTag    =    tag . getSubTags (  )  [  0  ]  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >    childTag . delete (  )  )  ;", "putExpected ( new   DomEvent ( element ,    false )  )  ;", "assertResultsAndClear (  )  ;", "assertEquals ( child ,    element . getChild (  )  )  ;", "assertEquals ( child 2  ,    element . getChild 2  (  )  )  ;", "assertEquals ( Arrays . asList ( lastChild )  ,    element . getChildElements (  )  )  ;", "assertCached ( lastChild ,    tag . getSubTags (  )  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testActuallyRemoveCollectionElement"], "fileName": "com.intellij.util.xml.impl.TreeIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "final   TreeIncrementalUpdateTest . MyElement   element    =    createElement (  \"  < a >  < child /  >  < child /  >  < child - element /  >  <  / a >  \"  )  ;", "final   TreeIncrementalUpdateTest . MyElement   child    =    element . getChild (  )  ;", "final   TreeIncrementalUpdateTest . MyElement   child 2     =    element . getChild 2  (  )  ;", "final   TreeIncrementalUpdateTest . MyElement   firstChild    =    element . getChildElements (  )  . get (  0  )  ;", "element . getXmlTag (  )  . add ( createTag (  \"  < child - element /  >  \"  )  )  ;", "final   XmlTag [  ]    subTags    =    element . getXmlTag (  )  . getSubTags (  )  ;", "assertEquals (  2  ,    element . getChildElements (  )  . size (  )  )  ;", "assertEquals ( firstChild ,    element . getChildElements (  )  . get (  0  )  )  ;", "TreeIncrementalUpdateTest . MyElement   nextChild    =    element . getChildElements (  )  . get (  1  )  ;", "putExpected ( new   DomEvent ( element ,    false )  )  ;", "assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["testAddCollectionElement"], "fileName": "com.intellij.util.xml.impl.TreeIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "final   TreeIncrementalUpdateTest . MyElement   element    =    createPhysicalElement (  (  \"  < a >  \"     +     (  (  \"  < child /  >  \"     +     \"  < child >  < child /  >  <  / child >  \"  )     +     \"  < child /  >  <  / a >  \"  )  )  )  ;", "final   TreeIncrementalUpdateTest . MyElement   child    =    element . getChild (  )  ;", "final   TreeIncrementalUpdateTest . MyElement   child 2     =    element . getChild 2  (  )  ;", "final   XmlTag   leafTag    =    child 2  . getChild (  )  . getXmlTag (  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "element . getXmlTag (  )  . addAfter ( createTag (  \"  < child /  >  \"  )  ,    child . getXmlTag (  )  )  ;", "}  )  ;", "assertNoCache ( leafTag )  ;", "final   XmlTag [  ]    subTags    =    element . getXmlTag (  )  . getSubTags (  )  ;", "assertFalse ( child 2  . isValid (  )  )  ;", "assertEquals ( child ,    element . getChild (  )  )  ;", "assertFalse ( child 2  . equals ( element . getChild 2  (  )  )  )  ;", "assertCached ( child ,    subTags [  0  ]  )  ;", "assertNoCache ( subTags [  2  ]  )  ;", "assertNoCache ( subTags [  3  ]  )  ;", "putExpected ( new   DomEvent ( element ,    false )  )  ;", "putExpected ( new   DomEvent ( element ,    false )  )  ;", "assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["testAddFixedElement"], "fileName": "com.intellij.util.xml.impl.TreeIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "final   TreeIncrementalUpdateTest . MyElement   element    =    createElement (  \"  < a >  <  / a >  \"  )  ;", "final   TreeIncrementalUpdateTest . MyElement   child    =    element . getChild (  )  ;", "element . getXmlTag (  )  . add ( createTag (  \"  < child /  >  \"  )  )  ;", "final   XmlTag [  ]    subTags    =    element . getXmlTag (  )  . getSubTags (  )  ;", "assertTrue ( child . equals ( element . getChild (  )  )  )  ;", "assertTrue ( element . getChild (  )  . equals ( child )  )  ;", "assertCached ( element . getChild (  )  ,    subTags [  0  ]  )  ;", "putExpected ( new   DomEvent ( element ,    false )  )  ;", "assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["testAddFixedElementCanDefineIt"], "fileName": "com.intellij.util.xml.impl.TreeIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "final   TreeIncrementalUpdateTest . MyElement   element    =    createElement (  \"  < a >  < child /  >  <  / a >  \"  )  ;", "element . getXmlTag (  )  . add ( createTag (  \"  < another - child /  >  \"  )  )  ;", "assertEquals (  1  ,    element . getAnotherChildren (  )  . size (  )  )  ;", "putExpected ( new   DomEvent ( element ,    false )  )  ;", "assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["testAnotherChildren"], "fileName": "com.intellij.util.xml.impl.TreeIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "getTypeChooserManager (  )  . registerTypeChooser ( TreeIncrementalUpdateTest . MyElement . class ,    TreeIncrementalUpdateTest . createClassChooser (  )  )  ;", "try    {", "final   TreeIncrementalUpdateTest . MyElement   element    =    getDomManager (  )  . createMockElement ( TreeIncrementalUpdateTest . MyElement . class ,    getModule (  )  ,    true )  ;", "final   DomFileElement < TreeIncrementalUpdateTest . MyElement >    root    =    DomUtil . getFileElement ( element )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "element . addChildElement (  )  . addChildElement (  )  ;", "}  )  ;", "final   TreeIncrementalUpdateTest . MyElement   child    =    element . getChildElements (  )  . get (  0  )  ;", "TreeIncrementalUpdateTest . MyElement   grandChild    =    child . getChildElements (  )  . get (  0  )  ;", "assertTrue (  ( child   instanceof   TreeIncrementalUpdateTest . BarInterface )  )  ;", "assertTrue (  ( grandChild   instanceof   TreeIncrementalUpdateTest . BarInterface )  )  ;", "grandChild    =    element . getChildElements (  )  . get (  0  )  . getChildElements (  )  . get (  0  )  ;", "final   XmlTag   tag    =    grandChild . getXmlTag (  )  ;", "assertTrue ( grandChild . isValid (  )  )  ;", "assertEquals ( grandChild ,    root . getRootElement (  )  . getChildElements (  )  . get (  0  )  . getChildElements (  )  . get (  0  )  )  ;", "assertNotNull ( element . getXmlTag (  )  )  ;", "assertNotNull ( child . getXmlTag (  )  )  ;", "assertNotNull ( tag )  ;", "assertTrue ( tag . isValid (  )  )  ;", "myCallRegistry . clear (  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "tag . add ( XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < foo /  >  \"  )  )  ;", "}  )  ;", "assertTrue ( root . isValid (  )  )  ;", "assertTrue ( element . isValid (  )  )  ;", "assertTrue ( grandChild . isValid (  )  )  ;", "final   TreeIncrementalUpdateTest . MyElement   newChild    =    root . getRootElement (  )  . getChildElements (  )  . get (  0  )  ;", "assertTrue (  ( newChild   instanceof   TreeIncrementalUpdateTest . BarInterface )  )  ;", "final   TreeIncrementalUpdateTest . MyElement   newGrandChild    =    newChild . getChildElements (  )  . get (  0  )  ;", "assertTrue ( newGrandChild . isValid (  )  )  ;", "assertTrue (  ( newGrandChild   instanceof   TreeIncrementalUpdateTest . FooInterface )  )  ;", "putExpected ( new   DomEvent ( child ,    false )  )  ;", "putExpected ( new   DomEvent ( grandChild ,    false )  )  ;", "assertResultsAndClear (  )  ;", "}    finally    {", "getTypeChooserManager (  )  . unregisterTypeChooser ( TreeIncrementalUpdateTest . MyElement . class )  ;", "}", "}", "METHOD_END"], "methodName": ["testChangeImplementationClass"], "fileName": "com.intellij.util.xml.impl.TreeIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "getTypeChooserManager (  )  . registerTypeChooser ( TreeIncrementalUpdateTest . MyElement . class ,    TreeIncrementalUpdateTest . createClassChooser (  )  )  ;", "try    {", "final   TreeIncrementalUpdateTest . MyElement   element    =    getDomManager (  )  . createMockElement ( TreeIncrementalUpdateTest . MyElement . class ,    getModule (  )  ,    true )  ;", "final   DomFileElement < TreeIncrementalUpdateTest . MyElement >    root    =    DomUtil . getFileElement ( element )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "element . addChildElement (  )  . addChildElement (  )  ;", "}  )  ;", "final   TreeIncrementalUpdateTest . MyElement   child    =    element . getChildElements (  )  . get (  0  )  ;", "final   TreeIncrementalUpdateTest . MyElement   grandChild    =    child . getChildElements (  )  . get (  0  )  ;", "assertTrue (  ( child   instanceof   TreeIncrementalUpdateTest . BarInterface )  )  ;", "assertTrue (  ( grandChild   instanceof   TreeIncrementalUpdateTest . BarInterface )  )  ;", "assertTrue ( element . isValid (  )  )  ;", "assertTrue ( child . isValid (  )  )  ;", "assertTrue ( grandChild . isValid (  )  )  ;", "assertNotNull ( element . getXmlTag (  )  )  ;", "assertNotNull ( child . getXmlTag (  )  )  ;", "final   XmlTag   tag    =    grandChild . getXmlTag (  )  ;", "assertNotNull ( tag )  ;", "myCallRegistry . clear (  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "tag . add ( XmlElementFactory . getInstance ( getProject (  )  )  . createTagFromText (  \"  < foo /  >  \"  )  )  ;", "}  )  ;", "assertTrue ( root . isValid (  )  )  ;", "assertTrue ( element . isValid (  )  )  ;", "assertTrue ( child . isValid (  )  )  ;", "final   TreeIncrementalUpdateTest . MyElement   newChild    =    element . getChildElements (  )  . get (  0  )  ;", "assertTrue ( newChild . isValid (  )  )  ;", "assertTrue ( newChild . getClass (  )  . toString (  )  ,     ( newChild   instanceof   TreeIncrementalUpdateTest . BarInterface )  )  ;", "assertTrue ( grandChild . isValid (  )  )  ;", "final   TreeIncrementalUpdateTest . MyElement   newGrandChild    =    newChild . getChildElements (  )  . get (  0  )  ;", "assertTrue ( newGrandChild . isValid (  )  )  ;", "assertTrue (  ( newGrandChild   instanceof   TreeIncrementalUpdateTest . FooInterface )  )  ;", "putExpected ( new   DomEvent ( child ,    false )  )  ;", "putExpected ( new   DomEvent ( grandChild ,    false )  )  ;", "assertResultsAndClear (  )  ;", "}    finally    {", "getTypeChooserManager (  )  . unregisterTypeChooser ( TreeIncrementalUpdateTest . MyElement . class )  ;", "}", "}", "METHOD_END"], "methodName": ["testChangeImplementationClass_InCollection"], "fileName": "com.intellij.util.xml.impl.TreeIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "final   TreeIncrementalUpdateTest . MyElement   root    =    getDomManager (  )  . createMockElement ( TreeIncrementalUpdateTest . MyElement . class ,    null ,    true )  ;", "final   TreeIncrementalUpdateTest . MyElement   element    =    WriteCommandAction . writeCommandAction ( getProject (  )  )  . compute (  (  )     -  >    root . addChildElement (  )  )  ;", "assertTrue ( root . isValid (  )  )  ;", "assertNotNull ( element . getXmlElement (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCollectionChildValidAfterFormattingReparse"], "fileName": "com.intellij.util.xml.impl.TreeIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "final   TreeIncrementalUpdateTest . Sepulka   element    =    createElement (  \"  < a >  < foo /  >  < bar /  >  <  / a >  \"  ,    TreeIncrementalUpdateTest . Sepulka . class )  ;", "final   List < TreeIncrementalUpdateTest . MyElement >    list    =    element . getCustomChildren (  )  ;", "final   XmlTag   tag    =    element . getXmlTag (  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "tag . getSubTags (  )  [  0  ]  . delete (  )  ;", "tag . getSubTags (  )  [  0  ]  . delete (  )  ;", "}  )  ;", "tag . add ( createTag (  \"  < goo /  >  \"  )  )  ;", "putExpected ( new   DomEvent ( element ,    false )  )  ;", "putExpected ( new   DomEvent ( element ,    false )  )  ;", "putExpected ( new   DomEvent ( element ,    false )  )  ;", "assertResultsAndClear (  )  ;", "assertEquals (  1  ,    element . getCustomChildren (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomChildrenEvents"], "fileName": "com.intellij.util.xml.impl.TreeIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =     (  ( XmlFile )     ( createFile (  \" file . xml \"  ,     (  \"  <  ? xml   version =  \\  '  1  .  0  \\  '    encoding =  \\  ' UTF -  8  \\  '  ?  >  \\ n \"     +     (  (  (  (  \"  < a >  \\ n \"     +     \"     < child >  \\ n \"  )     +     \"        < child /  >  \\ n \"  )     +     \"     <  / child >  \\ n \"  )     +     \"  <  / a >  \"  )  )  )  )  )  ;", "final   DomFileElementImpl <  . MyElement >    fileElement    =    getDomManager (  )  . getFileElement ( file ,     . MyElement . class ,     \" a \"  )  ;", "myCallRegistry . clear (  )  ;", "final    . MyElement   rootElement    =    fileElement . getRootElement (  )  ;", "final    . MyElement   oldLeaf    =    rootElement . getChild (  )  . getChild (  )  ;", "final   XmlTag   oldLeafTag    =    oldLeaf . getXmlTag (  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "final   Document   document    =    getDocument ( file )  ;", "document . replaceString (  0  ,    document . getText (  )  . length (  )  ,     \"  < a /  >  \"  )  ;", "commitDocument ( document )  ;", "}  )  ;", "assertFalse ( oldLeafTag . isValid (  )  )  ;", "putExpected ( new   DomEvent ( fileElement ,    false )  )  ;", "assertResultsAndClear (  )  ;", "assertEquals ( fileElement . getRootElement (  )  ,    rootElement )  ;", "assertTrue ( rootElement . isValid (  )  )  ;", "assertFalse ( oldLeaf . isValid (  )  )  ;", "assertTrue ( rootElement . getChild (  )  . isValid (  )  )  ;", "assertNull ( rootElement . getChild (  )  . getXmlTag (  )  )  ;", "assertNull ( rootElement . getChild (  )  . getChild (  )  . getXmlTag (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDocumentChange"], "fileName": "com.intellij.util.xml.impl.TreeIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =     (  ( XmlFile )     ( createFile (  \" file . xml \"  ,     (  \"  <  ? xml   version =  \\  '  1  .  0  \\  '    encoding =  \\  ' UTF -  8  \\  '  ?  >  \\ n \"     +     (  (  (  (  (  \"  <  ! DOCTYPE   ejb - jar   PUBLIC    \\  \"  -  /  / Sun   Microsystems ,    Inc .  /  / DTD   Enterprise   JavaBeans    2  .  0  /  / EN \\  \"     \\  \" http :  /  / com / dtd / ejb - jar _  2  _  0  . dtd \\  \"  >  \\ n \"     +     \"  < a >  \\ n \"  )     +     \"     < child >  \\ n \"  )     +     \"        < child /  >  \\ n \"  )     +     \"     <  / child >  \\ n \"  )     +     \"  <  / a >  \"  )  )  )  )  )  ;", "final   DomFileElementImpl <  . MyElement >    fileElement    =    getDomManager (  )  . getFileElement ( file ,     . MyElement . class ,     \" a \"  )  ;", "myCallRegistry . clear (  )  ;", "final    . MyElement   rootElement    =    fileElement . getRootElement (  )  ;", "final    . MyElement   oldLeaf    =    rootElement . getChild (  )  . getChild (  )  ;", "final   XmlTag   oldLeafTag    =    oldLeaf . getXmlTag (  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "file . getDocument (  )  . getProlog (  )  . delete (  )  ;", "final   XmlTag   tag    =    file . getDocument (  )  . getRootTag (  )  ;", "tag . setAttribute (  \" xmlns \"  ,     \" something \"  )  ;", "tag . setAttribute (  \" xmlns : xsi \"  ,     \" something \"  )  ;", "}  )  ;", "assertTrue ( oldLeafTag . isValid (  )  )  ;", "putExpected ( new   DomEvent ( fileElement ,    false )  )  ;", "putExpected ( new   DomEvent ( rootElement ,    false )  )  ;", "putExpected ( new   DomEvent ( rootElement ,    false )  )  ;", "assertResultsAndClear (  )  ;", "assertEquals ( fileElement . getRootElement (  )  ,    rootElement )  ;", "assertTrue ( rootElement . isValid (  )  )  ;", "assertTrue ( rootElement . getChild (  )  . isValid (  )  )  ;", "assertTrue ( rootElement . getChild (  )  . getXmlTag (  )  . isValid (  )  )  ;", "assertTrue ( rootElement . getChild (  )  . getChild (  )  . getXmlTag (  )  . isValid (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDocumentChange2"], "fileName": "com.intellij.util.xml.impl.TreeIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "final   TreeIncrementalUpdateTest . MyElement   root    =    getDomManager (  )  . createMockElement ( TreeIncrementalUpdateTest . MyElement . class ,    null ,    true )  ;", "WriteCommandAction . writeCommandAction ( getProject (  )  )  . compute (  (  )     -  >     {", "root . getChild (  )  . ensureTagExists (  )  ;", "root . getChild 2  (  )  . ensureTagExists (  )  ;", "final   MyElement   element    =    root . addChildElement (  )  . getChild (  )  ;", "element . ensureTagExists (  )  . getValue (  )  . setText (  \" abc \"  )  ;", "root . addChildElement (  )  ;", "root . addChildElement (  )  ;", "return   element ;", "}  )  ;", "assertTrue ( root . isValid (  )  )  ;", "final   TreeIncrementalUpdateTest . MyElement   element    =    root . getChildElements (  )  . get (  0  )  . getChild (  )  ;", "assertTrue ( element . isValid (  )  )  ;", "final   TreeIncrementalUpdateTest . MyElement   child    =    element . getChild (  )  ;", "final   TreeIncrementalUpdateTest . MyElement   genericValue    =    child . getChild (  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "final   Document   document    =    getDocument ( DomUtil . getFile ( element )  )  ;", "final   TextRange   range    =    element . getXmlTag (  )  . getTextRange (  )  ;", "document . replaceString ( range . getStartOffset (  )  ,    range . getEndOffset (  )  ,     \"  \"  )  ;", "commitDocument ( document )  ;", "}  )  ;", "assertFalse ( genericValue . isValid (  )  )  ;", "assertFalse ( child . isValid (  )  )  ;", "assertFalse ( element . isValid (  )  )  ;", "}", "METHOD_END"], "methodName": ["testInvalidateParent"], "fileName": "com.intellij.util.xml.impl.TreeIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =     (  ( XmlFile )     ( createFile (  \" file . xml \"  ,     (  \"  <  ? xml   version =  \\  '  1  .  0  \\  '    encoding =  \\  ' UTF -  8  \\  '  ?  >  \\ n \"     +     (  (  (  (  (  \"  < a >  \\ n \"     +     \"     < child >  \\ n \"  )     +     \"        < aboy    /  >  \\ n \"  )     +     \"        < agirl /  >  \\ n \"  )     +     \"     <  / child >  \\ n \"  )     +     \"  <  / a >  \"  )  )  )  )  )  ;", "final   DomFileElementImpl <  . MyElement >    fileElement    =    getDomManager (  )  . getFileElement ( file ,     . MyElement . class ,     \" a \"  )  ;", "myCallRegistry . clear (  )  ;", "final    . MyElement   rootElement    =    fileElement . getRootElement (  )  ;", "rootElement . getChild (  )  . getAboy (  )  ;", "rootElement . getChild (  )  . getAgirl (  )  ;", "final   Document   document    =    getDocument ( file )  ;", "final   int   len    =     \"  < agirl /  >  \"  . length (  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "final   int   agirl    =    document . getText (  )  . indexOf (  \"  < agirl /  >  \"  )  ;", "final   int   boy    =    document . getText (  )  . indexOf (  \"  < aboy    /  >  \"  )  ;", "document . replaceString ( agirl ,     ( agirl    +    len )  ,     \"  < aboy    /  >  \"  )  ;", "document . replaceString ( boy ,     ( boy    +    len )  ,     \"  < agirl /  >  \"  )  ;", "commitDocument ( document )  ;", "}  )  ;", "assertTrue ( rootElement . isValid (  )  )  ;", "final   XmlTag   tag 1     =    rootElement . getXmlTag (  )  . getSubTags (  )  [  0  ]  ;", "assertEquals ( getDomManager (  )  . getDomElement ( tag 1  . findFirstSubTag (  \" agirl \"  )  )  ,    rootElement . getChild (  )  . getAgirl (  )  )  ;", "assertEquals ( getDomManager (  )  . getDomElement ( tag 1  . findFirstSubTag (  \" aboy \"  )  )  ,    rootElement . getChild (  )  . getAboy (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMoveUp"], "fileName": "com.intellij.util.xml.impl.TreeIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =     (  ( XmlFile )     ( createFile (  \" file . xml \"  ,     (  \"  <  ? xml   version =  \\  '  1  .  0  \\  '    encoding =  \\  ' UTF -  8  \\  '  ?  >  \\ n \"     +     (  (  (  \"  <  ! DOCTYPE   ejb - jar   PUBLIC    \\  \"  -  /  / Sun   Microsystems ,    Inc .  /  / DTD   Enterprise   JavaBeans    2  .  0  /  / EN \\  \"     \\  \" http :  /  / com / dtd / ejb - jar _  2  _  0  . dtd \\  \"  >  \\ n \"     +     \"  < a >  \\ n \"  )     +     \"     < child - element   xxx =  \\  \"  2  3  9  \\  \"  /  >  \\ n \"  )     +     \"  <  / a >  \"  )  )  )  )  )  ;", "final   DomFileElementImpl <  . MyElement >    fileElement    =    getDomManager (  )  . getFileElement ( file ,     . MyElement . class ,     \" a \"  )  ;", "myCallRegistry . clear (  )  ;", "final    . MyElement   rootElement    =    fileElement . getRootElement (  )  ;", "final    . MyElement   oldLeaf    =    rootElement . getChildElements (  )  . get (  0  )  ;", "final   GenericAttributeValue < String >    xxx    =    oldLeaf . getXxx (  )  ;", "final   XmlTag   oldLeafTag    =    oldLeaf . getXmlTag (  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "oldLeafTag . delete (  )  ;", "}  )  ;", "assertFalse ( oldLeaf . isValid (  )  )  ;", "assertFalse ( xxx . isValid (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRemoveAttributeParent"], "fileName": "com.intellij.util.xml.impl.TreeIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "final   TreeIncrementalUpdateTest . MyElement   element    =    createElement (  (  \"  < a >  \"     +     (  (  (  \"  < child /  >  \"     +     \"  < child >  < child /  >  <  / child >  \"  )     +     \"  < child >  < child /  >  <  / child >  \"  )     +     \"  <  / a >  \"  )  )  )  ;", "final   TreeIncrementalUpdateTest . MyElement   child    =    element . getChild (  )  ;", "final   TreeIncrementalUpdateTest . MyElement   child 2     =    element . getChild 2  (  )  ;", "final   TreeIncrementalUpdateTest . MyElement   oldLeaf    =    child 2  . getChild (  )  ;", "final   XmlTag   tag    =    element . getXmlTag (  )  ;", "XmlTag   leafTag    =    tag . getSubTags (  )  [  2  ]  . getSubTags (  )  [  0  ]  ;", "assertNoCache ( leafTag )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >     {", "tag . getSubTags (  )  [  1  ]  . delete (  )  ;", "assertFalse ( oldLeaf . isValid (  )  )  ;", "putExpected ( new   DomEvent ( element ,    false )  )  ;", "assertResultsAndClear (  )  ;", "assertEquals ( child ,    element . getChild (  )  )  ;", "assertFalse ( child 2  . isValid (  )  )  ;", "tag . getSubTags (  )  [  1  ]  . delete (  )  ;", "}  )  ;", "putExpected ( new   DomEvent ( element ,    false )  )  ;", "assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["testRemoveFixedElement"], "fileName": "com.intellij.util.xml.impl.TreeIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "final   TreeIncrementalUpdateTest . MyElement   rootElement    =    createPhysicalElement (  (  \"  <  ? xml   version =  \\  '  1  .  0  \\  '    encoding =  \\  ' UTF -  8  \\  '  ?  >  \\ n \"     +     (  (  (  (  \"  < a >  \\ n \"     +     \"     < boy >  \\ n \"  )     +     \"     <  / boy >  \\ n \"  )     +     \"     < girl /  >  \\ n \"  )     +     \"  <  / a >  \"  )  )  )  ;", "myCallRegistry . clear (  )  ;", "assertEquals (  1  ,    rootElement . getBoys (  )  . size (  )  )  ;", "assertEquals (  1  ,    rootElement . getGirls (  )  . size (  )  )  ;", "final   TreeIncrementalUpdateTest . MyElement   oldBoy    =    rootElement . getBoys (  )  . get (  0  )  ;", "final   XmlTag   tag    =    oldBoy . getXmlTag (  )  ;", "assertNotNull ( tag )  ;", "final   int   offset    =    tag . getTextOffset (  )  ;", "final   int   endoffset    =    offset    +     ( tag . getTextLength (  )  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "rootElement . getGirls (  )  . get (  0  )  . undefine (  )  ;", "final   Document   document    =    getDocument ( DomUtil . getFile ( rootElement )  )  ;", "PsiDocumentManager . getInstance ( getProject (  )  )  . doPostponedOperationsAndUnblockDocument ( document )  ;", "document . replaceString (  ( offset    +     1  )  ,     (  ( offset    +     1  )     +     (  \" boy \"  . length (  )  )  )  ,     \" girl \"  )  ;", "commitDocument ( document )  ;", "}  )  ;", "assertFalse ( oldBoy . isValid (  )  )  ;", "assertEquals (  0  ,    rootElement . getBoys (  )  . size (  )  )  ;", "assertEquals (  1  ,    rootElement . getGirls (  )  . size (  )  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "final   Document   document    =    getDocument ( DomUtil . getFile ( rootElement )  )  ;", "document . replaceString (  ( endoffset    -     (  \" boy \"  . length (  )  )  )  ,    endoffset ,     \" girl \"  )  ;", "commitDocument ( document )  ;", "}  )  ;", "assertEquals (  0  ,    rootElement . getBoys (  )  . size (  )  )  ;", "assertEquals (  1  ,    rootElement . getGirls (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRenameCollectionTag"], "fileName": "com.intellij.util.xml.impl.TreeIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =     (  ( XmlFile )     ( createFile (  \" file . xml \"  ,     (  \"  <  ? xml   version =  \\  '  1  .  0  \\  '    encoding =  \\  ' UTF -  8  \\  '  ?  >  \\ n \"     +     (  (  (  (  \"  < a >  \\ n \"     +     \"     < aboy >  \\ n \"  )     +     \"     <  / aboy >  \\ n \"  )     +     \"     < agirl /  >  \\ n \"  )     +     \"  <  / a >  \"  )  )  )  )  )  ;", "final   DomFileElementImpl <  . MyElement >    fileElement    =    getDomManager (  )  . getFileElement ( file ,     . MyElement . class ,     \" a \"  )  ;", "myCallRegistry . clear (  )  ;", "final    . MyElement   rootElement    =    fileElement . getRootElement (  )  ;", "assertNotNull ( rootElement . getAboy (  )  . getXmlElement (  )  )  ;", "assertNotNull ( rootElement . getAgirl (  )  . getXmlElement (  )  )  ;", "final    . MyElement   oldBoy    =    rootElement . getAboy (  )  ;", "final   XmlTag   tag    =    oldBoy . getXmlTag (  )  ;", "assertNotNull ( tag )  ;", "final   int   offset    =    tag . getTextOffset (  )  ;", "final   int   endoffset    =    offset    +     ( tag . getTextLength (  )  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "rootElement . getAgirl (  )  . undefine (  )  ;", "final   Document   document    =    getDocument ( file )  ;", "PsiDocumentManager . getInstance ( getProject (  )  )  . doPostponedOperationsAndUnblockDocument ( document )  ;", "document . replaceString (  ( offset    +     1  )  ,     (  ( offset    +     1  )     +     (  \" aboy \"  . length (  )  )  )  ,     \" agirl \"  )  ;", "commitDocument ( document )  ;", "}  )  ;", "assertFalse ( oldBoy . isValid (  )  )  ;", "assertNull ( rootElement . getAboy (  )  . getXmlElement (  )  )  ;", "assertNotNull ( rootElement . getAgirl (  )  . getXmlElement (  )  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "final   Document   document    =    getDocument ( file )  ;", "document . replaceString (  ( endoffset    -     (  \" aboy \"  . length (  )  )  )  ,    endoffset ,     \" agirl \"  )  ;", "commitDocument ( document )  ;", "}  )  ;", "assertNull ( rootElement . getAboy (  )  . getXmlElement (  )  )  ;", "assertNotNull ( rootElement . getAgirl (  )  . getXmlElement (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRenameFixedTag"], "fileName": "com.intellij.util.xml.impl.TreeIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =    DomTestCase . createXmlFile (  \"  \"  )  ;", "final   DomFileElementImpl <  . MyElement >    fileElement    =    getDomManager (  )  . getFileElement ( file ,     . MyElement . class ,     \" root \"  )  ;", "myCallRegistry . clear (  )  ;", "assertNull ( fileElement . getRootElement (  )  . getXmlTag (  )  )  ;", "file . getDocument (  )  . replace ( DomTestCase . createXmlFile (  \"  < root /  >  \"  )  . getDocument (  )  )  ;", "final   XmlTag   rootTag    =    fileElement . getRootTag (  )  ;", "assertEquals ( rootTag ,    file . getDocument (  )  . getRootTag (  )  )  ;", "putExpected ( new   DomEvent ( fileElement . getRootElement (  )  ,    false )  )  ;", "assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["testRootTagAppearsLater"], "fileName": "com.intellij.util.xml.impl.TreeIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "getDomManager (  )  . registerFileDescription ( new   DomFileDescription ( TreeIncrementalUpdateTest . MyElement . class ,     \" a \"  )  ,    getTestRootDisposable (  )  )  ;", "final   XmlFile   file    =     (  ( XmlFile )     ( createFile (  \" file . xml \"  ,     (  \"  <  ? xml   version =  \\  '  1  .  0  \\  '    encoding =  \\  ' UTF -  8  \\  '  ?  >  \\ n \"     +     \"  < a /  >  \"  )  )  )  )  ;", "assertTrue ( getDomManager (  )  . isDomFile ( file )  )  ;", "final   DomFileElementImpl < TreeIncrementalUpdateTest . MyElement >    fileElement    =    getDomManager (  )  . getFileElement ( file ,    TreeIncrementalUpdateTest . MyElement . class )  ;", "assertTrue ( fileElement . isValid (  )  )  ;", "myCallRegistry . clear (  )  ;", "putExpected ( new   DomEvent ( fileElement ,    false )  )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", "final   Document   document    =    getDocument ( file )  ;", "final   int   i    =    document . getText (  )  . indexOf (  \"  < a \"  )  ;", "document . insertString ( i ,     \" a \"  )  ;", "commitDocument ( document )  ;", "}  )  ;", "assertFalse ( getDomManager (  )  . isDomFile ( file )  )  ;", "assertFalse ( fileElement . isValid (  )  )  ;", "assertResultsAndClear (  )  ;", "}", "METHOD_END"], "methodName": ["testTypeBeforeRootTag"], "fileName": "com.intellij.util.xml.impl.TreeIncrementalUpdateTest"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    o )", "return   true ;", "if    (  !  ( o   instanceof    )  )", "return   false ;", "final      that    =     (  (  )     ( o )  )  ;", "if    (  !  ( myParentHandler . equals ( that . myParentHandler )  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.intellij.util.xml.impl.VirtualDomParentStrategy"}, {"methodBody": ["METHOD_START", "{", "return   myModificationTracker . getModificationStamp (  )  ;", "}", "METHOD_END"], "methodName": ["getModCount"], "fileName": "com.intellij.util.xml.impl.VirtualDomParentStrategy"}, {"methodBody": ["METHOD_START", "{", "return   myParentHandler . hashCode (  )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.intellij.util.xml.impl.VirtualDomParentStrategy"}, {"methodBody": ["METHOD_START", "{", "final   Method   method    =    myMethods . get ( element . getClass (  )  )  ;", "assert   method    !  =    null    :     (  ( myClass )     +     \"    can ' t   accept   element   of   type    \"  )     +     ( element . getClass (  )  )  ;", "DomReflectionUtil . invokeMethod ( method ,    visitor ,    element )  ;", "}", "METHOD_END"], "methodName": ["acceptElement"], "fileName": "com.intellij.util.xml.impl.VisitorDescription"}, {"methodBody": ["METHOD_START", "{", "CachedValue < T >    cachedValue    =    dataHolder . getUserData ( myKey )  ;", "if    ( cachedValue    =  =    null )     {", "final   CachedValueProvider < T >    myProvider    =     (  )     -  >    computeValue ( dataHolder )  ;", "final   CachedValuesManager   manager    =    CachedValuesManager . getManager ( myProject )  ;", "cachedValue    =    manager . createCachedValue ( myProvider ,    false )  ;", "dataHolder . putUserData ( myKey ,    cachedValue )  ;", "}", "return   cachedValue . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getCachedValue"], "fileName": "com.intellij.util.xml.model.DomModelCache"}, {"methodBody": ["METHOD_START", "{", "for    ( DomElement   name    :    elements )     {", "existingNames . add ( name . getGenericInfo (  )  . getElementName ( name )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addNewNames"], "fileName": "com.intellij.util.xml.model.gotosymbol.GoToSymbolProvider"}, {"methodBody": ["METHOD_START", "{", "return   new   GoToSymbolProvider . BaseNavigationItem ( element ,    text ,    icon )  ;", "}", "METHOD_END"], "methodName": ["createNavigationItem"], "fileName": "com.intellij.util.xml.model.gotosymbol.GoToSymbolProvider"}, {"methodBody": ["METHOD_START", "{", "final   GenericDomValue   name    =    domElement . getGenericInfo (  )  . getNameDomElement ( domElement )  ;", "assert   name    !  =    null ;", "final   XmlElement   psiElement    =    name . getXmlElement (  )  ;", "final   String   value    =    name . getStringValue (  )  ;", "if    (  ( psiElement    =  =    null )     |  |     ( value    =  =    null )  )     {", "return   null ;", "}", "final   Icon   icon    =    ElementPresentationManager . getIcon ( domElement )  ;", "return    . createNavigationItem ( psiElement ,    value ,    icon )  ;", "}", "METHOD_END"], "methodName": ["createNavigationItem"], "fileName": "com.intellij.util.xml.model.gotosymbol.GoToSymbolProvider"}, {"methodBody": ["METHOD_START", "{", "return   CachedValuesManager . getManager ( project )  . getCachedValue ( project ,    ACCEPTABLE _ MODULES ,     (  )     -  >     {", "List < Module >    result    =    ContainerUtil . findAll ( ModuleManager . getInstance ( project )  . getModules (  )  ,     (    module )     -  >    acceptModule ( module )  )  ;", "return   CachedValue . Result . create ( result ,    PsiModificationTracker . MODIFICATION _ COUNT )  ;", "}  ,    false )  ;", "}", "METHOD_END"], "methodName": ["getAcceptableModules"], "fileName": "com.intellij.util.xml.model.gotosymbol.GoToSymbolProvider"}, {"methodBody": ["METHOD_START", "{", "final   ArrayList < Object >    dependencies    =    new   ArrayList <  >  (  )  ;", "dependencies . add ( OUT _ OF _ CODE _ BLOCK _ MODIFICATION _ COUNT )  ;", "if    ( scope    !  =    null )     {", "dependencies . add ( ProjectRootManager . getInstance ( getProject (  )  )  )  ;", "}", "return   ArrayUtoObjectArray ( dependencies )  ;", "}", "METHOD_END"], "methodName": ["computeDependencies"], "fileName": "com.intellij.util.xml.model.impl.BaseDomModelFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( scope    =  =    null )     {", "return   null ;", "}", "final   List < M >        =    getAllModels ( scope )  ;", "for    ( M    :     )     {", "final   Set < XmlFile >    configFiles    =    getConfigFiles (  )  ;", "if    ( configFiles . contains ( psiFile )  )     {", "return", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["computeModel"], "fileName": "com.intellij.util.xml.model.impl.BaseDomModelFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   CachedMultipleDomModelFactory < S ,    T ,    M ,    C >  ( aClass ,    modelMerger ,    project ,    name )     {", "@ Override", "public   M   getModel (  @ NotNull", "final   C   context )     {", "return    . this . getModel ( context )  ;", "}", "@ Override", "protected   List < M >    computeAllModels (  @ NotNull", "final   S   scope )     {", "return    . this . computeAllModels ( scope )  ;", "}", "@ Override", "protected   M   createCombinedModel ( final   Set < XmlFile >    configFiles ,    final   DomFileElement < T >    mergedModel ,    final   M   firstModel ,    final   S   scope )     {", "return    . this . createCombinedModel ( configFiles ,    mergedModel ,    firstModel ,    scope )  ;", "}", "@ Override", "@ NotNull", "public   Object [  ]    computeDependencies (  @ Nullable", "final   M   model ,     @ Nullable", "final   S   scope )     {", "return    . this . computeDependencies ( model ,    scope )  ;", "}", "@ Override", "public   S   getModelScope (  @ NotNull", "final   XmlFile   xmlFile )     {", "return    . this . getModelScope ( xmlFile )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createMultipleDomModelFactory"], "fileName": "com.intellij.util.xml.model.impl.BaseDomModelFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   CachedSimpleDomModelFactory < T ,    M ,    S >  ( aClass ,    modelMerger ,    project ,    name )     {", "@ Override", "protected   M   computeModel (  @ NotNull", "final   XmlFile   psiFile ,     @ Nullable", "final   S   scope )     {", "return    . this . computeModel ( psiFile ,    scope )  ;", "}", "@ Override", "@ NotNull", "public   Object [  ]    computeDependencies (  @ Nullable", "final   M   model ,     @ Nullable", "final   S   scope )     {", "return    . this . computeDependencies ( model ,    scope )  ;", "}", "@ Override", "public   S   getModelScope (  @ NotNull", "XmlFile   file )     {", "return    . this . getModelScope ( file )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createSimpleModelFactory"], "fileName": "com.intellij.util.xml.model.impl.BaseDomModelFactory"}, {"methodBody": ["METHOD_START", "{", "final   PsiFile   psiFile    =    context . getContainingFile (  )  ;", "if    ( psiFile   instanceof   XmlFile )     {", "return   getByConfigFile (  (  ( XmlFile )     ( psiFile )  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getModel"], "fileName": "com.intellij.util.xml.model.impl.BaseDomModelFactory"}, {"methodBody": ["METHOD_START", "{", "return   myProject ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "com.intellij.util.xml.model.impl.BaseDomModelFactory"}, {"methodBody": ["METHOD_START", "{", "final   List < M >        =    getAllModels ( scope )  ;", "switch    (  . size (  )  )     {", "case    0     :", "return   null ;", "case    1     :", "return    . get (  0  )  ;", "}", "final   Set < XmlFile >    configFiles    =    new   LinkedHashSet <  >  (  )  ;", "final   LinkedHashSet < DomFileElement < T >  >    list    =    new   LinkedHashSet <  >  (  . size (  )  )  ;", "for    ( M    :     )     {", "final   Set < XmlFile >    files    =    getConfigFiles (  )  ;", "for    ( XmlFile   file    :    files )     {", "ContainerUtil . addIfNotNull ( list ,    getDomRoot ( file )  )  ;", "}", "configFiles . addAll ( files )  ;", "}", "final   DomFileElement < T >    mergedModel    =    getModelMerger (  )  . mergeModels ( DomFileElement . class ,    list )  ;", "final   M   firstModel    =     . get (  0  )  ;", "return   createCombinedModel ( configFiles ,    mergedModel ,    firstModel ,    scope )  ;", "}", "METHOD_END"], "methodName": ["computeCombinedModel"], "fileName": "com.intellij.util.xml.model.impl.CachedMultipleDomModelFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( context    =  =    null )     {", "return   Collections . emptySet (  )  ;", "}", "final   M    =    getModel ( context )  ;", "if    (  =  =    null )     {", "return   Collections . emptySet (  )  ;", "} else    {", "return   getConfigFiles (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getConfigFiles"], "fileName": "com.intellij.util.xml.model.impl.CachedMultipleDomModelFactory"}, {"methodBody": ["METHOD_START", "{", "final   ArrayList < DomFileElement < T >  >    list    =    new   ArrayList <  >  ( model . getConfigFiles (  )  . size (  )  )  ;", "for    ( XmlFile   configFile    :    model . getConfigFiles (  )  )     {", "final   DomFileElement < T >    element    =    DomManager . getDomManager ( configFile . getProject (  )  )  . getFileElement ( configFile ,    myClass )  ;", "if    ( element    !  =    null )     {", "list . add ( element )  ;", "}", "}", "return   list ;", "}", "METHOD_END"], "methodName": ["getFileElements"], "fileName": "com.intellij.util.xml.model.impl.CachedMultipleDomModelFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( context    =  =    null )     {", "return   Collections . emptySet (  )  ;", "}", "final   M    =    getModel ( context )  ;", "if    (  =  =    null )     {", "return   Collections . emptySet (  )  ;", "} else    {", "return   getConfigFiles (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getConfigFiles"], "fileName": "com.intellij.util.xml.model.impl.DomModelFactory"}, {"methodBody": ["METHOD_START", "{", "final   ArrayList < DomFileElement < T >  >    list    =    new   ArrayList <  >  ( model . getConfigFiles (  )  . size (  )  )  ;", "for    ( XmlFile   configFile    :    model . getConfigFiles (  )  )     {", "final   DomFileElement < T >    element    =    DomManager . getDomManager ( configFile . getProject (  )  )  . getFileElement ( configFile ,    myClass )  ;", "if    ( element    !  =    null )     {", "list . add ( element )  ;", "}", "}", "return   list ;", "}", "METHOD_END"], "methodName": ["getFileElements"], "fileName": "com.intellij.util.xml.model.impl.DomModelFactory"}, {"methodBody": ["METHOD_START", "{", "final   DomFileElement < T >    element    =    getDomRoot ( configFile )  ;", "return   element    =  =    null    ?    null    :    element . getRootElement (  )  ;", "}", "METHOD_END"], "methodName": ["getDom"], "fileName": "com.intellij.util.xml.model.impl.DomModelFactoryHelper"}, {"methodBody": ["METHOD_START", "{", "return   myClass ;", "}", "METHOD_END"], "methodName": ["getDomModelClass"], "fileName": "com.intellij.util.xml.model.impl.DomModelFactoryHelper"}, {"methodBody": ["METHOD_START", "{", "return   DomManager . getDomManager ( configFile . getProject (  )  )  . getFileElement ( configFile ,    myClass )  ;", "}", "METHOD_END"], "methodName": ["getDomRoot"], "fileName": "com.intellij.util.xml.model.impl.DomModelFactoryHelper"}, {"methodBody": ["METHOD_START", "{", "return   myModelMerger ;", "}", "METHOD_END"], "methodName": ["getModelMerger"], "fileName": "com.intellij.util.xml.model.impl.DomModelFactoryHelper"}, {"methodBody": ["METHOD_START", "{", "return   myProject ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "com.intellij.util.xml.model.impl.DomModelImpl"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["supportsStubs"], "fileName": "com.intellij.util.xml.reflect.DomExtender"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myDomClass )     =  =    null )     {", "try    {", "myDomClass    =    findClass ( domClassName )  ;", "}    catch    ( Exception   e )     {", ". LOG . error ( e )  ;", "return   registrar ;", "}", "}", "if    (  !  ( myDomClass . isAssignableFrom ( handler . getRawType (  )  )  )  )     {", "return   registrar ;", "}", "if    (  ( myExtender )     =  =    null )     {", "try    {", "myExtender    =    instantiate ( extenderClassName ,    project . getPicoContainer (  )  )  ;", "}    catch    ( Exception   e )     {", ". LOG . error ( e )  ;", "return   registrar ;", "}", "}", "if    (  (  !  ( myExtender . supportsStubs (  )  )  )     &  &     ( XmlUtil . isStubBuilding (  )  )  )     {", "return   registrar ;", "}", "if    ( registrar    =  =    null )     {", "registrar    =    new   DomExtensionsRegistrarImpl (  )  ;", "}", "myExtender . registerExtensions ( handler . getProxy (  )  ,    registrar )  ;", "return   registrar ;", "}", "METHOD_END"], "methodName": ["extend"], "fileName": "com.intellij.util.xml.reflect.DomExtenderEP"}, {"methodBody": ["METHOD_START", "{", "t . setUserMap ( myUserMap )  ;", "if    (  ( myConverter )     !  =    null )     {", "t . addCustomAnnotation ( new   ConvertAnnotat ( myConverter ,    mySoft )  )  ;", "}", "for    ( final   Annotation   anno    :    myCustomAnnos )     {", "t . addCustomAnnotation ( anno )  ;", "}", "return   t ;", "}", "METHOD_END"], "methodName": ["addAnnotations"], "fileName": "com.intellij.util.xml.reflect.DomExtensionImpl"}, {"methodBody": ["METHOD_START", "{", "return   myAttributesDescriptor ;", "}", "METHOD_END"], "methodName": ["getAttributesDescriptor"], "fileName": "com.intellij.util.xml.reflect.DomExtensionImpl"}, {"methodBody": ["METHOD_START", "{", "return   myCount ;", "}", "METHOD_END"], "methodName": ["getCount"], "fileName": "com.intellij.util.xml.reflect.DomExtensionImpl"}, {"methodBody": ["METHOD_START", "{", "return   myTagNameDescriptor ;", "}", "METHOD_END"], "methodName": ["getTagNameDescriptor"], "fileName": "com.intellij.util.xml.reflect.DomExtensionImpl"}, {"methodBody": ["METHOD_START", "{", "return   myXmlName ;", "}", "METHOD_END"], "methodName": ["getXmlName"], "fileName": "com.intellij.util.xml.reflect.DomExtensionImpl"}, {"methodBody": ["METHOD_START", "{", "myAttributesDescriptor    =    attributesDescriptor ;", "}", "METHOD_END"], "methodName": ["setAttributesDescriptor"], "fileName": "com.intellij.util.xml.reflect.DomExtensionImpl"}, {"methodBody": ["METHOD_START", "{", "myCount    =    count ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setCount"], "fileName": "com.intellij.util.xml.reflect.DomExtensionImpl"}, {"methodBody": ["METHOD_START", "{", "myTagNameDescriptor    =    tagNameDescriptor ;", "}", "METHOD_END"], "methodName": ["setTagNameDescriptor"], "fileName": "com.intellij.util.xml.reflect.DomExtensionImpl"}, {"methodBody": ["METHOD_START", "{", "ContainerUtil . addAll ( myDependencies ,    deps )  ;", "}", "METHOD_END"], "methodName": ["addDependencies"], "fileName": "com.intellij.util.xml.reflect.DomExtensionsRegistrarImpl"}, {"methodBody": ["METHOD_START", "{", "final   DomExtensionImpl   extension    =    new   DomExtensionImpl ( type ,    name )  ;", "list . add ( extension )  ;", "return   extension ;", "}", "METHOD_END"], "methodName": ["addExtension"], "fileName": "com.intellij.util.xml.reflect.DomExtensionsRegistrarImpl"}, {"methodBody": ["METHOD_START", "{", "return   myAttributes ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "com.intellij.util.xml.reflect.DomExtensionsRegistrarImpl"}, {"methodBody": ["METHOD_START", "{", "return   myCollections ;", "}", "METHOD_END"], "methodName": ["getCollections"], "fileName": "com.intellij.util.xml.reflect.DomExtensionsRegistrarImpl"}, {"methodBody": ["METHOD_START", "{", "return   myCustoms ;", "}", "METHOD_END"], "methodName": ["getCustoms"], "fileName": "com.intellij.util.xml.reflect.DomExtensionsRegistrarImpl"}, {"methodBody": ["METHOD_START", "{", "return   myDependencies . toArray (  )  ;", "}", "METHOD_END"], "methodName": ["getDependencies"], "fileName": "com.intellij.util.xml.reflect.DomExtensionsRegistrarImpl"}, {"methodBody": ["METHOD_START", "{", "return   myFixeds ;", "}", "METHOD_END"], "methodName": ["getFixeds"], "fileName": "com.intellij.util.xml.reflect.DomExtensionsRegistrarImpl"}, {"methodBody": ["METHOD_START", "{", "assert   count    >     0  ;", "return    . addExtension ( myFixeds ,    name ,    type )  . setCount ( count )  ;", "}", "METHOD_END"], "methodName": ["registerFixedNumberChildrenExtension"], "fileName": "com.intellij.util.xml.reflect.DomExtensionsRegistrarImpl"}, {"methodBody": ["METHOD_START", "{", "return   new   DomStructureTreeElement ( element ,    myDescriptor ,    myNavigationProvider )  ;", "}", "METHOD_END"], "methodName": ["createChildElement"], "fileName": "com.intellij.util.xml.structure.DomStructureTreeElement"}, {"methodBody": ["METHOD_START", "{", "return   myElement ;", "}", "METHOD_END"], "methodName": ["getElement"], "fileName": "com.intellij.util.xml.structure.DomStructureTreeElement"}, {"methodBody": ["METHOD_START", "{", "return   myNavigationProvider ;", "}", "METHOD_END"], "methodName": ["getNavigationProvider"], "fileName": "com.intellij.util.xml.structure.DomStructureViewTreeModel"}, {"methodBody": ["METHOD_START", "{", "return   myValue ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.intellij.util.xml.stubs.AttributeStub"}, {"methodBody": ["METHOD_START", "{", "final   List < DomStub >    stubs    =    getChildrenStubs (  )  ;", "if    ( stubs . isEmpty (  )  )     {", "return   null ;", "}", "for    ( int   i    =     0  ,    size    =    stubs . size (  )  ;    i    <    size ;    i +  +  )     {", "final   DomStub   stub    =    stubs . get ( i )  ;", "if    (  ( stub   instanceof   AttributeStub )     &  &     ( stub . getName (  )  . equals ( name . getLocalName (  )  )  )  )     {", "return    (  ( AttributeStub )     ( stub )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAttributeStub"], "fileName": "com.intellij.util.xml.stubs.DomStub"}, {"methodBody": ["METHOD_START", "{", "final   List < DomStub >    stubs    =    getChildrenStubs (  )  ;", "if    ( stubs . isEmpty (  )  )     {", "return   Collections . emptyList (  )  ;", "}", "final   String   s    =     ( nsKey    =  =    null )     ?     \"  \"     :    nsKey ;", "final   List < DomStub >    result    =    new   SmartList (  )  ;", "for    ( int   i    =     0  ,    size    =    stubs . size (  )  ;    i    <    size ;    i +  +  )     {", "final   DomStub   stub    =    stubs . get ( i )  ;", "if    (  ( XmlUtil . getLocalName ( stub . getName (  )  )  . equals ( name )  )     &  &     ( Comparing . equal ( s ,    stub . getNamespaceKey (  )  )  )  )     {", "result . add ( stub )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getChildrenByName"], "fileName": "com.intellij.util.xml.stubs.DomStub"}, {"methodBody": ["METHOD_START", "{", "List < DomStub >    stubs    =    getChildrenStubs (  )  ;", "int   i    =     0  ;", "for    ( DomStub   stub    :    stubs )     {", "if    (  (  ( stub   instanceof   ElementStub )     &  &     ( name . equals ( stub . getName (  )  )  )  )     &  &     (  ( i +  +  )     =  =    index )  )     {", "return    (  ( ElementStub )     ( stub )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getElementStub"], "fileName": "com.intellij.util.xml.stubs.DomStub"}, {"methodBody": ["METHOD_START", "{", "return   myHandler ;", "}", "METHOD_END"], "methodName": ["getHandler"], "fileName": "com.intellij.util.xml.stubs.DomStub"}, {"methodBody": ["METHOD_START", "{", "return   myLocalName . getString (  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.intellij.util.xml.stubs.DomStub"}, {"methodBody": ["METHOD_START", "{", "return    ( myNamespace )     =  =    null    ?    null    :    myNamespace . getString (  )  ;", "}", "METHOD_END"], "methodName": ["getNamespaceKey"], "fileName": "com.intellij.util.xml.stubs.DomStub"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myHandler )     =  =    null )     {", "XmlName   name    =    description . getXmlName (  )  ;", "EvaluatedXmlNameImpl   evaluatedXmlName    =    EvaluatedXmlNameImpl . createEvaluatedXmlName ( name ,    name . getNamespaceKey (  )  ,    true )  ;", "myHandler    =    new   CollectionElementInvocationHandler ( evaluatedXmlName ,    description ,    manager ,     (  ( Element )     ( this )  )  )  ;", "}", "return   myHandler ;", "}", "METHOD_END"], "methodName": ["getOrCreateHandler"], "fileName": "com.intellij.util.xml.stubs.DomStub"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isCustom"], "fileName": "com.intellij.util.xml.stubs.DomStub"}, {"methodBody": ["METHOD_START", "{", "myHandler    =    handler ;", "}", "METHOD_END"], "methodName": ["setHandler"], "fileName": "com.intellij.util.xml.stubs.DomStub"}, {"methodBody": ["METHOD_START", "{", "DomExtenderEP   ep    =    new   DomExtenderEP (  )  ;", "ep . domClassName    =    Bar . class . getName (  )  ;", "ep . extenderClassName    =     . TestExtender . class . getName (  )  ;", "PlatformTestUtil . registerExtension ( Extensions . getRootArea (  )  ,    DomExtenderEP . EP _ NAME ,    ep ,    myFixture . getTestRootDisposable (  )  )  ;", "doBuilderTest (  \" extender . xml \"  ,     (  \" File : foo \\ n \"     +     (  (  (  \"       Element : foo \\ n \"     +     \"             Element : bar \\ n \"  )     +     \"                   Attribute : extend : xxx \\ n \"  )     +     \"             Element : bar \\ n \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testDomExtension"], "fileName": "com.intellij.util.xml.stubs.DomStubBuilderTest"}, {"methodBody": ["METHOD_START", "{", "getRootStub (  \" foo . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testDomLoading"], "fileName": "com.intellij.util.xml.stubs.DomStubBuilderTest"}, {"methodBody": ["METHOD_START", "{", "doBuilderTest (  \" foo . xml \"  ,     (  \" File : foo \\ n \"     +     (  (  (  (  (  (  (  \"       Element : foo \\ n \"     +     \"             Element : id : foo \\ n \"  )     +     \"             Element : list : list 0  \\ n \"  )     +     \"             Element : list : list 1  \\ n \"  )     +     \"             Element : bar \\ n \"  )     +     \"                   Attribute : string : xxx \\ n \"  )     +     \"                   Attribute : int :  6  6  6  \\ n \"  )     +     \"             Element : bar \\ n \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testFoo"], "fileName": "com.intellij.util.xml.stubs.DomStubBuilderTest"}, {"methodBody": ["METHOD_START", "{", "final   ElementStub   rootStub    =    getRootStub (  \" foo . xml \"  )  ;", "assertEquals (  \"  \"  ,    rootStub . getValue (  )  )  ;", "final      fooStub    =    assertOneElement ( rootStub . getChildrenStubs (  )  )  ;", "final   ElementStub   fooElementStub    =    assertInstanceOf ( fooStub ,    ElementStub . class )  ;", "assertEquals (  \"  \"  ,    fooElementStub . getValue (  )  )  ;", "final      idStub    =    ContainerUtil . getFirstItem ( fooStub . getChildrenStubs (  )  )  ;", "final   ElementStub   idElementStub    =    assertInstanceOf ( idStub ,    ElementStub . class )  ;", "assertEquals (  \" foo \"  ,    idElementStub . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFooNoStubbedValueWhenNestedTags"], "fileName": "com.intellij.util.xml.stubs.DomStubBuilderTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . copyFileToProject (  \" include . xml \"  )  ;", "do (  \" inclusion . xml \"  ,     (  \" File : foo \\ n \"     +     (  (  (  (  \"       Element : foo \\ n \"     +     \"             Element : bar \\ n \"  )     +     \"                   Attribute : string : xxx \\ n \"  )     +     \"                   Attribute : int :  6  6  6  \\ n \"  )     +     \"             Element : bar \\ n \"  )  )  )  ;", "PsiFile   file    =    myFixture . getFile (  )  ;", "DomFileElement < Foo >    element    =    DomManager . getDomManager ( getProject (  )  )  . getFileElement (  (  ( XmlFile )     ( file )  )  ,    Foo . class )  ;", "assert   element    !  =    null ;", "assertEquals (  2  ,    element . getRootElement (  )  . getBars (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testInclusion"], "fileName": "com.intellij.util.xml.stubs.DomStubBuilderTest"}, {"methodBody": ["METHOD_START", "{", "doBuilderTest (  \" incompleteAttribute . xml \"  ,     (  \" File : foo \\ n \"     +     (  (  \"       Element : foo \\ n \"     +     \"             Element : bar \\ n \"  )     +     \"                   Attribute : string :  \\ n \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testIncompleteAttribute"], "fileName": "com.intellij.util.xml.stubs.DomStubBuilderTest"}, {"methodBody": ["METHOD_START", "{", "VirtualFile   virtualFile    =    myFixture . copyFileToProject (  \" nullTag . xml \"  )  ;", "assertNotNull ( virtualFile )  ;", "PsiFile   psiFile    =     (  ( PsiManagerEx )     ( getPsiManager (  )  )  )  . getFileManager (  )  . findFile ( virtualFile )  ;", "StubTreeLoader   loader    =    StubTreeLoader . getInstance (  )  ;", "VirtualFile   file    =    psiFile . getVirtualFile (  )  ;", "assertTrue ( loader . canHaveStub ( file )  )  ;", "ObjectStubTree   stubTree    =    loader . readFromVFile ( getProject (  )  ,    file )  ;", "assertNotNull ( stubTree )  ;", "}", "METHOD_END"], "methodName": ["testNullTag"], "fileName": "com.intellij.util.xml.stubs.DomStubBuilderTest"}, {"methodBody": ["METHOD_START", "{", "ElementStub   stub    =    getRootStub ( file )  ;", "assertEquals ( stubText ,    DebugUtiTreeToString ( stub )  )  ;", "}", "METHOD_END"], "methodName": ["doBuilderTest"], "fileName": "com.intellij.util.xml.stubs.DomStubTest"}, {"methodBody": ["METHOD_START", "{", "return   DomStubTest . getRootStub ( filePath ,    myFixture )  ;", "}", "METHOD_END"], "methodName": ["getRootStub"], "fileName": "com.intellij.util.xml.stubs.DomStubTest"}, {"methodBody": ["METHOD_START", "{", "PsiFile   psiFile    =    fixture . configureByFile ( filePath )  ;", "reeLoader   loader    =    reeLoader . getInstance (  )  ;", "VirtualFile   file    =    psiFile . getVirtualFile (  )  ;", "assertTrue ( loader . canHaveStub ( file )  )  ;", "Objectree   stubTree    =    loader . readFromVFile ( fixture . getProject (  )  ,    file )  ;", "assertNotNull ( stubTree )  ;", "ElementStub   root    =     (  ( ElementStub )     ( stubTree . getRoot (  )  )  )  ;", "assertNotNull ( root )  ;", "return   root ;", "}", "METHOD_END"], "methodName": ["getRootStub"], "fileName": "com.intellij.util.xml.stubs.DomStubTest"}, {"methodBody": ["METHOD_START", "{", "XmlFile   file    =    prepareFile ( path )  ;", "FileElement < T >    fileElement    =    Manager . getManager ( getProject (  )  )  . getFileElement ( file ,    domClass )  ;", "assertNotNull ( fileElement )  ;", "return   fileElement ;", "}", "METHOD_END"], "methodName": ["prepare"], "fileName": "com.intellij.util.xml.stubs.DomStubTest"}, {"methodBody": ["METHOD_START", "{", "VirtualFile   virtualFile    =    myFixture . copyFileToProject ( path )  ;", "assertNotNull ( virtualFile )  ;", "XmlFile   file    =     (  ( XmlFile )     (  (  ( PsiManagerEx )     ( getPsiManager (  )  )  )  . getFileManager (  )  . findFile ( virtualFile )  )  )  ;", "assertFalse ( file . getNode (  )  . isParsed (  )  )  ;", "Objectree   tree    =    reeLoader . getInstance (  )  . readOrBuild ( getProject (  )  ,    virtualFile ,    file )  ;", "assertNotNull (  (  \" Can ' t   build   stubs   for    \"     +    path )  ,    tree )  ;", "(  ( PsiManagerImpl )     ( getPsiManager (  )  )  )  . cleanupForNextTest (  )  ;", "file    =     (  ( XmlFile )     ( getPsiManager (  )  . findFile ( virtualFile )  )  )  ;", "assertNotNull ( file )  ;", "return   file ;", "}", "METHOD_END"], "methodName": ["prepareFile"], "fileName": "com.intellij.util.xml.stubs.DomStubTest"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( domElement )  ;", "assertTrue ( domElement . exists (  )  )  ;", "WriteCommandAction . writeCommandAction ( null )  . run (  (  )     -  >    domElement . undefine (  )  )  ;", "assertFalse ( domElement . exists (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertUndefine"], "fileName": "com.intellij.util.xml.stubs.DomStubUsingTest"}, {"methodBody": ["METHOD_START", "{", "DomFileElement < Foo >    element    =    prepare (  \" foo . xml \"  ,    Foo . class )  ;", "assertNotNull ( element . getXmlElement (  )  )  ;", "XmlTag   tag    =    element . getRootTag (  )  ;", "assertNotNull ( tag )  ;", "Foo   foo    =    element . getRootElement (  )  ;", "assertNotNull ( foo . getXmlTag (  )  )  ;", "Bar   bar    =    foo . getBars (  )  . get (  0  )  ;", "assertNotNull ( bar . getXmlElement (  )  )  ;", "XmlAttribute   attribute    =    bar . getString (  )  . getXmlAttribute (  )  ;", "assertNotNull ( attribute )  ;", "}", "METHOD_END"], "methodName": ["testAccessingPsi"], "fileName": "com.intellij.util.xml.stubs.DomStubUsingTest"}, {"methodBody": ["METHOD_START", "{", "DomFileElement < Foo >    element    =    prepare (  \" foo . xml \"  ,    Foo . class )  ;", "Foo   foo    =    element . getRootElement (  )  ;", "List < Bar >    bars    =    DomUtil . getChildrenOf ( foo ,    Bar . class )  ;", "assertEquals (  2  ,    bars . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testChildrenOfType"], "fileName": "com.intellij.util.xml.stubs.DomStubUsingTest"}, {"methodBody": ["METHOD_START", "{", "DomFileElement < Foo >    element    =    prepare (  \" converters . xml \"  ,    Foo . class )  ;", "Bar   bar    =    element . getRootElement (  )  . getBars (  )  . get (  0  )  ;", "PsiClass   value    =    bar . getClazz (  )  . getValue (  )  ;", "assertNotNull ( value )  ;", "assertEquals (  \" String \"  ,    value . getQualifiedName (  )  )  ;", "assertFalse ( element . getFile (  )  . getNode (  )  . isParsed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConverters"], "fileName": "com.intellij.util.xml.stubs.DomStubUsingTest"}, {"methodBody": ["METHOD_START", "{", "XmlFile   file    =    prepareFile (  \" foo . xml \"  )  ;", "(  ( PsiManagerEx )     ( getPsiManager (  )  )  )  . setAssertOnFileLoadingFilter ( ALL ,    myFixture . getTestRootDisposable (  )  )  ;", "DomFileElement < Foo >    element    =    DomManager . getDomManager ( getProject (  )  )  . getFileElement ( file ,    Foo . class )  ;", "assertNotNull ( element )  ;", "GenericDomValue < String >    id    =    element . getRootElement (  )  . getId (  )  ;", "assertEquals (  \" foo \"  ,    id . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFileLoading"], "fileName": "com.intellij.util.xml.stubs.DomStubUsingTest"}, {"methodBody": ["METHOD_START", "{", "DomFileElement < Foo >    fileElement    =    prepare (  \" foo . xml \"  ,    Foo . class )  ;", "PsiFile   file    =    fileElement . getFile (  )  ;", "assertFalse ( file . getNode (  )  . isParsed (  )  )  ;", "Foo   foo    =    fileElement . getRootElement (  )  ;", "assertEquals (  \" foo \"  ,    foo . getId (  )  . getValue (  )  )  ;", "assertFalse ( file . getNode (  )  . isParsed (  )  )  ;", "List < Bar >    bars    =    foo . getBars (  )  ;", "assertFalse ( file . getNode (  )  . isParsed (  )  )  ;", "final   List < GenericDomValue < String >  >    listElements    =    foo . getLists (  )  ;", "final   GenericDomValue < String >    listElement 0     =    listElements . get (  0  )  ;", "assertEquals (  \" list 0  \"  ,    listElement 0  . getValue (  )  )  ;", "final   GenericDomValue < String >    listElement 1     =    listElements . get (  1  )  ;", "assertEquals (  \" list 1  \"  ,    listElement 1  . getValue (  )  )  ;", "assertFalse ( file . getNode (  )  . isParsed (  )  )  ;", "assertEquals (  2  ,    bars . size (  )  )  ;", "Bar   bar    =    bars . get (  0  )  ;", "String   value    =    bar . getString (  )  . getStringValue (  )  ;", "assertEquals (  \" xxx \"  ,    value )  ;", "Object   o    =    bar . getString (  )  . getValue (  )  ;", "assertEquals (  \" xxx \"  ,    o )  ;", "Integer   integer    =    bar . getInt (  )  . getValue (  )  ;", "assertEquals (  6  6  6  ,    integer . intValue (  )  )  ;", "assertFalse ( file . getNode (  )  . isParsed (  )  )  ;", "Bar   emptyBar    =    bars . get (  1  )  ;", "GenericAttributeValue < String >    string    =    emptyBar . getString (  )  ;", "assertNull ( string . getXmlElement (  )  )  ;", "assertFalse ( file . getNode (  )  . isParsed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFoo"], "fileName": "com.intellij.util.xml.stubs.DomStubUsingTest"}, {"methodBody": ["METHOD_START", "{", "DomFileElement < Foo >    element    =    prepare (  \" parent . xml \"  ,    Foo . class )  ;", "Bar   bar    =    element . getRootElement (  )  . getBars (  )  . get (  0  )  ;", "GenericAttributeValue < Integer >    notStubbed    =    bar . getNotStubbed (  )  ;", "DomElement   parent    =    notStubbed . getParent (  )  ;", "assertEquals ( bar ,    parent )  ;", "NotStubbed   child    =    bar . getNotStubbeds (  )  . get (  0  )  ;", "parent    =    child . getParent (  )  ;", "assertEquals ( bar ,    parent )  ;", "}", "METHOD_END"], "methodName": ["testParent"], "fileName": "com.intellij.util.xml.stubs.DomStubUsingTest"}, {"methodBody": ["METHOD_START", "{", "final   DomFileElement < Foo >    fileElement    =    prepare (  \" foo . xml \"  ,    Foo . class )  ;", "final   DomElement   rootElement    =    fileElement . getRootElement (  )  ;", ". assertUndefine ( rootElement )  ;", "}", "METHOD_END"], "methodName": ["testRootElementUndefineNotExisting"], "fileName": "com.intellij.util.xml.stubs.DomStubUsingTest"}, {"methodBody": ["METHOD_START", "{", "final   DomFileElement < Foo >    fileElement    =    prepare (  \" foo . xml \"  ,    Foo . class )  ;", "final   Bar   bar    =    fileElement . getRootElement (  )  . getBars (  )  . get (  0  )  ;", ". assertUndefine ( bar )  ;", "}", "METHOD_END"], "methodName": ["testStubbedElementUndefineNotExisting"], "fileName": "com.intellij.util.xml.stubs.DomStubUsingTest"}, {"methodBody": ["METHOD_START", "{", "myChildren . add ( child )  ;", "}", "METHOD_END"], "methodName": ["addChild"], "fileName": "com.intellij.util.xml.stubs.ElementStub"}, {"methodBody": ["METHOD_START", "{", "return    ( myElementClass )     =  =    null    ?    null    :    myElementClass . getString (  )  ;", "}", "METHOD_END"], "methodName": ["getElementClass"], "fileName": "com.intellij.util.xml.stubs.ElementStub"}, {"methodBody": ["METHOD_START", "{", "return   myValue ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.intellij.util.xml.stubs.ElementStub"}, {"methodBody": ["METHOD_START", "{", "return   myHeader ;", "}", "METHOD_END"], "methodName": ["getHeader"], "fileName": "com.intellij.util.xml.stubs.FileStub"}, {"methodBody": ["METHOD_START", "{", "List <  ?    extends   Stub >     =    getChildrenStubs (  )  ;", "return   isEmpty (  )     ?    null    :     (  ( ElementStub )     ( get (  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getRootTagStub"], "fileName": "com.intellij.util.xml.stubs.FileStub"}, {"methodBody": ["METHOD_START", "{", "if    ( stub    =  =    null )     {", "return   new    . Empty ( parent )  ;", "} else    {", "return   new    ( stub )     {", "@ Override", "public   XmlElement   getXmlElement (  )     {", "DomInvocationHandler   parentHandler    =    getParentHandler (  )  ;", "if    ( parentHandler    =  =    null )     {", ". LOG . error (  (  \" no   parent   handler   for    \"     +     ( this )  )  )  ;", "return   null ;", "}", "XmlTag   tag    =    parentHandler . getXmlTag (  )  ;", "if    ( tag    =  =    null )     {", ". LOG . error (  (  (  (  (  (  (  (  \" can ' t   find   tag   for    \"     +    parentHandler )     +     \"  \\ n \"  )     +     \" parent   stub :     \"  )     +     ( myStub . getParentStub (  )  )  )     +     \"  \\ n \"  )     +     \" parent ' s   children :     \"  )     +     ( myStub . getParentStub (  )  . getChildrenStubs (  )  )  )  )  ;", "return   null ;", "}", "return   tag . getAttribute ( myStub . getName (  )  )  ;", "}", "}  ;", "}", "}", "METHOD_END"], "methodName": ["createAttributeStrategy"], "fileName": "com.intellij.util.xml.stubs.StubParentStrategy"}, {"methodBody": ["METHOD_START", "{", "DomInvocationHandler   handler    =    myManager . getDomHandler ( element )  ;", "if    (  ( handler    =  =    null )     |  |     (  (  ( handler . getAnnotation ( Stubbed . class )  )     =  =    null )     &  &     (  !  ( handler . getChildDescription (  )  . isStubbed (  )  )  )  )  )", "return ;", "AbstractDomChildrenDescription   description    =    handler . getChildDescription (  )  ;", "String   nsKey    =     ( description   instanceof   DomChildrenDescription )     ?     (  ( DomChildrenDescription )     ( description )  )  . getXmlName (  )  . getNamespaceKey (  )     :     \"  \"  ;", "if    ( element   instanceof   XmlTag )     {", "XmlTag   tag    =     (  ( XmlTag )     ( element )  )  ;", "String   elementClass    =    null ;", "if    (  ( handler . getAnnotation ( StubbedOccurrence . class )  )     !  =    null )     {", "final   Type   type    =    description . getType (  )  ;", "elementClass    =     (  ( Class )     ( type )  )  . getName (  )  ;", "}", "ElementStub   stub    =    new   ElementStub ( parent ,    StringRef . fromString ( tag . getName (  )  )  ,    StringRef . fromNullableString ( nsKey )  ,    index ,     ( description   instanceof   CustomDomChildrenDescription )  ,     ( elementClass    =  =    null    ?    null    :    StringRef . fromNullableString ( elementClass )  )  ,     (  ( tag . getSubTags (  )  . length )     =  =     0     ?    tag . getValue (  )  . getTrimmedText (  )     :     \"  \"  )  )  ;", "for    ( XmlAttribute   attribute    :    tag . getAttributes (  )  )     {", "visitXmlElement ( attribute ,    stub ,     0  )  ;", "}", "Map < String ,    Integer >    indices    =    new   HashMap <  >  (  )  ;", "for    ( final   XmlTag   subTag    :    tag . getSubTags (  )  )     {", "String   name    =    subTag . getName (  )  ;", "Integer   i    =    indices . get ( name )  ;", "i    =     ( i    =  =    null )     ?     0     :    i    +     1  ;", "visitXmlElement ( subTag ,    stub ,    i )  ;", "indices . put ( name ,    i )  ;", "}", "} else", "if    ( element   instanceof   XmlAttribute )     {", "new   AttributeStub ( parent ,    StringRef . fromString (  (  ( XmlAttribute )     ( element )  )  . getLocalName (  )  )  ,    StringRef . fromNullableString ( nsKey )  ,     (  ( XmlAttribute )     ( element )  )  . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["visitXmlElement"], "fileName": "com.intellij.util.xml.stubs.builder.DomStubBuilderVisitor"}, {"methodBody": ["METHOD_START", "{", "return   DomElementClassIndex . ourInstance ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "com.intellij.util.xml.stubs.index.DomElementClassIndex"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   file    =    domFileElement . getFile (  )  . getVirtualFile (  )  ;", "if    (  !  ( file   instanceof   VirtualFileWithId )  )", "return   false ;", "final   String   clazzName    =    clazz . getName (  )  ;", "final   int   virtualFileId    =     (  ( VirtualFileWithId )     ( file )  )  . getId (  )  ;", "FindFirstProcessor <  ?    extends   PsiFile >    processor    =    new   CommonProcessors . FindFirstProcessor <  >  (  )  ;", "StubIndex . getInstance (  )  . processElements (  . KEY ,    clazzName ,    domFileElement . getFile (  )  . getProject (  )  ,    GlobalSearchScope . fileScope ( domFileElement . getFile (  )  )  ,    new   IdFilter (  )     {", "@ Override", "public   boolean   containsFileId ( int   id )     {", "return   id    =  =    virtualFileId ;", "}", "}  ,    PsiFile . class ,    processor )  ;", "return   processor . isFound (  )  ;", "}", "METHOD_END"], "methodName": ["hasStubElementsOfType"], "fileName": "com.intellij.util.xml.stubs.index.DomElementClassIndex"}, {"methodBody": ["METHOD_START", "{", "return   DomNamespaceKeyIndex . ourInstance ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "com.intellij.util.xml.stubs.index.DomNamespaceKeyIndex"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   file    =    domFileElement . getFile (  )  . getVirtualFile (  )  ;", "if    (  !  ( file   instanceof   VirtualFileWithId )  )", "return   false ;", "final   int   virtualFileId    =     (  ( VirtualFileWithId )     ( file )  )  . getId (  )  ;", "CommonProcessors . FindFirstProcessor < PsiFile >    processor    =    new   CommonProcessors . FindFirstProcessor <  >  (  )  ;", "StubIndex . getInstance (  )  . processElements (  . KEY ,    namespaceKey ,    domFileElement . getFile (  )  . getProject (  )  ,    GlobalSearchScope . fileScope ( domFileElement . getFile (  )  )  ,    new   IdFilter (  )     {", "@ Override", "public   boolean   containsFileId ( int   id )     {", "return   id    =  =    virtualFileId ;", "}", "}  ,    PsiFile . class ,    processor )  ;", "return   processor . isFound (  )  ;", "}", "METHOD_END"], "methodName": ["hasStubElementsWithNamespaceKey"], "fileName": "com.intellij.util.xml.stubs.index.DomNamespaceKeyIndex"}, {"methodBody": ["METHOD_START", "{", "return   getDomElement (  )  . getPresentation (  )  . getIcon (  )  ;", "}", "METHOD_END"], "methodName": ["getNodeIcon"], "fileName": "com.intellij.util.xml.tree.AbstractDomElementNode"}, {"methodBody": ["METHOD_START", "{", "return   getDomElement (  )  . getPresentation (  )  . getTypeName (  )  ;", "}", "METHOD_END"], "methodName": ["getPropertyName"], "fileName": "com.intellij.util.xml.tree.AbstractDomElementNode"}, {"methodBody": ["METHOD_START", "{", "return   new   com . intellij . ui . SimpleTextAttributes ( style ,    REGULAR _ ATTRIBUTES . getFgColor (  )  )  ;", "}", "METHOD_END"], "methodName": ["getSimpleAttributes"], "fileName": "com.intellij.util.xml.tree.AbstractDomElementNode"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpleTextAttributes (  ( style    |     ( SimpleTextAttributes . STYLE _ WAVED )  )  ,    REGULAR _ ATTRIBUTES . getFgColor (  )  ,    ERROR _ ATTRIBUTES . getFgColor (  )  )  ;", "}", "METHOD_END"], "methodName": ["getWavedAttributes"], "fileName": "com.intellij.util.xml.tree.AbstractDomElementNode"}, {"methodBody": ["METHOD_START", "{", "return   isExpanded ;", "}", "METHOD_END"], "methodName": ["isExpanded"], "fileName": "com.intellij.util.xml.tree.AbstractDomElementNode"}, {"methodBody": ["METHOD_START", "{", "isExpanded    =    expanded ;", "}", "METHOD_END"], "methodName": ["setExpanded"], "fileName": "com.intellij.util.xml.tree.AbstractDomElementNode"}, {"methodBody": ["METHOD_START", "{", "final   Map < Class ,    Boolean >    hiders    =    DomUtil . getFile ( getDomElement (  )  )  . getUserData ( AbstractDomElementNode . TREE _ NODES _ HIDERS _ KEY )  ;", "if    (  (  ( type    =  =    null )     |  |     ( hiders    =  =    null )  )     |  |     (  ( hiders . size (  )  )     =  =     0  )  )", "return   true ;", "final   Class   aClass    =    ReflectionUtil . getRawType ( type )  ;", "Optional < Class >    parent    =    hiders . keySet (  )  . stream (  )  . filter (  (    klass )     -  >    klass . isAssignableFrom ( aClass )  )  . min ( AbstractDomElementNode . INHERITORS _ COMPARATOR )  ;", "return   parent . map ( hiders :  : get )  . orElse ( Boolean . FALSE )  . booleanValue (  )  ;", "}", "METHOD_END"], "methodName": ["shouldBeShown"], "fileName": "com.intellij.util.xml.tree.AbstractDomElementNode"}, {"methodBody": ["METHOD_START", "{", "return   getNodeName (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.util.xml.tree.AbstractDomElementNode"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( element . isValid (  )  )  )", "return   NO _ CHILDREN ;", "List < SimpleNode >    children    =    new   ArrayList <  >  (  )  ;", "final   XmlTag   tag    =    element . getXmlTag (  )  ;", "if    (  ( tag    !  =    null )     &  &     (  !  (  ( tag . getContainingFile (  )  )    instanceof   XmlFile )  )  )", "return   NO _ CHILDREN ;", "final   XmlElementDescriptor   xmlElementDescriptor    =     ( tag    =  =    null )     ?    null    :    tag . getDescriptor (  )  ;", "final   XmlElementDescriptor [  ]    xmlDescriptors    =     ( xmlElementDescriptor    =  =    null )     ?    null    :    xmlElementDescriptor . getElementsDescriptors ( tag )  ;", "for    ( DomFixedChildDescription   description    :    element . getGenericInfo (  )  . getFixedChildrenDescriptions (  )  )     {", "String   childName    =    description . getXmlElementName (  )  ;", "if    ( xmlDescriptors    !  =    null )     {", "if    (  (  . findDescriptor ( xmlDescriptors ,    childName )  )     =  =     (  -  1  )  )", "continue ;", "}", "final   List <  ?    extends   DomElement >    values    =    description . getStableValues ( element )  ;", "if    ( shouldBeShown ( description . getType (  )  )  )     {", "if    ( DomUtil . isGenericValueType ( description . getType (  )  )  )     {", "for    ( DomElement   value    :    values )     {", "children . add ( new   GenericValueNode (  (  ( GenericDomValue )     ( value )  )  ,    this )  )  ;", "}", "} else    {", "for    ( DomElement   domElement    :    values )     {", "children . add ( new    ( domElement ,    myRootDomElement ,    this )  )  ;", "}", "}", "}", "}", "for    ( DomCollectionChildDescription   description    :    element . getGenericInfo (  )  . getCollectionChildrenDescriptions (  )  )     {", "if    ( shouldBeShown ( description . getType (  )  )  )     {", "DomElementsGroupNode   groupNode    =    new   DomElementsGroupNode ( element ,    description ,    this ,    myRootDomElement )  ;", "if    ( isMarkedType ( description . getType (  )  ,     . CONSOLIDATED _ NODES _ KEY )  )     {", "Collections . addAll ( children ,    groupNode . getChildren (  )  )  ;", "} else    {", "children . add ( groupNode )  ;", "}", "}", "}", "AbstractDomElementNode [  ]    childrenNodes    =    children . toArray ( new   AbstractDomElementNode [  0  ]  )  ;", "Comparator < AbstractDomElementNode >    comparator    =    DomUtil . getFile ( myDomElement )  . getUserData (  . COMPARATOR _ KEY )  ;", "if    ( comparator    =  =    null )     {", "comparator    =    getDefaultComparator ( element )  ;", "}", "if    ( comparator    !  =    null )     {", "Arrays . sort ( childrenNodes ,    comparator )  ;", "}", "return   childrenNodes ;", "}", "METHOD_END"], "methodName": ["doGetChildren"], "fileName": "com.intellij.util.xml.tree.BaseDomElementNode"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( descriptors . length )  ;    i +  +  )     {", "if    ( descriptors [ i ]  . getDefaultName (  )  . equals ( name )  )     {", "return   i ;", "}", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["findDescriptor"], "fileName": "com.intellij.util.xml.tree.BaseDomElementNode"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( myDomElement . isValid (  )  )  )", "return   emptyList (  )  ;", "final   List < DomCollectionChildDescription >    consolidated    =    new   ArrayList <  >  (  )  ;", "for    ( DomCollectionChildDescription   description    :    myDomElement . getGenericInfo (  )  . getCollectionChildrenDescriptions (  )  )     {", "if    ( isMarkedType ( description . getType (  )  ,     . CONSOLIDATED _ NODES _ KEY )  )     {", "consolidated . add ( description )  ;", "}", "}", "return   consolidated ;", "}", "METHOD_END"], "methodName": ["getConsolidatedChildrenDescriptions"], "fileName": "com.intellij.util.xml.tree.BaseDomElementNode"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["highlightIfChildrenHaveProblems"], "fileName": "com.intellij.util.xml.tree.BaseDomElementNode"}, {"methodBody": ["METHOD_START", "{", "if    ( type    =  =    null )     {", "return   false ;", "}", "final   List < Class >    classes    =    DomUtil . getFile ( get (  )  )  . getUserData ( key )  ;", "if    ( classes    !  =    null )     {", "Class   clazz    =    ReflectionUtil . getRawType ( type )  ;", "return   classes . contains ( clazz )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isMarkedType"], "fileName": "com.intellij.util.xml.tree.BaseDomElementNode"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( myRootDomElement . isValid (  )  )  )", "return   false ;", "DomElement   root    =    myRootDomElement ;", "while    ( root   instanceof   StableElement )     {", "root    =     (  ( StableElement < DomElement >  )     ( root )  )  . getWrappedElement (  )  ;", "}", "return    ( root   instanceof   MergedObject )     &  &     (  (  (  ( MergedObject )     ( root )  )  . getImplementations (  )  . size (  )  )     >     1  )  ;", "}", "METHOD_END"], "methodName": ["isShowContainingFileInfo"], "fileName": "com.intellij.util.xml.tree.BaseDomElementNode"}, {"methodBody": ["METHOD_START", "{", "return   myChildDescription ;", "}", "METHOD_END"], "methodName": ["getChildDescription"], "fileName": "com.intellij.util.xml.tree.DomElementsGroupNode"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( myParentElement . isValid (  )  )  )", "return   false ;", "for    ( DomElement   domElement    :    myChildDescription . getStableValues ( myParentElement )  )     {", "final   DomElementAnnotationsManager   annotationsManager    =    DomElementAnnotationsManager . getInstance ( getProject (  )  )  ;", "final   ProblemsHolder   holder    =    annotationsManager . getCachedProblemHolder ( domElement )  ;", "final   List < DomElementProblemDescriptor >    problems    =    holder . getProblems ( domElement ,    true ,    ERROR )  ;", "if    (  ( problems . size (  )  )     >     0  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasErrors"], "fileName": "com.intellij.util.xml.tree.DomElementsGroupNode"}, {"methodBody": ["METHOD_START", "{", "return   new   BaseDomElementNode ( myDomElement )  ;", "}", "METHOD_END"], "methodName": ["createRoot"], "fileName": "com.intellij.util.xml.tree.DomModelTreeStructure"}, {"methodBody": ["METHOD_START", "{", "return   myDomElement ;", "}", "METHOD_END"], "methodName": ["getRootDomElement"], "fileName": "com.intellij.util.xml.tree.DomModelTreeStructure"}, {"methodBody": ["METHOD_START", "{", "return   myBuilder ;", "}", "METHOD_END"], "methodName": ["getBuilder"], "fileName": "com.intellij.util.xml.tree.DomModelTreeView"}, {"methodBody": ["METHOD_START", "{", "return   visit (  (  ( SimpleNode )     ( myBuilder . getTreeStructure (  )  . getRootElement (  )  )  )  ,    domElement )  ;", "}", "METHOD_END"], "methodName": ["getNodeFor"], "fileName": "com.intellij.util.xml.tree.DomModelTreeView"}, {"methodBody": ["METHOD_START", "{", "DefaultActionGroup   group    =    new   DefaultActionGroup (  )  ;", "group . add ( ActionManager . getInstance (  )  . getAction (  \" DomElementsTreeView . TreePopup \"  )  )  ;", "group . addSeparator (  )  ;", "group . add ( new   i . treeStructure . actions . ExpandAllAction ( myTree )  )  ;", "group . add ( new   i . treeStructure . actions . CollapseAllAction ( myTree )  )  ;", "return   group ;", "}", "METHOD_END"], "methodName": ["getPopupActions"], "fileName": "com.intellij.util.xml.tree.DomModelTreeView"}, {"methodBody": ["METHOD_START", "{", "return   myDomManager . getProject (  )  ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "com.intellij.util.xml.tree.DomModelTreeView"}, {"methodBody": ["METHOD_START", "{", "return   myRootElement ;", "}", "METHOD_END"], "methodName": ["getRootElement"], "fileName": "com.intellij.util.xml.tree.DomModelTreeView"}, {"methodBody": ["METHOD_START", "{", "return   myTree ;", "}", "METHOD_END"], "methodName": ["getTree"], "fileName": "com.intellij.util.xml.tree.DomModelTreeView"}, {"methodBody": ["METHOD_START", "{", "DomElement   currParent    =    domElement ;", "while    ( currParent    !  =    null )     {", "if    ( currParent . equals ( potentialParent )  )", "return   true ;", "currParent    =    currParent . getParent (  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isParent"], "fileName": "com.intellij.util.xml.tree.DomModelTreeView"}, {"methodBody": ["METHOD_START", "{", "return    (  ( myRootElement )     =  =    null )     |  |     (  ( myRootElement . isValid (  )  )     &  &     ( file . equals ( DomUtil . getFile ( myRootElement )  . getVirtualFile (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isRightFile"], "fileName": "com.intellij.util.xml.tree.DomModelTreeView"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isRootVisible"], "fileName": "com.intellij.util.xml.tree.DomModelTreeView"}, {"methodBody": ["METHOD_START", "{", "if    ( file    =  =    null )", "return ;", "if    ( getProject (  )  . isDisposed (  )  )", "return ;", "ApplicationManager . getApplication (  ) vokeLater (  (  )     -  >     {", "if    ( getProject (  )  . isDisposed (  )  )", "return ;", "if    (  (  !  ( file . isValid (  )  )  )     |  |     ( isRightFile ( file )  )  )     {", "myBuilder . updateFromRoot (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["queueUpdate"], "fileName": "com.intellij.util.xml.tree.DomModelTreeView"}, {"methodBody": ["METHOD_START", "{", "if    ( domElement    =  =    null )", "return ;", "final   SimpleNode   node    =    getNodeFor ( domElement )  ;", "if    ( node    !  =    null )     {", "get (  )  . setSelectedNode ( getBuilder (  )  ,    node ,    true )  ;", "}", "}", "METHOD_END"], "methodName": ["setSelectedDomElement"], "fileName": "com.intellij.util.xml.tree.DomModelTreeView"}, {"methodBody": ["METHOD_START", "{", "myBuilder . updateFromRoot (  )  ;", "}", "METHOD_END"], "methodName": ["updateTree"], "fileName": "com.intellij.util.xml.tree.DomModelTreeView"}, {"methodBody": ["METHOD_START", "{", "boolean   validCandidate    =    false ;", "if    ( simpleNode   instanceof   AbstractDomElementNode )     {", "final   DomElement   nodeElement    =     (  ( AbstractDomElementNode )     ( simpleNode )  )  . getDomElement (  )  ;", "if    ( nodeElement    !  =    null )     {", "validCandidate    =     !  ( simpleNode   instanceof   DomElementsGroupNode )  ;", "if    ( validCandidate    &  &     ( nodeElement . equals ( domElement )  )  )     {", "return   simpleNode ;", "}", "if    (  (  !  ( nodeElement   instanceof   MergedObject )  )     &  &     (  !  (  . isParent ( nodeElement ,    domElement )  )  )  )     {", "return   null ;", "}", "}", "}", "final   Object [  ]    childElements    =    myBuilder . getTreeStructure (  )  . getChildElements ( simpleNode )  ;", "if    (  (  ( childElements . length )     =  =     0  )     &  &    validCandidate )     {", "return   simpleNode ;", "}", "for    ( Object   child    :    childElements )     {", "SimpleNode   result    =    visit (  (  ( SimpleNode )     ( child )  )  ,    domElement )  ;", "if    ( result    !  =    null )     {", "return   result ;", "}", "}", "return   validCandidate    ?    simpleNode    :    null ;", "}", "METHOD_END"], "methodName": ["visit"], "fileName": "com.intellij.util.xml.tree.DomModelTreeView"}, {"methodBody": ["METHOD_START", "{", "SimpleNode   simpleNode    =    treeView . getTree (  )  . getSelectedNode (  )  ;", "while    ( simpleNode    !  =    null )     {", "if    ( simpleNode   instanceof   DomsGroupNode )", "return    (  ( DomsGroupNode )     ( simpleNode )  )  ;", "simpleNode    =    simpleNode . getParent (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDomElementsGroupNode"], "fileName": "com.intellij.util.xml.tree.actions.AddElementInCollectionAction"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myTreeView )     !  =    null )", "return   myTreeView ;", "return   DomModelTreeView . DATA _ KEY . getData ( e . getDataContext (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTreeView"], "fileName": "com.intellij.util.xml.tree.actions.AddElementInCollectionAction"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myTreeView )     !  =    null )", "return   myTreeView ;", "return   DomModelTreeView . DATA _ KEY . getData ( e . getDataContext (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTreeView"], "fileName": "com.intellij.util.xml.tree.actions.BaseDomTreeAction"}, {"methodBody": ["METHOD_START", "{", "final   ElementPresentation   presentation    =     (  ( BaseDomElementNode )     ( selectedNode )  )  . getDomElement (  )  . getPresentation (  )  ;", "removeString    +  =     (  \"     \"     +     ( presentation . getTypeName (  )  )  )     +     (  (  ( presentation . getElementName (  )  )     =  =    null )     |  |     (  ( presentation . getElementName (  )  . trim (  )  . length (  )  )     =  =     0  )     ?     \"  \"     :     \"  :     \"     +     ( presentation . getElementName (  )  )  )  ;", "return   removeString ;", "}", "METHOD_END"], "methodName": ["getPresentationText"], "fileName": "com.intellij.util.xml.tree.actions.DeleteDomElement"}, {"methodBody": ["METHOD_START", "{", "return   DomUtil . getFile ( myTreeView . getRootElement (  )  )  . getUserData ( BaseDomElementNode . TREE _ NODES _ HIDERS _ KEY )  ;", "}", "METHOD_END"], "methodName": ["getHiders"], "fileName": "com.intellij.util.xml.tree.actions.DomElementsToggleAction"}, {"methodBody": ["METHOD_START", "{", "return   myDomElement ;", "}", "METHOD_END"], "methodName": ["getDomElement"], "fileName": "com.intellij.util.xml.ui.AbstractDomElementComponent"}, {"methodBody": ["METHOD_START", "{", "UIUtil . setEnabled ( component ,    enabled ,    true )  ;", "}", "METHOD_END"], "methodName": ["setEnabled"], "fileName": "com.intellij.util.xml.ui.AbstractDomElementComponent"}, {"methodBody": ["METHOD_START", "{", "myDispatcher . addListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["addChangeListener"], "fileName": "com.intellij.util.xml.ui.AbstractTableView"}, {"methodBody": ["METHOD_START", "{", "final   ColumnInfo [  ]    columnInfos    =    myTableModel . getColumnInfos (  )  ;", "for    ( int   i    =     0  ;    i    <     ( columnInfos . length )  ;    i +  +  )     {", "final   int   width    =    getColumnPreferredWidth ( i )  ;", "if    ( width    >     0  )     {", "myTable . getColumnModel (  )  . getColumn ( i )  . setPreferredWidth ( width )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["adjustColumnWidths"], "fileName": "com.intellij.util.xml.ui.AbstractTableView"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["allowMultipleRowsSelection"], "fileName": "com.intellij.util.xml.ui.AbstractTableView"}, {"methodBody": ["METHOD_START", "{", "myDispatcher . getMulticaster (  )  . changed (  )  ;", "}", "METHOD_END"], "methodName": ["fireChanged"], "fileName": "com.intellij.util.xml.ui.AbstractTableView"}, {"methodBody": ["METHOD_START", "{", "final   ColumnInfo   columnInfo    =    myTableModel . getColumnInfos (  )  [ i ]  ;", "final   List   items    =    myTableModel . getItems (  )  ;", "int   width    =     -  1  ;", "for    ( int   j    =     0  ;    j    <     ( items . size (  )  )  ;    j +  +  )     {", "final   TableCellRenderer   renderer    =    myTable . getCellRenderer ( j ,    i )  ;", "final   Component   component    =    renderer . geCellRendererComponent ( myTable ,    columnInfo . valueOf ( items . get ( j )  )  ,    false ,    false ,    j ,    i )  ;", "width    =    Math . max ( width ,    component . getPreferredSize (  )  . width )  ;", "}", "return   width ;", "}", "METHOD_END"], "methodName": ["getColumnPreferredWidth"], "fileName": "com.intellij.util.xml.ui.AbstractTableView"}, {"methodBody": ["METHOD_START", "{", "return   myEmptyPaneText ;", "}", "METHOD_END"], "methodName": ["getEmptyPaneText"], "fileName": "com.intellij.util.xml.ui.AbstractTableView"}, {"methodBody": ["METHOD_START", "{", "return   myHelpID ;", "}", "METHOD_END"], "methodName": ["getHelpId"], "fileName": "com.intellij.util.xml.ui.AbstractTableView"}, {"methodBody": ["METHOD_START", "{", "return   myProject ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "com.intellij.util.xml.ui.AbstractTableView"}, {"methodBody": ["METHOD_START", "{", "return   myTable ;", "}", "METHOD_END"], "methodName": ["getTable"], "fileName": "com.intellij.util.xml.ui.AbstractTableView"}, {"methodBody": ["METHOD_START", "{", "return   getTableModel (  )  . getColumnInfos (  )  [ column ]  . getCustomizedRenderer ( value ,    new   StripeTableCellRenderer ( superRenderer )  )  ;", "}", "METHOD_END"], "methodName": ["getTableCellRenderer"], "fileName": "com.intellij.util.xml.ui.AbstractTableView"}, {"methodBody": ["METHOD_START", "{", "return   myTableModel ;", "}", "METHOD_END"], "methodName": ["getTableModel"], "fileName": "com.intellij.util.xml.ui.AbstractTableView"}, {"methodBody": ["METHOD_START", "{", "return   AbstractTableView . ToolbarPosition . TOP ;", "}", "METHOD_END"], "methodName": ["getToolbarPosition"], "fileName": "com.intellij.util.xml.ui.AbstractTableView"}, {"methodBody": ["METHOD_START", "{", "myTable . setModelAndUpdateColumns ( myTableModel )  ;", "if    (  ( getEmptyPaneText (  )  )     !  =    null )     {", "final   CardLayout   cardLayout    =     (  ( CardLayout )     ( myInnerPanel . getLayout (  )  )  )  ;", "myTable . getModel (  )  . addTableModelListener ( new   TableModelListener (  )     {", "@ Override", "public   void   tableChanged ( TableModelEvent   e )     {", "cardLayout . show ( myInnerPanel ,     (  ( myTable . getRowCount (  )  )     =  =     0     ?     . EMPTY _ PANE    :     . TREE )  )  ;", "}", "}  )  ;", "}", "tuneTable ( myTable )  ;", "}", "METHOD_END"], "methodName": ["initializeTable"], "fileName": "com.intellij.util.xml.ui.AbstractTableView"}, {"methodBody": ["METHOD_START", "{", "PopupHandler . installPopupHandler ( myTable ,    group ,    place ,    ActionManager . getInstance (  )  )  ;", "}", "METHOD_END"], "methodName": ["installPopup"], "fileName": "com.intellij.util.xml.ui.AbstractTableView"}, {"methodBody": ["METHOD_START", "{", "final   boolean   columnsChanged    =    myTableModel . setColumnInfos ( columnInfos )  ;", "final   boolean   dataChanged    =     !  ( data . equals ( myTableModel . getItems (  )  )  )  ;", "final   int   oldRowCount    =    myTableModel . getRowCount (  )  ;", "if    (  ( dataChanged    |  |    columnsChanged )     &  &     ( myTable . isEditing (  )  )  )     {", "myTable . getCellEditor (  )  . cancelCellEditing (  )  ;", "}", "if    ( dataChanged )     {", "final   int   selectedRow    =    myTable . getSelectedRow (  )  ;", "myTableModel . setItems ( new   ArrayList ( data )  )  ;", "if    (  ( selectedRow    >  =     0  )     &  &     ( selectedRow    <     ( myTableModel . getRowCount (  )  )  )  )     {", "myTable . getSelectionModel (  )  . setSelectionInterval ( selectedRow ,    selectedRow )  ;", "}", "}", "myTableModel . cacheValues (  )  ;", "final   int   rowCount    =    myTableModel . getRowCount (  )  ;", "final   int   columnCount    =    myTableModel . getColumnCount (  )  ;", "myCachedRenderers    =    new   TableCellRenderer [ rowCount ]  [ columnCount ]  ;", "for    ( int   row    =     0  ;    row    <    rowCount ;    row +  +  )     {", "for    ( int   column    =     0  ;    column    <    columnCount ;    column +  +  )     {", "final   TableCellRenderer   superRenderer    =    myTable . getSuperCellRenderer ( row ,    column )  ;", "myCachedRenderers [ row ]  [ column ]     =    geCellRenderer ( row ,    column ,    superRenderer ,    myTableModel . getItems (  )  . get ( row )  )  ;", "}", "}", "if    ( columnsChanged    |  |     (  ( oldRowCount    =  =     0  )     &  &     ( rowCount    !  =     0  )  )  )     {", "adjustColumnWidths (  )  ;", "}", "myTable . revalidate (  )  ;", "myTable . repaint (  )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.intellij.util.xml.ui.AbstractTableView"}, {"methodBody": ["METHOD_START", "{", "final   boolean   empty    =     ( messages . length )     =  =     0  ;", "final   String   tooltipText    =    TooltipUtils . getTooltipText ( messages )  ;", "if    (  ( myEmptyPane )     !  =    null )     {", "myEmptyPane . getComponent (  )  . setBackground (  ( empty    ?    UIUtil . getTreeTextBackground (  )     :    BaseControl . ERROR _ BACKGROUND )  )  ;", "myEmptyPane . getComponent (  )  . setToolTipText ( tooltipText )  ;", "}", "final   JViewport   viewport    =     (  ( JViewport )     ( myTable . getParent (  )  )  )  ;", "final   Color   tableBackground    =     ( empty )     ?    UIUtil . geBackground (  )     :    BaseControl . ERROR _ BACKGROUND ;", "viewport . setBackground ( tableBackground )  ;", "viewport . setToolTipText ( tooltipText )  ;", "myTable . setBackground ( tableBackground )  ;", "myTable . setToolTipText ( tooltipText )  ;", "if    ( tooltipText    =  =    null )", "sharedInstance (  )  . registerComponent ( myTable )  ;", "}", "METHOD_END"], "methodName": ["setErrorMessages"], "fileName": "com.intellij.util.xml.ui.AbstractTableView"}, {"methodBody": ["METHOD_START", "{", "final   DefaultActionGroup   actionGroup    =    new   DefaultActionGroup (  )  ;", "for    ( final   AnAction   action    :    actions )     {", "actionGroup . add ( action )  ;", "}", "if    (  ( getHelpId (  )  )     !  =    null )     {", "actionGroup . add ( Separator . getInstance (  )  )  ;", "actionGroup . add ( new   ContextHelpAction ( getHelpId (  )  )  )  ;", "}", "final   ActionManager   actionManager    =    ActionManager . getInstance (  )  ;", "final    . ToolbarPosition   position    =    getToolbarPosition (  )  ;", "final   ActionToolbar   myActionToolbar    =    actionManager . createActionToolbar ( PROJECT _ VIEW _ TOOLBAR ,    actionGroup ,     (  ( position    =  =     (  . ToolbarPosition . TOP )  )     |  |     ( position    =  =     (  . ToolbarPosition . BOTTOM )  )  )  )  ;", "myActionToolbar . setTargetComponent ( myInnerPanel )  ;", "final   JComponent   toolbarComponent    =    myActionToolbar . getComponent (  )  ;", "final   MatteBorder   matteBorder    =    BorderFactory . createMatteBorder (  0  ,     0  ,     ( position    =  =     (  . ToolbarPosition . TOP )     ?     1     :     0  )  ,     0  ,    DARK _ GRAY )  ;", "toolbarComponent . setBorder ( BorderFactory . createCompoundBorder ( matteBorder ,    toolbarComponent . getBorder (  )  )  )  ;", "getTable (  )  . getSelectionModel (  )  . addListSelectionListener ( new   ListSelectionListener (  )     {", "@ Override", "public   void   valueChanged ( ListSelectionEvent   e )     {", "myActionToolbar . updateActionsImmediately (  )  ;", "}", "}  )  ;", "add ( toolbarComponent ,    position . getPosition (  )  )  ;", "}", "METHOD_END"], "methodName": ["setToolbarActions"], "fileName": "com.intellij.util.xml.ui.AbstractTableView"}, {"methodBody": ["METHOD_START", "{", "final   int   i    =    myTable . columnAtPoint ( e . getPoint (  )  )  ;", "if    ( i    >  =     0  )     {", "myTable . geHeader (  )  . setToolTipText ( myTableModel . getColumnInfos (  )  [ i ]  . getTooltipText (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateTooltip"], "fileName": "com.intellij.util.xml.ui.AbstractTableView"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myBoundComponent )     !  =    null )", "return ;", "initialize ( null )  ;", "}", "METHOD_END"], "methodName": ["checkInitialized"], "fileName": "com.intellij.util.xml.ui.BaseControl"}, {"methodBody": ["METHOD_START", "{", "myDomWrapper . setValue (  (  \"  \"  . equals ( value )     ?    null    :    value )  )  ;", "}", "METHOD_END"], "methodName": ["doCommit"], "fileName": "com.intellij.util.xml.ui.BaseControl"}, {"methodBody": ["METHOD_START", "{", "if    ( valuesDiffer (  )  )     {", "setValue ( getValueFrXml (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doReset"], "fileName": "com.intellij.util.xml.ui.BaseControl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( valueInXml   instanceof   String )     &  &     ( valueInControl   instanceof   String )  )     &  &     (  (  ( String )     ( valueInXml )  )  . trim (  )  . equals (  (  ( String )     ( valueInControl )  )  . trim (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["equalModuloTrim"], "fileName": "com.intellij.util.xml.ui.BaseControl"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getComponentToListenFocusLost"], "fileName": "com.intellij.util.xml.ui.BaseControl"}, {"methodBody": ["METHOD_START", "{", "return   myDefaultBackground ;", "}", "METHOD_END"], "methodName": ["getDefaultBackground"], "fileName": "com.intellij.util.xml.ui.BaseControl"}, {"methodBody": ["METHOD_START", "{", "return   myDefaultForeground ;", "}", "METHOD_END"], "methodName": ["getDefaultForeground"], "fileName": "com.intellij.util.xml.ui.BaseControl"}, {"methodBody": ["METHOD_START", "{", "return   myDomWrapper ;", "}", "METHOD_END"], "methodName": ["getDomWrapper"], "fileName": "com.intellij.util.xml.ui.BaseControl"}, {"methodBody": ["METHOD_START", "{", "return   BaseControl . ERROR _ BACKGROUND ;", "}", "METHOD_END"], "methodName": ["getErrorBackground"], "fileName": "com.intellij.util.xml.ui.BaseControl"}, {"methodBody": ["METHOD_START", "{", "return   BaseControl . ERROR _ FOREGROUND ;", "}", "METHOD_END"], "methodName": ["getErrorForeground"], "fileName": "com.intellij.util.xml.ui.BaseControl"}, {"methodBody": ["METHOD_START", "{", "return   component ;", "}", "METHOD_END"], "methodName": ["getHighlightedComponent"], "fileName": "com.intellij.util.xml.ui.BaseControl"}, {"methodBody": ["METHOD_START", "{", "return   myDomWrapper . getProject (  )  ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "com.intellij.util.xml.ui.BaseControl"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   myDomWrapper . getValue (  )  ;", "}    catch    ( IllegalAccessException    |    InvocationTargetException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["getValueFromXml"], "fileName": "com.intellij.util.xml.ui.BaseControl"}, {"methodBody": ["METHOD_START", "{", "return   BaseControl . WARNING _ BACKGROUND ;", "}", "METHOD_END"], "methodName": ["getWarningBackground"], "fileName": "com.intellij.util.xml.ui.BaseControl"}, {"methodBody": ["METHOD_START", "{", "myBoundComponent    =    createMainComponent ( boundComponent )  ;", "final   JComponent   highlightedComponent    =    getHighlightedComponent ( myBoundComponent )  ;", "myDefaultForeground    =    highlightedComponent . getForeground (  )  ;", "myDefaultBackground    =    highlightedComponent . getBackground (  )  ;", "final   JComponent   ponent    =    getComponentToListenFocusLost ( myBoundComponent )  ;", "if    ( ponent    !  =    null )     {", "ponent . addFocusListener ( new   FocusListener (  )     {", "@ Override", "public   void   focusGained ( FocusEvent   e )     {", "}", "@ Override", "public   void   focusLost ( FocusEvent   e )     {", "if    (  (  !  ( e . isTemporary (  )  )  )     &  &     ( isValid (  )  )  )     {", "mit (  )  ;", "}", "}", "}  )  ;", "}", "updateComponent (  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.intellij.util.xml.ui.BaseControl"}, {"methodBody": ["METHOD_START", "{", "return    !  ( valuesDiffer (  )  )  ;", "}", "METHOD_END"], "methodName": ["isCommitted"], "fileName": "com.intellij.util.xml.ui.BaseControl"}, {"methodBody": ["METHOD_START", "{", "return   myDomWrapper . isValid (  )  ;", "}", "METHOD_END"], "methodName": ["isValid"], "fileName": "com.intellij.util.xml.ui.BaseControl"}, {"methodBody": ["METHOD_START", "{", "if    ( myCommitting )", "return ;", "myCommitting    =    true ;", "try    {", "final   CommitListener   multicaster    =    myDispatcher . getMulticaster (  )  ;", "multicaster . beforeCommit ( this )  ;", "try    {", "WriteCommandAction . writeCommandAction ( getProject (  )  ,    getDomWrapper (  )  . getFile (  )  )  . run (  (  )     -  >     {", "doCommit ( value )  ;", "}  )  ;", "}    catch    ( ReflectiveOperationException   e )     {", ". LOG . error ( e )  ;", "}", "multicaster . afterCommit ( this )  ;", "}    finally    {", "myCommitting    =    false ;", "}", "}", "METHOD_END"], "methodName": ["setValueToXml"], "fileName": "com.intellij.util.xml.ui.BaseControl"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  \"  \"  . equals ( valueInControl )  )     &  &     ( null    =  =    valueInXml )  )     |  |     ( BaseControl . equalModuloTrim ( valueInXml ,    valueInControl )  )  )     |  |     ( Comparing . equal ( valueInXml ,    valueInControl )  )  ;", "}", "METHOD_END"], "methodName": ["valuesAreEqual"], "fileName": "com.intellij.util.xml.ui.BaseControl"}, {"methodBody": ["METHOD_START", "{", "return    !  ( BaseControl . valuesAreEqual ( getValueFromXml (  )  ,    getValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["valuesDiffer"], "fileName": "com.intellij.util.xml.ui.BaseControl"}, {"methodBody": ["METHOD_START", "{", "myModified    =    true ;", "}", "METHOD_END"], "methodName": ["setModified"], "fileName": "com.intellij.util.xml.ui.BaseModifiableControl"}, {"methodBody": ["METHOD_START", "{", "bindProperties ( getDomElement (  )  )  ;", "}", "METHOD_END"], "methodName": ["bindProperties"], "fileName": "com.intellij.util.xml.ui.BasicDomElementComponent"}, {"methodBody": ["METHOD_START", "{", "if    ( domElement    =  =    null )", "return ;", "DomElementAnnotationsManager . getInstance ( domElement . getManager (  )  . getProject (  )  )  . addHighlightingListener ( new   DomElementAnnotationsManager . DomHighlightingListener (  )     {", "@ Override", "public   void   highlightingFinished (  @ NotNull", "final   DomFileElement   element )     {", "ApplicationManager . getApplication (  )  . invokeLater (  (  )     -  >     {", "if    (  ( getComponent (  )  . isShowing (  )  )     &  &     ( element . isValid (  )  )  )     {", "updateHighlighting (  )  ;", "}", "}  )  ;", "}", "}  ,    this )  ;", "for    ( final   AbstractDomChildrenDescription   description    :    domElement . getGenericInfo (  )  . getChildrenDescriptions (  )  )     {", "final   JComponent   boundComponent    =    getBoundComponent ( description )  ;", "if    ( boundComponent    !  =    null )     {", "if    (  ( description   instanceof   DomFixedChildDescription )     &  &     ( DomUtil . isGenericValueType ( description . getType (  )  )  )  )     {", "if    (  ( description . getValues ( domElement )  . size (  )  )     =  =     1  )     {", "final   GenericDomValue   element    =    domElement . getManager (  )  . createStableValue (  (  )     -  >    domElement . isValid (  )     ?     (  ( GenericDomValue )     ( description . getValues ( domElement )  . get (  0  )  )  )     :    null )  ;", "doBind ( DomUIFactory . createControl ( element ,    commitOnEveryChange ( element )  )  ,    boundComponent )  ;", "} else    {", "}", "} else", "if    ( description   instanceof   reflect . DomCollectionChildDescription )     {", "doBind ( DomUIFactory . getDomUIFactory (  )  . createCollectionControl ( domElement ,     (  ( reflect . DomCollectionChildDescription )     ( description )  )  )  ,    boundComponent )  ;", "}", "}", "}", "reset (  )  ;", "}", "METHOD_END"], "methodName": ["bindProperties"], "fileName": "com.intellij.util.xml.ui.BasicDomElementComponent"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["commitOnEveryChange"], "fileName": "com.intellij.util.xml.ui.BasicDomElementComponent"}, {"methodBody": ["METHOD_START", "{", "propertyName    =    StringUtil . trimStart ( propertyName ,     \" my \"  )  ;", "String   convertedName    =    description . getDomNameStrategy ( get (  )  )  . convertName ( propertyName )  ;", "if    ( description   instanceof   DomCollectionChildDescription )     {", "final   String   unpluralizedStr    =    StringUtil . unpluralize ( convertedName )  ;", "if    ( unpluralizedStr    !  =    null )", "return   unpluralizedStr ;", "}", "return   convertedName ;", "}", "METHOD_END"], "methodName": ["convertFieldName"], "fileName": "com.intellij.util.xml.ui.BasicDomElementComponent"}, {"methodBody": ["METHOD_START", "{", "myBoundComponents . put ( boundComponent ,    control )  ;", "control . bind ( boundComponent )  ;", "addComponent ( control )  ;", "}", "METHOD_END"], "methodName": ["doBind"], "fileName": "com.intellij.util.xml.ui.BasicDomElementComponent"}, {"methodBody": ["METHOD_START", "{", "for    ( Field   field    :    getClass (  )  . getDeclaredFields (  )  )     {", "try    {", "field . setAccessible ( true )  ;", "if    ( description   instanceof   DomChildrenDescription )     {", "final   DomChildrenDescription   childrenDescription    =     (  ( DomChildrenDescription )     ( description )  )  ;", "if    (  ( convertFieldName ( field . getName (  )  ,    childrenDescription )  . equals ( childrenDescription . getXmlElementName (  )  )  )     &  &     (  ( field . get ( this )  )    instanceof   JComponent )  )     {", "return    (  ( JComponent )     ( field . get ( this )  )  )  ;", "}", "}", "}    catch    ( IllegalAccessException   e )     {", ". LOG . error ( e )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getBoundComponent"], "fileName": "com.intellij.util.xml.ui.BasicDomElementComponent"}, {"methodBody": ["METHOD_START", "{", "return   myBoundComponents . get ( component )  ;", "}", "METHOD_END"], "methodName": ["getDomControl"], "fileName": "com.intellij.util.xml.ui.BasicDomElementComponent"}, {"methodBody": ["METHOD_START", "{", "return   getDomElement (  )  . getModule (  )  ;", "}", "METHOD_END"], "methodName": ["getModule"], "fileName": "com.intellij.util.xml.ui.BasicDomElementComponent"}, {"methodBody": ["METHOD_START", "{", "return   getDomElement (  )  . getManager (  )  . getProject (  )  ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "com.intellij.util.xml.ui.BasicDomElementComponent"}, {"methodBody": ["METHOD_START", "{", "return   myDescriptionLabel . getText (  )  ;", "}", "METHOD_END"], "methodName": ["getDescriptionText"], "fileName": "com.intellij.util.xml.ui.CaptionComponent"}, {"methodBody": ["METHOD_START", "{", "return   myIconLabel . getIcon (  )  ;", "}", "METHOD_END"], "methodName": ["getIcon"], "fileName": "com.intellij.util.xml.ui.CaptionComponent"}, {"methodBody": ["METHOD_START", "{", "return   myCaptionLabel . getText (  )  ;", "}", "METHOD_END"], "methodName": ["getText"], "fileName": "com.intellij.util.xml.ui.CaptionComponent"}, {"methodBody": ["METHOD_START", "{", "DomUIFactory . getDomUIFactory (  )  . addErrorPanel ( this ,    elements )  ;", "}", "METHOD_END"], "methodName": ["initErrorPanel"], "fileName": "com.intellij.util.xml.ui.CaptionComponent"}, {"methodBody": ["METHOD_START", "{", "myCommittableErrorPanel    =    errorPanel ;", "Disposer . register ( this ,    errorPanel )  ;", "final   J   component    =    errorPanel . get (  )  ;", "component . setBackground ( getBackground (  )  )  ;", "myErrorPanel . setLayout ( new   BorderLayout (  )  )  ;", "myErrorPanel . add ( component ,    BorderLayout . CENTER )  ;", "}", "METHOD_END"], "methodName": ["initErrorPanel"], "fileName": "com.intellij.util.xml.ui.CaptionComponent"}, {"methodBody": ["METHOD_START", "{", "return   myBordered ;", "}", "METHOD_END"], "methodName": ["isBordered"], "fileName": "com.intellij.util.xml.ui.CaptionComponent"}, {"methodBody": ["METHOD_START", "{", "myBordered    =    bordered ;", "updaBorder (  )  ;", "}", "METHOD_END"], "methodName": ["setBordered"], "fileName": "com.intellij.util.xml.ui.CaptionComponent"}, {"methodBody": ["METHOD_START", "{", "myDescriptionLabel . setVisible (  (  ( text    !  =    null )     &  &     (  ( text . trim (  )  . length (  )  )     >     0  )  )  )  ;", "myDescriptionLabel . setText ( text )  ;", "}", "METHOD_END"], "methodName": ["setDescriptionText"], "fileName": "com.intellij.util.xml.ui.CaptionComponent"}, {"methodBody": ["METHOD_START", "{", "myIconLabel . setVisible (  ( icon    !  =    null )  )  ;", "myIconLabel . setIcon ( icon )  ;", "}", "METHOD_END"], "methodName": ["setIcon"], "fileName": "com.intellij.util.xml.ui.CaptionComponent"}, {"methodBody": ["METHOD_START", "{", "if    ( text    =  =    null )", "return ;", "myLabel . setText ( text )  ;", "}", "METHOD_END"], "methodName": ["setText"], "fileName": "com.intellij.util.xml.ui.CaptionComponent"}, {"methodBody": ["METHOD_START", "{", "if    ( myBordered )     {", "myRootPanel . setBorder ( BorderFactory . creaMatBorder (  0  ,     0  ,     1  ,     0  ,    LIGHT _ GRAY )  )  ;", "} else    {", "myRootPanel . setBorder ( BorderFactory . creaEmptyBorder (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateBorder"], "fileName": "com.intellij.util.xml.ui.CaptionComponent"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    o )", "return   true ;", "if    (  ( o    =  =    null )     |  |     (  ( getClass (  )  )     !  =     ( o . getClass (  )  )  )  )", "return   false ;", "if    (  !  ( super . equals ( o )  )  )", "return   false ;", "final      that    =     (  (  )     ( o )  )  ;", "if    (  !  ( myChildDescription . equals ( that . myChildDescription )  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.intellij.util.xml.ui.ChildGenericValueColumnInfo"}, {"methodBody": ["METHOD_START", "{", "return   myChildDescription ;", "}", "METHOD_END"], "methodName": ["getChildDescription"], "fileName": "com.intellij.util.xml.ui.ChildGenericValueColumnInfo"}, {"methodBody": ["METHOD_START", "{", "return    \"  \"  ;", "}", "METHOD_END"], "methodName": ["getEmptyValuePresentation"], "fileName": "com.intellij.util.xml.ui.ChildGenericValueColumnInfo"}, {"methodBody": ["METHOD_START", "{", "return   new   ErrorableTableCellRenderer <  >  ( getGenericValue ( domElement )  ,    renderer ,    domElement )  ;", "}", "METHOD_END"], "methodName": ["getErrorableCellRenderer"], "fileName": "com.intellij.util.xml.ui.ChildGenericValueColumnInfo"}, {"methodBody": ["METHOD_START", "{", "return    (  ( GenericDomValue )     ( myChildDescription . getValues ( o )  . get (  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getGenericValue"], "fileName": "com.intellij.util.xml.ui.ChildGenericValueColumnInfo"}, {"methodBody": ["METHOD_START", "{", "int   result    =    super . hashCode (  )  ;", "result    =     (  3  1     *    result )     +     ( myDescription . hashCode (  )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.intellij.util.xml.ui.ChildGenericValueColumnInfo"}, {"methodBody": ["METHOD_START", "{", "return   ComboControl . tuneUpComboBox ( new   JComboBox (  )  ,    ComboControl . createEnumFactory ( type )  )  ;", "}", "METHOD_END"], "methodName": ["createEnumComboBox"], "fileName": "com.intellij.util.xml.ui.ComboControl"}, {"methodBody": ["METHOD_START", "{", "return    (  )     -  >    ContainerUtil . map 2 List ( aClass . getEnumConstants (  )  ,     (  ( Function < Enum ,    Pair < String ,    Icon >  >  )     (  (    s )     -  >    com . intellij . openapi . util . Pair . create ( NamedEnumUtil . getEnumValueByElement ( s )  ,    ElementPresentationManager . getIcon ( s )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createEnumFactory"], "fileName": "com.intellij.util.xml.ui.ComboControl"}, {"methodBody": ["METHOD_START", "{", "return    (  )     -  >    ContainerUtil . map ( variantFactory . create (  )  ,     (  ( Function < Object ,    Pair < String ,    Icon >  >  )     (  (    s )     -  >    com . intellij . openapi . util . Pair . create ( ElementPresentationManager . getElementName ( s )  ,    ElementPresentationManager . getIcon ( s )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createPresentationFunction"], "fileName": "com.intellij.util.xml.ui.ComboControl"}, {"methodBody": ["METHOD_START", "{", "return    (  )     -  >     {", "final   Converter   converter    =    reference . getConverter (  )  ;", "if    ( converter   instanceof   ResolvingConverter )     {", "final   AbstractConvertContext   context    =    new   AbstractConvertContext (  )     {", "@ Override", "@ NotNull", "public   DomElement   getInvocationElement (  )     {", "return   reference ;", "}", "}  ;", "final   ResolvingConverter   resolvingConverter    =     (  ( ResolvingConverter )     ( converter )  )  ;", "final   Collection < Object >    variants    =    resolvingConverter . getVariants ( context )  ;", "final   List < Pair < String ,    Icon >  >    all    =    new   ArrayList <  >  ( ContainerUtil . map ( variants ,     (    s )     -  >    openapi . util . Pair . create ( ElementPresentationManager . getElementName ( s )  ,    ElementPresentationManager . getIcon ( s )  )  )  )  ;", "all . addAll ( ContainerUtil . map ( resolvingConverter . getAdditionalVariants ( context )  ,     (  ( Function )     (  (    s )     -  >    new   openapi . util . Pair ( s ,    null )  )  )  )  )  ;", "return   all ;", "}", "return   Collections . emptyList (  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["createResolvingFunction"], "fileName": "com.intellij.util.xml.ui.ComboControl"}, {"methodBody": ["METHOD_START", "{", "final   JComboBox   comboBox    =    getComponent (  )  ;", "final   int   size    =    comboBox . getItemCount (  )  ;", "final   List < Pair < String ,    Icon >  >    oldData    =    new   ArrayList <  >  ( size )  ;", "for    ( int   i    =     0  ;    i    <    size ;    i +  +  )     {", "oldData . add (  (  ( Pair < String ,    Icon >  )     ( comboBox . getItemAt ( i )  )  )  )  ;", "}", "if    ( myNullable )     {", "final   LinkedList < Pair < String ,    Icon >  >    list    =    new   LinkedList ( newData )  ;", "list . addFirst (  . EMPTY )  ;", "newData    =    list ;", "}", "return    !  ( newData . equals ( oldData )  )  ;", "}", "METHOD_END"], "methodName": ["dataChanged"], "fileName": "com.intellij.util.xml.ui.ComboControl"}, {"methodBody": ["METHOD_START", "{", "comboBox . setEditable ( false )  ;", "comboBox . setPrototypeDisplayValue ( new    . ComboBoxItem (  \" A \"  ,    null )  )  ;", "comboBox . setRenderer ( new   DefaultListCellRenderer (  )     {", "@ Override", "public   Component   getListCellRendererComponent ( JList   list ,    Object   value ,    int   index ,    boolean   isSelected ,    boolean   cellHasFocus )     {", "super . getListCellRendererComponent ( list ,    value ,    index ,    isSelected ,    cellHasFocus )  ;", "final   Pair < String ,    Icon >    pair    =     (  ( Pair < String ,    Icon >  )     ( value )  )  ;", "final   String   text    =     ( pair    =  =    null )     ?    null    :    pair . first ;", "setText ( text )  ;", "final   Dimension   dimension    =    getPreferredSize (  )  ;", "if    (  !  ( validity . value ( text )  )  )     {", "setFont ( getFont (  )  . deriveFont ( Font . ITALIC )  )  ;", "setForeground ( RED )  ;", "}", "setIcon (  ( pair    =  =    null    ?    null    :    pair . second )  )  ;", "setPreferredSize ( new   Dimension (  (  -  1  )  ,    dimension . height )  )  ;", "return   this ;", "}", "}  )  ;", "return   comboBox ;", "}", "METHOD_END"], "methodName": ["initComboBox"], "fileName": "com.intellij.util.xml.ui.ComboControl"}, {"methodBody": ["METHOD_START", "{", "return   myNullable ;", "}", "METHOD_END"], "methodName": ["isNullable"], "fileName": "com.intellij.util.xml.ui.ComboControl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( myNullable )     &  &     ( object    =  =     ( ComboControl . EMPTY . first )  )  )     |  |     ( myIcons . containsKey ( object )  )  ;", "}", "METHOD_END"], "methodName": ["isValidValue"], "fileName": "com.intellij.util.xml.ui.ComboControl"}, {"methodBody": ["METHOD_START", "{", "myNullable    =    nullable ;", "}", "METHOD_END"], "methodName": ["setNullable"], "fileName": "com.intellij.util.xml.ui.ComboControl"}, {"methodBody": ["METHOD_START", "{", "final   List < Pair < String ,    Icon >  >    list    =    dataFactory . create (  )  ;", "final   Set < String >    standardValues    =    new   HashSet <  >  (  )  ;", "for    ( final   Pair < String ,    Icon >    pair    :    list )     {", "comboBox . addItem ( new    . ComboBoxItem ( pair )  )  ;", "standardValues . add ( pair . first )  ;", "}", "return    . initComboBox ( comboBox ,     (    object )     -  >    standardValues . contains ( object )  )  ;", "}", "METHOD_END"], "methodName": ["tuneUpComboBox"], "fileName": "com.intellij.util.xml.ui.ComboControl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myPanel )     !  =    null )     {", "commit ( myPanel )  ;", "}", "}", "METHOD_END"], "methodName": ["applyChanges"], "fileName": "com.intellij.util.xml.ui.CommitablePanelUserActivityListener"}, {"methodBody": ["METHOD_START", "{", "final   ProgressIndicator   indicator    =    ProgressManager . getInstance (  )  . getProgressIndicator (  )  ;", "if    ( indicator    !  =    null )     {", "indicator . cancel (  )  ;", "}", "}", "METHOD_END"], "methodName": ["cancel"], "fileName": "com.intellij.util.xml.ui.CommitablePanelUserActivityListener"}, {"methodBody": ["METHOD_START", "{", "myAlarm . cancelAllRequests (  )  ;", "}", "METHOD_END"], "methodName": ["cancelAllRequests"], "fileName": "com.intellij.util.xml.ui.CommitablePanelUserActivityListener"}, {"methodBody": ["METHOD_START", "{", "ServiceManager . getService ( getProject (  )  ,    CommittableUtil . class )  . commit ( panel )  ;", "}", "METHOD_END"], "methodName": ["commit"], "fileName": "com.intellij.util.xml.ui.CommitablePanelUserActivityListener"}, {"methodBody": ["METHOD_START", "{", "return   myProject ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "com.intellij.util.xml.ui.CommitablePanelUserActivityListener"}, {"methodBody": ["METHOD_START", "{", "return    !  ( myAlarm . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["isWaiting"], "fileName": "com.intellij.util.xml.ui.CommitablePanelUserActivityListener"}, {"methodBody": ["METHOD_START", "{", "committable . commit (  )  ;", "}", "METHOD_END"], "methodName": ["commit"], "fileName": "com.intellij.util.xml.ui.CommittableUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( committable   instanceof   Highlightable )     {", "(  ( Highlightable )     ( committable )  )  . updateHighlighting (  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateHighlighting"], "fileName": "com.intellij.util.xml.ui.CommittableUtil"}, {"methodBody": ["METHOD_START", "{", "myComponents . add ( panel )  ;", "Disposer . register ( this ,    panel )  ;", "return   panel ;", "}", "METHOD_END"], "methodName": ["addComponent"], "fileName": "com.intellij.util.xml.ui.CompositeCommittable"}, {"methodBody": ["METHOD_START", "{", "return   myComponents ;", "}", "METHOD_END"], "methodName": ["getChildren"], "fileName": "com.intellij.util.xml.ui.CompositeCommittable"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["createAdditionActions"], "fileName": "com.intellij.util.xml.ui.DomCollectionControl"}, {"methodBody": ["METHOD_START", "{", "return   myColumnInfos ;", "}", "METHOD_END"], "methodName": ["createColumnInfos"], "fileName": "com.intellij.util.xml.ui.DomCollectionControl"}, {"methodBody": ["METHOD_START", "{", "return   new   ControlAddAction ( name ,    name ,    icon )     {", "@ Override", "protected   Type   getElementType (  )     {", "return   type ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createDefaultAction"], "fileName": "com.intellij.util.xml.ui.DomCollectionControl"}, {"methodBody": ["METHOD_START", "{", "final   DefaultActionGroup   group    =    new   DefaultActionGroup (  )  ;", "group . addAll (  (  ( DefaultActionGroup )     ( ActionManager . getInstance (  )  . getAction (  \"  \"  )  )  )  )  ;", "return   group ;", "}", "METHOD_END"], "methodName": ["createPopupActionGroup"], "fileName": "com.intellij.util.xml.ui.DomCollectionControl"}, {"methodBody": ["METHOD_START", "{", "doEdit ( myCollectionElements . get ( sortAdjustedIndex ( myCollectionPanel . getTable (  )  . getSelectedRow (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["doEdit"], "fileName": "com.intellij.util.xml.ui.DomCollectionControl"}, {"methodBody": ["METHOD_START", "{", "final   DomEditorManager   manager    =    DomCollectionControl . getDomEditorManager ( this )  ;", "if    ( manager    !  =    null )     {", "manager . openDomElementEditor ( t )  ;", "}", "}", "METHOD_END"], "methodName": ["doEdit"], "fileName": "com.intellij.util.xml.ui.DomCollectionControl"}, {"methodBody": ["METHOD_START", "{", "ApplicationManager . getApplication (  )  . invokeLater (  (  )     -  >     {", "final   int [  ]    selected    =    myPanel . getTable (  )  . getSelectedRows (  )  ;", "if    (  ( selected    =  =    null )     |  |     ( selected . length    =  =     0  )  )", "return ;", "final   List < T >    selectedElements    =    new   ArrayList <  >  ( selected . length )  ;", "for    ( final   int   i    :    selected )     {", "selectedElements . add ( myElements . get ( sortAdjustedIndex ( i )  )  )  ;", "}", "doRemove ( selectedElements )  ;", "reset (  )  ;", "int   selection    =    selected [  0  ]  ;", "if    ( selection    >  =     ( myElements . size (  )  )  )     {", "selection    =     ( myElements . size (  )  )     -     1  ;", "}", "if    ( selection    >  =     0  )     {", "myPanel . getTable (  )  . setRowSelectionInterval ( selection ,    selection )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["doRemove"], "fileName": "com.intellij.util.xml.ui.DomCollectionControl"}, {"methodBody": ["METHOD_START", "{", "Set < PsiFile >    files    =    new   HashSet <  >  (  )  ;", "for    ( final   T   t    :    toDelete )     {", "final   XmlElement   element    =    t . getXmlElement (  )  ;", "if    ( element    !  =    null )     {", "ContainerUtil . addIfNotNull ( files ,    element . getContainingFile (  )  )  ;", "}", "}", "WriteCommandA . writeCommandA ( getProject (  )  ,    PsiUtilCore . toPsiFileArray ( files )  )  . run (  (  )     -  >     {", "for    ( final   T   t    :    toDelete )     {", "if    ( t . isValid (  )  )     {", "t . undefine (  )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["doRemove"], "fileName": "com.intellij.util.xml.ui.DomCollectionControl"}, {"methodBody": ["METHOD_START", "{", "return   myChildDescription ;", "}", "METHOD_END"], "methodName": ["getChildDescription"], "fileName": "com.intellij.util.xml.ui.DomCollectionControl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( List < T >  )     ( myChildDescription . getValues ( myParentDomElement )  )  )  ;", "}", "METHOD_END"], "methodName": ["getCollectionElements"], "fileName": "com.intellij.util.xml.ui.DomCollectionControl"}, {"methodBody": ["METHOD_START", "{", "return   e . getData ( DomCollectionControl . DOM _ COLLECTION _ CONTROL )  ;", "}", "METHOD_END"], "methodName": ["getDomCollectionControl"], "fileName": "com.intellij.util.xml.ui.DomCollectionControl"}, {"methodBody": ["METHOD_START", "{", "JComponent   component    =    control . getComponent (  )  ;", "while    (  ( component    !  =    null )     &  &     (  !  ( component   instanceof   DomEditorManager )  )  )     {", "final   Container   parent    =    component . getParent (  )  ;", "if    (  !  ( parent   instanceof   JComponent )  )     {", "return   null ;", "}", "component    =     (  ( JComponent )     ( parent )  )  ;", "}", "return    (  ( DomEditorManager )     ( component )  )  ;", "}", "METHOD_END"], "methodName": ["getDomEditorManager"], "fileName": "com.intellij.util.xml.ui.DomCollectionControl"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getEmptyPaneText"], "fileName": "com.intellij.util.xml.ui.DomCollectionControl"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getHelpId"], "fileName": "com.intellij.util.xml.ui.DomCollectionControl"}, {"methodBody": ["METHOD_START", "{", "return   myParentDomElement . getManager (  )  . getProject (  )  ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "com.intellij.util.xml.ui.DomCollectionControl"}, {"methodBody": ["METHOD_START", "{", "if    ( boundComponent    =  =    null )     {", "myCollectionPanel    =    new   DomTableView ( getProject (  )  ,    getEmptyPaneText (  )  ,    getHelpId (  )  )  ;", "} else    {", "myCollectionPanel    =    boundComponent ;", "}", "myCollectionPanel . setToolbarActions ( new    . AddAction (  )  ,    new    . EditAction (  )  ,    new    . RemoveAction (  )  )  ;", "myCollectionPanel . installPopup ( J 2 EE _ ATTRIBUTES _ VIEW _ POPUP ,    createPopupActionGroup (  )  )  ;", "myCollectionPanel . initializeTable (  )  ;", "myCollectionPanel . addCustomDataProvider ( this )  ;", "myCollectionPanel . addChangeListener ( new   AbstractTableView . ChangeListener (  )     {", "@ Override", "public   void   changed (  )     {", "reset (  )  ;", "}", "}  )  ;", "reset (  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.intellij.util.xml.ui.DomCollectionControl"}, {"methodBody": ["METHOD_START", "{", "return   myEditable ;", "}", "METHOD_END"], "methodName": ["isEditable"], "fileName": "com.intellij.util.xml.ui.DomCollectionControl"}, {"methodBody": ["METHOD_START", "{", "return   myCollectionPanel . getTable (  )  . convertRowIndexToModel ( index )  ;", "}", "METHOD_END"], "methodName": ["sortAdjustedIndex"], "fileName": "com.intellij.util.xml.ui.DomCollectionControl"}, {"methodBody": ["METHOD_START", "{", "DomElement   domElement    =    getDomElement (  )  ;", "final   List < DomElementProblemDescriptor >    list    =    DomElementAnnotationsManager . getInstance ( getProject (  )  )  . getCachedProblemHolder ( domElement )  . getProblems ( domElement )  ;", "final   List < String >    messages    =    new   ArrayList <  >  (  )  ;", "for    ( final   DomElementProblemDescriptor   descriptor    :    list )     {", "if    (  ( descriptor   instanceof   ProblemDescriptor )     &  &     ( myChildDescription . equals (  (  ( ProblemDescriptor )     ( descriptor )  )  . getChildDescription (  )  )  )  )     {", "messages . add ( descriptor . getDescriptionTemplate (  )  )  ;", "}", "}", "myCollectionPanel . setErrorMessages ( ArrayUtil . toStringArray ( messages )  )  ;", "myCollectionPanel . repaint (  )  ;", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "com.intellij.util.xml.ui.DomCollectionControl"}, {"methodBody": ["METHOD_START", "{", "final   JPanel   panel    =    new   JPanel ( new   BorderLayout (  )  )  ;", "panel . add ( captionComponent ,    BorderLayout . NORTH )  ;", "panel . add (  ( element . isValid (  )     ?    mittablePanel . getComponent (  )     :    new   JPanel (  )  )  ,    BorderLayout . CENTER )  ;", "BasicDomElementComponent   ponent    =    new   BasicDomElementComponent ( element )     {", "@ Override", "public   JComponent   getComponent (  )     {", "return   panel ;", "}", "}  ;", "ponent . addComponent ( mittablePanel )  ;", "ponent . addComponent ( captionComponent )  ;", "return   ponent ;", "}", "METHOD_END"], "methodName": ["createComponentWithCaption"], "fileName": "com.intellij.util.xml.ui.DomFileEditor"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =    DomUtil . getFile ( element )  ;", "final   Factory < BasicDomElementComponent >    factory    =     (  )     -  >     {", "CaptionComponent   captionComponent    =    new   CaptionComponent ( name ,    icon )  ;", "captionComponent . initErrorPanel ( element )  ;", "BasicDomElementComponent   component    =    createComponentWithCaption ( committablePanel . create (  )  ,    captionComponent ,    element )  ;", "Disposer . register ( component ,    captionComponent )  ;", "return   component ;", "}  ;", "return   new    < BasicDomElementComponent >  ( file . getProject (  )  ,    file . getVirtualFile (  )  ,    name ,    factory )     {", "@ Override", "public   JComponent   getPreferredFocusedComponent (  )     {", "return   null ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createDomFileEditor"], "fileName": "com.intellij.util.xml.ui.DomFileEditor"}, {"methodBody": ["METHOD_START", "{", "return   myComponent ;", "}", "METHOD_END"], "methodName": ["getDomComponent"], "fileName": "com.intellij.util.xml.ui.DomFileEditor"}, {"methodBody": ["METHOD_START", "{", "return   myComponent . getDomElement (  )  ;", "}", "METHOD_END"], "methodName": ["getDomElement"], "fileName": "com.intellij.util.xml.ui.DomFileEditor"}, {"methodBody": ["METHOD_START", "{", "myCustomDataProviders . add ( provider )  ;", "}", "METHOD_END"], "methodName": ["addCustomDataProvider"], "fileName": "com.intellij.util.xml.ui.DomTableView"}, {"methodBody": ["METHOD_START", "{", "installPopup ( J 2 EE _ ATTRIBUTES _ VIEW _ POPUP ,    group )  ;", "}", "METHOD_END"], "methodName": ["installPopup"], "fileName": "com.intellij.util.xml.ui.DomTableView"}, {"methodBody": ["METHOD_START", "{", "control . addCommitListener ( new   CommitAdapter (  )     {", "@ Override", "public   void   afterCommit ( final      control )     {", "reset (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addDependency"], "fileName": "com.intellij.util.xml.ui.DomUIControl"}, {"methodBody": ["METHOD_START", "{", "return   DomUIFactory . getDomUIFactory (  )  . createCellEditor ( genericDomValue ,    DomUtil . extractParameterClassFromGenericType ( genericDomValue . getDomElementType (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createCellEditor"], "fileName": "com.intellij.util.xml.ui.DomUIFactory"}, {"methodBody": ["METHOD_START", "{", "final   ColumnInfo   columnInfo    =    createColumnInfo ( description ,    element )  ;", "final   Class   aClass    =    DomUextractParameterClassFromGenericType ( description . getType (  )  )  ;", "return   new   DomCollectionControl ( element ,    description ,     ( aClass    =  =    null )  ,    columnInfo )  ;", "}", "METHOD_END"], "methodName": ["createCollectionControl"], "fileName": "com.intellij.util.xml.ui.DomUIFactory"}, {"methodBody": ["METHOD_START", "{", "final   String   presentableName    =    description . getCommonPresentableName ( element )  ;", "final   Class   aClass    =    DomUextractParameterClassFromGenericType ( description . getType (  )  )  ;", "if    ( aClass    !  =    null )     {", "if    (  ( Boolean . class . equals ( aClass )  )     |  |     ( boolean . class . equals ( aClass )  )  )     {", "return   new   BooleanColumnInfo ( presentableName )  ;", "}", "return   new   GenericValueColumnInfo ( presentableName ,    aClass ,    createCellEditor ( element ,    aClass )  )  ;", "}", "return   new   StringColumnInfo ( presentableName )  ;", "}", "METHOD_END"], "methodName": ["createColumnInfo"], "fileName": "com.intellij.util.xml.ui.DomUIFactory"}, {"methodBody": ["METHOD_START", "{", "return   DomUIFactory . createControl ( element ,    false )  ;", "}", "METHOD_END"], "methodName": ["createControl"], "fileName": "com.intellij.util.xml.ui.DomUIFactory"}, {"methodBody": ["METHOD_START", "{", "return   DomUIFactory . createGenericValueControl ( DomUtil . getGenericValueParameter ( element . getDomElementType (  )  )  ,    element ,    commitOnEveryChange )  ;", "}", "METHOD_END"], "methodName": ["createControl"], "fileName": "com.intellij.util.xml.ui.DomUIFactory"}, {"methodBody": ["METHOD_START", "{", "final   DomStringWrapper   stringWrapper    =    new   DomStringWrapper ( element )  ;", "final   Class   rawType    =    ReflectionUtil . getRawType ( type )  ;", "if    (  ( type   instanceof   Class )     &  &     ( Enum . class . isAssignableFrom ( rawType )  )  )     {", "return   new   ComboControl ( stringWrapper ,    rawType )  ;", "}", "if    ( DomElement . class . isAssignableFrom ( rawType )  )     {", "final   ComboControl   control    =    new   ComboControl ( element )  ;", "final   Required   annotation    =    element . getAnnotation ( Required . class )  ;", "if    (  (  ( annotation    =  =    null )     |  |     (  !  ( annotation . value (  )  )  )  )     |  |     (  !  ( annotation . nonEmpty (  )  )  )  )     {", "control . setNullable ( true )  ;", "}", "return   control ;", "}", "final   DomFixedWrapper   wrapper    =    new   DomFixedWrapper ( element )  ;", "if    (  ( type . equals ( boolean . class )  )     |  |     ( type . equals ( Boolean . class )  )  )     {", "return   new   BooleanControl ( wrapper )  ;", "}", "if    ( type . equals ( String . class )  )     {", "return    . get (  )  . createTextControl ( wrapper ,    commitOnEveryChange )  ;", "}", "final   BaseControl   customControl    =     . get (  )  . createCustomControl ( type ,    stringWrapper ,    commitOnEveryChange )  ;", "if    ( customControl    !  =    null )", "return   customControl ;", "return    . get (  )  . createTextControl ( stringWrapper ,    commitOnEveryChange )  ;", "}", "METHOD_END"], "methodName": ["createGenericValueControl"], "fileName": "com.intellij.util.xml.ui.DomUIFactory"}, {"methodBody": ["METHOD_START", "{", "return   DomUIFactory . getDomUIFactory (  )  . createTextControl ( new   DomCollectionWrapper <  >  ( parent ,    parent . getGenericInfo (  )  . getCollectionChildDescription (  \" description \"  )  )  ,    commitOnEveryChange )  ;", "}", "METHOD_END"], "methodName": ["createLargeDescriptionControl"], "fileName": "com.intellij.util.xml.ui.DomUIFactory"}, {"methodBody": ["METHOD_START", "{", "return   DomUIFactory . createLargeDescriptionControl ( parent ,    commitOnEveryChange )  ;", "}", "METHOD_END"], "methodName": ["createSmallDescriptionControl"], "fileName": "com.intellij.util.xml.ui.DomUIFactory"}, {"methodBody": ["METHOD_START", "{", "return   DomUIFactory . getDomUIFactory (  )  . createTextControl ( new   DomStringWrapper ( value )  ,    commitOnEveryChange )  ;", "}", "METHOD_END"], "methodName": ["createTextControl"], "fileName": "com.intellij.util.xml.ui.DomUIFactory"}, {"methodBody": ["METHOD_START", "{", "return   DomUIFactory . getDomUIFactory (  )  . createTextControl ( wrapper ,    false )  ;", "}", "METHOD_END"], "methodName": ["createTextControl"], "fileName": "com.intellij.util.xml.ui.DomUIFactory"}, {"methodBody": ["METHOD_START", "{", "for    ( Method   method    :    ReflectionUtil . getClassPublicMethods ( clazz )  )     {", "if    ( methodName . equals ( method . getName (  )  )  )     {", "return   method ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findMethod"], "fileName": "com.intellij.util.xml.ui.DomUIFactory"}, {"methodBody": ["METHOD_START", "{", "return   ServiceManager . getService ( DomUIFactory . class )  ;", "}", "METHOD_END"], "methodName": ["getDomUIFactory"], "fileName": "com.intellij.util.xml.ui.DomUIFactory"}, {"methodBody": ["METHOD_START", "{", "component . setBorder ( Borders . empty (  )  )  ;", "return   component ;", "}", "METHOD_END"], "methodName": ["removeBorder"], "fileName": "com.intellij.util.xml.ui.DomUIFactoryImpl"}, {"methodBody": ["METHOD_START", "{", "final   List < Committable >    list    =    compositCommitable . getChildren (  )  ;", "for    ( Committable   committable    :    list )     {", "if    ( committable   instanceof   DomUIControl )     {", "if    (  (  ( DomUIControl )     ( committable )  )  . canNavigate ( domElement )  )     {", "return    (  ( DomUIControl )     ( committable )  )  ;", "}", "} else", "if    ( committable   instanceof   CompositeCommittable )     {", "final   DomUIControl   control    =     . findDomControl (  (  ( CompositeCommittable )     ( committable )  )  ,    domElement )  ;", "if    ( control    !  =    null )", "return   control ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findDomControl"], "fileName": "com.intellij.util.xml.ui.DomUINavigationProvider"}, {"methodBody": ["METHOD_START", "{", "final   Component   component    =    KeyboardFocusManager . getCurrentKeyboardFocusManager (  )  . getPermanentFocusOwner (  )  ;", "if    ( component    !  =    null )     {", "final   DomElement   domElement    =     . findDomElement ( compositCommitable ,    component )  ;", "if    ( domElement    !  =    null )     {", "return   domElement ;", "}", "}", "return   compositCommitable . getDomElement (  )  ;", "}", "METHOD_END"], "methodName": ["findDomElement"], "fileName": "com.intellij.util.xml.ui.DomUINavigationProvider"}, {"methodBody": ["METHOD_START", "{", "final   List < Committable >    list    =    compositCommitable . getChildren (  )  ;", "for    ( Committable   committable    :    list )     {", "if    ( committable   instanceof   DomUIControl )     {", "final   DomUIControl   uiControl    =     (  ( DomUIControl )     ( committable )  )  ;", "if    ( uiControl . getComponent (  )  . isAncestorOf ( component )  )     {", "return   uiControl . getDomElement (  )  ;", "}", "} else", "if    ( committable   instanceof   CompositeCommittable )     {", "final   com . intellij . util . xml . DomElement   element    =     . findDomElement (  (  ( CompositeCommittable )     ( committable )  )  ,    component )  ;", "if    ( element    !  =    null )", "return   element ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findDomElement"], "fileName": "com.intellij.util.xml.ui.DomUINavigationProvider"}, {"methodBody": ["METHOD_START", "{", "return   DomUtil . getFile ( getExistingDomElement (  )  )  ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "com.intellij.util.xml.ui.DomWrapper"}, {"methodBody": ["METHOD_START", "{", "return   getExistingDomElement (  )  . getManager (  )  . getProject (  )  ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "com.intellij.util.xml.ui.DomWrapper"}, {"methodBody": ["METHOD_START", "{", "return   getExistingDomElement (  )  . getResolveScope (  )  ;", "}", "METHOD_END"], "methodName": ["getResolveScope"], "fileName": "com.intellij.util.xml.ui.DomWrapper"}, {"methodBody": ["METHOD_START", "{", "return   getExistingDomElement (  )  . isValid (  )  ;", "}", "METHOD_END"], "methodName": ["isValid"], "fileName": "com.intellij.util.xml.ui.DomWrapper"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getEditedFile"], "fileName": "com.intellij.util.xml.ui.EditedElementDescription"}, {"methodBody": ["METHOD_START", "{", "final   EmptyPane   emptyPane    =    new   EmptyPane ( text )  ;", "panel . setLayout ( new   BorderLayout (  )  )  ;", "panel . add ( emptyPane . getComponent (  )  ,    BorderLayout . CENTER )  ;", "}", "METHOD_END"], "methodName": ["addToPanel"], "fileName": "com.intellij.util.xml.ui.EmptyPane"}, {"methodBody": ["METHOD_START", "{", "return   myPanel ;", "}", "METHOD_END"], "methodName": ["getComponent"], "fileName": "com.intellij.util.xml.ui.EmptyPane"}, {"methodBody": ["METHOD_START", "{", "myLabel . setText ( text )  ;", "}", "METHOD_END"], "methodName": ["setText"], "fileName": "com.intellij.util.xml.ui.EmptyPane"}, {"methodBody": ["METHOD_START", "{", "return   General . ExclMark ;", "}", "METHOD_END"], "methodName": ["getErrorIcon"], "fileName": "com.intellij.util.xml.ui.ErrorableTableCellRenderer"}, {"methodBody": ["METHOD_START", "{", "final   DomManager   domManager    =    DomManager . getDomManager ( myModule . getProject (  )  )  ;", "final   T   t    =    domManager . createStableValue (  (  )     -  >     {", "T   t 1     =    description . find (  )  ;", "if    ( t 1     =  =    null )     {", "return   createMockElement ( aClass )  ;", "}", "return   t 1  ;", "}  )  ;", "my . put ( description ,    t )  ;", "return   t ;", "}", "METHOD_END"], "methodName": ["addEditedElement"], "fileName": "com.intellij.util.xml.ui.MockDomElementsEditor"}, {"methodBody": ["METHOD_START", "{", "return   createMockElement ( aClass ,    myModule )  ;", "}", "METHOD_END"], "methodName": ["createMockElement"], "fileName": "com.intellij.util.xml.ui.MockDomElementsEditor"}, {"methodBody": ["METHOD_START", "{", "final   Project   project    =    module . getProject (  )  ;", "ApplicationManager . getApplication (  )  . invokeLater (  (  )     -  >     {", "if    ( myFileEditor . isInitialised (  )  )     {", "myContents . reset (  )  ;", "}", "}  )  ;", "final   DomManager   domManager    =    DomManager . getDomManager ( project )  ;", "final   T   mock    =    domManager . createMock ( aClass ,    module ,    true )  ;", "if    (  ( myFileEditor )     !  =    null )     {", "myFileEditor . addWatched ( mock )  ;", "}", "return   mock ;", "}", "METHOD_END"], "methodName": ["createMockElement"], "fileName": "com.intellij.util.xml.ui.MockDomElementsEditor"}, {"methodBody": ["METHOD_START", "{", "return   myFileEditor ;", "}", "METHOD_END"], "methodName": ["getFileEditor"], "fileName": "com.intellij.util.xml.ui.MockDomElementsEditor"}, {"methodBody": ["METHOD_START", "{", "myFileEditor    =    new   DomFileEditor < BasicDomElementComponent >  ( project ,    virtualFile ,    name ,    component )     {", "@ Override", "public   JComponent   getPreferredFocusedComponent (  )     {", "return   null ;", "}", "@ Override", "@ NotNull", "protected   JComponent   createCustomComponent (  )     {", "final   JComponent   customComponent    =    super . createCustomComponent (  )  ;", "myContents    =    getDomComponent (  )  ;", "return   customComponent ;", "}", "@ Override", "public   void   reset (  )     {", "for    ( final   Map . Entry < EditedElementDescription <  ?    extends   DomElement >  ,    DomElement >    entry    :    my . entrySet (  )  )     {", "final   DomElement   newValue    =    entry . getKey (  )  . find (  )  ;", "final   DomElement   oldValue    =    entry . getValue (  )  ;", "if    (  (  ( newValue    !  =    null )     &  &     (  !  ( newValue . equals ( oldValue )  )  )  )     |  |     (  ( newValue    =  =    null )     &  &     (  !  ( oldValue . getManager (  )  . isMockElement ( oldValue )  )  )  )  )     {", "(  ( StableElement )     ( oldValue )  )  . revalidate (  )  ;", "}", "}", "super . reset (  )  ;", "}", "@ Override", "public   void   commit (  )     {", "super . commit (  )  ;", "final   List < EditedElementDescription >    descriptions    =    new   ArrayList <  >  (  )  ;", "final   Set < PsiFile >    changedFiles    =    new   HashSet <  >  (  )  ;", "for    ( final   Map . Entry < EditedElementDescription <  ?    extends   DomElement >  ,    DomElement >    entry    :    my . entrySet (  )  )     {", "final   EditedElementDescription   description    =    entry . getKey (  )  ;", "final   DomElement   editedElement    =    entry . getValue (  )  ;", "if    (  (  ( description . find (  )  )     =  =    null )     &  &     (  ( editedElement . getXmlTag (  )  )     !  =    null )  )     {", "descriptions . add ( description )  ;", "final   XmlFile   xmlFile    =    description . getEditedFile (  )  ;", "if    ( xmlFile    !  =    null )     {", "changedFiles . add ( xmlFile )  ;", "}", "}", "}", "WriteCommandAction . writeCommandAction ( project ,    PsiUtilCore . toPsiFileArray ( changedFiles )  )  . run (  (  )     -  >     {", "for    ( EditedElementDescription   description    :    descriptions )     {", "final   DomElement   editedElement    =    my . get ( description )  ;", "DomElement   element    =    description . addElement (  )  ;", "element . copyFrom ( editedElement )  ;", "description . initialize ( element )  ;", "removeWatchedElement ( editedElement )  ;", "(  ( StableElement )     ( editedElement )  )  . invalidate (  )  ;", "}", "}  )  ;", "}", "}  ;", "final   DomManager   domManager    =    DomManager . getDomManager ( project )  ;", "for    ( final   DomElement   element    :    my . values (  )  )     {", "if    ( domManager . isMockElement ( element )  )     {", "myFileEditor . addWatchedElement ( element )  ;", "}", "}", "return   myFileEditor ;", "}", "METHOD_END"], "methodName": ["initFileEditor"], "fileName": "com.intellij.util.xml.ui.MockDomElementsEditor"}, {"methodBody": ["METHOD_START", "{", "initFileEditor ( component . getProject (  )  ,    virtualFile ,    name ,     (  )     -  >    component )  ;", "Disposer . register ( myFileEditor ,    component )  ;", "return   myFileEditor ;", "}", "METHOD_END"], "methodName": ["initFileEditor"], "fileName": "com.intellij.util.xml.ui.MockDomElementsEditor"}, {"methodBody": ["METHOD_START", "{", "return   myRowCount ;", "}", "METHOD_END"], "methodName": ["getRowCount"], "fileName": "com.intellij.util.xml.ui.MultiLineTextPanel"}, {"methodBody": ["METHOD_START", "{", "myRowCount    =    rowCount ;", "}", "METHOD_END"], "methodName": ["setRowCount"], "fileName": "com.intellij.util.xml.ui.MultiLineTextPanel"}, {"methodBody": ["METHOD_START", "{", "myUndoHelper . addWatchedDocument ( document )  ;", "}", "METHOD_END"], "methodName": ["addWatchedDocument"], "fileName": "com.intellij.util.xml.ui.PerspectiveFileEditor"}, {"methodBody": ["METHOD_START", "{", "addWatchedDocument ( getDocumentManager (  )  . getDocument ( DomUtil . getFile ( domElement )  )  )  ;", "}", "METHOD_END"], "methodName": ["addWatchedElement"], "fileName": "com.intellij.util.xml.ui.PerspectiveFileEditor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( myInvalidated )  )     &  &     (  !  ( isValid (  )  )  )  )     {", "myInvalidated    =    true ;", "myPropertyChangeSupport . firePropertyChange ( PROP _ VALID ,    Boolean . TRUE ,    Boolean . FALSE )  ;", "}", "return    !  ( myInvalidated )  ;", "}", "METHOD_END"], "methodName": ["checkIsValid"], "fileName": "com.intellij.util.xml.ui.PerspectiveFileEditor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( isInitialised (  )  )  )     &  &     (  !  ( myInitializing )  )  )     {", "myInitializing    =    true ;", "JComponent   ponent    =    createCustomComponent (  )  ;", "myWrapper . setContent ( ponent )  ;", "myInitialised    =    true ;", "}", "}", "METHOD_END"], "methodName": ["ensureInitialized"], "fileName": "com.intellij.util.xml.ui.PerspectiveFileEditor"}, {"methodBody": ["METHOD_START", "{", "return   PsiDocumentManager . getInstance ( myProject )  ;", "}", "METHOD_END"], "methodName": ["getDocumentManager"], "fileName": "com.intellij.util.xml.ui.PerspectiveFileEditor"}, {"methodBody": ["METHOD_START", "{", "return   myProject ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "com.intellij.util.xml.ui.PerspectiveFileEditor"}, {"methodBody": ["METHOD_START", "{", "return   PsiManager . getInstance ( myProject )  . findFile ( myFile )  ;", "}", "METHOD_END"], "methodName": ["getPsiFile"], "fileName": "com.intellij.util.xml.ui.PerspectiveFileEditor"}, {"methodBody": ["METHOD_START", "{", "final   PsiFile   psiFile    =    getPsiFile (  )  ;", "if    ( psiFile    =  =    null )", "return   null ;", "final   PsiElement   psiElement    =    psiFile . findElementAt ( text . get (  )  . getCaretModel (  )  . getOffset (  )  )  ;", "if    ( psiElement    =  =    null )", "return   null ;", "final   XmlTag   xmlTag    =    PsiTreeUtil . getParentOfType ( psiElement ,    XmlTag . class )  ;", "return   DomManager . getDomManager ( myProject )  . getDomElement ( xmlTag )  ;", "}", "METHOD_END"], "methodName": ["getSelectedDomElementFromTextEditor"], "fileName": "com.intellij.util.xml.ui.PerspectiveFileEditor"}, {"methodBody": ["METHOD_START", "{", "return   myFile ;", "}", "METHOD_END"], "methodName": ["getVirtualFile"], "fileName": "com.intellij.util.xml.ui.PerspectiveFileEditor"}, {"methodBody": ["METHOD_START", "{", "return   myWrapper ;", "}", "METHOD_END"], "methodName": ["getWrapper"], "fileName": "com.intellij.util.xml.ui.PerspectiveFileEditor"}, {"methodBody": ["METHOD_START", "{", "return   myInitialised ;", "}", "METHOD_END"], "methodName": ["isInitialised"], "fileName": "com.intellij.util.xml.ui.PerspectiveFileEditor"}, {"methodBody": ["METHOD_START", "{", "myUndoHelper . removeWatchedDocument ( document )  ;", "}", "METHOD_END"], "methodName": ["removeWatchedDocument"], "fileName": "com.intellij.util.xml.ui.PerspectiveFileEditor"}, {"methodBody": ["METHOD_START", "{", "removeWatchedDocument ( getDocumentManager (  )  . getDocument ( DomUtil . getFile ( domElement )  )  )  ;", "}", "METHOD_END"], "methodName": ["removeWatchedElement"], "fileName": "com.intellij.util.xml.ui.PerspectiveFileEditor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( element    !  =    null )     &  &     ( element . isValid (  )  )  )     {", "final   XmlTag   tag    =    element . getXmlTag (  )  ;", "if    ( tag    =  =    null )", "return ;", "final   PsiFile   file    =    tag . getContainingFile (  )  ;", "if    ( file    =  =    null )", "return ;", "final   Document   document    =    getDocumentManager (  )  . getDocument ( file )  ;", "if    (  ( document    =  =    null )     |  |     (  !  ( document . equals ( text . get (  )  . getDocument (  )  )  )  )  )", "return ;", "text . get (  )  . getCaretModel (  )  . moveToOffset ( tag . getTextOffset (  )  )  ;", "text . get (  )  . getScrollingModel (  )  . scrollToCaret ( CENTER )  ;", "}", "}", "METHOD_END"], "methodName": ["setSelectionInTextEditor"], "fileName": "com.intellij.util.xml.ui.PerspectiveFileEditor"}, {"methodBody": ["METHOD_START", "{", "myUndoHelper . setShowing ( b )  ;", "}", "METHOD_END"], "methodName": ["setShowing"], "fileName": "com.intellij.util.xml.ui.PerspectiveFileEditor"}, {"methodBody": ["METHOD_START", "{", "return   getClass (  )  . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getComponentName"], "fileName": "com.intellij.util.xml.ui.PerspectiveFileEditorProvider"}, {"methodBody": ["METHOD_START", "{", "return   new   Color ( Math . max (  (  ( int )     (  ( color . getRed (  )  )     *     ( StripeTableCellRenderer . FACTOR )  )  )  ,     0  )  ,    Math . max (  (  ( int )     (  ( color . getGreen (  )  )     *     ( StripeTableCellRenderer . FACTOR )  )  )  ,     0  )  ,    Math . max (  (  ( int )     (  ( color . getBlue (  )  )     *     ( StripeTableCellRenderer . FACTOR )  )  )  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["darken"], "fileName": "com.intellij.util.xml.ui.StripeTableCellRenderer"}, {"methodBody": ["METHOD_START", "{", "return   myRenderer ;", "}", "METHOD_END"], "methodName": ["getRenderer"], "fileName": "com.intellij.util.xml.ui.StripeTableCellRenderer"}, {"methodBody": ["METHOD_START", "{", "editor . setVerticalScrollbarVisible ( true )  ;", "final   JArea   area    =    new   JArea (  1  0  ,     5  0  )  ;", "area . setRows ( rowCount )  ;", "editor . getComponent (  )  . setPreferredSize ( area . getPreferredSize (  )  )  ;", "return   editor ;", "}", "METHOD_END"], "methodName": ["makeBigEditor"], "fileName": "com.intellij.util.xml.ui.TextControl"}, {"methodBody": ["METHOD_START", "{", "String [  ]    messages    =    new   String [ problems . size (  )  ]  ;", "for    (    i    =     0  ;    i    <     ( problems . size (  )  )  ;    i +  +  )     {", "messages [ i ]     =    problems . get ( i )  . getDescriptionTemplate (  )  ;", "}", "return   messages ;", "}", "METHOD_END"], "methodName": ["getMessages"], "fileName": "com.intellij.util.xml.ui.TooltipUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( messages . length )     =  =     0  )", "return   null ;", "StringBuilder   text    =    new   StringBuilder (  \"  < html >  < body >  < table >  < tr >  < td >  & nbsp ;  <  / td >  < td >  \"  )  ;", "int   len    =     (  ( messages . length )     >     1  0  )     ?     1  0     :    messages . length ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "if    ( i    !  =     0  )     {", "text . append (  . MESSAGE _ DELIMITER )  ;", "}", "text . append ( messages [ i ]  )  ;", "}", "if    (  ( messages . length )     >     1  0  )     {", "text . append (  . MESSAGE _ DELIMITER )  ;", "text . append (  \"  .  .  .  \"  )  ;", "}", "text . append (  \"  <  / td >  < td >  & nbsp ;  <  / td >  <  / tr >  <  / table >  <  / body >  <  / html >  \"  )  ;", "return   text . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getTooltipText"], "fileName": "com.intellij.util.xml.ui.TooltipUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( annotations . size (  )  )     =  =     0  )", "return   null ;", "return    . getTooltipText (  . getMessages ( annotations )  )  ;", "}", "METHOD_END"], "methodName": ["getTooltipText"], "fileName": "com.intellij.util.xml.ui.TooltipUtils"}, {"methodBody": ["METHOD_START", "{", "return   TooltipUtils . getTooltipText ( ArrayUtil . mergeArrays ( TooltipUtils . getMessages ( annotations )  ,    messages )  )  ;", "}", "METHOD_END"], "methodName": ["getTooltipText"], "fileName": "com.intellij.util.xml.ui.TooltipUtils"}, {"methodBody": ["METHOD_START", "{", "stopListeningDocuments (  )  ;", "myCurrentDocuments . add ( document )  ;", "startListeningDocuments (  )  ;", "}", "METHOD_END"], "methodName": ["addWatchedDocument"], "fileName": "com.intellij.util.xml.ui.UndoHelper"}, {"methodBody": ["METHOD_START", "{", "return   myCurrentDocuments . toArray ( EMPTY _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["getDocuments"], "fileName": "com.intellij.util.xml.ui.UndoHelper"}, {"methodBody": ["METHOD_START", "{", "return   myShowing ;", "}", "METHOD_END"], "methodName": ["isShowing"], "fileName": "com.intellij.util.xml.ui.UndoHelper"}, {"methodBody": ["METHOD_START", "{", "stopListeningDocuments (  )  ;", "myCurrentDocuments . remove ( document )  ;", "startListeningDocuments (  )  ;", "}", "METHOD_END"], "methodName": ["removeWatchedDocument"], "fileName": "com.intellij.util.xml.ui.UndoHelper"}, {"methodBody": ["METHOD_START", "{", "myShowing    =    showing ;", "}", "METHOD_END"], "methodName": ["setShowing"], "fileName": "com.intellij.util.xml.ui.UndoHelper"}, {"methodBody": ["METHOD_START", "{", "for    ( final   Document   document    :    myCurrentDocuments )     {", "document . addDocumentListener ( myDocumentAdapter )  ;", "}", "}", "METHOD_END"], "methodName": ["startListeningDocuments"], "fileName": "com.intellij.util.xml.ui.UndoHelper"}, {"methodBody": ["METHOD_START", "{", "for    ( final   Document   document    :    myCurrentDocuments )     {", "document . removeDocumentListener ( myDocumentAdapter )  ;", "}", "}", "METHOD_END"], "methodName": ["stopListeningDocuments"], "fileName": "com.intellij.util.xml.ui.UndoHelper"}, {"methodBody": ["METHOD_START", "{", "return   myComponent ;", "}", "METHOD_END"], "methodName": ["getComponent"], "fileName": "com.intellij.util.xml.ui.Warning"}, {"methodBody": ["METHOD_START", "{", "return   myWarning ;", "}", "METHOD_END"], "methodName": ["getWarning"], "fileName": "com.intellij.util.xml.ui.Warning"}, {"methodBody": ["METHOD_START", "{", "return   getWarning (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.intellij.util.xml.ui.Warning"}, {"methodBody": ["METHOD_START", "{", "return   e . getPresentation (  )  . getText (  )  ;", "}", "METHOD_END"], "methodName": ["getActionText"], "fileName": "com.intellij.util.xml.ui.actions.AddDomElementAction"}, {"methodBody": ["METHOD_START", "{", "Project   project    =     ( e    =  =    null )     ?    null    :    e . getProject (  )  ;", "if    ( project    =  =    null )", "return   AnAction . EMPTY _ ARRAY ;", "DomCollectionChildDescription [  ]    descriptions    =    getDomCollectionChildDescriptions ( e )  ;", "final   List < AnAction >    actions    =    new   ArrayList <  >  (  )  ;", "for    ( DomCollectionChildDescription   description    :    descriptions )     {", "final   TypeChooser   chooser    =    DomManager . getDomManager ( project )  . getTypeChooserManager (  )  . getTypeChooser ( description . getType (  )  )  ;", "for    ( Type   type    :    chooser . getChooserTypes (  )  )     {", "final   Class <  ?  >    rawType    =    ReflectionUtil . getRawType ( type )  ;", "String   name    =    TypePresentationService . getService (  )  . getTypePresentableName ( rawType )  ;", "Icon   icon    =    null ;", "if    (  (  !  ( showAsPopup (  )  )  )     |  |     (  ( descriptions . length )     =  =     1  )  )     {", "icon    =    ElementPresentationManager . getIconForClass ( rawType )  ;", "}", "actions . add ( createAddingAction ( e ,     (  (  ( ApplicationBundle . message (  \" action . add \"  )  )     +     \"     \"  )     +    name )  ,    icon ,    type ,    description )  )  ;", "}", "}", "if    (  (  ( actions . size (  )  )     >     1  )     &  &     ( showAsPopup (  )  )  )     {", "ActionGroup   group    =    new   ActionGroup (  )     {", "@ Override", "@ NotNull", "public   AnAction [  ]    getChildren (  @ Nullable", "AnActionEvent   e )     {", "return   actions . toArray ( EMPTY _ ARRAY )  ;", "}", "}  ;", "return   new   AnAction [  ]  {    new    . ShowPopupAction ( group )     }  ;", "} else    {", "if    (  ( actions . size (  )  )     >     1  )     {", "actions . add ( Separator . getInstance (  )  )  ;", "} else", "if    (  ( actions . size (  )  )     =  =     1  )     {", "}", "}", "return   actions . toArray ( EMPTY _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["getChildren"], "fileName": "com.intellij.util.xml.ui.actions.AddDomElementAction"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isEnabled"], "fileName": "com.intellij.util.xml.ui.actions.AddDomElementAction"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["showAsPopup"], "fileName": "com.intellij.util.xml.ui.actions.AddDomElementAction"}, {"methodBody": ["METHOD_START", "{", "final   Component   component    =    e . getInputEvent (  )  . getComponent (  )  ;", "if    ( component   instanceof   ButtonComponent )     {", "groupPopup . showUnderneathOf ( component )  ;", "} else    {", "groupPopup . showInBestPositionFor ( e . getDataContext (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["showPopup"], "fileName": "com.intellij.util.xml.ui.actions.AddDomElementAction"}, {"methodBody": ["METHOD_START", "{", "return   getDomCollectionChildDescription (  )  . getType (  )  ;", "}", "METHOD_END"], "methodName": ["getElementType"], "fileName": "com.intellij.util.xml.ui.actions.DefaultAddAction"}, {"methodBody": ["METHOD_START", "{", "final   DomElement   parent    =    getParentDomElement (  )  ;", "final   DomManager   domManager    =    parent . getManager (  )  ;", "final   TypeChooser [  ]    oldChoosers    =    new   TypeChooser [  ]  {    null    }  ;", "final   Type [  ]    aClass    =    new   Type [  ]  {    null    }  ;", "final   StableElement < T >    result    =    WriteComman . writeComman ( domManager . getProject (  )  ,    DomUtil . getFile ( parent )  )  . compute (  (  )     -  >     {", "final   DomElement   parentDomElement    =    getParentDomElement (  )  ;", "final   T   t    =     (  ( T )     ( getDomCollectionChildDescription (  )  . addValue ( parentDomElement ,    getElementType (  )  )  )  )  ;", "tuneNewValue ( t )  ;", "aClass [  0  ]     =    parent . getGenericInfo (  )  . getCollectionChildDescription ( t . getXmlElementName (  )  )  . getType (  )  ;", "oldChoosers [  0  ]     =    domManager . getTypeChooserManager (  )  . getTypeChooser ( aClass [  0  ]  )  ;", "final   SmartPsiElementPointer   pointer    =    SmartPointerManager . getInstance ( domManager . getProject (  )  )  . createSmartPsiElementPointer ( t . getXmlTag (  )  )  ;", "domManager . getTypeChooserManager (  )  . registerTypeChooser ( aClass [  0  ]  ,    new   TypeChooser (  )     {", "@ Override", "public   Type   chooseType ( final   XmlTag   tag )     {", "if    ( tag    =  =     ( pointer . getElement (  )  )  )     {", "return   getElementType (  )  ;", "}", "return   oldChoosers [  0  ]  . chooseType ( tag )  ;", "}", "@ Override", "public   void   distinguishTag ( final   XmlTag   tag ,    final   Type   aClass )    throws   IncorrectOperationException    {", "oldChoosers [  0  ]  . distinguishTag ( tag ,    aClass )  ;", "}", "@ Override", "public   Type [  ]    getChooserTypes (  )     {", "return   oldChoosers [  0  ]  . getChooserTypes (  )  ;", "}", "}  )  ;", "return    (  ( StableElement < T >  )     ( t . createStableCopy (  )  )  )  ;", "}  )  ;", "if    ( result    !  =    null )     {", "domManager . getTypeChooserManager (  )  . registerTypeChooser ( aClass [  0  ]  ,    oldChoosers [  0  ]  )  ;", "return   result . getWrappedElement (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["performElementAddition"], "fileName": "com.intellij.util.xml.ui.actions.DefaultAddAction"}, {"methodBody": ["METHOD_START", "{", "return   DomUtil . getContextElement ( editor ,    myContextClass )  ;", "}", "METHOD_END"], "methodName": ["getContextElement"], "fileName": "com.intellij.util.xml.ui.actions.generate.CreateDomElementAction"}, {"methodBody": ["METHOD_START", "{", "element . setStringValue (  \"  \"  )  ;", "Xml   xml    =    element . getXml (  )  ;", "builder . replace ( xml ,    Manipulators . getValueTextRange ( xml )  ,    expression )  ;", "}", "METHOD_END"], "methodName": ["replaceElementValue"], "fileName": "com.intellij.util.xml.ui.actions.generate.CreateDomElementAction"}, {"methodBody": ["METHOD_START", "{", "return   myProvider ;", "}", "METHOD_END"], "methodName": ["getProvider"], "fileName": "com.intellij.util.xml.ui.actions.generate.GenerateDomElementAction"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["startInWriteAction"], "fileName": "com.intellij.util.xml.ui.actions.generate.GenerateDomElementAction"}, {"methodBody": ["METHOD_START", "{", "navigateProvider . navigate ( copy ,    true )  ;", "}", "METHOD_END"], "methodName": ["doNavigate"], "fileName": "com.intellij.util.xml.ui.actions.generate.GenerateDomElementProvider"}, {"methodBody": ["METHOD_START", "{", "return    ( myDescription )     =  =    null    ?     \"  \"     :    myDescription ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "com.intellij.util.xml.ui.actions.generate.GenerateDomElementProvider"}, {"methodBody": ["METHOD_START", "{", "return   DomElementsNavigationManager . getManager ( project )  . getDomElementsNavigateProvider ( DomElementsNavigationManager . DEFAULT _ PROVIDER _ NAME )  ;", "}", "METHOD_END"], "methodName": ["getNavigationProviderName"], "fileName": "com.intellij.util.xml.ui.actions.generate.GenerateDomElementProvider"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isAvailableForElement"], "fileName": "com.intellij.util.xml.ui.actions.generate.GenerateDomElementProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  ( element    !  =    null )     &  &     ( element . isValid (  )  )  )     {", "final   DomElement   copy    =    element . createStableCopy (  )  ;", "final   Project   project    =    element . getManager (  )  . getProject (  )  ;", "final   DomElementNavigationProvider   navigateProvider    =     . getNavigationProviderName ( project )  ;", "if    (  ( navigateProvider    !  =    null )     &  &     ( navigateProvider . canNavigate ( copy )  )  )     {", "ApplicationManager . getApplication (  )  . invokeLater (  (  )     -  >     {", "if    (  !  ( project . isDisposed (  )  )  )     {", "doNavigate ( navigateProvider ,    copy )  ;", "}", "}  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["navigate"], "fileName": "com.intellij.util.xml.ui.actions.generate.GenerateDomElementProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( tagName    =  =    null )     {", "return   namespaces ;", "}", "final   HashSet < String >    set    =    new   HashSet <  >  (  )  ;", "for    ( String   namespace    :    namespaces )     {", "final   XmlFile   xmlFile    =    XmlUtil . findNamespace ( context ,    namespace )  ;", "if    ( xmlFile    !  =    null )     {", "final   XmlDocument   document    =    xmlFile . getDocument (  )  ;", "assert   document    !  =    null ;", "final   XmlNSDescriptor   nsDescriptor    =     (  ( XmlNSDescriptor )     ( document . getMetaData (  )  )  )  ;", "assert   nsDescriptor    !  =    null ;", "final   XmlElementDescriptor [  ]    elementDescriptors    =    nsDescriptor . getRootElementsDescriptors ( document )  ;", "for    ( XmlElementDescriptor   elementDescriptor    :    elementDescriptors )     {", ". LOG . assertTrue (  ( elementDescriptor    !  =    null )  ,     (  \" Null   returned   from    \"     +    nsDescriptor )  )  ;", "if    (  . hasTag ( elementDescriptor ,    tagName ,    new   HashSet <  >  (  )  )  )     {", "set . add ( namespace )  ;", "break ;", "}", "}", "}", "}", "return   set ;", "}", "METHOD_END"], "methodName": ["filterNamespaces"], "fileName": "com.intellij.xml.DefaultXmlExtension"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    elementDescriptor . getDefaultName (  )  ;", "if    ( name    =  =    null )     {", ". LOG . error (  ( elementDescriptor    +     \"    returned   null   as   default   name \"  )  )  ;", "return   false ;", "}", "if    ( name . equals ( tagName )  )     {", "return   true ;", "}", "for    ( XmlElementDescriptor   descriptor    :    elementDescriptor . getElementsDescriptors ( null )  )     {", "if    (  !  ( visited . contains ( elementDescriptor )  )  )     {", "visited . add ( elementDescriptor )  ;", "if    (  . hasTag ( descriptor ,    tagName ,    visited )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasTag"], "fileName": "com.intellij.xml.DefaultXmlExtension"}, {"methodBody": ["METHOD_START", "{", "final   XmlAttribute [  ]    attributes    =    rootTag . getAttributes (  )  ;", "XmlAttribute   anchor    =    null ;", "for    ( XmlAttribute   attribute    :    attributes )     {", "final   XmlAttributeDescriptor   descriptor    =    attribute . getDescriptor (  )  ;", "if    (  ( attribute . isDeclaration (  )  )     |  |     (  ( descriptor    !  =    null )     &  &     ( descriptor . isRequired (  )  )  )  )     {", "anchor    =    attribute ;", "} else    {", "break ;", "}", "}", "return   anchor ;", "}", "METHOD_END"], "methodName": ["getAnchor"], "fileName": "com.intellij.xml.DefaultXmlNamespaceHelper"}, {"methodBody": ["METHOD_START", "{", "String   location    =    null ;", "if    (  ( n . length (  )  )     >     0  )     {", "for    ( XmlSchemaProvider   provider    :    providers )     {", "Set < String >    locations    =    provider . getLocations ( n ,    file )  ;", "if    (  ( locations    !  =    null )     &  &     (  !  ( locations . isEmpty (  )  )  )  )     {", "location    =    locations . iterator (  )  . next (  )  ;", "}", "}", "}", "return   location ;", "}", "METHOD_END"], "methodName": ["getLocation"], "fileName": "com.intellij.xml.DefaultXmlNamespaceHelper"}, {"methodBody": ["METHOD_START", "{", "String   prefix    =    nsPrefix ;", "if    ( prefix    =  =    null )     {", "for    ( XmlSchemaProvider   provider    :    providers )     {", "prefix    =    provider . getDefaultPrefix ( n ,    file )  ;", "if    ( prefix    !  =    null )     {", "break ;", "}", "}", "}", "if    ( prefix    =  =    null )     {", "prefix    =     \"  \"  ;", "}", "return   prefix ;", "}", "METHOD_END"], "methodName": ["getPrefix"], "fileName": "com.intellij.xml.DefaultXmlNamespaceHelper"}, {"methodBody": ["METHOD_START", "{", "final   Project   project    =    file . getProject (  )  ;", "final   Collection < VirtualFile >    files    =    XmlTagNamesIndex . getFilesByTagName ( tagName ,    project )  ;", "final   Set < String >    possibleUris    =    new   LinkedHashSet ( files . size (  )  )  ;", "for    ( VirtualFile   virtualFile    :    files )     {", "final   String   namespace    =    Index . getNamespace ( virtualFile ,    project ,    file )  ;", "if    ( namespace    !  =    null )     {", "possibleUris . add ( namespace )  ;", "}", "}", "return   possibleUris ;", "}", "METHOD_END"], "methodName": ["guessNamespace"], "fileName": "com.intellij.xml.DefaultXmlNamespaceHelper"}, {"methodBody": ["METHOD_START", "{", "if    ( Html 5 SchemaProvider . ourInitialized )", "return ;", "Html 5 SchemaProvider . ourInitialized    =    true ;", "final   Html 5 SchemaProvider [  ]    providers    =    Html 5 SchemaProvider . EP _ NAME . getExtensions (  )  ;", "final   URL   htmlSchemaLocationURL ;", "final   URL   xhtmlSchemaLocationURL ;", "final   URL   dtdCharsLocationURL ;", "if    (  ( providers . length )     >     1  )     {", "Html 5 SchemaProvider . LOG . error (  (  \" More   than   one   HTML 5    schema   providers   found :     \"     +     ( Html 5 SchemaProvider . getClassesListString ( providers )  )  )  )  ;", "}", "if    (  ( providers . length )     >     0  )     {", "htmlSchemaLocationURL    =    providers [  0  ]  . getHtmlSchemaLocation (  )  ;", "xhtmlSchemaLocationURL    =    providers [  0  ]  . getXhtmlSchemaLocation (  )  ;", "dtdCharsLocationURL    =    providers [  0  ]  . getCharsLocation (  )  ;", "} else    {", "Html 5 SchemaProvider . LOG . info (  \" RelaxNG   based   schema   for   HTML 5    is   not   supported .    Old   XSD   schema   will   be   used \"  )  ;", "htmlSchemaLocationURL    =    Html 5 SchemaProvider . class . getResource (  (  ( ExternalResourceManagerEx . STANDARD _ SCHEMAS )     +     \" html 5  / xhtml 5  . xsd \"  )  )  ;", "xhtmlSchemaLocationURL    =    htmlSchemaLocationURL ;", "dtdCharsLocationURL    =    htmlSchemaLocationURL ;", "}", "Html 5 SchemaProvider . HTML 5  _ SCHEMA _ LOCATION    =    VfsUtilCore . urlToPath ( VfsUtilCore . fixURLforIDEA ( URLUtil . unescapePercentSequences ( htmlSchemaLocationURL . toExternalForm (  )  )  )  )  ;", "Html 5 SchemaProvider . LOG . info (  (  \" HTML 5  _ SCHEMA _ LOCATION    =     \"     +     ( Html 5 SchemaProvider . getHtml 5 SchemaLocation (  )  )  )  )  ;", "Html 5 SchemaProvider . XHTML 5  _ SCHEMA _ LOCATION    =    VfsUtilCore . urlToPath ( VfsUtilCore . fixURLforIDEA ( URLUtil . unescapePercentSequences ( xhtmlSchemaLocationURL . toExternalForm (  )  )  )  )  ;", "Html 5 SchemaProvider . LOG . info (  (  \" XHTML 5  _ SCHEMA _ LOCATION    =     \"     +     ( Html 5 SchemaProvider . getXhtml 5 SchemaLocation (  )  )  )  )  ;", "Html 5 SchemaProvider . CHARS _ DTD _ LOCATION    =    VfsUtilCore . urlToPath ( VfsUtilCore . fixURLforIDEA ( URLUtil . unescapePercentSequences ( dtdCharsLocationURL . toExternalForm (  )  )  )  )  ;", "Html 5 SchemaProvider . LOG . info (  (  \" CHARS _ DTD _ LOCATION    =     \"     +     ( Html 5 SchemaProvider . getCharsDtdLocation (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["ensureInitialized"], "fileName": "com.intellij.xml.Html5SchemaProvider"}, {"methodBody": ["METHOD_START", "{", "Html 5 SchemaProvider . ensureInitialized (  )  ;", "return   Html 5 SchemaProvider . CHARS _ DTD _ LOCATION ;", "}", "METHOD_END"], "methodName": ["getCharsDtdLocation"], "fileName": "com.intellij.xml.Html5SchemaProvider"}, {"methodBody": ["METHOD_START", "{", "final   StringBuilder   builder    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ,    n    =    a . length ;    i    <    n ;    i +  +  )     {", "T   element    =    a [ i ]  ;", "builder . append (  ( element    !  =    null    ?    element . getClass (  )  . getName (  )     :     \" NULL \"  )  )  ;", "if    ( i    <     ( n    -     1  )  )     {", "builder . append (  \"  ,     \"  )  ;", "}", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getClassesListString"], "fileName": "com.intellij.xml.Html5SchemaProvider"}, {"methodBody": ["METHOD_START", "{", "Html 5 SchemaProvider . ensureInitialized (  )  ;", "return   Html 5 SchemaProvider . HTML 5  _ SCHEMA _ LOCATION ;", "}", "METHOD_END"], "methodName": ["getHtml5SchemaLocation"], "fileName": "com.intellij.xml.Html5SchemaProvider"}, {"methodBody": ["METHOD_START", "{", "Html 5 SchemaProvider . ensureInitialized (  )  ;", "return   Html 5 SchemaProvider . XHTML 5  _ SCHEMA _ LOCATION ;", "}", "METHOD_END"], "methodName": ["getXhtml5SchemaLocation"], "fileName": "com.intellij.xml.Html5SchemaProvider"}, {"methodBody": ["METHOD_START", "{", "return   new   XMLCatalogManager (  (  ( getTestDataPath (  )  )     +     \" catalog . properties \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getManager"], "fileName": "com.intellij.xml.XMLCatalogManagerTest"}, {"methodBody": ["METHOD_START", "{", "XMLCatalogManager   manager    =    getManager (  )  ;", "CatalogManager   catalogManager    =    manager . getManager (  )  ;", "Vector   files    =    catalogManager . getCatalogFiles (  )  ;", "assertEquals (  1  ,    files . size (  )  )  ;", "String   filePath    =     (  ( String )     ( files . get (  0  )  )  )  ;", "assertTrue ( filePath ,    filePath . endsWith (  \" catalog . xml \"  )  )  ;", "assertTrue ( filePath ,    new   File ( new   URI ( filePath )  )  . exists (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCatalogManager"], "fileName": "com.intellij.xml.XMLCatalogManagerTest"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( new   XMLCatalogConfigurable (  )  . isModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConfigurable"], "fileName": "com.intellij.xml.XMLCatalogManagerTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  \" policy . xml \"  )  ;", "try    {", "ExternalResourceManagerEx . getInstanceEx (  )  . setPropertiesFile (  (  ( getTestDataPath (  )  )     +     \" catalog . properties \"  )  )  ;", "myFixture . checkHighlighting (  )  ;", "}    finally    {", "ExternalResourceManagerEx . getInstanceEx (  )  . setPropertiesFile ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["testFixedHighlighting"], "fileName": "com.intellij.xml.XMLCatalogManagerTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  \" policy . xml \"  )  ;", "List < HighlightInfo >    infos    =    myFixture . doHighlighting (  )  ;", "assertSize (  2  7  ,    infos )  ;", "String   expectedUrn    =     \" urn : oasis : names : tc : xacml :  1  .  0  : policy \"  ;", "boolean   hasUrn    =    false ;", "for    ( HighlightInfo   info    :    infos )     {", "String   text    =    info . getText (  )  ;", "assertOneOf ( text ,     \" x \"  ,    expectedUrn )  ;", "hasUrn    |  =    expectedUrn . equals ( text )  ;", "}", "assertTrue ( hasUrn )  ;", "}", "METHOD_END"], "methodName": ["testHighlighting"], "fileName": "com.intellij.xml.XMLCatalogManagerTest"}, {"methodBody": ["METHOD_START", "{", "String   resolve    =    getManager (  )  . resolve (  \"  -  /  / W 3 C /  / DTD   XHTML    1  .  0    Strict /  / EN \"  )  ;", "assertNotNull ( resolve )  ;", "assertTrue ( resolve ,    resolve . endsWith (  \"  / catalog / xhtml 1  - strict . dtd \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testResolvePublic"], "fileName": "com.intellij.xml.XMLCatalogManagerTest"}, {"methodBody": ["METHOD_START", "{", "String   resolve    =    getManager (  )  . resolve (  \" http :  /  / www . w 3  . org / TR / xhtml 1  / DTD / xhtml 1  - strict . dtd \"  )  ;", "assertNotNull ( resolve )  ;", "assertTrue ( resolve ,    resolve . endsWith (  \"  / catalog / xhtml 1  - strict . dtd \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testResolveSystem"], "fileName": "com.intellij.xml.XMLCatalogManagerTest"}, {"methodBody": ["METHOD_START", "{", "ResourceBundle   bundle    =    SoftReference . dereference ( XmlBundle . ourBundle )  ;", "if    ( bundle    =  =    null )     {", "bundle    =    ResourceBundle . getBundle ( XmlBundle . PATH _ TO _ BUNDLE )  ;", "XmlBundle . ourBundle    =    new   SoftReference <  >  ( bundle )  ;", "}", "return   bundle ;", "}", "METHOD_END"], "methodName": ["getBundle"], "fileName": "com.intellij.xml.XmlBundle"}, {"methodBody": ["METHOD_START", "{", "return   CommonBundle . message ( XmlBundle . getBundle (  )  ,    key ,    params )  ;", "}", "METHOD_END"], "methodName": ["message"], "fileName": "com.intellij.xml.XmlBundle"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFiles ( files )  ;", "Tag   tag    =     (  ( File )     ( getFile (  )  )  )  . getRootTag (  )  ;", "assertNotNull ( tag )  ;", "ElementDescriptor   descriptor    =    tag . getDescriptor (  )  ;", "assertNotNull ( descriptor )  ;", "ElementDescriptor [  ]    descriptors    =    descriptor . getElementsDescriptors ( tag )  ;", "Map < String ,    ElementDescriptor >    map    =    ContainerUtil . newMapFromValues ( Arrays . asList ( descriptors )  . iterator (  )  ,     (    o )     -  >    o . getName (  )  )  ;", "map . put ( tag . getName (  )  ,    tag . getDescriptor (  )  )  ;", "return   map ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "com.intellij.xml.XmlConstraintsTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFiles ( files )  ;", "XmlFile   file    =     (  ( XmlFile )     ( myFixture . getFile (  )  )  )  ;", "ValidateXmlActionHandler   handler    =    new   ValidateXmlActionHandler ( false )     {", "@ Override", "protected   SAXParser   createParser (  )    throws   ParserConfigurationException ,    SAXException    {", "SAXParser   parser    =    super . createParser (  )  ;", "parser . getXMLReader (  )  . setFeature (  (  ( ants . XERCES _ FEATURE _ PREFIX )     +     ( ants . CONTINUE _ AFTER _ FATAL _ ERROR _ FEATURE )  )  ,    true )  ;", "return   parser ;", "}", "}  ;", "handler . setErrorReporter ( new   TestErrorReporter ( handler )  )  ;", "handler . doValidate ( file )  ;", "XMLGrammarPool   grammarPool    =    ValidateXmlActionHandler . getGrammarPool ( file )  ;", "assert   grammarPool    !  =    null ;", "Grammar [  ]    grammars    =    grammarPool . retrieveInitialGrammarSet ( XML _ SCHEMA )  ;", "XSGrammar   grammar    =     (  ( XSGrammar )     ( grammars [  0  ]  )  )  ;", "return   grammar . toXSModel (  )  ;", "}", "METHOD_END"], "methodName": ["getXSModel"], "fileName": "com.intellij.xml.XmlConstraintsTest"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    XmlElementDescriptor >    map    =    configure (  \" testDtd . xml \"  )  ;", "XmlElementDescriptor   a    =    map . get (  \" a \"  )  ;", "XmlElementDescriptor   b    =    map . get (  \" b \"  )  ;", "XmlElementDescriptor   c    =    map . get (  \" c \"  )  ;", "XmlElementDescriptor   d    =    map . get (  \" d \"  )  ;", "XmlElementDescriptor   e    =    map . get (  \" e \"  )  ;", "}", "METHOD_END"], "methodName": ["testDtdConstraints"], "fileName": "com.intellij.xml.XmlConstraintsTest"}, {"methodBody": ["METHOD_START", "{", "XSModel   xsModel    =    getXSModel (  \" testCompletion . xml \"  ,     \" test . xsd \"  )  ;", "PsiElement   element    =    myFixture . getFile (  )  . findElementAt ( getEditor (  )  . getCaretModel (  )  . getOffset (  )  )  ;", "XmlTag   tag    =    PsiTreeUtil . getParentOfType ( element ,    XmlTag . class )  ;", "assert   tag    !  =    null ;", "XSElementDeclaration   elementDeclaration    =    xsModel . getElementDeclaration ( tag . getLocalName (  )  ,    tag . getNamespace (  )  )  ;", "XSComplexTypeDefinition   typeDefinition    =     (  ( XSComplexTypeDefinition )     ( elementDeclaration . getTypeDefinition (  )  )  )  ;", "CMBuilder   cmBuilder    =    new   CMBuilder ( new   CMNodeFactory (  )  )  ;", "XSCMValidator   validator    =    cmBuilder . getContentModel (  (  ( XSComplexTypeDecl )     ( typeDefinition )  )  ,    true )  ;", "int [  ]    ints    =    validator . startContentModel (  )  ;", "Vector   vector    =    validator . whatCanGoHere ( ints )  ;", "XSElementDecl   o    =     (  ( XSElementDecl )     ( vector . get (  0  )  )  )  ;", "assertEquals (  \" b \"  ,    o . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testXercesForCompletion"], "fileName": "com.intellij.xml.XmlConstraintsTest"}, {"methodBody": ["METHOD_START", "{", "XSModel   xsModel    =    getXSModel (  \" test . xml \"  ,     \" test . xsd \"  )  ;", "XSElementDeclaration   elementDeclaration    =    xsModel . getElementDeclaration (  \" a \"  ,     \"  \"  )  ;", "XSComplexTypeDefinition   typeDefinition    =     (  ( XSComplexTypeDefinition )     ( elementDeclaration . getTypeDefinition (  )  )  )  ;", "CMBuilder   cmBuilder    =    new   CMBuilder ( new   CMNodeFactory (  )  )  ;", "XSCMValidator   validator    =    cmBuilder . getContentModel (  (  ( XSComplexTypeDecl )     ( typeDefinition )  )  ,    true )  ;", "int [  ]    ints    =    validator . startContentModel (  )  ;", "Vector   vector    =    validator . whatCanGoHere ( ints )  ;", "XSElementDecl   o    =     (  ( XSElementDecl )     ( vector . get (  0  )  )  )  ;", "assertEquals (  \" b \"  ,    o . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testXercesGrammar"], "fileName": "com.intellij.xml.XmlConstraintsTest"}, {"methodBody": ["METHOD_START", "{", "XSModel   xsModel    =    getXSModel (  \" testIncomplete . xml \"  ,     \" test . xsd \"  )  ;", "XSElementDeclaration   elementDeclaration    =    xsModel . getElementDeclaration (  \" a \"  ,     \"  \"  )  ;", "XSComplexTypeDefinition   typeDefinition    =     (  ( XSComplexTypeDefinition )     ( elementDeclaration . getTypeDefinition (  )  )  )  ;", "CMBuilder   cmBuilder    =    new   CMBuilder ( new   CMNodeFactory (  )  )  ;", "XSCMValidator   validator    =    cmBuilder . getContentModel (  (  ( XSComplexTypeDecl )     ( typeDefinition )  )  ,    true )  ;", "int [  ]    ints    =    validator . startContentModel (  )  ;", "Vector   vector    =    validator . whatCanGoHere ( ints )  ;", "XSElementDecl   o    =     (  ( XSElementDecl )     ( vector . get (  0  )  )  )  ;", "assertEquals (  \" b \"  ,    o . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testXercesIncomplete"], "fileName": "com.intellij.xml.XmlConstraintsTest"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    XmlElementDescriptor >    map    =    configure (  \" test . xml \"  ,     \" test . xsd \"  )  ;", "XmlElementDescriptor   a    =    map . get (  \" a \"  )  ;", "XmlElementsGroup   topGroup    =    a . getTopGroup (  )  ;", "}", "METHOD_END"], "methodName": ["testXsdConstraints"], "fileName": "com.intellij.xml.XmlConstraintsTest"}, {"methodBody": ["METHOD_START", "{", "ExternalResourceManagerExImpl . registerResourceTemporarily (  \" http :  /  / dl . google . com / gwt / DTD / xhtml . ent \"  ,     (  ( getTestDataPath (  )  )     +     \" xhtml . ent \"  )  ,    myFixture . getTestRootDisposable (  )  )  ;", "ExternalResourceManagerExImpl . registerResourceTemporarily (  \" urn : ui : com . google . gwt . uibinder \"  ,     (  ( getTestDataPath (  )  )     +     \" UiBinder . xsd \"  )  ,    myFixture . getTestRootDisposable (  )  )  ;", "myFixture . enableInspections ( CheckXmlFileWithXercesValidatorInspection . class )  ;", "myFixture . configureByFile (  (  ( getTestName ( false )  )     +     \"  . ui . xml \"  )  )  ;", "myFixture . checkHighlighting (  )  ;", "myFixture . type (  '  \\ b '  )  ;", "myFixture . checkHighlighting (  )  ;", "}", "METHOD_END"], "methodName": ["testXmlEntityManagerCaching"], "fileName": "com.intellij.xml.XmlEntityManagerCachingTest"}, {"methodBody": ["METHOD_START", "{", "for    ( XmlExtension   extension    :    Extensions . getExtensions ( XmlExtension . EP _ NAME )  )     {", "if    ( extension . isAvailable ( file )  )     {", "return   extension ;", "}", "}", "return   DefaultXmlExtension . DEFAULT _ EXTENSION ;", "}", "METHOD_END"], "methodName": ["calcExtension"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["canBeDuplicated"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "return   new   TagNameReference ( nameElement ,    startTagFlag )  ;", "}", "METHOD_END"], "methodName": ["createTagNameReference"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlExtension . AttributeValuePresentation (  )     {", "@ NotNull", "@ Override", "public   String   getPrefix (  )     {", "return   defaultAttributeQuote ;", "}", "@ NotNull", "@ Override", "public   String   getPostfix (  )     {", "return   defaultAttributeQuote ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getAttributeValuePresentation"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "if    ( element    =  =    null )     {", "return   null ;", "}", "final   PsiFile   psiFile    =    element . getContainingFile (  )  ;", "return   psiFile   instanceof   File    ?     (  ( File )     ( psiFile )  )     :    null ;", "}", "METHOD_END"], "methodName": ["getContainingFile"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "return   descr ;", "}", "METHOD_END"], "methodName": ["getDescriptorFromDoctype"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "return   parentDescriptor . getElementDescriptor ( tag ,    contextTag )  ;", "}", "METHOD_END"], "methodName": ["getElementDescriptor"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "return   CachedValuesManager . getCachedValue ( file ,     (  )     -  >    CachedValueProvider . Result . create ( calcExtension ( file )  ,    PsiModificationTracker . MODIFICATION _ COUNT )  )  ;", "}", "METHOD_END"], "methodName": ["getExtension"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "final   PsiFile   psiFile    =    element . getContainingFile (  )  ;", "if    ( psiFile    !  =    null )     {", "return    . getExtension ( psiFile )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getExtensionByElement"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "return   HighlightInfoType . ERROR ;", "}", "METHOD_END"], "methodName": ["getHighlightInfoType"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "return   element . getNSDescriptor ( namespace ,    strict )  ;", "}", "METHOD_END"], "methodName": ["getNSDescriptor"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "return   declarationsExist    ?    null    :    XmlUtil . getDefaultNamespaces ( parent )  ;", "}", "METHOD_END"], "methodName": ["getNamespacesFromDocument"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "return   new   LocalSearchScope ( declaration . getParent (  )  )  ;", "}", "METHOD_END"], "methodName": ["getNsPrefixScope"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "return   tag . getParentTag (  )  ;", "}", "METHOD_END"], "methodName": ["getParentTagForNamespace"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["hasDynamicComponents"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "final   XmlExtension   extension    =    XmlExtension . getExtensionByElement ( tag )  ;", "return    ( extension    =  =    null )     |  |     ( extension . isCollapsibleTag ( tag )  )  ;", "}", "METHOD_END"], "methodName": ["isCollapsible"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isCollapsibleTag"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isCustomTagAllowed"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isIndirectSyntax"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isRequiredAttributeImplicitlyPresent"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isSelfClosingTagAllowed"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isSingleTagException"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["shouldBeHighlightedAsTag"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "return   descriptor . isRequired (  )  ;", "}", "METHOD_END"], "methodName": ["shouldBeInserted"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "final   XmlExtension   extension    =    XmlExtension . getExtensionByElement ( tag )  ;", "return    ( extension    !  =    null )     &  &     ( extension . isSelfClosingTagAllowed ( tag )  )  ;", "}", "METHOD_END"], "methodName": ["shouldIgnoreSelfClosingTag"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["useXmlTagInsertHandler"], "fileName": "com.intellij.xml.XmlExtension"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  . html \"  )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.xml.XmlFoldingTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . testFolding (  (  (  ( getTestDataPath (  )  )     +     ( getTestName ( true )  )  )     +    extension )  )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.xml.XmlFoldingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testCustomRegions"], "fileName": "com.intellij.xml.XmlFoldingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testDataUri"], "fileName": "com.intellij.xml.XmlFoldingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testEntities"], "fileName": "com.intellij.xml.XmlFoldingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testStyleAttributeFolding"], "fileName": "com.intellij.xml.XmlFoldingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testStyleAttributeFolding2"], "fileName": "com.intellij.xml.XmlFoldingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testTagFolding"], "fileName": "com.intellij.xml.XmlFoldingTest"}, {"methodBody": ["METHOD_START", "{", "for    ( XmlNamespaceHelper   extension    :    Extensions . getExtensions ( XmlNamespaceHelper . EP _ NAME )  )     {", "if    ( extension . isAvailable ( file )  )     {", "return   extension ;", "}", "}", "return   XmlNamespaceHelper . DEFAULT _ EXTENSION ;", "}", "METHOD_END"], "methodName": ["getHelper"], "fileName": "com.intellij.xml.XmlNamespaceHelper"}, {"methodBody": ["METHOD_START", "{", "return   XmlBundle . message (  \" namespace . alias \"  )  ;", "}", "METHOD_END"], "methodName": ["getNamespaceAlias"], "fileName": "com.intellij.xml.XmlNamespaceHelper"}, {"methodBody": ["METHOD_START", "{", "if    ( element   instanceof   XmlAttribute )     {", "XmlAttribute   attribute    =     (  ( XmlAttribute )     ( element )  )  ;", "String   prefix    =    attribute . getPrefix (  )  ;", "if    (  !  ( StringUtil . isEmpty ( prefix )  )  )     {", "return   prefix ;", "}", "}", "final   PsiElement   tag    =     ( element   instanceof   XmlTag )     ?    element    :    element . getParent (  )  ;", "if    ( tag   instanceof   XmlTag )     {", "return    (  ( XmlTag )     ( tag )  )  . getPrefix (  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getNamespacePrefix"], "fileName": "com.intellij.xml.XmlNamespaceHelper"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   tag    =     ( element   instanceof   XmlTag )     ?    element    :    element . getParent (  )  ;", "if    ( tag   instanceof   XmlTag )     {", "final   String   prefix    =     (  ( XmlTag )     ( tag )  )  . getPrefix (  )  ;", "if    (  !  ( prefix . equals ( namespacePrefix )  )  )     {", "final   String   name    =     ( namespacePrefix    +     \"  :  \"  )     +     (  (  ( XmlTag )     ( tag )  )  . getLocalName (  )  )  ;", "(  ( XmlTag )     ( tag )  )  . setName ( name )  ;", "}", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["qualifyWithPrefix"], "fileName": "com.intellij.xml.XmlNamespaceHelper"}, {"methodBody": ["METHOD_START", "{", "myFixture . testHighlighting (  )  ;", "WriteCommandAction . writeCommandAction ( getProject (  )  ,    getFile (  )  )  . run (  (  )     -  >     {", "new   OptimizeImportsProcessor ( getProject (  )  ,    getFile (  )  )  . runWithoutProgress (  )  ;", "}  )  ;", "myFixture . checkResult ( after )  ;", "}", "METHOD_END"], "methodName": ["doOptimizeImportsTest"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "doUnusedDeclarationTest ( text ,    after ,    name ,    true )  ;", "}", "METHOD_END"], "methodName": ["doUnusedDeclarationTest"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText (  \" a . xml \"  ,    text )  ;", "myFixture . testHighlighting (  )  ;", "IntentionAction   action    =    myFixture . getAvailableIntention ( name )  ;", "assertNotNull (  ( name    +     \"    not   found \"  )  ,    action )  ;", "myFixture . launchAction ( action )  ;", "myFixture . checkResult ( after )  ;", "myFixture . configureByText (  \" a . xml \"  ,    text )  ;", "if    ( testOptimizeImports )     {", "doOptimizeImport ( after )  ;", "}", "}", "METHOD_END"], "methodName": ["doUnusedDeclarationTest"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "doUnusedDeclarationTest (  (  \"  < x : all       < warning   descr =  \\  \" Namespace   declaration   is   never   used \\  \"  > xmlns =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLS < caret > chema \\  \"  <  / warning >  \\ n \"     +     (  \"                         xmlns : x =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  \\ n \"     +     \"                          < warning   descr =  \\  \" Namespace   declaration   is   never   used \\  \"  > xmlns : y =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  <  / warning >  /  >  \"  )  )  ,     (  \"  < x : all \\ n \"     +     (  \"                         xmlns : x =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  \\ n \"     +     \"                         xmlns : y =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  /  >  \"  )  )  ,    XmlBundle . message (  \" xml . inspections . unused . schema . remove \"  )  ,    false )  ;", "doOptimizeImportsTest (  (  \"  < x : all \\ n \"     +     (  \"                         xmlns : x =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  \\ n \"     +     \"  /  >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testDifferentPrefixes"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . disableInspections ( new   XmlUnusedNamespaceInspection (  )  )  ;", "String   text    =     \"  < all   xmlns =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"    xmlns : xsi =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema - instance \\  \"  /  >  \"  ;", "myFixture . configureByText ( XmlFileType . INSTANCE ,    text )  ;", "doOptimizeImportsTest ( text )  ;", "}", "METHOD_END"], "methodName": ["testDoNotOptimizeWhenInspectionDisabled"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFiles (  \" fixAll . xml \"  ,     \" spring - beans -  2  .  5  . xsd \"  ,     \" spring - batch -  2  .  1  . xsd \"  )  ;", "IntentionAction   action    =    myFixture . findSingleIntention (  \" Fix   all \"  )  ;", "assertNotNull ( action )  ;", "myFixture . launchAction ( action )  ;", "myFixture . checkResultByFile (  \" fixAll _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testFixAll"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText (  \" a . xml \"  ,     (  \"  < xs : schema   xmlns : xs =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  \\ n \"     +     (  (  (  \"                                  xmlns : x 2  =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  \\ n \"     +     \"                                   < warning   descr =  \\  \" Namespace   declaration   is   never   used \\  \"  > xmlns : x 3  =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  <  / warning >     >  \\ n \"  )     +     \"        < xs : element   name =  \\  \" a \\  \"    type =  \\  \" x 2  : string \\  \"  /  >  \\ n \"  )     +     \"  <  / xs : schema >  \"  )  )  )  ;", "myFixture . testHighlighting (  )  ;", "}", "METHOD_END"], "methodName": ["testImplicitPrefixUsage"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText ( XmlFileType . INSTANCE ,     (  \"  < schema   xmlns =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"     \\ n \"     +     (  (  (  \"                         xmlns : x =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  \\ n \"     +     \"                          < warning   descr =  \\  \" Namespace   declaration   is   never   used \\  \"  > xmlns : y =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  <  / warning >  >  \\ n \"  )     +     \"              < element   name =  \\  \" a \\  \"    default =  \\  \" x : y \\  \"  /  >  \\ n \"  )     +     \"  <  / schema >  \"  )  )  )  ;", "myFixture . testHighlighting (  )  ;", "}", "METHOD_END"], "methodName": ["testImplicitPrefixes"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText ( XmlFileType . INSTANCE ,     (  \"  < html   xmlns =  \\  \" http :  /  / www . w 3  . org /  1  9  9  9  / xhtml \\  \"  \\ n \"     +     (  (  (  \"                               xmlns : xs =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \\ n \"     +     \"              < body   about =  \\  \" wsdl : definitions / wsdl : types / xs : schema [  @ targetNamespace =  \\  ' http :  /  / www . w 3 schools . com / webservices /  \\  '  ]  \\  \"  >  \\ n \"  )     +     \"              <  / body >  \\ n \"  )     +     \"  <  / html >  \"  )  )  )  ;", "myFixture . testHighlighting (  )  ;", "}", "METHOD_END"], "methodName": ["testImplicitPrefixesPattern"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "doUnusedDeclarationTest (  (  \"  < xs : schema   attributeFormDefault =  \\  \" unqualified \\  \"  \\ n \"     +     (  (  (  (  (  (  (  (  \"                                   < warning   descr =  \\  \" Namespace   declaration   is   never   used \\  \"  > xmlns : xsi =  \\  \" http :  /  / www . w 3  . org /  2  0  < caret >  0  1  / XMLSchema - instance \\  \"  <  / warning >  \\ n \"     +     \"                                  elementFormDefault =  \\  \" qualified \\  \"    xmlns : xs =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \\ n \"  )     +     \"  \\ n \"  )     +     \"                          <  !  -  -    keep   formatting   here -  -  >  \\ n \"  )     +     \"              < xs : element   name =  \\  \" a \\  \"    type =  \\  \" aType \\  \"  /  >  \\ n \"  )     +     \"        < xs : complexType   name =  \\  \" aType \\  \"  >  \\ n \"  )     +     \"  \\ n \"  )     +     \"        <  / xs : complexType >  \\ n \"  )     +     \"  <  / xs : schema >  \"  )  )  ,     (  \"  < xs : schema   attributeFormDefault =  \\  \" unqualified \\  \"  \\ n \"     +     (  (  (  (  (  (  (  \"                                  elementFormDefault =  \\  \" qualified \\  \"    xmlns : xs =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  >  \\ n \"     +     \"  \\ n \"  )     +     \"                          <  !  -  -    keep   formatting   here -  -  >  \\ n \"  )     +     \"              < xs : element   name =  \\  \" a \\  \"    type =  \\  \" aType \\  \"  /  >  \\ n \"  )     +     \"        < xs : complexType   name =  \\  \" aType \\  \"  >  \\ n \"  )     +     \"  \\ n \"  )     +     \"        <  / xs : complexType >  \\ n \"  )     +     \"  <  / xs : schema >  \"  )  )  ,    XmlBundle . message (  \" xml . inspections . unused . schema . remove \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testKeepFormatting"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText (  \" a . xml \"  ,     (  \"  < x : all \\ n \"     +     (  (  (  (  (  (  \"                         xmlns : x =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  \\ n \"     +     \"                         xmlns : xsi =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema - instance \\  \"  \\ n \"  )     +     \"                         xsi : schemaLocation =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema   http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema . xsd \\ n \"  )     +     \"                                                 http :  /  / www . w 3  . org /  2  0  0  1  / XInclude   http :  /  / www . w 3  . org /  2  0  0  1  / XInclude . xsd \\  \"  >  \\ n \"  )     +     \"  \\ n \"  )     +     \"              < include   xmlns =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XInclude \\  \"    href =  \\  \" a . xml \\  \"  /  >  \\ n \"  )     +     \"  <  / x : all >  \"  )  )  )  ;", "myFixture . testHighlighting (  )  ;", "}", "METHOD_END"], "methodName": ["testLocallyUsedNamespace"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText (  \" a . xml \"  ,     (  \"  < s : foo   xmlns : s =  \\  \"  < error   descr =  \\  \" URI   is   not   registered    ( Settings    |    Languages    &    Frameworks    |    Schemas   and   DTDs )  \\  \"  > http :  /  / foo <  / error >  \\  \"  \\ n \"     +     (  (  (  (  (  (  \"                       < warning   descr =  \\  \" Namespace   declaration   is   never   used \\  \"  > xmlns : bar =  \\  \"  < error   descr =  \\  \" URI   is   not   registered    ( Settings    |    Languages    &    Frameworks    |    Schemas   and   DTDs )  \\  \"  > http :  /  / bar <  / error >  \\  \"  <  / warning >  \\ n \"     +     \"                      xmlns : xsi =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema - instance \\  \"  \\ n \"  )     +     \"                      xsi : schemaLocation =  \\  \" http :  /  / bar    < error   descr =  \\  \" Cannot   resolve   file    \\  ' bar . xsd \\  '  \\  \"  > bar . xsd <  / error >    http :  /  / foo    < error   descr =  \\  \" Cannot   resolve   file    \\  ' foo . xsd \\  '  \\  \"  > foo . xsd <  / error >  \\  \"  >  \\ n \"  )     +     \"  \\ n \"  )     +     \"              < bar   xmlns =  \\  \"  < error   descr =  \\  \" URI   is   not   registered    ( Settings    |    Languages    &    Frameworks    |    Schemas   and   DTDs )  \\  \"  > http :  /  / bar <  / error >  \\  \"  /  >  \\ n \"  )     +     \"  \\ n \"  )     +     \"  <  / s : foo >  \"  )  )  )  ;", "myFixture . testHighlighting (  )  ;", "}", "METHOD_END"], "methodName": ["testLocallyUsedNamespaceWithPrefix"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  \" idproblem . html \"  )  ;", "PlatformUtil . startPerformance (  \"  ?  \"  ,     1  0  0  ,     (  )     -  >    myFixture . doHighlighting (  )  )  . assertTiming (  )  ;", "}", "METHOD_END"], "methodName": ["testPatternPerformanceProblem"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText (  \" a . xml \"  ,     (  \"  <  < info   descr =  \\  \" Namespace    \\  '  \\  '    is   not   bound \\  \"  > nodeTypes <  / info >    xmlns : nt =  \\  \"  < error   descr =  \\  \" URI   is   not   registered    ( Settings    |    Languages    &    Frameworks    |    Schemas   and   DTDs )  \\  \"  > http :  /  / www . jcp . org / jcr / nt /  1  .  0  <  / error >  \\  \"    xmlns : customns =  \\  \"  < error   descr =  \\  \" URI   is   not   registered    ( Settings    |    Languages    &    Frameworks    |    Schemas   and   DTDs )  \\  \"  > http :  /  / customurl <  / error >  \\  \"  >  \\ n \"     +     (  (  (  (  (  \"  < nodeType   name =  \\  \" customns : item \\  \"    isMixin =  \\  \" false \\  \"    hasOrderableChildNodes =  \\  \" false \\  \"  >  \\ n \"     +     \"           < supertypes >  \\ n \"  )     +     \"                    < supertype > nt : folder <  / supertype >  \\ n \"  )     +     \"           <  / supertypes >  \\ n \"  )     +     \"  <  / nodeType >  \\ n \"  )     +     \"  <  /  < info   descr =  \\  \" Namespace    \\  '  \\  '    is   not   bound \\  \"  > nodeTypes <  / info >  >  \"  )  )  )  ;", "myFixture . testHighlighting (  )  ;", "}", "METHOD_END"], "methodName": ["testPrefixesInTagValues"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . testHighlighting (  \" moved . xml \"  ,     \" trg / move - def . xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testSubDirectory"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  \" web - app _  2  _  5  . xsd \"  )  ;", "String   text    =     \"  <  !  -  - suppress   XmlUnusedDeclaration    -  -  >  \\ n \"     +     (  (  (  (  (  \"  < web - app   xmlns =  \\  \" http :  /  / com / xml / ns / javaee \\  \"  \\ n \"     +     \"                            xmlns : xsi =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema - instance \\  \"  \\ n \"  )     +     \"                            xsi : schemaLocation =  \\  \" http :  /  / com / xml / ns / javaee \\ n \"  )     +     \"                            web - app _  2  _  5  . xsd \\  \"  \\ n \"  )     +     \"                            version =  \\  \"  2  .  5  \\  \"  >  \\ n \"  )     +     \"  <  / web - app >  \"  )  ;", "myFixture . configureByText (  \" a . xml \"  ,    text )  ;", "doOptimizeImportsTest ( text )  ;", "}", "METHOD_END"], "methodName": ["testSuppressedOptimize"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "doUnusedDeclarationTest (  (  \"  < x : all \\ n \"     +     (  (  \"                         xmlns : x =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  \\ n \"     +     \"                         xmlns : xsi =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema - instance \\  \"  \\ n \"  )     +     \"                          < warning   descr =  \\  \" Namespace   location   is   never   used \\  \"  > xsi : noNamespaceSc < caret > hemaLocation =  \\  \"  < error   descr =  \\  \" Cannot   resolve   file    \\  ' zzz \\  '  \\  \"  > zzz <  / error >  \\  \"  <  / warning >     /  >  \"  )  )  ,     (  \"  < x : all \\ n \"     +     (  (  \"                         xmlns : x =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  \\ n \"     +     \"                         xmlns : xsi =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema - instance \\  \"  \\ n \"  )     +     \"  /  >  \"  )  )  ,    XmlUnusedNamespaceInspection . RemoveNamespaceLocationFix . NAME )  ;", "}", "METHOD_END"], "methodName": ["testUnusedDefaultLocation"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "doUnusedDeclarationTest (  (  \"  < schema : schema    \\ n \"     +     (  (  (  (  \"                                     xmlns : schema =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  \\ n \"     +     \"                                      < warning   descr =  \\  \" Namespace   declaration   is   never   used \\  \"  > xmlns =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / X < caret > Include \\  \"  <  / warning >  \\ n \"  )     +     \"                                     xmlns : xsi =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema - instance \\  \"  \\ n \"  )     +     \"                                      < warning   descr =  \\  \" Namespace   location   is   never   used \\  \"  > xsi : noNamespaceSchemaLocation =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XInclude \\  \"  <  / warning >  >  \\ n \"  )     +     \"  <  / schema : schema >  \"  )  )  ,     (  \"  < schema : schema \\ n \"     +     (  (  (  \"                         xmlns : schema =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  \\ n \"     +     \"                         xmlns : xsi =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema - instance \\  \"  \\ n \"  )     +     \"  >  \\ n \"  )     +     \"  <  / schema : schema >  \"  )  )  ,    XmlBundle . message (  \" xml . inspections . unused . schema . remove \"  )  ,    false )  ;", "doOptimizeImportsTest (  (  \"  < schema : schema    \\ n \"     +     (  (  (  \"                                     xmlns : schema =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  \\ n \"     +     \"                                     xmlns : xsi =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema - instance \\  \"  \\ n \"  )     +     \"  >  \\ n \"  )     +     \"  <  / schema : schema >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testUnusedDefaultNamespace"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "doUnusedDeclarationTest (  (  \"  < x : all \\ n \"     +     (  (  (  \"                         xmlns : x =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  \\ n \"     +     \"                         xmlns : xsi =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema - instance \\  \"  \\ n \"  )     +     \"                         xsi : schemaLocation =  \\  \"  < warning   descr =  \\  \" Namespace   location   is   never   used \\  \"  > http :  /  / www . w 3  . org /  2  0  0  1  / XML < caret > Sche <  / warning >     \"  )     +     \"  < warning   descr =  \\  \" Namespace   location   is   never   used \\  \"  > http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema . xsd <  / warning >  \\  \"  /  >  \"  )  )  ,     (  \"  < x : all \\ n \"     +     (  (  \"                         xmlns : x =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  \\ n \"     +     \"                         xmlns : xsi =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema - instance \\  \"  \\ n \"  )     +     \"  /  >  \"  )  )  ,    XmlUnusedNamespaceInspection . RemoveNamespaceLocationFix . NAME )  ;", "}", "METHOD_END"], "methodName": ["testUnusedLocation"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  \" web - app _  2  _  5  . xsd \"  )  ;", "myFixture . configureByText (  \" a . xml \"  ,     (  \"  < web - app   xmlns =  \\  \" http :  /  / com / xml / ns / javaee \\  \"  \\ n \"     +     (  (  (  (  (  \"                            xmlns : xsi =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema - instance \\  \"  \\ n \"     +     \"                             < warning   descr =  \\  \"    declaration   is   never   used \\  \"  > xmlns : web =  \\  \" http :  /  / com / xml / ns / javaee / web - app _  2  _  5  . xsd \\  \"  <  / warning >  \\ n \"  )     +     \"                            xsi : schemaLocation =  \\  \" http :  /  / com / xml / ns / javaee \\ n \"  )     +     \"                            web - app _  2  _  5  . xsd \\  \"  \\ n \"  )     +     \"                            version =  \\  \"  2  .  5  \\  \"  >  \\ n \"  )     +     \"  <  / web - app >  \"  )  )  )  ;", "myFixture . testHighlighting (  )  ;", "}", "METHOD_END"], "methodName": ["testUnusedLocationDetection"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "doUnusedDeclarationTest (  (  \"  < x : all \\ n \"     +     (  (  (  (  \"                         xmlns : x =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  \\ n \"     +     \"                          < warning   descr =  \\  \" Namespace   declaration   is   never   used \\  \"  > xmlns : y =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XInclude \\  \"  <  / warning >  \\ n \"  )     +     \"                         xmlns : xsi =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema - instance \\  \"  \\ n \"  )     +     \"                         xsi : schemaLocation =  \\  \"  < warning   descr =  \\  \" Namespace   location   is   never   used \\  \"  > http :  /  / www . w 3  . org /  2  0  0  1  / XI < caret > nclude <  / warning >     < warning   descr =  \\  \" Namespace   location   is   never   used \\  \"  > http :  /  / www . w 3  . org /  2  0  0  1  / XInclude . xsd <  / warning >  \\ n \"  )     +     \"                         http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema   http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema . xsd \\  \"  /  >  \"  )  )  ,     (  \"  < x : all \\ n \"     +     (  (  \"                         xmlns : x =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  \\ n \"     +     \"                         xmlns : xsi =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema - instance \\  \"  \\ n \"  )     +     \"                         xsi : schemaLocation =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema   http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema . xsd \\  \"  /  >  \"  )  )  ,    XmlBundle . message (  \" xml . inspections . unused . schema . remove \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testUnusedLocationOnly"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "doUnusedDeclarationTest (  \"  < all   xmlns =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"     < warning   descr =  \\  \" Namespace   declaration   is   never   used \\  \"  > xmlns : xsi =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSc < caret > hema - instance \\  \"  <  / warning >  /  >  \"  ,     \"  < all   xmlns =  \\  \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \\  \"  /  >  \"  ,    XmlBundle . message (  \" xml . inspections . unused . schema . remove \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testUnusedNamespaces"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . testHighlighting (  \" spring . xml \"  ,     \" spring - beans -  2  .  5  . xsd \"  ,     \" spring - batch -  2  .  1  . xsd \"  )  ;", "IntentionAction   action    =    myFixture . getAvailableIntention ( XmlBundle . message (  \" xml . inspections . unused . schema . remove \"  )  )  ;", "assertNotNull ( action )  ;", "myFixture . launchAction ( action )  ;", "myFixture . checkResultByFile (  \" spring _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testUsedInXmlns"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText (  \" a . xml \"  ,     (  \"  < deployment   xmlns =  \\  \" http :  /  / xml . apache . org / axis / wsdd /  \\  \"    xmlns : java =  \\  \" http :  /  / xml . apache . org / axis / wsdd / providers / java \\  \"  >  \\ n \"     +     (  \"  < typeMapping   deserializer =  \\  \" BeanDeserializerFactory \\  \"    encodingStyle =  \\  \"  \\  \"    qname =  \\  \" ns 3  8  : AxisAnalysis \\  \"    serializer =  \\  \" BeanSerializerFactory \\  \"    languageSpecificType =  \\  \" java : com . pls . xactservice . axis . bindings . AxisAnalysis \\  \"  /  >  \\ n \"     +     \"  <  / deployment >  \"  )  )  )  ;", "myFixture . testHighlighting (  )  ;", "}", "METHOD_END"], "methodName": ["testWSDD"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . testHighlighting (  \" import . xml \"  ,     \" import . xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["testXsiType"], "fileName": "com.intellij.xml.XmlNamespacesTest"}, {"methodBody": ["METHOD_START", "{", "assertSize ( usages ,    myFixture . testFindUsages ( filename )  )  ;", "}", "METHOD_END"], "methodName": ["doFindUsages"], "fileName": "com.intellij.xml.XmlSchemaPrefixTest"}, {"methodBody": ["METHOD_START", "{", "doRename (  \" xsd \"  )  ;", "}", "METHOD_END"], "methodName": ["doRename"], "fileName": "com.intellij.xml.XmlSchemaPrefixTest"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    getTestName ( true )  ;", "CodeInsightTestUtil . doInlineRenameTest ( new   RenameHandler (  )  ,    name ,     \" xml \"  ,    newValue ,    myFixture )  ;", "}", "METHOD_END"], "methodName": ["doRename"], "fileName": "com.intellij.xml.XmlSchemaPrefixTest"}, {"methodBody": ["METHOD_START", "{", "doFindUsages (  \" usages . xml \"  ,     1  6  )  ;", "doFindUsages (  \" usages 1  . xml \"  ,     1  6  )  ;", "}", "METHOD_END"], "methodName": ["testPrefixUsages"], "fileName": "com.intellij.xml.XmlSchemaPrefixTest"}, {"methodBody": ["METHOD_START", "{", "doRename (  )  ;", "}", "METHOD_END"], "methodName": ["testRename"], "fileName": "com.intellij.xml.XmlSchemaPrefixTest"}, {"methodBody": ["METHOD_START", "{", "doRename (  )  ;", "}", "METHOD_END"], "methodName": ["testRename1"], "fileName": "com.intellij.xml.XmlSchemaPrefixTest"}, {"methodBody": ["METHOD_START", "{", "doRename (  )  ;", "}", "METHOD_END"], "methodName": ["testRename2"], "fileName": "com.intellij.xml.XmlSchemaPrefixTest"}, {"methodBody": ["METHOD_START", "{", "doRename (  )  ;", "}", "METHOD_END"], "methodName": ["testRenameFromClosingTag"], "fileName": "com.intellij.xml.XmlSchemaPrefixTest"}, {"methodBody": ["METHOD_START", "{", "if    ( file . getProject (  )  . isDefault (  )  )", "return   null ;", "final   boolean   dumb    =    DumbService . getInstance ( file . getProject (  )  )  . isDumb (  )  ;", "for    (    provider    :    Extensions . getExtensions (  . EP _ NAME )  )     {", "if    ( dumb    &  &     (  !  ( DumbService . isDumbAware ( provider )  )  )  )     {", "continue ;", "}", "if    (  ( file   instanceof   XmlFile )     &  &     (  !  ( provider . isAvailable (  (  ( XmlFile )     ( file )  )  )  )  )  )     {", "continue ;", "}", "final   XmlFile   schema    =    provider . getSchema ( namespace ,    module ,    file )  ;", "if    ( schema    !  =    null )     {", "return   schema ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findSchema"], "fileName": "com.intellij.xml.XmlSchemaProvider"}, {"methodBody": ["METHOD_START", "{", "final   PsiDirectory   directory    =    baseFile . getParent (  )  ;", "final   Module   module    =    ModuleUtilCore . findModuleForPsiElement (  ( directory    =  =    null    ?    baseFile    :    directory )  )  ;", "return    . findSchema ( namespace ,    module ,    baseFile )  ;", "}", "METHOD_END"], "methodName": ["findSchema"], "fileName": "com.intellij.xml.XmlSchemaProvider"}, {"methodBody": ["METHOD_START", "{", "return   Collections . emptySet (  )  ;", "}", "METHOD_END"], "methodName": ["getAvailableNamespaces"], "fileName": "com.intellij.xml.XmlSchemaProvider"}, {"methodBody": ["METHOD_START", "{", "for    ( XmlSchemaProvider   provider    :    Extensions . getExtensions ( XmlSchemaProvider . EP _ NAME )  )     {", "if    ( provider . isAvailable ( file )  )     {", "return   provider ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAvailableProvider"], "fileName": "com.intellij.xml.XmlSchemaProvider"}, {"methodBody": ["METHOD_START", "{", "return   ContainerUtil . findAll ( Extensions . getExtensions ( XmlSchemaProvider . EP _ NAME )  ,     (    xmlSchemaProvider )     -  >    xmlSchemaProvider . isAvailable ( file )  )  ;", "}", "METHOD_END"], "methodName": ["getAvailableProviders"], "fileName": "com.intellij.xml.XmlSchemaProvider"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getDefaultPrefix"], "fileName": "com.intellij.xml.XmlSchemaProvider"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getLocations"], "fileName": "com.intellij.xml.XmlSchemaProvider"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isAvailable"], "fileName": "com.intellij.xml.XmlSchemaProvider"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["createFixes"], "fileName": "com.intellij.xml.XmlUndefinedElementFixProvider"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["createFixes"], "fileName": "com.intellij.xml.XmlUndefinedElementFixProvider"}, {"methodBody": ["METHOD_START", "{", "final   StringBuilder   result    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <     ( text . length (  )  )  ;    i +  +  )     {", "char   c    =    text . charAt ( i )  ;", "final   PsiElement   element    =    file . findElementAt (  ( start    +    i )  )  ;", "if    (  ( element    !  =    null )     &  &     (  . isCharacterElement ( element )  )  )     {", "if    (  (  (  (  (  ( c    =  =     '  <  '  )     |  |     ( c    =  =     '  >  '  )  )     |  |     ( c    =  =     '  &  '  )  )     |  |     ( c    =  =     '  \"  '  )  )     |  |     ( c    =  =     '  \\  '  '  )  )     |  |     ( c    >     1  2  7  )  )     {", "final   String   escape    =     . ESCAPES . getValue ( file )  . get ( c )  ;", "if    ( escape    !  =    null )     {", "result . append (  \"  &  \"  )  . append ( escape )  . append (  \"  ;  \"  )  ;", "continue ;", "}", "}", "}", "result . append ( c )  ;", "}", "return   result . toString (  )  ;", "}", "METHOD_END"], "methodName": ["escape"], "fileName": "com.intellij.xml.actions.EscapeEntitiesAction"}, {"methodBody": ["METHOD_START", "{", "final   IElementType   type    =    element . getNode (  )  . getElementType (  )  ;", "if    ( type    =  =     ( XmlTokenType . XML _ DATA _ CHARACTERS )  )", "return   true ;", "if    ( type    =  =     ( XmlTokenType . XML _ ATTRIBUTE _ VALUE _ TOKEN )  )     {", "if    (  ( element . getParent (  )  . getParent (  )  )    instanceof   XmlAttribute )", "return   true ;", "}", "if    ( type    =  =     ( XmlTokenType . XML _ BAD _ CHARACTER )  )", "return   true ;", "if    ( type    =  =     ( XmlTokenType . XML _ START _ TAG _ START )  )     {", "if    (  ( element . getNextSibling (  )  )    instanceof   PsiErrorElement )", "return   true ;", "if    (  ( element . getParent (  )  )    instanceof   PsiErrorElement )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isCharacterElement"], "fileName": "com.intellij.xml.actions.EscapeEntitiesAction"}, {"methodBody": ["METHOD_START", "{", "if    (  ( group . getMinOccurs (  )  )     <     1  )", "return   Collections . emptyList (  )  ;", "switch    ( group . getGroupType (  )  )     {", "case   LEAF    :", "XmlElementDescriptor   descriptor    =    group . getLeafDescriptor (  )  ;", "return   descriptor    =  =    null    ?    Collections . emptyList (  )     :    Collections . singletonList ( descriptor )  ;", "case   CHOICE    :", "LinkedHashSet < XmlElementDescriptor >    set    =    null ;", "for    ( XmlElementsGroup   subGroup    :    group . getSubGroups (  )  )     {", "List < XmlElementDescriptor >    descriptors    =     . computeRequiredSubTags ( subGroup )  ;", "if    ( set    =  =    null )     {", "set    =    new   LinkedHashSet <  >  ( descriptors )  ;", "} else    {", "set . retainAll ( descriptors )  ;", "}", "}", "if    (  ( set    =  =    null )     |  |     ( set . isEmpty (  )  )  )     {", "return   Collections . singletonList ( null )  ;", "}", "return   new   ArrayList <  >  ( set )  ;", "default    :", "ArrayList < XmlElementDescriptor >    list    =    new   ArrayList <  >  (  )  ;", "for    ( XmlElementsGroup   subGroup    :    group . getSubGroups (  )  )     {", "list . addAll (  . computeRequiredSubTags ( subGroup )  )  ;", "}", "return   list ;", "}", "}", "METHOD_END"], "methodName": ["computeRequiredSubTags"], "fileName": "com.intellij.xml.actions.GenerateXmlTagAction"}, {"methodBody": ["METHOD_START", "{", "String   namespace    =    GenerateXmlTagAction . getNamespace ( descriptor )  ;", "XmlTag   tag    =    contextTag . createChildTag ( descriptor . getName (  )  ,    namespace ,    null ,    false )  ;", "PsiElement   lastChild    =    tag . getLastChild (  )  ;", "assert   lastChild    !  =    null ;", "lastChild . delete (  )  ;", "return   tag ;", "}", "METHOD_END"], "methodName": ["createTag"], "fileName": "com.intellij.xml.actions.GenerateXmlTagAction"}, {"methodBody": ["METHOD_START", "{", "XmlElementDescriptor   selected    =    newTag . getDescriptor (  )  ;", "if    ( selected    =  =    null )", "return ;", "switch    ( selected . getContentType (  )  )     {", "case   XmlElementDescriptor . CONTENT _ TYPE _ EMPTY    :", "newTag . collapseIfEmpty (  )  ;", "ASTNode   node    =    newTag . getNode (  )  ;", "assert   node    !  =    null ;", "ASTNode   elementEnd    =    node . findChildByType ( XmlTokenType . XML _ EMPTY _ ELEMENT _ END )  ;", "if    ( elementEnd    =  =    null )     {", "LeafElement   emptyTagEnd    =    Factory . createSingleLeafElement ( XmlTokenType . XML _ EMPTY _ ELEMENT _ END ,     \"  /  >  \"  ,     0  ,     2  ,    null ,    newTag . getManager (  )  )  ;", "node . addChild ( emptyTagEnd )  ;", "}", "break ;", "case   XmlElementDescriptor . CONTENT _ TYPE _ MIXED    :", "newTag . getValue (  )  . setText (  \"  \"  )  ;", "}", "for    ( XmlAttributeDescriptor   descriptor    :    selected . getAttributesDescriptors ( newTag )  )     {", "if    ( descriptor . isRequired (  )  )     {", "newTag . setAttribute ( descriptor . getName (  )  ,     \"  \"  )  ;", "}", "}", "List < XmlElementDescriptor >    tags    =     . getRequiredSubTags ( selected )  ;", "for    ( XmlElementDescriptor   descriptor    :    tags )     {", "if    ( descriptor    =  =    null )     {", "XmlTag   tag    =    XmlElementFactory . getInstance ( newTag . getProject (  )  )  . createTagFromText (  \"  <  \"  ,    newTag . getLanguage (  )  )  ;", "newTag . addSubTag ( tag ,    false )  ;", "} else    {", "XmlTag   subTag    =    newTag . addSubTag (  . createTag ( newTag ,    descriptor )  ,    false )  ;", ". generateRaw ( subTag )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["generateRaw"], "fileName": "com.intellij.xml.actions.GenerateXmlTagAction"}, {"methodBody": ["METHOD_START", "{", "GenerateXmlTagAction . generateRaw ( newTag )  ;", "final   XmlTag   restored    =    CodeInsightUtilCore . forcePsiPostprocessAndRestoreElement ( newTag )  ;", "if    ( restored    =  =    null )     {", "GenerateXmlTagAction . LOG . error (  (  \" Could   not   restore   tag :     \"     +     ( newTag . getText (  )  )  )  )  ;", "}", "TemplateBuilder   builder    =    TemplateBuilderFactory . getInstance (  )  . createTemplateBuilder ( restored )  ;", "GenerateXmlTagAction . replaceElements ( restored ,    builder )  ;", "builder . run ( editor ,    false )  ;", "}", "METHOD_END"], "methodName": ["generateTag"], "fileName": "com.intellij.xml.actions.GenerateXmlTagAction"}, {"methodBody": ["METHOD_START", "{", "XmlContentDFA   contentDFA    =    XmlContentDFA . getContentDFA ( contextTag )  ;", "int   offset    =    editor . getCaretModel (  )  . getOffset (  )  ;", "if    ( contentDFA    =  =    null )     {", "return   null ;", "}", "anchor    =    null ;", "boolean   previousPositionIsPossible    =    true ;", "for    (    subTag    :    contextTag . getSubTags (  )  )     {", "if    ( contentDFA . getPossibleElements (  )  . contains ( selected )  )     {", "if    (  ( subTag . getTextOffset (  )  )     >    offset )     {", "break ;", "}", "anchor    =    subTag ;", "previousPositionIsPossible    =    true ;", "} else    {", "previousPositionIsPossible    =    false ;", "}", "contentDFA . transition ( subTag )  ;", "}", "return   previousPositionIsPossible    ?    null    :    anchor ;", "}", "METHOD_END"], "methodName": ["getAnchor"], "fileName": "com.intellij.xml.actions.GenerateXmlTagAction"}, {"methodBody": ["METHOD_START", "{", "PsiElement   element    =    file . findElementAt ( editor . getCaretModel (  )  . getOffset (  )  )  ;", "tag    =    null ;", "if    ( element    !  =    null )     {", "tag    =    PsiTreeUtil . getParentOfType ( element ,     . class )  ;", "}", "if    ( tag    =  =    null )     {", "tag    =     (  ( XmlFile )     ( file )  )  . getRootTag (  )  ;", "}", "return   tag ;", "}", "METHOD_END"], "methodName": ["getContextTag"], "fileName": "com.intellij.xml.actions.GenerateXmlTagAction"}, {"methodBody": ["METHOD_START", "{", "return   descriptor   instanceof   XmlElementDescriptorImpl    ?     (  ( XmlElementDescriptorImpl )     ( descriptor )  )  . getNamespace (  )     :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["getNamespace"], "fileName": "com.intellij.xml.actions.GenerateXmlTagAction"}, {"methodBody": ["METHOD_START", "{", "XmlElementsGroup   topGroup    =    selected . getTopGroup (  )  ;", "if    ( topGroup    =  =    null )", "return   emptyList (  )  ;", "return    . computeRequiredSubTags ( topGroup )  ;", "}", "METHOD_END"], "methodName": ["getRequiredSubTags"], "fileName": "com.intellij.xml.actions.GenerateXmlTagAction"}, {"methodBody": ["METHOD_START", "{", "return   contextTag . getValue (  )  . getTextRange (  )  . contains ( editor . getCaretModel (  )  . getOffset (  )  )  ;", "}", "METHOD_END"], "methodName": ["isInsideTagBody"], "fileName": "com.intellij.xml.actions.GenerateXmlTagAction"}, {"methodBody": ["METHOD_START", "{", "for    ( XmlAttribute   attribute    :    tag . getAttributes (  )  )     {", "XmlAttributeValue   value    =    attribute . getValueElement (  )  ;", "if    ( value    !  =    null )     {", "builder . replaceElement ( value ,    TextRange . from (  1  ,     0  )  ,    new   com . intellij . codeInsight . template . impl . MacroCallNode ( new   CompleteMacro (  )  )  )  ;", "}", "}", "if    (  \"  <  \"  . equals ( tag . getText (  )  )  )     {", "builder . replaceElement ( tag ,    TextRange . from (  1  ,     0  )  ,    new   com . intellij . codeInsight . template . impl . MacroCallNode ( new   CompleteSmartMacro (  )  )  )  ;", "} else", "if    (  ( tag . getSubTags (  )  . length )     =  =     0  )     {", "int   i    =    tag . getText (  )  . indexOf (  \"  >  <  /  \"  )  ;", "if    ( i    >     0  )     {", "builder . replaceElement ( tag ,    TextRange . from (  ( i    +     1  )  ,     0  )  ,    new   com . intellij . codeInsight . template . impl . MacroCallNode ( new   CompleteMacro (  )  )  )  ;", "}", "}", "for    ( XmlTag   subTag    :    tag . getSubTags (  )  )     {", ". replaceElements ( subTag ,    builder )  ;", "}", "}", "METHOD_END"], "methodName": ["replaceElements"], "fileName": "com.intellij.xml.actions.GenerateXmlTagAction"}, {"methodBody": ["METHOD_START", "{", "GenerateXmlTagAction . TEST _ THREAD _ LOCAL . set ( tagName )  ;", "CodeInsightTestUtil . doActionTest ( new   GenerateXmlTagAction (  )  ,    file ,    myFixture )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.xml.actions.GenerateXmlTagTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  \" web - app _  2  _  5  . xsd \"  )  ;", "doTest (  \" g . xml \"  ,     \" security - constraint \"  )  ;", "}", "METHOD_END"], "methodName": ["testGenerate"], "fileName": "com.intellij.xml.actions.GenerateXmlTagTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" generateDTD . xml \"  ,     \" b \"  )  ;", "}", "METHOD_END"], "methodName": ["testGenerateDTD"], "fileName": "com.intellij.xml.actions.GenerateXmlTagTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" generateDTDComplex . xml \"  ,     \" b \"  )  ;", "}", "METHOD_END"], "methodName": ["testGenerateDTDComplex"], "fileName": "com.intellij.xml.actions.GenerateXmlTagTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  \" xsd \"  )  ;", "myFixture . configureByFile (  \" web - app _  2  _  5  . xsd \"  )  ;", "doTest (  \" gEmpty . xml \"  ,     \" distributable \"  )  ;", "}", "METHOD_END"], "methodName": ["testGenerateEmpty"], "fileName": "com.intellij.xml.actions.GenerateXmlTagTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" try _ to _ generate _ in _ tag _ name . xml \"  ,     \" context - param \"  )  ;", "}", "METHOD_END"], "methodName": ["testInTagName"], "fileName": "com.intellij.xml.actions.GenerateXmlTagTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" initParam . xml \"  ,     \" context - param \"  )  ;", "}", "METHOD_END"], "methodName": ["testInitParam"], "fileName": "com.intellij.xml.actions.GenerateXmlTagTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  \" spring - beans _  3  .  0  . xsd \"  )  ;", "do (  \" spring . xml \"  ,     \" bean \"  )  ;", "}", "METHOD_END"], "methodName": ["testSpring"], "fileName": "com.intellij.xml.actions.GenerateXmlTagTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  \" spring - beans _  3  .  0  . xsd \"  )  ;", "do (  \" springAfterBean . xml \"  ,     \" bean \"  )  ;", "}", "METHOD_END"], "methodName": ["testSpringAfterBean"], "fileName": "com.intellij.xml.actions.GenerateXmlTagTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  \" spring - beans _  3  .  0  . xsd \"  )  ;", "do (  \" springAlias . xml \"  ,     \" alias \"  )  ;", "}", "METHOD_END"], "methodName": ["testSpringAlias"], "fileName": "com.intellij.xml.actions.GenerateXmlTagTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  \" spring - beans _  3  .  0  . xsd \"  )  ;", "do (  \" springAtCaret . xml \"  ,     \" bean \"  )  ;", "}", "METHOD_END"], "methodName": ["testSpringAtCaret"], "fileName": "com.intellij.xml.actions.GenerateXmlTagTest"}, {"methodBody": ["METHOD_START", "{", "doAllTests (  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "com.intellij.xml.actions.SplitTagActionTest"}, {"methodBody": ["METHOD_START", "{", "final   StringBuilder   attrsWoId    =    new   StringBuilder (  )  ;", "for    ( XmlAttribute   attribute    :    Tag . getAttributes (  )  )     {", "if    (  !  ( HtmlUtil . ID _ ATTRIBUTE _ NAME . equals ( attribute . getName (  )  )  )  )     {", "attrsWoId . append ( attribute . getName (  )  )  . append (  \"  =  \\  \"  \"  )  . append ( attribute . getValue (  )  )  . append (  \"  \\  \"     \"  )  ;", "}", "}", "return    ( attrsWoId . length (  )  )     =  =     0     ?     \"  \"     :     \"     \"     +     ( attrsWoId . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAttrsWithoutId"], "fileName": "com.intellij.xml.actions.XmlSplitTagAction"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( grandParent   instanceof   HtmlTag )  )     &  &     (  ( grandParent . getContainingFile (  )  . getLanguage (  )  )     !  =     ( XHTMLLanguage . INSTANCE )  )  )     {", "return   false ;", "}", "final   String   name    =     (  ( XmlTag )     ( grandParent )  )  . getName (  )  ;", "return    (  (  \" html \"  . equals ( name )  )     |  |     (  \" body \"  . equals ( name )  )  )     |  |     (  \" title \"  . equals ( name )  )  ;", "}", "METHOD_END"], "methodName": ["isInsideUnsplittableElement"], "fileName": "com.intellij.xml.actions.XmlSplitTagAction"}, {"methodBody": ["METHOD_START", "{", "if    ( ex   instanceof   ProcessCanceledException )", "throw    (  ( ProcessCanceledException )     ( ex )  )  ;", "if    ( ex   instanceof   XmlResourceResolver . IgnoredResourceException )", "throw    (  ( XmlResourceResolver . IgnoredResourceException )     ( ex )  )  ;", "if    (  (  (  (  (  ( ex   instanceof   FileNotFoundException )     |  |     ( ex   instanceof   MalformedURLException )  )     |  |     ( ex   instanceof   NoRouteToHostException )  )     |  |     ( ex   instanceof   SocketTimeoutException )  )     |  |     ( ex   instanceof   UnknownHostException )  )     |  |     ( ex   instanceof   ConnectException )  )     {", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["filterValidationException"], "fileName": "com.intellij.xml.actions.validate.ErrorReporter"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isStopOnUndeclaredResource"], "fileName": "com.intellij.xml.actions.validate.ErrorReporter"}, {"methodBody": ["METHOD_START", "{", "String   error    =    myHandler . buildMessageString ( e )  ;", "if    ( oursSet . contains ( error )  )", "return   false ;", "oursSet . add ( error )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["isUniqueProblem"], "fileName": "com.intellij.xml.actions.validate.ErrorReporter"}, {"methodBody": ["METHOD_START", "{", "myHandler . doParse (  )  ;", "}", "METHOD_END"], "methodName": ["startProcessing"], "fileName": "com.intellij.xml.actions.validate.ErrorReporter"}, {"methodBody": ["METHOD_START", "{", "CommandProcessor   commandProcessor    =    CommandProcessor . getInstance (  )  ;", "commandProcessor . executeCommand ( myProject ,     (  )     -  >     {", "MessageView   messageView    =    MessageView . SERVICE . getInstance ( myProject )  ;", "final   Content   content    =    ContentFactory . SERVICE . getInstance (  )  . createContent ( myErrorsView . getComponent (  )  ,    myContentName ,    true )  ;", "content . putUserData (  . KEY ,    myErrorsView )  ;", "messageView . getContentManager (  )  . addContent ( content )  ;", "messageView . getContentManager (  )  . setSelectedContent ( content )  ;", "messageView . getContentManager (  )  . addContentManagerListener ( new   CloseListener ( content ,    messageView . getContentManager (  )  )  )  ;", "ContentManagerUtil . cleanupContents ( content ,    myProject ,    myContentName )  ;", "messageView . getContentManager (  )  . addContentManagerListener ( new   MyContentDisposer ( content ,    messageView )  )  ;", "}  ,    XmlBundle . message (  \" validate . xml . open . message . view . command . name \"  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["openMessageView"], "fileName": "com.intellij.xml.actions.validate.StdErrorReporter"}, {"methodBody": ["METHOD_START", "{", "return   errors ;", "}", "METHOD_END"], "methodName": ["getErrors"], "fileName": "com.intellij.xml.actions.validate.TestErrorReporter"}, {"methodBody": ["METHOD_START", "{", "CommandProcessor . getInstance (  )  . executeCommand ( psiFile . getProject (  )  ,     (  )     -  >     {", "final   Runnable   action    =     (  )     -  >     {", "try    {", "psiFile . putUserData (  . runningValidationKey ,     \"  \"  )  ;", "PsiDocumentManager . getInstance ( psiFile . getProject (  )  )  . commitAllDocuments (  )  ;", "getHandler ( psiFile )  . doValidate (  (  ( XmlFile )     ( psiFile )  )  )  ;", "}    finally    {", "psiFile . putUserData (  . runningValidationKey ,    null )  ;", "}", "}  ;", "ApplicationManager . getApplication (  )  . runWriteAction ( action )  ;", "}  ,    getCommandName (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["doRunAction"], "fileName": "com.intellij.xml.actions.validate.ValidateXmlAction"}, {"methodBody": ["METHOD_START", "{", "String   text    =    getTemplatePresentation (  )  . getText (  )  ;", "return   text    !  =    null    ?    text    :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["getCommandName"], "fileName": "com.intellij.xml.actions.validate.ValidateXmlAction"}, {"methodBody": ["METHOD_START", "{", "ValidateXmlActionHandler   handler    =    new   ValidateXmlActionHandler ( true )  ;", "handler . setErrorReporter ( new   StdErrorReporter ( handler ,    file ,     (  )     -  >    doRunAction ( file )  )  )  ;", "return   handler ;", "}", "METHOD_END"], "methodName": ["getHandler"], "fileName": "com.intellij.xml.actions.validate.ValidateXmlAction"}, {"methodBody": ["METHOD_START", "{", "String   msg    =     (  (  (  (  \"  (  \"     +     ( ex . getLineNumber (  )  )  )     +     \"  :  \"  )     +     ( ex . getColumnNumber (  )  )  )     +     \"  )     \"  )     +     ( ex . getMessage (  )  )  ;", "final   VirtualFile   file    =    getProblemFile ( ex )  ;", "if    (  ( file    !  =    null )     &  &     (  !  ( file . equals ( myFile . getVirtualFile (  )  )  )  )  )     {", "msg    =     (  ( file . getName (  )  )     +     \"  :  \"  )     +    msg ;", "}", "return   msg ;", "}", "METHOD_END"], "methodName": ["buildMessageString"], "fileName": "com.intellij.xml.actions.validate.ValidateXmlActionHandler"}, {"methodBody": ["METHOD_START", "{", "long   timestamp    =     0  ;", "for    ( VirtualFile   file    :    files )     {", "if    (  ( file    =  =    null )     |  |     (  !  ( file . is (  )  )  )  )", "break ;", "final   PsiFile   psifile    =    PsiManager . getInstance ( myProject )  . findFile ( file )  ;", "if    (  ( psifile    !  =    null )     &  &     ( psifile . is (  )  )  )     {", "timestamp    +  =    psifile . getViewProvider (  )  . getModificationStamp (  )  ;", "} else    {", "break ;", "}", "}", "return   timestamp ;", "}", "METHOD_END"], "methodName": ["calculateTimeStamp"], "fileName": "com.intellij.xml.actions.validate.ValidateXmlActionHandler"}, {"methodBody": ["METHOD_START", "{", "XMLEntityManager   entityManager    =     (  ( XMLEntityManager )     ( parser . getXMLReader (  )  . getProperty ( ValidateXmlActionHandler . ENTITY _ MANAGER _ PROPERTY _ ID )  )  )  ;", "Map < String ,    XMLEntityManager . Entity >    entities    =    file . getUserData ( ValidateXmlActionHandler . ENTITIES _ KEY )  ;", "if    ( entities    !  =    null )     {", "Map < String ,    XMLEntityManager . Entity >    map    =    XercesAccessor . getEntities ( entityManager )  ;", "for    ( Map . Entry < String ,    XMLEntityManager . Entity >    entry    :    entities . entrySet (  )  )     {", "if    ( entry . getValue (  )  . isEntityDeclInExternalSubset (  )  )     {", "map . put ( entry . getKey (  )  ,    entry . getValue (  )  )  ;", "}", "}", "} else    {", "file . putUserData ( ValidateXmlActionHandler . ENTITIES _ KEY ,    XercesAccessor . getEntities ( entityManager )  )  ;", "}", "}", "METHOD_END"], "methodName": ["configureEntityManager"], "fileName": "com.intellij.xml.actions.validate.ValidateXmlActionHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  !  ( needsDtdChecking (  )  )  )     &  &     (  !  ( needsSchemaChecking (  )  )  )  )     &  &     (  !  ( myForceChecking )  )  )     {", "return   null ;", "}", "SAXParserFactory   factory    =    new   SAXParserFactoryImpl (  )  ;", "boolean   schemaChecking    =    false ;", "if    ( hasDtdDeclaration (  )  )     {", "factory . setValidating ( true )  ;", "}", "if    ( needsSchemaChecking (  )  )     {", "factory . setValidating ( true )  ;", "factory . setNamespaceAware ( true )  ;", "try    {", "factory . setXIncludeAware ( true )  ;", "}    catch    ( NoSuchMethodError   ignore )     {", "}", "schemaChecking    =    true ;", "}", "try    {", "factory . setFeature ( XMLConstants . FEATURE _ SECURE _ PROCESSING ,    true )  ;", "}    catch    ( Exception   ignore )     {", "}", "SAXParser   parser    =    factory . newSAXParser (  )  ;", "parser . setProperty (  . ENTITY _ RESOLVER _ PROPERTY _ NAME ,    myXmlResourceResolver )  ;", "try    {", "parser . getXMLReader (  )  . setFeature ( XMLConstants . FEATURE _ SECURE _ PROCESSING ,    true )  ;", "}    catch    ( Exception   ignore )     {", "}", "String   property    =    System . getProperty (  . JDK _ XML _ MAX _ OCCUR _ LIMIT )  ;", "if    ( property    !  =    null )     {", "SecurityManager   securityManager    =     (  ( SecurityManager )     ( parser . getProperty ( Constants . SECURITY _ MANAGER )  )  )  ;", "securityManager . setMaxOccurNodeLimit ( Integer . parseInt ( property )  )  ;", "}", "if    ( schemaChecking )     {", "XMLGrammarPool   grammarPool    =     . getGrammarPool ( myFile ,    myForceChecking )  ;", ". configureEntityManager ( myFile ,    parser )  ;", "parser . getXMLReader (  )  . setProperty (  . GRAMMAR _ FEATURE _ ID ,    grammarPool )  ;", "}", "try    {", "if    ( schemaChecking )     {", "parser . setProperty ( JAXP _ SCHEMA _ LANGUAGE ,    W 3 C _ XML _ SCHEMA )  ;", "parser . getXMLReader (  )  . setFeature (  . SCHEMA _ FULL _ CHECKING _ FEATURE _ ID ,    true )  ;", "if    ( Boolean . TRUE . equals ( Boolean . getBoolean ( XmlResourceResolver . HONOUR _ ALL _ SCHEMA _ LOCATIONS _ PROPERTY _ KEY )  )  )     {", "parser . getXMLReader (  )  . setFeature (  \" http :  /  / apache . org / xml / features / honour - all - schemaLocations \"  ,    true )  ;", "}", "parser . getXMLReader (  )  . setFeature (  \" http :  /  / apache . org / xml / features / validation / warn - on - undeclared - elemdef \"  ,    Boolean . TRUE )  ;", "parser . getXMLReader (  )  . setFeature (  \" http :  /  / apache . org / xml / features / validation / warn - on - duplicate - attdef \"  ,    Boolean . TRUE )  ;", "}", "parser . getXMLReader (  )  . setFeature (  \" http :  /  / apache . org / xml / features / warn - on - duplicate - entitydef \"  ,    Boolean . TRUE )  ;", "parser . getXMLReader (  )  . setFeature (  \" http :  /  / apache . org / xml / features / validation / unparsed - entity - checking \"  ,    Boolean . FALSE )  ;", "}    catch    ( SAXNotRecognizedException   ex )     {", ". LOG . info (  \" Xml   parser   installation   seems   screwed \"  ,    ex )  ;", "}", "return   parser ;", "}", "METHOD_END"], "methodName": ["createParser"], "fileName": "com.intellij.xml.actions.validate.ValidateXmlActionHandler"}, {"methodBody": ["METHOD_START", "{", "try    {", "myParser . parse ( new   InputSource ( new   StringReader ( myFile . getText (  )  )  )  ,    new   DefaultHandler (  )     {", "@ Override", "public   void   warning ( SAXParseException   e )    throws   SAXException    {", "if    ( myErrorReporter . isUniqueProblem ( e )  )", "myErrorReporter . processError ( e ,     . ProblemType . WARNING )  ;", "}", "@ Override", "public   void   error ( SAXParseException   e )    throws   SAXException    {", "if    ( myErrorReporter . isUniqueProblem ( e )  )", "myErrorReporter . processError ( e ,     . ProblemType . ERROR )  ;", "}", "@ Override", "public   void   fatalError ( SAXParseException   e )    throws   SAXException    {", "if    ( myErrorReporter . isUniqueProblem ( e )  )", "myErrorReporter . processError ( e ,     . ProblemType . FATAL )  ;", "}", "@ Override", "public   InputSource   resolveEntity ( String   publicId ,    String   systemId )     {", "final   PsiFile   psiFile    =    myXmlResourceResolver . resolve ( null ,    systemId )  ;", "if    ( psiFile    =  =    null )", "return   null ;", "return   new   InputSource ( new   StringReader ( psiFile . getText (  )  )  )  ;", "}", "@ Override", "public   void   startDocument (  )    throws   SAXException    {", "super . startDocument (  )  ;", "myParser . setProperty (  . ENTITY _ RESOLVER _ PROPERTY _ NAME ,    myXmlResourceResolver )  ;", ". configureEntityManager ( myFile ,    myParser )  ;", "}", "}  )  ;", "final   String [  ]    resourcePaths    =    myXmlResourceResolver . getResourcePaths (  )  ;", "if    (  ( resourcePaths . length )     >     0  )     {", "final   VirtualFile [  ]    files    =    new   VirtualFile [ resourcePaths . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( resourcePaths . length )  ;     +  + i )     {", "files [ i ]     =    UriUtil . findRelativeFile ( resourcePaths [ i ]  ,    null )  ;", "}", "myFile . putUserData (  . DEPENDENT _ FILES _ KEY ,    files )  ;", "myFile . putUserData (  . GRAMMAR _ POOL _ TIME _ STAMP _ KEY ,     . calculateTimeStamp ( files ,    myProject )  )  ;", "}", "myFile . putUserData (  . KNOWN _ NAMESPACES _ KEY ,     . getNamespaces ( myFile )  )  ;", "}    catch    ( SAXException   e )     {", ". LOG . debug ( e )  ;", "}    catch    ( Exception   exception )     {", "filterAppException ( exception )  ;", "}    catch    ( StackOverflowError   error )     {", "}", "}", "METHOD_END"], "methodName": ["doParse"], "fileName": "com.intellij.xml.actions.validate.ValidateXmlActionHandler"}, {"methodBody": ["METHOD_START", "{", "myProject    =    file . getProject (  )  ;", "myFile    =    file ;", "myXmlResourceResolver    =    new   XmlResourceResolver ( myFile ,    myProject ,    myErrorReporter )  ;", "myXmlResourceResolver . setStopOnUnDeclaredResource ( myErrorReporter . isStopOnUndeclaredResource (  )  )  ;", "try    {", "try    {", "myParser    =    createParser (  )  ;", "}    catch    ( Excep   e )     {", "filterAppExcep ( e )  ;", "}", "if    (  ( myParser )     =  =    null )", "return ;", "myErrorReporter . startProcessing (  )  ;", "}    catch    ( XmlResourceResolver . IgnoredResourceExcep   ignore )     {", "}    catch    ( Excep   excep )     {", "filterAppExcep ( excep )  ;", "}", "}", "METHOD_END"], "methodName": ["doValidate"], "fileName": "com.intellij.xml.actions.validate.ValidateXmlActionHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( myErrorReporter . filterValidationException ( exception )  )  )     {", ". LOG . error ( exception )  ;", "}", "}", "METHOD_END"], "methodName": ["filterAppException"], "fileName": "com.intellij.xml.actions.validate.ValidateXmlActionHandler"}, {"methodBody": ["METHOD_START", "{", "return   file . getUserData ( ValidateXmlActionHandler . GRAMMAR _ POOL _ KEY )  ;", "}", "METHOD_END"], "methodName": ["getGrammarPool"], "fileName": "com.intellij.xml.actions.validate.ValidateXmlActionHandler"}, {"methodBody": ["METHOD_START", "{", "final   XMLGrammarPool   previousGrammarPool    =    ValidateXmlActionHandler . getGrammarPool ( file )  ;", "XMLGrammarPool   grammarPool    =    null ;", "if    (  (  ! forceChecking )     &  &     (  !  ( ValidateXmlActionHandler . isValidationDependentFilesOutOfDate ( file )  )  )  )     {", "grammarPool    =    previousGrammarPool ;", "}", "if    ( grammarPool    =  =    null )     {", "ValidateXmlActionHandler . invalidateEntityManager ( file )  ;", "grammarPool    =    new   XMLGrammarPoolImpl (  )  ;", "file . putUserData ( ValidateXmlActionHandler . GRAMMAR _ POOL _ KEY ,    grammarPool )  ;", "}", "return   grammarPool ;", "}", "METHOD_END"], "methodName": ["getGrammarPool"], "fileName": "com.intellij.xml.actions.validate.ValidateXmlActionHandler"}, {"methodBody": ["METHOD_START", "{", "XmlTag   rootTag    =    file . getRootTag (  )  ;", "if    ( rootTag    =  =    null )", "return   util . ArrayUtil . EMPTY _ STRING _ ARRAY ;", "return   ContainerUtil . mapNotNull ( rootTag . getAttributes (  )  ,     (    attribute )     -  >    attribute . getValue (  )  ,    EMPTY _ STRING _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["getNamespaces"], "fileName": "com.intellij.xml.actions.validate.ValidateXmlActionHandler"}, {"methodBody": ["METHOD_START", "{", "String   publicId    =    ex . getPublicId (  )  ;", "String   systemId    =    ex . getSystemId (  )  ;", "if    ( publicId    =  =    null )     {", "if    ( systemId    !  =    null )     {", "if    ( systemId . startsWith (  \" file :  /  \"  )  )     {", "VirtualFile   file    =    VirtualFileManager . getInstance (  )  . findFileByUrl (  ( systemId . startsWith (  \" file :  /  /  \"  )     ?    systemId    :    systemId . replace (  \" file :  /  \"  ,     \" file :  /  /  \"  )  )  )  ;", "if    ( file    !  =    null )", "return   file ;", "}", "final   String   path    =    myXmlResourceResolver . getPathByPublicId ( systemId )  ;", "if    ( path    !  =    null )", "return   findRelativeFile ( path ,    null )  ;", "final   PsiFile   file    =    myXmlResourceResolver . resolve ( null ,    systemId )  ;", "if    ( file    !  =    null )", "return   file . getVirtualFile (  )  ;", "}", "return   myFile . getVirtualFile (  )  ;", "}", "final   String   path    =    myXmlResourceResolver . getPathByPublicId ( publicId )  ;", "if    ( path    !  =    null )", "return   findRelativeFile ( path ,    null )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["getProblemFile"], "fileName": "com.intellij.xml.actions.validate.ValidateXmlActionHandler"}, {"methodBody": ["METHOD_START", "{", "XmlDocument   document    =    myFile . getDocument (  )  ;", "if    ( document    =  =    null )", "return   false ;", "XmlProlog   prolog    =    document . getProlog (  )  ;", "if    ( prolog    =  =    null )", "return   false ;", "XmlDoctype   doctype    =    prolog . getDoctype (  )  ;", "if    ( doctype    =  =    null )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["hasDtdDeclaration"], "fileName": "com.intellij.xml.actions.validate.ValidateXmlActionHandler"}, {"methodBody": ["METHOD_START", "{", "file . putUserData ( ValidateXmlActionHandler . ENTITIES _ KEY ,    null )  ;", "}", "METHOD_END"], "methodName": ["invalidateEntityManager"], "fileName": "com.intellij.xml.actions.validate.ValidateXmlActionHandler"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile [  ]    files    =    myFile . getUserData ( ValidateXmlActionHandler . DEPENDENT _ FILES _ KEY )  ;", "final   Long   grammarPoolTimeStamp    =    myFile . getUserData ( ValidateXmlActionHandler . GRAMMAR _ POOL _ TIME _ STAMP _ KEY )  ;", "String [  ]    ns    =    myFile . getUserData ( ValidateXmlActionHandler . KNOWN _ NAMESPACES _ KEY )  ;", "if    (  !  ( Arrays . equals ( ns ,    ValidateXmlActionHandler . getNamespaces ( myFile )  )  )  )     {", "return   true ;", "}", "if    (  ( grammarPoolTimeStamp    !  =    null )     &  &     ( files    !  =    null )  )     {", "long   dependentFilesTimestamp    =    ValidateXmlActionHandler . calculateTimeStamp ( files ,    myFile . getProject (  )  )  ;", "if    ( dependentFilesTimestamp    =  =     ( grammarPoolTimeStamp . longValue (  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isValidationDependentFilesOutOfDate"], "fileName": "com.intellij.xml.actions.validate.ValidateXmlActionHandler"}, {"methodBody": ["METHOD_START", "{", "XmlDocument   document    =    myFile . getDocument (  )  ;", "if    ( document    =  =    null )", "return   false ;", "return    (  ( document . getProlog (  )  )     !  =    null )     &  &     (  ( document . getProlog (  )  . getDoctype (  )  )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["needsDtdChecking"], "fileName": "com.intellij.xml.actions.validate.ValidateXmlActionHandler"}, {"methodBody": ["METHOD_START", "{", "XmlDocument   document    =    myFile . getDocument (  )  ;", "if    ( document    =  =    null )", "return   false ;", "XmlTag   rootTag    =    document . getRootTag (  )  ;", "if    ( rootTag    =  =    null )", "return   false ;", "ttribute [  ]    attributes    =    rootTag . getAttributes (  )  ;", "for    ( ttribute   attribute    :    attributes )     {", "if    ( attribute . isNamespaceDeclaration (  )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["needsSchemaChecking"], "fileName": "com.intellij.xml.actions.validate.ValidateXmlActionHandler"}, {"methodBody": ["METHOD_START", "{", "myErrorReporter    =    errorReporter ;", "}", "METHOD_END"], "methodName": ["setErrorReporter"], "fileName": "com.intellij.xml.actions.validate.ValidateXmlActionHandler"}, {"methodBody": ["METHOD_START", "{", "try    {", "InputStream   fis    =    new   InputStream ( in )  ;", "OutputStream   fos    =    new   OutputStream ( out )  ;", "byte [  ]    buf    =    new   byte [  1  0  2  4  ]  ;", "int   i ;", "while    (  ( i    =    fis . read ( buf )  )     !  =     (  -  1  )  )     {", "fos . write ( buf ,     0  ,    i )  ;", "}", "fis . close (  )  ;", "fos . close (  )  ;", "return   true ;", "}    catch    ( Exception   e )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["copyFile"], "fileName": "com.intellij.xml.actions.xmlbeans.FileUtils"}, {"methodBody": ["METHOD_START", "{", "File   f    =    new   File ( filename )  ;", "if    (  !  ( f . exists (  )  )  )", "return   filename ;", "int   dot    =    filename . lastIndexOf (  '  .  '  )  ;", "String   name    =    filename . substring (  0  ,    dot )  ;", "String   ext    =    filename . substring ( dot )  ;", "int   num    =     0  ;", "do    {", "f    =    new   File (  (  ( name    +     (  +  + num )  )     +    ext )  )  ;", "}    while    ( f . exists (  )     )  ;", "return    ( name    +    num )     +    ext ;", "}", "METHOD_END"], "methodName": ["findFreeFileName"], "fileName": "com.intellij.xml.actions.xmlbeans.FileUtils"}, {"methodBody": ["METHOD_START", "{", "fullFileName    =    FileUtils . findFreeFileName ( fullFileName )  ;", "OutputStream   ostream    =    new   FileOutputStream ( fullFileName )  ;", "byte [  ]    buf    =    new   byte [  8  1  9  2  ]  ;", "while    ( true )     {", "int   read    =    stream . read ( buf ,     0  ,    buf . length )  ;", "if    ( read    =  =     (  -  1  )  )", "break ;", "ostream . write ( buf ,     0  ,    read )  ;", "}", "ostream . flush (  )  ;", "ostream . close (  )  ;", "return   new   File ( fullFileName )  ;", "}", "METHOD_END"], "methodName": ["saveStreamContentAsFile"], "fileName": "com.intellij.xml.actions.xmlbeans.FileUtils"}, {"methodBody": ["METHOD_START", "{", "FileDocumentManager . getInstance (  )  . saveAllDocuments (  )  ;", "@ NonNls", "List < String >    parameters    =    new   LinkedList <  >  (  )  ;", "final   String   url    =    dialog . getUrl (  )  . getText (  )  ;", "final   VirtualFile   relativeFile    =    VfsUtilCore . findRelativeFile ( ExternalResourceManager . getInstance (  )  . getResourceLocation ( url )  ,    null )  ;", "if    ( relativeFile    =  =    null )     {", "Messages . showErrorDialog ( project ,    XmlBundle . message (  \" file . doesnt . exist \"  ,    url )  ,    XmlBundle . message (  \" error \"  )  )  ;", "return ;", "}", "final   PsiFile   file    =    PsiManager . getInstance ( project )  . findFile ( relativeFile )  ;", "if    (  !  ( file   instanceof   XmlFile )  )     {", "Messages . showErrorDialog ( project ,     (  (  \"     (  \"     +     ( file . getFileType (  )  . getName (  )  )  )     +     \"  )  \"  )  ,    XmlBundle . message (  \" error \"  )  )  ;", "return ;", "}", "VirtualFile   relativeFileDir    =    relativeFile . getParent (  )  ;", "if    ( relativeFileDir    =  =    null )     {", "Messages . showErrorDialog ( project ,    XmlBundle . message (  \" file . doesnt . exist \"  ,    url )  ,    XmlBundle . message (  \" error \"  )  )  ;", "return ;", "}", "if    (  !  ( dialog . enableRestrictionCheck (  )  )  )     {", "parameters . add (  \"  - nopvr \"  )  ;", "}", "if    (  !  ( dialog . enableUniquenessCheck (  )  )  )     {", "parameters . add (  \"  - noupa \"  )  ;", "}", "String   pathToUse ;", "try    {", "final   File   tempDir    =    FileUtil . createTempFile (  \" xsd 2 inst \"  ,     \"  \"  )  ;", "tempDir . delete (  )  ;", "tempDir . mkdir (  )  ;", "pathToUse    =     (  ( tempDir . getPath (  )  )     +     ( File . separatorChar )  )     +     ( Xsd 2 InstanceUtils . processAndSaveAllSchemas (  (  ( XmlFile )     ( file )  )  ,    new   gnu . trove . THashMap (  )  ,    new   Xsd 2 InstanceUtils . SchemaReferenceProcessor (  )     {", "@ Override", "public   void   processSchema ( String   schemaFileName ,    byte [  ]    schemaContent )     {", "try    {", "final   String   fullFileName    =     (  ( tempDir . getPath (  )  )     +     ( File . separatorChar )  )     +    schemaFileName ;", "FileUtils . saveStreamContentAsFile ( fullFileName ,    new   ByteArrayInputStream ( schemaContent )  )  ;", "}    catch    ( IOException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "}  )  )  ;", "}    catch    ( IOException   e )     {", "return ;", "}", "parameters . add ( pathToUse )  ;", "parameters . add (  \"  - name \"  )  ;", "parameters . add ( dialog . getElementName (  )  )  ;", "String   xml ;", "try    {", "xml    =    Xsd 2 InstanceUtils . generate ( ArrayUtil . toStringArray ( parameters )  )  ;", "}    catch    ( IllegalArgumentException   e )     {", "Messages . showErrorDialog ( project ,    StringUtil . getMessage ( e )  ,    XmlBundle . message (  \" error \"  )  )  ;", "return ;", "}", "String   xmlFileName    =     (  ( relativeFileDir . getPath (  )  )     +     ( File . separatorChar )  )     +     ( dialog . getOutputFileName (  )  )  ;", "try    {", "final   File   xmlFile    =    new   File ( xmlFileName )  ;", "FileUtil . writeToFile ( xmlFile ,    xml )  ;", "VirtualFile   virtualFile    =    WriteAction . compute (  (  )     -  >    LocalFileSystem . getInstance (  )  . refreshAndFindFileByIoFile ( xmlFile )  )  ;", "FileEditorManager . getInstance ( project )  . openFile ( virtualFile ,    true )  ;", "}    catch    ( IOException   e )     {", "Messages . showErrorDialog ( project ,     (  \" Could   not   save   generated   XML   document :     \"     +     ( StringUtil . getMessage ( e )  )  )  ,    XmlBundle . message (  \" error \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doAction"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateInstanceDocumentFromSchemaAction"}, {"methodBody": ["METHOD_START", "{", "return   GenerateInstanceDocumentFromSchemaAction . isAcceptableFileForGenerateSchemaFromInstanceDocument ( file )  ;", "}", "METHOD_END"], "methodName": ["isAcceptableFile"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateInstanceDocumentFromSchemaAction"}, {"methodBody": ["METHOD_START", "{", "return    ( virtualFile    !  =    null )     &  &     (  \" xsd \"  . equalsIgnoreCase ( virtualFile . getExtension (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAcceptableFileForGenerateSchemaFromInstanceDocument"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateInstanceDocumentFromSchemaAction"}, {"methodBody": ["METHOD_START", "{", "updateFile (  )  ;", "return    ( rootEleChooser . getSelectedItem (  )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["areCurrentParametersStillValid"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateInstanceDocumentFromSchemaDialog"}, {"methodBody": ["METHOD_START", "{", "combo . setModel ( new   DefaultComboBoxModel ( ArrayUtil . toStringArray ( lastValues )  )  )  ;", "}", "METHOD_END"], "methodName": ["configureComboBox"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateInstanceDocumentFromSchemaDialog"}, {"methodBody": ["METHOD_START", "{", "textComponent . setLabelFor ( component )  ;", "if    ( component   instanceof   JTextField )     {", "(  ( JTextField )     ( component )  )  . get (  )  . addListener ( new   Listener (  )     {", "@ Override", "public   void   insertUpdate ( Event   e )     {", "validateData (  )  ;", "}", "@ Override", "public   void   removeUpdate ( Event   e )     {", "validateData (  )  ;", "}", "@ Override", "public   void   changedUpdate ( Event   e )     {", "validateData (  )  ;", "}", "}  )  ;", "} else", "if    ( component   instanceof   JComboBox )     {", "JComboBox   jComboBox    =     (  ( JComboBox )     ( component )  )  ;", "jComboBox . addActionListener ( new   ActionListener (  )     {", "@ Override", "public   void   actionPerformed ( ActionEvent   e )     {", "validateData (  )  ;", "}", "}  )  ;", "(  ( JTextField )     ( jComboBox . getEditor (  )  . getEditorComponent (  )  )  )  . get (  )  . addListener ( new   Listener (  )     {", "@ Override", "public   void   insertUpdate ( Event   e )     {", "validateData (  )  ;", "}", "@ Override", "public   void   removeUpdate ( Event   e )     {", "validateData (  )  ;", "}", "@ Override", "public   void   changedUpdate ( Event   e )     {", "validateData (  )  ;", "}", "}  )  ;", "if    ( jComboBox . isEditable (  )  )     {", "jComboBox . getEditor (  )  . getEditorComponent (  )  . addKeyListener ( new   KeyAdapter (  )     {", "@ Override", "public   void   keyTyped ( KeyEvent   e )     {", "validateData (  )  ;", "}", "}  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doInitFor"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateInstanceDocumentFromSchemaDialog"}, {"methodBody": ["METHOD_START", "{", "String   rootElementName    =    getElementName (  )  ;", "if    (  ( rootElementName    =  =    null )     |  |     (  ( rootElementName . length (  )  )     =  =     0  )  )     {", "return   XmlBundle . message (  \" schema 2  . instance . no . valid . root . element . name . validation . error \"  )  ;", "}", "final   PsiFile   psiFile    =    findFile ( getUrl (  )  . getText (  )  )  ;", "if    ( psiFile   instanceof   XmlFile )     {", "final   XmlTag   tag    =     . getRootTag ( psiFile )  ;", "if    ( tag    !  =    null )     {", "final   XmlElementDescriptor   descriptor    =    Xsd 2 InstanceUtils . getDescriptor ( tag ,    rootElementName )  ;", "if    ( descriptor    =  =    null )     {", "return   XmlBundle . message (  \" schema 2  . instance . no . valid . root . element . name . validation . error \"  )  ;", "}", "}", "}", "final   String   fileName    =    getOutputFileName (  )  ;", "if    (  ( fileName    =  =    null )     |  |     (  ( fileName . length (  )  )     =  =     0  )  )     {", "return   XmlBundle . message (  \" schema 2  . instance . output . file . name . is . empty . validation . problem \"  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["doValidateWithData"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateInstanceDocumentFromSchemaDialog"}, {"methodBody": ["METHOD_START", "{", "return   enableRestrictionCheck . isSelected (  )  ;", "}", "METHOD_END"], "methodName": ["enableRestrictionCheck"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateInstanceDocumentFromSchemaDialog"}, {"methodBody": ["METHOD_START", "{", "return   enableUniqueCheck . isSelected (  )  ;", "}", "METHOD_END"], "methodName": ["enableUniquenessCheck"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateInstanceDocumentFromSchemaDialog"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   file    =     ( uri    !  =    null )     ?    VfsUtilCore . findRelativeFile ( ExternalResourceManager . getInstance (  )  . getResourceLocation ( uri )  ,    null )     :    null ;", "return   file    !  =    null    ?    PsiManager . getInstance ( myProject )  . findFile ( file )     :    null ;", "}", "METHOD_END"], "methodName": ["findFile"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateInstanceDocumentFromSchemaDialog"}, {"methodBody": ["METHOD_START", "{", "return    (  ( String )     ( rootElementChooser . getSelectedItem (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getElementName"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateInstanceDocumentFromSchemaDialog"}, {"methodBody": ["METHOD_START", "{", "return   outputFileName . getText (  )  ;", "}", "METHOD_END"], "methodName": ["getOutputFileName"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateInstanceDocumentFromSchemaDialog"}, {"methodBody": ["METHOD_START", "{", "XmlFile   xmlFile    =    null ;", "if    ( psifile   instanceof   XmlFile )     {", "xmlFile    =     (  ( XmlFile )     ( psifile )  )  ;", "} else", "if    (  ( psifile . getViewProvider (  )  )    instanceof   psi . templateLanguages . TemplateLanguageFileViewProvider )     {", "psi . templateLanguages . TemplateLanguageFileViewProvider   viewProvider    =     (  ( psi . templateLanguages . TemplateLanguageFileViewProvider )     ( psifile . getViewProvider (  )  )  )  ;", "if    (  ( viewProvider . getPsi ( viewProvider . getTemplateDataLanguage (  )  )  )    instanceof   XmlFile )     {", "xmlFile    =     (  ( XmlFile )     ( viewProvider . getPsi ( viewProvider . getTemplateDataLanguage (  )  )  )  )  ;", "}", "}", "if    ( xmlFile    !  =    null )     {", "return   xmlFile . getDocument (  )  . getRootTag (  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getRootTag"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateInstanceDocumentFromSchemaDialog"}, {"methodBody": ["METHOD_START", "{", "return   status ;", "}", "METHOD_END"], "methodName": ["getStatusField"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateInstanceDocumentFromSchemaDialog"}, {"methodBody": ["METHOD_START", "{", "return   statusText ;", "}", "METHOD_END"], "methodName": ["getStatusTextField"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateInstanceDocumentFromSchemaDialog"}, {"methodBody": ["METHOD_START", "{", "return   generateFromUrl ;", "}", "METHOD_END"], "methodName": ["getUrl"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateInstanceDocumentFromSchemaDialog"}, {"methodBody": ["METHOD_START", "{", "return   generateFromUrlText ;", "}", "METHOD_END"], "methodName": ["getUrlText"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateInstanceDocumentFromSchemaDialog"}, {"methodBody": ["METHOD_START", "{", "return   GenerateInstanceDocumentFromSchemaAction . isAcceptableFileForGenerateSchemaFromInstanceDocument ( virtualFile )  ;", "}", "METHOD_END"], "methodName": ["isAcceptableFile"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateInstanceDocumentFromSchemaDialog"}, {"methodBody": ["METHOD_START", "{", "myOkAction    =    runnable ;", "}", "METHOD_END"], "methodName": ["setOkAction"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateInstanceDocumentFromSchemaDialog"}, {"methodBody": ["METHOD_START", "{", "String   uri    =    generateFromUrl . getText (  )  ;", "boolean   hasPrevious    =     (  ( previousUri )     !  =    null )     &  &     ( previousUri . equals ( uri )  )  ;", "final   PsiFile   psifile    =    findFile ( uri )  ;", "List < String >    myRootValues ;", "if    ( psifile    =  =    null )     {", ". configureComboBox ( rootElementChooser ,    Collections . emptyList (  )  )  ;", "return ;", "}", "final   XmlTag   rootTag    =     . getRootTag ( psifile )  ;", "if    ( rootTag    =  =    null )     {", ". configureComboBox ( rootElementChooser ,    Collections . emptyList (  )  )  ;", "rootElementChooser . setSelectedIndex (  (  -  1  )  )  ;", "previousUri    =    uri ;", "return ;", "}", "myRootValues    =    Xsd 2 InstanceUtils . addVariantsFromRootTag ( rootTag )  ;", "Object   selectedItem    =    rootElementChooser . getSelectedItem (  )  ;", ". configureComboBox ( rootElementChooser ,    myRootValues )  ;", "if    ( hasPrevious )     {", "rootElementChooser . setSelectedItem ( selectedItem )  ;", "} else    {", "rootElementChooser . setSelectedIndex (  (  ( myRootValues . size (  )  )     >     0     ?     0     :     -  1  )  )  ;", "}", "previousUri    =    uri ;", "}", "METHOD_END"], "methodName": ["updateFile"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateInstanceDocumentFromSchemaDialog"}, {"methodBody": ["METHOD_START", "{", "String   msg    =    doValidateWithData (  )  ;", "setOKAEnabled (  ( msg    =  =    null )  )  ;", "status . setText (  ( msg    =  =    null    ?     \"  \"     :    msg )  )  ;", "status . setForeground ( RED )  ;", "}", "METHOD_END"], "methodName": ["validateData"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateInstanceDocumentFromSchemaDialog"}, {"methodBody": ["METHOD_START", "{", "FileDocumentManager . getInstance (  )  . saveAllDocuments (  )  ;", "final   String   url    =    dialog . getUrl (  )  . getText (  )  ;", "final   VirtualFile   relativeFile    =    VfsUtilCore . findRelativeFile ( ExternalResourceManager . getInstance (  )  . getResourceLocation ( url )  ,    null )  ;", "VirtualFile   relativeFileDir ;", "if    ( relativeFile    =  =    null )     {", "Messages . showErrorDialog ( project ,    XmlBundle . message (  \" file . doesnt . exist \"  ,    url )  ,    XmlBundle . message (  \" error \"  )  )  ;", "return ;", "} else    {", "relativeFileDir    =    relativeFile . getParent (  )  ;", "}", "if    ( relativeFileDir    =  =    null )     {", "Messages . showErrorDialog ( project ,    XmlBundle . message (  \" file . doesnt . exist \"  ,    url )  ,    XmlBundle . message (  \" error \"  )  )  ;", "return ;", "}", "@ NonNls", "List < String >    parameters    =    new   LinkedList <  >  (  )  ;", "parameters . add (  \"  - design \"  )  ;", "parameters . add (  . DESIGN _ TYPES . get ( dialog . getDesignType (  )  )  )  ;", "parameters . add (  \"  - simple - content - types \"  )  ;", "parameters . add (  . CONTENT _ TYPES . get ( dialog . getSimpleContentType (  )  )  )  ;", "parameters . add (  \"  - enumerations \"  )  ;", "String   enumLimit    =    dialog . getEnumerationsLimit (  )  ;", "parameters . add (  (  \"  0  \"  . equals ( enumLimit )     ?     \" never \"     :    enumLimit )  )  ;", "parameters . add (  \"  - outDir \"  )  ;", "final   String   dirPath    =    relativeFileDir . getPath (  )  ;", "parameters . add ( dirPath )  ;", "final   File   expectedSchemaFile    =    new   File (  (  (  ( dirPath    +     ( File . separator )  )     +     ( relativeFile . getName (  )  )  )     +     \"  0  . xsd \"  )  )  ;", "if    ( expectedSchemaFile . exists (  )  )     {", "if    (  !  ( expectedSchemaFile . delete (  )  )  )     {", "Messages . showErrorDialog ( project ,    XmlBundle . message (  \" cant . delete . file \"  ,    expectedSchemaFile . getPath (  )  )  ,    XmlBundle . message (  \" error \"  )  )  ;", "return ;", "}", "}", "parameters . add (  \"  - outPrefix \"  )  ;", "parameters . add ( relativeFile . getName (  )  )  ;", "parameters . add ( url )  ;", "File   xsd    =    new   File (  (  ( dirPath    +     ( File . separator )  )     +     ( dialog . getTargetSchemaName (  )  )  )  )  ;", "final   VirtualFile   xsdFile    =    LocalFileSystem . getInstance (  )  . refreshAndFindFileByIoFile ( xsd )  ;", "if    ( xsdFile    !  =    null )     {", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >     {", "try    {", "xsdFile . delete ( null )  ;", "}    catch    (    e )     {", "}", "}  )  ;", "}", "Inst 2 Xsd . main ( ArrayUtil . toStringArray ( parameters )  )  ;", "if    ( expectedSchemaFile . exists (  )  )     {", "final   boolean   renamed    =    expectedSchemaFile . renameTo ( xsd )  ;", "if    (  ! renamed )     {", "Messages . showErrorDialog ( project ,    XmlBundle . message (  \" cant . rename . file \"  ,    expectedSchemaFile . getPath (  )  ,    xsd . getPath (  )  )  ,    XmlBundle . message (  \" error \"  )  )  ;", "}", "}", "VirtualFile   xsdVFile    =    LocalFileSystem . getInstance (  )  . refreshAndFindFileByIoFile ( xsd )  ;", "if    ( xsdVFile    !  =    null )     {", "FileEditorManager . getInstance ( project )  . openFile ( xsdVFile ,    true )  ;", "} else    {", "Messages . showErrorDialog ( project ,    XmlBundle . message (  \" xml 2 xsd . generator . error . message \"  )  ,    XmlBundle . message (  \" xml 2 xsd . generator . error \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doAction"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateSchemaFromInstanceDocumentAction"}, {"methodBody": ["METHOD_START", "{", "return    ( file    !  =    null )     &  &     (  \" xml \"  . equalsIgnoreCase ( file . getExtension (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAcceptableFile"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateSchemaFromInstanceDocumentAction"}, {"methodBody": ["METHOD_START", "{", "combo . setModel ( new   DefaultComboBoxModel ( ArrayUtil . toStringArray ( lastValues )  )  )  ;", "if    (  ( combo . getItemCount (  )  )     !  =     0  )     {", "combo . setSelectedIndex (  0  )  ;", "combo . getEditor (  )  . selectAll (  )  ;", "}", "}", "METHOD_END"], "methodName": ["configureComboBox"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateSchemaFromInstanceDocumentDialog"}, {"methodBody": ["METHOD_START", "{", "textComponent . setLabelFor ( component )  ;", "if    ( component   instanceof   JTextField )     {", "(  ( JTextField )     ( component )  )  . get (  )  . addListener ( new   Listener (  )     {", "@ Override", "public   void   insertUpdate ( Event   e )     {", "validateData (  )  ;", "}", "@ Override", "public   void   removeUpdate ( Event   e )     {", "validateData (  )  ;", "}", "@ Override", "public   void   changedUpdate ( Event   e )     {", "validateData (  )  ;", "}", "}  )  ;", "} else", "if    ( component   instanceof   JComboBox )     {", "JComboBox   jComboBox    =     (  ( JComboBox )     ( component )  )  ;", "jComboBox . addActionListener ( new   ActionListener (  )     {", "@ Override", "public   void   actionPerformed ( ActionEvent   e )     {", "validateData (  )  ;", "}", "}  )  ;", "if    ( jComboBox . isEditable (  )  )     {", "jComboBox . getEditor (  )  . getEditorComponent (  )  . addKeyListener ( new   KeyAdapter (  )     {", "@ Override", "public   void   keyTyped ( KeyEvent   e )     {", "validateData (  )  ;", "}", "}  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doInitFor"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateSchemaFromInstanceDocumentDialog"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( new   File ( generateFromUrl . getText (  )  )  . exists (  )  )  )     {", "return   XmlBundle . message (  \" instance . document . file . is . not . exist \"  )  ;", "}", "try    {", "int   i    =    Integer . parseInt ( getEnumerationsLimit (  )  )  ;", "if    ( i    <     0  )", "return   XmlBundle . message (  \" negative . number . validation . problem \"  )  ;", "}    catch    ( NumberFormatException   ex )     {", "return   XmlBundle . message (  \" invalid . number . validation . problem \"  )  ;", "}", "if    (  (  ( getTargetSchemaName (  )  )     =  =    null )     |  |     (  ( getTargetSchemaName (  )  . length (  )  )     =  =     0  )  )     {", "return   XmlBundle . message (  \" result . schema . file . name . is . empty . validation . problem \"  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["doValidateWithData"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateSchemaFromInstanceDocumentDialog"}, {"methodBody": ["METHOD_START", "{", "return    (  ( String )     ( designType . getSelectedItem (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getDesignType"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateSchemaFromInstanceDocumentDialog"}, {"methodBody": ["METHOD_START", "{", "return   detectEnumerationsLimit . getText (  )  ;", "}", "METHOD_END"], "methodName": ["getEnumerationsLimit"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateSchemaFromInstanceDocumentDialog"}, {"methodBody": ["METHOD_START", "{", "return    (  ( String )     ( detectSimpleContentTypes . getSelectedItem (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSimpleContentType"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateSchemaFromInstanceDocumentDialog"}, {"methodBody": ["METHOD_START", "{", "return   status ;", "}", "METHOD_END"], "methodName": ["getStatusField"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateSchemaFromInstanceDocumentDialog"}, {"methodBody": ["METHOD_START", "{", "return   statusText ;", "}", "METHOD_END"], "methodName": ["getStatusTextField"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateSchemaFromInstanceDocumentDialog"}, {"methodBody": ["METHOD_START", "{", "return   resultSchemaFileName . getText (  )  ;", "}", "METHOD_END"], "methodName": ["getTargetSchemaName"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateSchemaFromInstanceDocumentDialog"}, {"methodBody": ["METHOD_START", "{", "return   generateFromUrl ;", "}", "METHOD_END"], "methodName": ["getUrl"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateSchemaFromInstanceDocumentDialog"}, {"methodBody": ["METHOD_START", "{", "return   generateFromUrlText ;", "}", "METHOD_END"], "methodName": ["getUrlText"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateSchemaFromInstanceDocumentDialog"}, {"methodBody": ["METHOD_START", "{", "generateFromUrl . setText ( url )  ;", "}", "METHOD_END"], "methodName": ["setFileUrl"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateSchemaFromInstanceDocumentDialog"}, {"methodBody": ["METHOD_START", "{", "myOkAction    =    okAction ;", "}", "METHOD_END"], "methodName": ["setOkAction"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateSchemaFromInstanceDocumentDialog"}, {"methodBody": ["METHOD_START", "{", "String   msg    =    doValidateWithData (  )  ;", "setOKAEnabled (  ( msg    =  =    null )  )  ;", "status . setText (  ( msg    =  =    null    ?     \"  \"     :    msg )  )  ;", "status . setForeground ( RED )  ;", "}", "METHOD_END"], "methodName": ["validateData"], "fileName": "com.intellij.xml.actions.xmlbeans.GenerateSchemaFromInstanceDocumentDialog"}, {"methodBody": ["METHOD_START", "{", "wsdlUrl . getButton (  )  . setToolTipText ( XmlBundle . message (  \" browse . button . tooltip \"  )  )  ;", "wsdlUrl . getButton (  )  . addActionListener ( new   ActionListener (  )     {", "@ Override", "public   void   Performed ( ActionEvent   Event )     {", "final   FileChooserDescriptor   fileChooserDescriptor    =    new   FileChooserDescriptor ( true ,    false ,    false ,    false ,    false ,    multipleFileSelection )     {", "private   final   List < String >    extensions    =    Arrays . asList (  _ extensions )  ;", "@ Override", "public   boolean   isFileSelectable ( VirtualFile   virtualFile )     {", "return   extensions . contains ( virtualFile . getExtension (  )  )  ;", "}", "@ Override", "public   boolean   isFileVisible ( VirtualFile   file ,    boolean   showHiddenFiles )     {", "return    ( super . isFileVisible ( file ,    showHiddenFiles )  )     &  &     (  ( file . isDirectory (  )  )     |  |     ( isFileSelectable ( file )  )  )  ;", "}", "}  ;", "fileChooserDescriptor . setTitle ( selectFileDialogTitle )  ;", "VirtualFile   initialFile    =    myProject . getBaseDir (  )  ;", "String   selectedItem    =    wsdlUrl . getTextField (  )  . getText (  )  ;", "if    (  ( selectedItem    !  =    null )     &  &     ( selectedItem . startsWith ( PROTOCOL _ PREFIX )  )  )     {", "VirtualFile   fileByPath    =    VfsUtilCore . findRelativeFile ( ExternalResourceManager . getInstance (  )  . getResourceLocation ( VfsUtilCore . fixURLforIDEA ( selectedItem )  )  ,    null )  ;", "if    ( fileByPath    !  =    null )", "initialFile    =    fileByPath ;", "}", "final   VirtualFile [  ]    virtualFiles    =    FileChooser . chooseFiles ( fileChooserDescriptor ,    myProject ,    initialFile )  ;", "if    (  ( virtualFiles . length )     =  =     1  )     {", "String   url    =    VfsUtilCore . fixIDEAUrl ( virtualFiles [  0  ]  . getUrl (  )  )  ;", "wsdlUrl . setText ( url )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureBrowseButton"], "fileName": "com.intellij.xml.actions.xmlbeans.UIUtils"}, {"methodBody": ["METHOD_START", "{", "PsiMetaData   metaData    =    rootTag . getMetaData (  )  ;", "if    ( metaData   iof   XmlNSDescriptorImpl )     {", "XmlNSDescriptorImpl   nsDescriptor    =     (  ( XmlNSDescriptorImpl )     ( metaData )  )  ;", "List < String >    elementDescriptors    =    new   ArrayList <  >  (  )  ;", "XmlElementDescriptor [  ]    rootElementsDescriptors    =    nsDescriptor . getRootElementsDescriptors ( PsiTreeUtil . getParentOfType ( rootTag ,    XmlDocument . class )  )  ;", "for    ( XmlElementDescriptor   e    :    rootElementsDescriptors )     {", "elementDescriptors . add ( e . getName (  )  )  ;", "}", "return   elementDescriptors ;", "}", "return   Collections . emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["addVariantsFromRootTag"], "fileName": "com.intellij.xml.actions.xmlbeans.Xsd2InstanceUtils"}, {"methodBody": ["METHOD_START", "{", "Set   flags    =    new   HashSet (  )  ;", "Set   opts    =    new   HashSet (  )  ;", "flags . add (  \" h \"  )  ;", "flags . add (  \" help \"  )  ;", "flags . add (  \" usage \"  )  ;", "flags . add (  \" license \"  )  ;", "flags . add (  \" version \"  )  ;", "flags . add (  \" dl \"  )  ;", "flags . add (  \" noupa \"  )  ;", "flags . add (  \" nopvr \"  )  ;", "flags . add (  \" partial \"  )  ;", "opts . add (  \" name \"  )  ;", "CommandLine   cl    =    new   CommandLine ( args ,    flags ,    opts )  ;", "String [  ]    badOpts    =    cl . getBadOpts (  )  ;", "if    (  ( badOpts . length )     >     0  )     {", "throw   new   IllegalArgumentException (  (  \" Unrecognized   option :     \"     +     ( badOpts [  0  ]  )  )  )  ;", "}", "boolean   dl    =     ( cl . getOpt (  \" dl \"  )  )     !  =    null ;", "boolean   nopvr    =     ( cl . getOpt (  \" nopvr \"  )  )     !  =    null ;", "boolean   noupa    =     ( cl . getOpt (  \" noupa \"  )  )     !  =    null ;", "File [  ]    schemaFiles    =    cl . filesEndingWith (  \"  . xsd \"  )  ;", "String   rootName    =    cl . getOpt (  \" name \"  )  ;", "if    ( rootName    =  =    null )     {", "throw   new   IllegalArgumentException (  \" Required   option    \\  \"  - name \\  \"    must   be   present \"  )  ;", "}", "List   sdocs    =    new   ArrayList (  )  ;", "for    ( File   schemaFile    :    schemaFiles )     {", "try    {", "sdocs . add ( Factory . parse ( schemaFile ,    new   XmlOp )  . setLoadLineNumbers (  )  . setLoadMessageDigest (  )  )  )  ;", "}    catch    ( Exception   e )     {", "throw   new   IllegalArgumentException (  (  (  (  \" Can   not   load   schema   file :     \"     +    schemaFile )     +     \"  :     \"  )     +     ( e . getLocalizedMessage (  )  )  )  )  ;", "}", "}", "XmlObject [  ]    schemas    =     (  ( XmlObject [  ]  )     ( sdocs . toArray ( new   XmlObject [  0  ]  )  )  )  ;", "SchemaTypeSystem   sts    =    null ;", "if    (  ( schemas . length )     >     0  )     {", "XmlOpcompileOp =    new   XmlOp )  ;", "if    ( dl )", "compileOpsetCompileDownloadUrls (  )  ;", "if    ( nopvr )", "compileOpsetCompileNoPvrRule (  )  ;", "if    ( noupa )", "compileOpsetCompileNoUpaRule (  )  ;", "try    {", "sts    =    XmlBeans . compileXsd ( schemas ,    XmlBeans . getBuiltinTypeSystem (  )  ,    compileOp ;", "}    catch    ( XmlException   e )     {", "StringBuilder   out    =    new   StringBuilder (  \" Schema   compilation   errors :     \"  )  ;", "Collection   errors    =    e . getErrors (  )  ;", "for    ( Object   error    :    errors )", "out . append (  \"  \\ n \"  )  . append ( error )  ;", "throw   new   IllegalArgumentException ( out . toString (  )  )  ;", "}", "}", "if    ( sts    =  =    null )     {", "throw   new   IllegalArgumentException (  \" No   Schemas   to   process .  \"  )  ;", "}", "SchemaType [  ]    globalElems    =    sts . documentTypes (  )  ;", "SchemaType   elem    =    null ;", "for    ( SchemaType   globalElem    :    globalElems )     {", "if    ( rootName . equals ( globalElem . getDocumentElementName (  )  . getLocalPart (  )  )  )     {", "elem    =    globalElem ;", "break ;", "}", "}", "if    ( elem    =  =    null )     {", "throw   new   IllegalArgumentException (  (  (  \" Could   not   find   a   global   element   with   name    \\  \"  \"     +    rootName )     +     \"  \\  \"  \"  )  )  ;", "}", "return   SampleXmlUtil . createSampleForType ( elem )  ;", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "com.intellij.xml.actions.xmlbeans.Xsd2InstanceUtils"}, {"methodBody": ["METHOD_START", "{", "final   PsiMetaData   metaData    =    tag . getMetaData (  )  ;", "if    ( metaData   iof   XmlNSDescriptorImpl )     {", "final   XmlNSDescriptorImpl   nsDescriptor    =     (  ( XmlNSDescriptorImpl )     ( metaData )  )  ;", "return   nsDescriptor . getElementDescriptor ( elementName ,    nsDescriptor . getDefaultNamespace (  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "com.intellij.xml.actions.xmlbeans.Xsd2InstanceUtils"}, {"methodBody": ["METHOD_START", "{", "final   String   fileName    =    file . getName (  )  ;", "String   previous    =    scannedToFileName . get ( fileName )  ;", "if    ( previous    !  =    null )", "return   previous ;", "scannedToFileName . put ( fileName ,    fileName )  ;", "final   StringBuilder   result    =    new   StringBuilder (  )  ;", "file . acceptChildren ( new   XmlRecursiveElementVisitor (  )     {", "@ Override", "public   void   visitElement ( PsiElement   psiElement )     {", "super . visitElement ( psiElement )  ;", "if    ( psiElement   instanceof   LeafPsiElement )     {", "final   String   text    =    psiElement . getText (  )  ;", "result . append ( text )  ;", "}", "}", "@ Override", "public   void   visitXmlAttribute ( XmlAttribute   xmlAttribute )     {", "boolean   replaced    =    false ;", "if    ( xmlAttribute . isNamespaceDeclaration (  )  )     {", "replaced    =    true ;", "final   String   value    =    xmlAttribute . getValue (  )  ;", "result . append ( xmlAttribute . getText (  )  )  . append (  \"     \"  )  ;", "if    (  !  ( scannedToFileName . containsKey ( value )  )  )     {", "final   XmlNSDescriptor   nsDescriptor    =    xmlAttribute . getParent (  )  . getNSDescriptor ( value ,    true )  ;", "if    ( nsDescriptor    !  =    null )     {", ". processAndSaveAllSchemas ( nsDescriptor . getDescriptorFile (  )  ,    scannedToFileName ,    schemaReferenceProcessor )  ;", "}", "}", "} else", "if    (  \" schemaLocation \"  . equals ( xmlAttribute . getName (  )  )  )     {", "final   com . intellij . psi . PsiReference [  ]    references    =    xmlAttribute . getValueElement (  )  . getReferences (  )  ;", "if    (  ( references . length )     >     0  )     {", "PsiElement   psiElement    =    references [  0  ]  . resolve (  )  ;", "if    ( psiElement   instanceof   XmlFile )     {", "final   String   s    =     . processAndSaveAllSchemas (  (  ( XmlFile )     ( psiElement )  )  ,    scannedToFileName ,    schemaReferenceProcessor )  ;", "if    ( s    !  =    null )     {", "result . append ( xmlAttribute . getName (  )  )  . append (  \"  =  '  \"  )  . append ( s )  . append (  '  \\  '  '  )  ;", "replaced    =    true ;", "}", "}", "}", "}", "if    (  ! replaced )", "result . append ( xmlAttribute . getText (  )  )  ;", "}", "}  )  ;", "final   VirtualFile   virtualFile    =    file . getVirtualFile (  )  ;", "final   String   content    =    result . toString (  )  ;", "byte [  ]    bytes ;", "if    ( virtualFile    !  =    null )     {", "bytes    =    content . getBytes ( virtualFile . getCharset (  )  )  ;", "} else    {", "try    {", "final   String   charsetName    =    XmlUtil . extractXmlEncodingFromProlog ( content . getBytes (  )  )  ;", "bytes    =     ( charsetName    !  =    null )     ?    content . getBytes ( charsetName )     :    content . getBytes (  )  ;", "}    catch    ( UnsupportedEncodingException   e )     {", "bytes    =    content . getBytes (  )  ;", "}", "}", "schemaReferenceProcessor . processSchema ( fileName ,    bytes )  ;", "return   fileName ;", "}", "METHOD_END"], "methodName": ["processAndSaveAllSchemas"], "fileName": "com.intellij.xml.actions.xmlbeans.Xsd2InstanceUtils"}, {"methodBody": ["METHOD_START", "{", "myEntries . add ( entry )  ;", "}", "METHOD_END"], "methodName": ["addEntry"], "fileName": "com.intellij.xml.arrangement.XmlArrangementParseInfo"}, {"methodBody": ["METHOD_START", "{", "return   myEntries ;", "}", "METHOD_END"], "methodName": ["getEntries"], "fileName": "com.intellij.xml.arrangement.XmlArrangementParseInfo"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( range . getStartOffset (  )  )     =  =     0  )     &  &     (  ( range . getEndOffset (  )  )     =  =     0  )  )     |  |     (  !  ( isWithinBounds ( range )  )  )  )     {", "return   null ;", "}", "final   DefaultEntry   current    =    getCurrent (  )  ;", "final   XmlElementEntry   entry    =    new   XmlElementEntry ( current ,    range ,    type ,    name ,    namespace ,    canBeMatched )  ;", "if    ( current    =  =    null )     {", "myInfo . addEntry ( entry )  ;", "} else    {", "current . addChild ( entry )  ;", "}", "return   entry ;", "}", "METHOD_END"], "methodName": ["createNewEntry"], "fileName": "com.intellij.xml.arrangement.XmlArrangementVisitor"}, {"methodBody": ["METHOD_START", "{", "return   myStack . isEmpty (  )     ?    null    :    myStack . peek (  )  ;", "}", "METHOD_END"], "methodName": ["getCurrent"], "fileName": "com.intellij.xml.arrangement.XmlArrangementVisitor"}, {"methodBody": ["METHOD_START", "{", "for    ( TextRange   textRange    :    myRanges )     {", "if    ( textRangersects ( range )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isWithinBounds"], "fileName": "com.intellij.xml.arrangement.XmlArrangementVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( entry    =  =    null )     |  |     ( nextEl =  =    null )  )     {", "return ;", "}", "myStack . push ( entry )  ;", "try    {", "nextElacceptChildren ( this )  ;", "}    finally    {", "myStack . pop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["processEntry"], "fileName": "com.intellij.xml.arrangement.XmlArrangementVisitor"}, {"methodBody": ["METHOD_START", "{", "return   new   com . intellij . psi . codeStyle . arrangement . match . StdArrangementMatchRule ( new   com . intellij . psi . codeStyle . arrangement . match . StdArrangementEntryMatcher ( ArrangementUtil . combine ( new   com . intellij . psi . codeStyle . arrangement . model . ArrangementAtomMatchCondition ( Regexp . NAME ,    nameFilter )  ,    new   com . intellij . psi . codeStyle . arrangement . model . ArrangementAtomMatchCondition ( Regexp . XML _ NAMESPACE ,    namespaceFilter )  )  )  ,    orderType )  ;", "}", "METHOD_END"], "methodName": ["attrArrangementRule"], "fileName": "com.intellij.xml.arrangement.XmlRearranger"}, {"methodBody": ["METHOD_START", "{", "myListeners . add ( listener )  ;", "}", "METHOD_END"], "methodName": ["addBreadcrumbsItemListener"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsComponent"}, {"methodBody": ["METHOD_START", "{", "if    (  ( elements . size (  )  )     =  =     0  )     {", "return   null ;", "}", "final   LinkedList <  . Crumb >    result    =    new   LinkedList <  >  (  )  ;", "int   screenWidth    =     0  ;", ". Crumb   rightmostCrumb    =    null ;", "final    . NavigationCrumb   fwd    =    new    . NavigationCrumb ( this ,    fm ,    true ,     . DEFAULT _ PAINTER )  ;", "for    ( int   i    =     ( elements . size (  )  )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "final    . NavigationCrumb   forward    =    new    . NavigationCrumb ( this ,    fm ,    true ,     . DEFAULT _ PAINTER )  ;", "final    . NavigationCrumb   backward    =    new    . NavigationCrumb ( this ,    fm ,    false ,     . DEFAULT _ PAINTER )  ;", "final   BreadcrumbsItem   element    =    elements . get ( i )  ;", "final   String   s    =    element . getDisplayText (  )  ;", "final   Dimension   d    =     . DEFAULT _ PAINTER . getSize ( s ,    fm ,     (  ( width    -     ( forward . getWidth (  )  )  )     -     ( backward . getWidth (  )  )  )  )  ;", "final    . Crumb   crumb    =    new    . Crumb ( this ,    s ,     (  ( d . width )     +     (  . EXTRA _ WIDTH )  )  ,    element )  ;", "if    (  ( screenWidth    +     ( d . width )  )     >    width )     {", ". Crumb   first    =    null ;", "if    (  (  ( screenWidth    +     ( backward . getWidth (  )  )  )     >    width )     &  &     (  !  ( result . isEmpty (  )  )  )  )     {", "first    =    result . removeFirst (  )  ;", "screenWidth    -  =    first . getWidth (  )  ;", "}", "result . addFirst ( backward )  ;", "screenWidth    +  =     ( backward . getWidth (  )  )     -     ( myOffset )  ;", "int   dummyWidth    =    width    -    screenWidth ;", "if    ( dummyWidth    >     0  )     {", "final    . DummyCrumb   dummy    =    new    . DummyCrumb ( dummyWidth )  ;", "if    ( rightmostCrumb    !  =    null )     {", "result . add (  (  ( result . indexOf ( rightmostCrumb )  )     +     1  )  ,    dummy )  ;", "} else    {", "result . addLast ( dummy )  ;", "}", "}", "screenWidth    =    forward . getWidth (  )  ;", "result . addFirst ( forward )  ;", "if    ( first    !  =    null )     {", "result . addFirst ( first )  ;", "screenWidth    +  =    first . getWidth (  )  ;", "}", "rightmostCrumb    =     ( first    !  =    null )     ?    first    :    crumb ;", "}", "result . addFirst ( crumb )  ;", "screenWidth    +  =    d . width ;", "}", "if    (  ( rightmostCrumb    !  =    null )     &  &     ( screenWidth    <    width )  )     {", "result . add (  (  ( result . indexOf ( rightmostCrumb )  )     +     2  )  ,    new    . DummyCrumb (  (  (  ( width    -    screenWidth )     -     ( fwd . getWidth (  )  )  )     -     8  )  )  )  ;", "}", "int   offset    =    myOffset ;", "for    ( final    . Crumb   each    :    result )     {", "each . setOffset ( offset )  ;", "offset    +  =    each . getWidth (  )  ;", "}", "if    (  ( result . size (  )  )     >     0  )     {", "for    ( int   i    =     ( result . size (  )  )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "final    . Crumb   c    =    result . get ( i )  ;", "if    (  !  ( c   instanceof    . DummyCrumb )  )     {", "c . setSelected ( true )  ;", "break ;", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["createCrumbList"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsComponent"}, {"methodBody": ["METHOD_START", "{", "if    ( item    !  =    null )     {", "for    ( ItemListener   listener    :    myListeners )     {", "listener . itemSelected ( item ,    modifiers )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["fireItemSelected"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsComponent"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myCrumbs )     !  =    null )     {", "final   Rectangle   r    =    getBounds (  )  ;", "p . translate ( r . x ,    r . y )  ;", "if    (  !  ( r . contains ( p )  )  )     {", "return   null ;", "}", "if    (  ( myBuffer )     =  =    null )     {", "return   null ;", "}", "final   int   offset    =    myBuffer . getPageOffset (  )  ;", "for    ( final    . Crumb   each    :    myCrumbs )     {", "if    (  (  (  ( p . x )     +    offset )     >  =     ( each . getOffset (  )  )  )     &  &     (  (  ( p . x )     +    offset )     <     (  ( each . getOffset (  )  )     +     ( each . getWidth (  )  )  )  )  )     {", "return   each ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getCrumb"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsComponent"}, {"methodBody": ["METHOD_START", "{", "int   totalWidth    =     0  ;", "for    ( final    . Crumb   each    :    crumbList )     {", "totalWidth    +  =    each . getWidth (  )  ;", "}", "return   totalWidth ;", "}", "METHOD_END"], "methodName": ["getTotalWidth"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsComponent"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myBuffer )     !  =    null )     {", "final      page    =    myBuffer . getPage (  )  ;", "if    (  ( page    +     1  )     <     ( myBuffer . getPageCount (  )  )  )     {", "myBuffer . setPage (  ( page    +     1  )  )  ;", "}", "}", "repa (  )  ;", "}", "METHOD_END"], "methodName": ["nextPage"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsComponent"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myBuffer )     !  =    null )     {", "final      page    =    myBuffer . getPage (  )  ;", "if    (  ( page    -     1  )     >  =     0  )     {", "myBuffer . setPage (  ( page    -     1  )  )  ;", "}", "}", "repa (  )  ;", "}", "METHOD_END"], "methodName": ["previousPage"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsComponent"}, {"methodBody": ["METHOD_START", "{", "myListeners . remove ( listener )  ;", "}", "METHOD_END"], "methodName": ["removeBreadcrumbsItemListener"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsComponent"}, {"methodBody": ["METHOD_START", "{", "if    ( crumb    !  =    null )     {", "crumb . setHovered ( true )  ;", "}", "if    (  ( myHovered )     !  =    null )     {", "myHovered . setHovered ( false )  ;", "}", "myHovered    =    crumb ;", "for    ( ItemListener   listener    :    myListeners )     {", "listener . itemHovered (  (  ( myHovered )     !  =    null    ?    myHovered . myItem    :    null )  )  ;", "}", "repaint (  )  ;", "}", "METHOD_END"], "methodName": ["setHoveredCrumb"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsComponent"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myItems )     !  =    itemsList )     {", "myItems    =    itemsList ;", "myC    =    null ;", "}", "repaint (  )  ;", "}", "METHOD_END"], "methodName": ["setItems"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsComponent"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myOffset )     !  =    offset )     {", "myOffset    =    offset ;", "repa (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setOffset"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsComponent"}, {"methodBody": ["METHOD_START", "{", "final   T   selectedElement    =    c . getItem (  )  ;", "final   Set < BreadcrumbsItem >    items    =    new   HashSet <  >  (  )  ;", "boolean   light    =    false ;", "for    ( final    . Crumb   each    :    myCrumbs )     {", "final   BreadcrumbsItem   item    =    each . getItem (  )  ;", "if    (  ( item    !  =    null )     &  &     ( items . contains ( item )  )  )     {", "light    =    false ;", "}", "each . setLight ( light )  ;", "if    (  ( item    !  =    null )     &  &     (  ! light )  )     {", "items . add ( item )  ;", "}", "if    ( selectedElement    =  =    item )     {", "each . setSelected ( true )  ;", "light    =    true ;", "} else    {", "each . setSelected ( false )  ;", "}", "}", "fireItemSelected ( selectedElement ,    modifiers )  ;", "repaint (  )  ;", "}", "METHOD_END"], "methodName": ["setSelectedCrumb"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsComponent"}, {"methodBody": ["METHOD_START", "{", "return    (  ( above )     !  =    null )     &  &     ( above . isSelected (  )  )  ;", "}", "METHOD_END"], "methodName": ["isBreadcrumbsAbove"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsConfigurable"}, {"methodBody": ["METHOD_START", "{", "return    (  ( show )     !  =    null )     &  &     ( show . isSelected (  )  )  ;", "}", "METHOD_END"], "methodName": ["isBreadcrumbsShown"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsConfigurable"}, {"methodBody": ["METHOD_START", "{", "JRadioButton   button    =     ( value )     ?    above    :    below ;", "if    ( button    !  =    null )", "button . setSelected ( true )  ;", "}", "METHOD_END"], "methodName": ["setBreadcrumbsAbove"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsConfigurable"}, {"methodBody": ["METHOD_START", "{", "if    (  ( show )     !  =    null )", "show . setSelected ( value )  ;", "}", "METHOD_END"], "methodName": ["setBreadcrumbsShown"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsConfigurable"}, {"methodBody": ["METHOD_START", "{", "boolean   enabled    =    isBreadcrumbsShown (  )  ;", "if    (  ( above )     !  =    null )", "above . setEnabled ( enabled )  ;", "if    (  ( below )     !  =    null )", "below . setEnabled ( enabled )  ;", "if    (  ( placement )     !  =    null )", "placement . setEnabled ( enabled )  ;", "if    (  ( languages )     !  =    null )", "languages . setEnabled ( enabled )  ;", "for    ( JCheckBox   box    :    map . values (  )  )", "box . setEnabled ( enabled )  ;", "}", "METHOD_END"], "methodName": ["updateEnabled"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsConfigurable"}, {"methodBody": ["METHOD_START", "{", "if    ( wrapper . breadcrumbs . above )     {", "manager . addTopComponent ( editor ,    wrapper )  ;", "} else    {", "manager . addBottomComponent ( editor ,    wrapper )  ;", "}", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsInitializingActivity"}, {"methodBody": ["METHOD_START", "{", "BreadcrumbsInitializingActivity . remove ( fileEditorManager ,    fileEditor ,    wrapper )  ;", "Disposer . dispose ( wrapper )  ;", "}", "METHOD_END"], "methodName": ["disposeWrapper"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsInitializingActivity"}, {"methodBody": ["METHOD_START", "{", "if    ( file   instanceof   HttpVirtualFile )     {", "return   false ;", "}", "return    ( editor . isValid (  )  )     &  &     (  ( XmlWrapper . findInfoProvider ( editor . getEditor (  )  ,    file )  )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["isSuitable"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsInitializingActivity"}, {"methodBody": ["METHOD_START", "{", "BreadcrumbsInitializingActivity . add ( fileEditorManager ,    fileEditor ,    wrapper )  ;", "Disposer . register ( fileEditor ,     (  )     -  >    disposeWrapper ( fileEditorManager ,    fileEditor ,    wrapper )  )  ;", "}", "METHOD_END"], "methodName": ["registerWrapper"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsInitializingActivity"}, {"methodBody": ["METHOD_START", "{", "boolean   above    =    EditorSettingsExternalizable . getInstance (  )  . isBreadcrumbsAbove (  )  ;", "for    ( FileEditor   fileEditor    :    fileEditorManager . getAllEditors ( file )  )     {", "if    ( fileEditor   instanceof   TextEditor )     {", "TextEditor   textEditor    =     (  ( TextEditor )     ( fileEditor )  )  ;", "Editor   editor    =    textEditor . getEditor (  )  ;", "BreadcrumbsXmlWrapper   wrapper    =    BreadcrumbsXmlWrapper . getBreadcrumbsComponent ( editor )  ;", "if    (  . isSuitable ( textEditor ,    file )  )     {", "if    ( wrapper    !  =    null )     {", "if    (  ( wrapper . breadcrumbs . above )     !  =    above )     {", ". remove ( fileEditorManager ,    fileEditor ,    wrapper )  ;", "wrapper . breadcrumbs . above    =    above ;", ". add ( fileEditorManager ,    fileEditor ,    wrapper )  ;", "}", "wrapper . queueUpdate (  )  ;", "} else    {", ". registerWrapper ( fileEditorManager ,    fileEditor ,    new   BreadcrumbsXmlWrapper ( editor )  )  ;", "}", "} else", "if    ( wrapper    !  =    null )     {", ". disposeWrapper ( fileEditorManager ,    fileEditor ,    wrapper )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["reinitBreadcrumbsComponent"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsInitializingActivity"}, {"methodBody": ["METHOD_START", "{", "if    ( project . isDisposed (  )  )", "return ;", "FileEditorManager   fileEditorManager    =    FileEditorManager . getInstance ( project )  ;", "for    ( VirtualFile   virtualFile    :    fileEditorManager . getOpenFiles (  )  )     {", ". reinitBreadcrumbsComponent ( fileEditorManager ,    virtualFile )  ;", "}", "}", "METHOD_END"], "methodName": ["reinitBreadcrumbsInAllEditors"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsInitializingActivity"}, {"methodBody": ["METHOD_START", "{", "if    ( wrapper . breadcrumbs . above )     {", "manager . removeTopComponent ( editor ,    wrapper )  ;", "} else    {", "manager . removeBottomComponent ( editor ,    wrapper )  ;", "}", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsInitializingActivity"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getPresentation"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsItem"}, {"methodBody": ["METHOD_START", "{", "return    \"  \"  ;", "}", "METHOD_END"], "methodName": ["getTooltip"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsItem"}, {"methodBody": ["METHOD_START", "{", "if    (  ( file    =  =    null )     |  |     (  !  ( file . isValid (  )  )  )  )", "return   null ;", "PriorityQueue < PsiElement >    leafs    =    new   PriorityQueue <  >  (  3  ,     (    o 1  ,    o 2  )     -  >     {", "TextRange   range 1     =    o 1  . getTextRange (  )  ;", "if    ( range 1     =  =    null )     {", ". LOG . error (  ( o 1     +     \"    returned   null   range \"  )  )  ;", "return    1  ;", "}", "TextRange   range 2     =    o 2  . getTextRange (  )  ;", "if    ( range 2     =  =    null )     {", ". LOG . error (  ( o 2     +     \"    returned   null   range \"  )  )  ;", "return    -  1  ;", "}", "return    ( range 2  . getStartOffset (  )  )     -     ( range 1  . getStartOffset (  )  )  ;", "}  )  ;", "FileViewProvider   viewProvider    =     . findViewProvider ( file ,    project )  ;", "if    ( viewProvider    =  =    null )", "return   null ;", "for    ( final   Language   language    :    viewProvider . getLanguages (  )  )     {", "ContainerUtil . addIfNotNull ( leafs ,    viewProvider . findElementAt ( offset ,    language )  )  ;", "}", "while    (  !  ( leafs . isEmpty (  )  )  )     {", "final   PsiElement   element    =    leafs . remove (  )  ;", "if    (  !  ( element . isValid (  )  )  )", "continue ;", "BreadcrumbsProvider   provider    =     . findProviderForElement ( element ,    defaultInfoProvider )  ;", "if    (  ( provider    !  =    null )     &  &     ( provider . acceptElement ( element )  )  )     {", "return   element ;", "}", "if    (  !  ( element   instanceof   PsiFile )  )     {", "ContainerUtil . addIfNotNull ( leafs ,     . getParent ( element ,    provider )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findFirstBreadcrumbedElement"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "EditorSettingsExternalizable   settings    =    EditorSettingsExternalizable . getInstance (  )  ;", "if    ( checkSettings    &  &     (  !  ( settings . isShown (  )  )  )  )", "return   null ;", "Language   baseLang    =    viewProvider . getBaseLanguage (  )  ;", "if    ( checkSettings    &  &     (  !  ( settings . isShownFor ( baseLang . getID (  )  )  )  )  )", "return   null ;", "Provider   provider    =    Util . getInfoProvider ( baseLang )  ;", "if    ( provider    =  =    null )     {", "for    ( Language   language    :    viewProvider . getLanguages (  )  )     {", "if    (  (  ! checkSettings )     |  |     ( settings . isShownFor ( language . getID (  )  )  )  )     {", "provider    =    Util . getInfoProvider ( language )  ;", "if    ( provider    !  =    null )", "break ;", "}", "}", "}", "return   provider ;", "}", "METHOD_END"], "methodName": ["findInfoProvider"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "Project   project    =    editor . getProject (  )  ;", "return   project    =  =    null    ?    null    :     . findInfoProvider ( editor ,     . findViewProvider ( file ,    project )  )  ;", "}", "METHOD_END"], "methodName": ["findInfoProvider"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "if    ( viewProvider    =  =    null )", "return   null ;", "Boolean   shown    =    ToggleBreadcrumbsAction . getForcedShown ( editor )  ;", "return    ( shown    !  =    null )     &  &     (  ! shown )     ?    null    :     . findInfoProvider (  ( shown    =  =    null )  ,    viewProvider )  ;", "}", "METHOD_END"], "methodName": ["findInfoProvider"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "Language   language    =    element . getLanguage (  )  ;", "if    (  !  ( EditorSettingsExternalizable . getInstance (  )  . isShownFor ( language . getID (  )  )  )  )", "return   defaultProvider ;", "Provider   provider    =    Util . getInfoProvider ( language )  ;", "return   provider    =  =    null    ?    defaultProvider    :    provider ;", "}", "METHOD_END"], "methodName": ["findProviderForElement"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "if    ( editor    =  =    null )", "return   null ;", "Project   project    =    editor . getProject (  )  ;", "if    ( project    =  =    null )", "return   null ;", "VirtualFile   file    =     . getVirtualFile ( editor )  ;", "return    . findViewProvider ( file ,    project )  ;", "}", "METHOD_END"], "methodName": ["findViewProvider"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( file    =  =    null )     |  |     ( file . isDirectory (  )  )  )", "return   null ;", "return   PsiManager . getInstance ( project )  . findViewProvider ( file )  ;", "}", "METHOD_END"], "methodName": ["findViewProvider"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "return   editor . getUserData ( BreadcrumbsXmlWrapper . BREADCRUMBS _ COMPONENT _ KEY )  ;", "}", "METHOD_END"], "methodName": ["getBreadcrumbsComponent"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "return   this ;", "}", "METHOD_END"], "methodName": ["getComponent"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "for    ( BreadcrumbsPresentationProvider   provider    :    BreadcrumbsPresentationProvider . EP _ NAME . getExtensions (  )  )     {", "final   CrumbPresentation [  ]    presentations    =    provider . getCrumbPresentations ( elements )  ;", "if    ( presentations    !  =    null )     {", "return   presentations ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getCrumbPresentations"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "return   ComplementaryFontsRegistry . getFontAbleToDisplay (  ' a '  ,    Font . PLAIN ,    editor . getColorsScheme (  )  . getFontPreferences (  )  ,    null )  . getFont (  )  ;", "}", "METHOD_END"], "methodName": ["getEditorFont"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "PsiElement   element    =    BreadcrumbsXmlWrapper . findFirstBreadcrumbedElement ( offset ,    file ,    project ,    defaultInfoProvider )  ;", "if    ( element    =  =    null )", "return   null ;", "LinkedList < Pair < PsiElement ,    BreadcrumbsProvider >  >    result    =    new   LinkedList <  >  (  )  ;", "while    ( element    !  =    null )     {", "BreadcrumbsProvider   provider    =    BreadcrumbsXmlWrapper . findProviderForElement ( element ,    defaultInfoProvider )  ;", "if    (  ( provider    !  =    null )     &  &     ( provider . acceptElement ( element )  )  )     {", "result . addFirst ( Pair . create ( element ,    provider )  )  ;", "}", "element    =    BreadcrumbsXmlWrapper . getParent ( element ,    provider )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getLineElements"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "Collection < Pair < PsiElement ,    BreadcrumbsProvider >  >    pairs    =    BreadcrumbsXmlWrapper . getLineElements ( offset ,    file ,    project ,    infoProvider )  ;", "return   pairs    =  =    null    ?    null    :    BreadcrumbsXmlWrapper . toPsiElementArray ( pairs )  ;", "}", "METHOD_END"], "methodName": ["getLinePsiElements"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "Font   font    =     (  ( editor    =  =    null )     |  |     ( Registry . is (  \" editor . breadcrumbs . system . font \"  )  )  )     ?    getLabelFont (  )     :    BreadcrumbsXmlWrapper . getEditorFont ( editor )  ;", "return   UISettings . getInstance (  )  . getUseSmallLabelsOnTabs (  )     ?    SMALL . derive ( font )     :    font ;", "}", "METHOD_END"], "methodName": ["getNewFont"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "return   provider    !  =    null    ?    provider . getParent ( element )     :    element . getParent (  )  ;", "}", "METHOD_END"], "methodName": ["getParent"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "Collection < Pair < PsiElement ,    BreadcrumbsProvider >  >    pairs    =    BreadcrumbsXmlWrapper . getLineElements ( editor . logicalPositionToOffset ( position )  ,    file ,    project ,    defaultInfoProvider )  ;", "if    ( pairs    =  =    null )", "return   null ;", "ArrayList < PsiCrumb >    result    =    new   ArrayList ( pairs . size (  )  )  ;", "CrumbPresentation [  ]    presentations    =    BreadcrumbsXmlWrapper . getCrumbPresentations ( BreadcrumbsXmlWrapper . toPsiElementArray ( pairs )  )  ;", "int   index    =     0  ;", "for    ( Pair < PsiElement ,    BreadcrumbsProvider >    pair    :    pairs )     {", "PsiCrumb   crumb    =    new   PsiCrumb ( pair . first ,    pair . second )  ;", "if    (  (  ( presentations    !  =    null )     &  &     (  0     <  =    index )  )     &  &     ( index    <     ( presentations . length )  )  )     {", "crumb . presentation    =    presentations [  ( index +  +  )  ]  ;", "}", "result . add ( crumb )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getPresentableLineElements"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "return   FileDocumentManager . getInstance (  )  . getFile ( editor . getDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["getVirtualFile"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( Registry . is (  \" editor . breadcrumbs . highlight . on . hover \"  )  )  )     {", "return ;", "}", "HighlightManager   hm    =    HighlightManager . getInstance ( myProject )  ;", "if    (  ( myHighlighed )     !  =    null )     {", "for    ( RangeHighlighter   highlighter    :    myHighlighed )     {", "hm . removeSegmentHighlighter ( myEditor ,    highlighter )  ;", "}", "myHighlighed    =    null ;", "}", "PsiElement   psiElement    =    PsiCrumb . getElement ( crumb )  ;", "if    ( psiElement    !  =    null )     {", "final   TextRange   range    =    psiElement . getTextRange (  )  ;", "final   TextAttributes   attributes    =    new   TextAttributes (  )  ;", "final   CrumbPresentation   p    =    PsiCrumb . getPresentation ( crumb )  ;", "Color   color    =     ( p    =  =    null )     ?    null    :    p . getBackgroundColor ( false ,    false ,    false )  ;", "if    ( color    =  =    null )", "color    =    BreadcrumbsComponent . ButtonSettings . getBackgroundColor ( false ,    false ,    false ,    false )  ;", "if    ( color    =  =    null )", "color    =    com . intellij . util . ui . UIUtil . getLabelBackground (  )  ;", "final   Color   background    =    EditorColorsManager . getInstance (  )  . getGlobalScheme (  )  . getColor ( CARET _ ROW _ COLOR )  ;", "attributes . setBackgroundColor ( XmlTagTreeHighlightingUtil . makeTransparent ( color ,     ( background    !  =    null    ?    background    :    Gray .  _  2  0  0  )  ,     0  .  3  )  )  ;", "myHighlighed    =    new   ArrayList (  1  )  ;", "int   flags    =     (  ( HighlightManager . HIDE _ BY _ ESCAPE )     |     ( HighlightManager . HIDE _ BY _ TEXT _ CHANGE )  )     |     ( HighlightManager . HIDE _ BY _ ANY _ KEY )  ;", "hm . addOccurrenceHighlight ( myEditor ,    range . getStartOffset (  )  ,    range . getEndOffset (  )  ,    attributes ,    flags ,    myHighlighed ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["itemHovered"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "if    ( event    =  =    null )", "return ;", "PsiElement   psiElement    =    PsiCrumb . getElement (  )  ;", "if    ( psiElement    =  =    null )", "return ;", "moveEditorCaretTo ( psiElement )  ;", "if    (  ( event . isShiftDown (  )  )     |  |     ( event . isMetaDown (  )  )  )     {", "final   TextRange   range    =    psiElement . getTextRange (  )  ;", "myEditor . getSelectionModel (  )  . setSelection ( range . getStartOffset (  )  ,    range . getEndOffset (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["itemSelected"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "if    ( element . isValid (  )  )     {", "setUserCaretChange ( false )  ;", "myEditor . getCaretModel (  )  . moveToOffset ( element . getTextOffset (  )  )  ;", "myEditor . getScrongModel (  )  . scrollToCaret ( MAKE _ VISIBLE )  ;", "}", "}", "METHOD_END"], "methodName": ["moveEditorCaretTo"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "myQueue . cancelAllUpdates (  )  ;", "myQueue . queue ( myUpdate )  ;", "}", "METHOD_END"], "methodName": ["queueUpdate"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "myUserCaretChange    =    userCaretChange ;", "}", "METHOD_END"], "methodName": ["setUserCaretChange"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "PsiElement [  ]    elements    =    new   PsiElement [ pairs . size (  )  ]  ;", "int   index    =     0  ;", "for    ( Pair < PsiElement ,    Provider >    pair    :    pairs )     {", "elements [  ( index +  +  )  ]     =    pair . first ;", "}", "return   elements ;", "}", "METHOD_END"], "methodName": ["toPsiElementArray"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( myEditor )     =  =    null )     |  |     ( myEditor . isDisposed (  )  )  )", "return ;", "if    (  ( myPsiAvaiableProgress )     !  =    null )     {", "myPsiAvaiableProgress . cancel (  )  ;", "}", "ProgressIndicator   progress    =    new   ProgressIndicatorBase (  )  ;", "myPsiAvaiableProgress    =    progress ;", "PsiAvailabilityService . getInstance ( myProject )  . performWhenPsiAvailable ( myEditor . getDocument (  )  ,     (  )     -  >     {", "if    (  (  (  (  (  !  ( progress . isCanceled (  )  )  )     &  &     (  ( myFile )     !  =    null )  )     &  &     (  ( myEditor )     !  =    null )  )     &  &     (  !  ( myEditor . isDisposed (  )  )  )  )     &  &     (  !  ( myProject . isDisposed (  )  )  )  )     {", "setFont ( getNewFont ( myEditor )  )  ;", "updateCrumbs ( myEditor . getCaretModel (  )  . getLogicalPosition (  )  )  ;", "}", "}  ,    progress )  ;", "}", "METHOD_END"], "methodName": ["updateCrumbs"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( breadcrumbs . isShowing (  )  )  )     {", "breadcrumbs . setCrumbs ( null )  ;", "return ;", "}", "breadcrumbs . setCrumbs (  . getPresentableLineElements ( position ,    myFile ,    myEditor ,    myProject ,    myInfoProvider )  )  ;", "}", "METHOD_END"], "methodName": ["updateCrumbs"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "if    ( PROP _ FONT _ SIZE . equals ( event . getPropertyName (  )  )  )", "queueUpdate (  )  ;", "}", "METHOD_END"], "methodName": ["updateEditorFont"], "fileName": "com.intellij.xml.breadcrumbs.BreadcrumbsXmlWrapper"}, {"methodBody": ["METHOD_START", "{", "if    ( isHovered ( crumb )  )", "return   EditorColors . BREADCRUMBS _ HOVERED ;", "if    ( isSelected ( crumb )  )", "return   EditorColors . BREADCRUMBS _ CURRENT ;", "if    ( isAfterSelected ( crumb )  )", "return   EditorColors . BREADCRUMBS _ INACTIVE ;", "return   EditorColors . BREADCRUMBS _ DEFAULT ;", "}", "METHOD_END"], "methodName": ["getKey"], "fileName": "com.intellij.xml.breadcrumbs.PsiBreadcrumbs"}, {"methodBody": ["METHOD_START", "{", "setBorder ( new   EmptyBorder (  0  ,    offset ,     0  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["updateBorder"], "fileName": "com.intellij.xml.breadcrumbs.PsiBreadcrumbs"}, {"methodBody": ["METHOD_START", "{", "return   crumb   instanceof   PsiCrumb    ?     (  ( PsiCrumb )     ( crumb )  )  . anchor . retrieve (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getElement"], "fileName": "com.intellij.xml.breadcrumbs.PsiCrumb"}, {"methodBody": ["METHOD_START", "{", "return   crumb   instanceof   PsiCrumb    ?     (  ( PsiCrumb )     ( crumb )  )  . presentation    :    null ;", "}", "METHOD_END"], "methodName": ["getPresentation"], "fileName": "com.intellij.xml.breadcrumbs.PsiCrumb"}, {"methodBody": ["METHOD_START", "{", "return   event    =  =    null    ?    null    :    event . getData ( EDITOR _ EVEN _ IF _ INACTIVE )  ;", "}", "METHOD_END"], "methodName": ["findEditor"], "fileName": "com.intellij.xml.breadcrumbs.ToggleBreadcrumbsAction"}, {"methodBody": ["METHOD_START", "{", "FileViewProvider   provider    =    BreadcrumbsXmlWrapper . findViewProvider ( editor )  ;", "return   provider    =  =    null    ?    null    :    provider . getBaseLanguage (  )  . getID (  )  ;", "}", "METHOD_END"], "methodName": ["findLanguageID"], "fileName": "com.intellij.xml.breadcrumbs.ToggleBreadcrumbsAction"}, {"methodBody": ["METHOD_START", "{", "return   editor . getUserData ( ToggleBreadcrumbsAction . FORCED _ BREADCRUMBS )  ;", "}", "METHOD_END"], "methodName": ["getForcedShown"], "fileName": "com.intellij.xml.breadcrumbs.ToggleBreadcrumbsAction"}, {"methodBody": ["METHOD_START", "{", "FileViewProvider   provider    =    BreadcrumbsXmlWrapper . findViewProvider ( editor )  ;", "return    ( provider    =  =    null )     |  |     ( null    !  =     ( BreadcrumbsXmlWrapper . findInfoProvider ( false ,    provider )  )  )  ;", "}", "METHOD_END"], "methodName": ["isEnabled"], "fileName": "com.intellij.xml.breadcrumbs.ToggleBreadcrumbsAction"}, {"methodBody": ["METHOD_START", "{", "if    ( editor    !  =    null )     {", "Boolean   selected    =     . getForcedShown ( editor )  ;", "if    ( selected    !  =    null )", "return   selected ;", "}", "EditorSettingsExternalizable   settings    =    EditorSettingsExternalizable . getInstance (  )  ;", "boolean   selected    =    settings . isBreadcrumbsShown (  )  ;", "if    (  ! selected )", "return   false ;", "String   languageID    =     . findLanguageID ( editor )  ;", "return    ( languageID    =  =    null )     |  |     ( settings . isBreadcrumbsShownFor ( languageID )  )  ;", "}", "METHOD_END"], "methodName": ["isSelected"], "fileName": "com.intellij.xml.breadcrumbs.ToggleBreadcrumbsAction"}, {"methodBody": ["METHOD_START", "{", "if    ( editor    =  =    null )", "return   false ;", "Boolean   old    =     . getForcedShown ( editor )  ;", "editor . putUserData (  . FORCED _ BREADCRUMBS ,    selected )  ;", "return    !  ( Objects . equals ( old ,    selected )  )  ;", "}", "METHOD_END"], "methodName": ["setSelected"], "fileName": "com.intellij.xml.breadcrumbs.ToggleBreadcrumbsAction"}, {"methodBody": ["METHOD_START", "{", "return   myFiles ;", "}", "METHOD_END"], "methodName": ["getFilesByModules"], "fileName": "com.intellij.xml.config.ConfigFileSearcher"}, {"methodBody": ["METHOD_START", "{", "return   myJars ;", "}", "METHOD_END"], "methodName": ["getJars"], "fileName": "com.intellij.xml.config.ConfigFileSearcher"}, {"methodBody": ["METHOD_START", "{", "return   myVirtualFiles ;", "}", "METHOD_END"], "methodName": ["getVirtualFiles"], "fileName": "com.intellij.xml.config.ConfigFileSearcher"}, {"methodBody": ["METHOD_START", "{", "searchWithFiles (  )  ;", "}", "METHOD_END"], "methodName": ["search"], "fileName": "com.intellij.xml.config.ConfigFileSearcher"}, {"methodBody": ["METHOD_START", "{", "myFiles . clear (  )  ;", "myJars . clear (  )  ;", "PsiManager   psiManager    =    PsiManager . getInstance ( myProject )  ;", "List < PsiFile >    files    =    new   ArrayList <  >  (  )  ;", "for    ( PsiFile   file    :    s ( myModule ,    myProject )  )     {", "files . add ( file )  ;", "VirtualFile   jar    =    JarFileSystem . getInstance (  )  . getVirtualFileForJar ( file . getVirtualFile (  )  )  ;", "if    ( jar    !  =    null )     {", "myJars . putValue ( jar ,    file )  ;", "} else    {", "Module   module    =    ModuleUtilCore . findModuleForPsiElement ( file )  ;", "if    ( module    !  =    null )     {", "myFiles . putValue ( module ,    file )  ;", "} else    {", "VirtualFile   virtualFile    =    file . getVirtualFile (  )  ;", "myVirtualFiles . putValue ( virtualFile . getParent (  )  ,    psiManager . findFile ( virtualFile )  )  ;", "}", "}", "}", "return   files ;", "}", "METHOD_END"], "methodName": ["searchWithFiles"], "fileName": "com.intellij.xml.config.ConfigFileSearcher"}, {"methodBody": ["METHOD_START", "{", "Collections . sort ( moduleFiles ,    ConfigFilesTreeBuilder . FILE _ COMPARATOR )  ;", "for    ( PsiFile   file    :    moduleFiles )     {", "final   DefaultMutableTreeNode   fileNode    =    createFileNode ( file )  ;", "parentNode . add ( fileNode )  ;", "psiFiles . add ( file )  ;", "}", "}", "METHOD_END"], "methodName": ["addChildrenFiles"], "fileName": "com.intellij.xml.config.ConfigFilesTreeBuilder"}, {"methodBody": ["METHOD_START", "{", "final   DefaultMutableTreeNode   root    =     (  ( DefaultMutableTreeNode )     ( myTree . getModel (  )  . getRoot (  )  )  )  ;", "final   DefaultMutableTreeNode   treeNode    =    createFileNode ( file )  ;", "root . add ( treeNode )  ;", "DefaultTreeModel   model    =     (  ( DefaultTreeModel )     ( myTree . getModel (  )  )  )  ;", "model . nodeStructureChanged ( root )  ;", "return   treeNode ;", "}", "METHOD_END"], "methodName": ["addFile"], "fileName": "com.intellij.xml.config.ConfigFilesTreeBuilder"}, {"methodBody": ["METHOD_START", "{", "final   HashSet < PsiFile >    psiFiles    =    new   HashSet <  >  (  )  ;", "final   List < Module >    modules    =    new   ArrayList ( files . keySet (  )  )  ;", "Collections . sort ( modules ,    INSTANCE )  ;", "for    ( Module   module    :    modules )     {", "DefaultMutableTreeNode   moduleNode    =    createFileNode ( module )  ;", "root . add ( moduleNode )  ;", "if    ( files . containsKey ( module )  )     {", "List < PsiFile >    moduleFiles    =    new   ArrayList ( files . get ( module )  )  ;", "MultiMap < FileType ,    PsiFile >    filesByType    =    new   MultiMap (  )  ;", "for    ( PsiFile   file    :    moduleFiles )     {", "filesByType . putValue ( file . getFileType (  )  ,    file )  ;", "}", "if    (  . hasNonEmptyGroups ( filesByType )  )     {", "for    ( Map . Entry < FileType ,    Collection < PsiFile >  >    entry    :    filesByType . entrySet (  )  )     {", "DefaultMutableTreeNode   fileTypeNode    =    createFileNode ( entry . getKey (  )  )  ;", "moduleNode . add ( fileTypeNode )  ;", "addChildrenFiles ( psiFiles ,    fileTypeNode ,    new   ArrayList ( entry . getValue (  )  )  )  ;", "}", "} else    {", "addChildrenFiles ( psiFiles ,    moduleNode ,    moduleFiles )  ;", "}", "}", "}", "List < VirtualFile >    sortedJars    =    new   ArrayList ( jars . keySet (  )  )  ;", "Collections . sort ( sortedJars ,     (    o 1  ,    o 2  )     -  >    StringUtil . naturalCompare ( o 1  . getName (  )  ,    o 2  . getName (  )  )  )  ;", "for    ( VirtualFile   file    :    sortedJars )     {", "if    (  !  ( file . isValid (  )  )  )", "continue ;", "final   List < PsiFile >    list    =    new   ArrayList ( jars . get ( file )  )  ;", "final   PsiFile   jar    =    list . get (  0  )  . getManager (  )  . findFile ( file )  ;", "if    ( jar    !  =    null )     {", "final   DefaultMutableTreeNode   jarNode    =    createFileNode ( jar )  ;", "root . add ( jarNode )  ;", "Collections . sort ( list ,     . FILE _ COMPARATOR )  ;", "for    ( PsiFile   psiFile    :    list )     {", "jarNode . add ( createFileNode ( psiFile )  )  ;", "psiFiles . add ( psiFile )  ;", "}", "}", "}", "return   psiFiles ;", "}", "METHOD_END"], "methodName": ["buildModuleNodes"], "fileName": "com.intellij.xml.config.ConfigFilesTreeBuilder"}, {"methodBody": ["METHOD_START", "{", "final   Set < PsiFile >    psiFiles    =    new   HashSet <  >  (  )  ;", "final   MultiMap < Module ,    PsiFile >    files    =    new   MultiMap (  )  ;", "final   MultiMap < VirtualFile ,    PsiFile >    jars    =    new   MultiMap (  )  ;", "final   MultiMap < VirtualFile ,    PsiFile >    virtualFiles    =    new   MultiMap (  )  ;", "for    ( ConfigFileSearcher   searcher    :    searchers )     {", "files . putAllValues ( searcher . getFilesByModules (  )  )  ;", "jars . putAllValues ( searcher . getJars (  )  )  ;", "virtualFiles . putAllValues ( searcher . getVirtualFiles (  )  )  ;", "}", "psiFiles . addAll ( buildModuleNodes ( files ,    jars ,    root )  )  ;", "for    ( Map . Entry < VirtualFile ,    Collection < PsiFile >  >    entry    :    virtualFiles . entrySet (  )  )     {", "DefaultMutableTreeNode   node    =    createFileNode ( entry . getKey (  )  )  ;", "List < PsiFile >    list    =    new   ArrayList ( entry . getValue (  )  )  ;", "Collections . sort ( list ,     . FILE _ COMPARATOR )  ;", "for    ( PsiFile   file    :    list )     {", "node . add ( createFileNode ( file )  )  ;", "}", "root . add ( node )  ;", "}", "return   psiFiles ;", "}", "METHOD_END"], "methodName": ["buildTree"], "fileName": "com.intellij.xml.config.ConfigFilesTreeBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultMutableTreeNode ( file )  ;", "}", "METHOD_END"], "methodName": ["createFileNode"], "fileName": "com.intellij.xml.config.ConfigFilesTreeBuilder"}, {"methodBody": ["METHOD_START", "{", "return    ( fileType . getName (  )  )     +     \"    files \"  ;", "}", "METHOD_END"], "methodName": ["getFileTypeNodeName"], "fileName": "com.intellij.xml.config.ConfigFilesTreeBuilder"}, {"methodBody": ["METHOD_START", "{", "long   nonEmptyGroups    =    filesByType . entrySet (  )  . stream (  )  . map ( Map . Entry :  : getValue )  . filter (  (    files )     -  >     ( files    !  =    null )     &  &     (  !  ( files . isEmpty (  )  )  )  )  . limit (  2  )  . count (  )  ;", "return   nonEmptyGroups    >     1  ;", "}", "METHOD_END"], "methodName": ["hasNonEmptyGroups"], "fileName": "com.intellij.xml.config.ConfigFilesTreeBuilder"}, {"methodBody": ["METHOD_START", "{", "new   TreeSpeedSearch ( tree ,     (    treePath )     -  >     {", "final   Object   object    =     (  ( DefaultMutableTreeNode )     ( treePath . getLastPathComponent (  )  )  )  . getUserObject (  )  ;", "if    ( object   instanceof   Module )     {", "return    (  ( Module )     ( object )  )  . getName (  )  ;", "} else", "if    ( object   instanceof   psi . PsiFile )     {", "return    (  ( psi . PsiFile )     ( object )  )  . getName (  )  ;", "} else", "if    ( object   instanceof   openapi . vfs . VirtualFile )     {", "return    (  ( openapi . vfs . VirtualFile )     ( object )  )  . getName (  )  ;", "} else    {", "return    \"  \"  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["installSearch"], "fileName": "com.intellij.xml.config.ConfigFilesTreeBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( value   instanceof   DefaultMutableTreeNode )  )", "return ;", "final   Object   object    =     (  ( DefaultMutableTreeNode )     ( value )  )  . getUserObject (  )  ;", "if    ( object   instanceof   FileType )     {", "final   FileType   fileType    =     (  ( FileType )     ( object )  )  ;", "final   Icon   icon    =    fileType . getIcon (  )  ;", "renderer . setIcon ( icon )  ;", "renderer . append (  . getFileTypeNodeName ( fileType )  ,    REGULAR _ ATTRIBUTES )  ;", "} else", "if    ( object   instanceof   com . intellij . openapi . module . Module )     {", "final   com . intellij . openapi . module . Module   module    =     (  ( com . intellij . openapi . module . Module )     ( object )  )  ;", "final   Icon   icon    =    com . intellij . openapi . module . ModuleType . get ( module )  . getIcon (  )  ;", "renderer . setIcon ( icon )  ;", "final   String   moduleName    =    module . getName (  )  ;", "renderer . append ( moduleName ,    REGULAR _ ATTRIBUTES )  ;", "} else", "if    ( object   instanceof   com . intellij . psi . PsiFile )     {", "final   com . intellij . psi . PsiFile   psiFile    =     (  ( com . intellij . psi . PsiFile )     ( object )  )  ;", "final   Icon   icon    =    psiFile . getIcon (  0  )  ;", "renderer . setIcon ( icon )  ;", "final   String   fileName    =    psiFile . getName (  )  ;", "renderer . append ( fileName ,    REGULAR _ ATTRIBUTES )  ;", "final   com . intellij . openapi . vfs . VirtualFile   virtualFile    =    psiFile . getVirtualFile (  )  ;", "if    ( virtualFile    !  =    null )     {", ". renderPath ( renderer ,    virtualFile )  ;", "}", "} else", "if    ( object   instanceof   com . intellij . openapi . vfs . VirtualFile )     {", "com . intellij . openapi . vfs . VirtualFile   file    =     (  ( com . intellij . openapi . vfs . VirtualFile )     ( object )  )  ;", "renderer . setIcon ( com . intellij . ide . presentation . VirtualFilePresentation . getIcon ( file )  )  ;", "renderer . append ( file . getName (  )  ,    REGULAR _ ATTRIBUTES )  ;", ". renderPath ( renderer ,    file )  ;", "}", "}", "METHOD_END"], "methodName": ["renderNode"], "fileName": "com.intellij.xml.config.ConfigFilesTreeBuilder"}, {"methodBody": ["METHOD_START", "{", "String   path    =    virtualFile . getPath (  )  ;", "final   int   i    =    path . indexOf ( JAR _ SEPARATOR )  ;", "if    ( i    >  =     0  )     {", "path    =    path . substring (  ( i    +     ( JAR _ SEPARATOR . length (  )  )  )  )  ;", "}", "renderer . append (  (  (  \"     (  \"     +     ( StringUtil . trimEnd ( StringUtil . trimEnd ( path ,    virtualFile . getName (  )  )  ,     \"  /  \"  )  )  )     +     \"  )  \"  )  ,    GRAYED _ ATTRIBUTES )  ;", "}", "METHOD_END"], "methodName": ["renderPath"], "fileName": "com.intellij.xml.config.ConfigFilesTreeBuilder"}, {"methodBody": ["METHOD_START", "{", "return   getEnumeratedValues (  )  ;", "}", "METHOD_END"], "methodName": ["getEnumeratedValues"], "fileName": "com.intellij.xml.impl.BasicXmlAttributeDescriptor"}, {"methodBody": ["METHOD_START", "{", "for    ( ExternalDocumentValidator . ValidationInfo   info    :    highlightInfos )     {", "host . addMessage ( info . element ,    info . message ,    info . type )  ;", "}", "}", "METHOD_END"], "methodName": ["addAllInfos"], "fileName": "com.intellij.xml.impl.ExternalDocumentValidator"}, {"methodBody": ["METHOD_START", "{", "currentElement    =    PsiTreeUtil . getParentOfType ( currentElement ,    XmlTag . class ,    false )  ;", "if    ( currentElement    =  =    null )     {", "currentElement    =    PsiTreeUtil . getParentOfType ( originalElement ,    XmlElementDecl . class ,    false )  ;", "}", "if    ( currentElement    =  =    null )     {", "currentElement    =    originalElement ;", "}", ". assertValidElement ( currentElement ,    originalElement ,    localizedMessage )  ;", "if    ( currentElement    !  =    null )     {", "myHost . addMessage ( currentElement ,    localizedMessage ,     . getProblemType ( problemType )  )  ;", "}", "return   currentElement ;", "}", "METHOD_END"], "methodName": ["addProblemToTagName"], "fileName": "com.intellij.xml.impl.ExternalDocumentValidator"}, {"methodBody": ["METHOD_START", "{", "if    ( currentElement    =  =    null )     {", "XmlTag   tag    =    PsiTreeUtil . getParentOfType ( originalElement ,    XmlTag . class )  ;", ". LOG . error (  (  (  (  (  (  (  (  (  (  (  (  (  (  \" The   validator   message :  \"     +    message )     +     \"    is   bound   to   null   node ,  \\ n \"  )     +     \" initial   element :  \"  )     +     ( originalElement . getText (  )  )  )     +     \"  ,  \\ n \"  )     +     \" parent :  \"  )     +     ( originalElement . getParent (  )  )  )     +     \"  ,  \\ n \"  )     +     \" tag :  \"  )     +     ( tag    !  =    null    ?    tag . getText (  )     :     \" null \"  )  )     +     \"  ,  \\ n \"  )     +     \" offset   in   tag :     \"  )     +     (  ( originalElement . getTextOffset (  )  )     -     ( tag    =  =    null    ?     0     :    tag . getTextOffset (  )  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertValidElement"], "fileName": "com.intellij.xml.impl.ExternalDocumentValidator"}, {"methodBody": ["METHOD_START", "{", "final   PsiFile   containingFile    =    document . getContainingFile (  )  ;", "if    ( containingFile    =  =    null )     {", "return ;", "}", "if    (  ( containingFile . getViewProvider (  )  )    instanceof   TemplateLanguageFileViewProvider )     {", "return ;", "}", "final   FileType   fileType    =    containingFile . getViewProvider (  )  . getFileType (  )  ;", "if    (  ( fileType    !  =     ( XmlFileType . INSTANCE )  )     &  &     ( fileType    !  =     ( XHtmlFileType . INSTANCE )  )  )     {", "return ;", "}", "for    ( Language   lang    :    containingFile . getViewProvider (  )  . getLanguages (  )  )     {", "if    (  \" ANT \"  . equals ( lang . getID (  )  )  )", "return ;", "}", "final   XmlTag   rootTag    =    document . getRootTag (  )  ;", "if    ( rootTag    =  =    null )", "return ;", "String   namespace    =    rootTag . getNamespace (  )  ;", "if    ( XmlUtil . ANT _ URI . equals ( namespace )  )", "return ;", "final   Project   project    =    document . getProject (  )  ;", "final   InspectionProfile   profile    =    InspectionProjectProfileManager . getInstance ( project )  . getCurrentProfile (  )  ;", "final   InspectionToolWrapper   toolWrapper    =    profile . getInspectionTool (  . INSPECTION _ SHORT _ NAME ,    containingFile )  ;", "if    ( toolWrapper    =  =    null )", "return ;", "if    (  !  ( profile . isToolEnabled ( HighlightDisplayKey . find (  . INSPECTION _ SHORT _ NAME )  ,    containingFile )  )  )", "return ;", "SoftReference <  >    validatorReference    =    project . getUserData (  . validatorInstanceKey )  ;", "validator    =    SoftReference . dereference ( validatorReference )  ;", "if    ( validator    =  =    null )     {", "validator    =    new    (  )  ;", "project . putUserData (  . validatorInstanceKey ,    new   SoftReference ( validator )  )  ;", "}", "validator . runJaxpValidation ( document ,    host )  ;", "}", "METHOD_END"], "methodName": ["doValidation"], "fileName": "com.intellij.xml.impl.ExternalDocumentValidator"}, {"methodBody": ["METHOD_START", "{", "PsiElement   parentOfType    =    PsiTreeUtil . getNonStrictParentOfType ( currentElement ,    XmlTag . class ,    XmlProcessingInstruction . class ,    XmlElementDecl . class ,    XmlMarkupDecl . class ,    XmlEntityRef . class ,    XmlDoctype . class )  ;", "if    ( parentOfType    =  =    null )     {", "if    ( currentElement   instanceof   XmlToken )     {", "parentOfType    =    currentElement . getParent (  )  ;", "} else    {", "parentOfType    =    currentElement ;", "}", "}", "return   parentOfType ;", "}", "METHOD_END"], "methodName": ["getNodeForMessage"], "fileName": "com.intellij.xml.impl.ExternalDocumentValidator"}, {"methodBody": ["METHOD_START", "{", "return   warning    =  =     ( ValidateXmlActionHandler . ProblemType . WARNING )     ?    ErrorType . WARNING    :    ErrorType . ERROR ;", "}", "METHOD_END"], "methodName": ["getProblemType"], "fileName": "com.intellij.xml.impl.ExternalDocumentValidator"}, {"methodBody": ["METHOD_START", "{", "final   PsiFile   file    =    element . getContainingFile (  )  ;", "if    (  ( file    =  =    null )     |  |     (  ( file . getVirtualFile (  )  )     =  =    null )  )", "return ;", "if    (  (  (  (  ( myFile )     =  =    file )     &  &     (  ( myModificationStamp )     =  =     ( file . getModificationStamp (  )  )  )  )     &  &     (  !  ( ValidateXmlActionHandler . isValidationDependentFilesOutOfDate (  (  ( XmlFile )     ( file )  )  )  )  )  )     &  &     (  ( SoftReference . dereference ( myInfos )  )     !  =    null )  )     {", ". addAllInfos ( host ,    myInfos . get (  )  )  ;", "return ;", "}", "if    (  ( myHandler )     =  =    null )", "myHandler    =    new   ValidateXmlActionHandler ( false )  ;", "final   Project   project    =    element . getProject (  )  ;", "final   Document   document    =    PsiDocumentManager . getInstance ( project )  . getDocument ( file )  ;", "if    ( document    =  =    null )", "return ;", "final   List <  . ValidationInfo >    results    =    new   LinkedList <  >  (  )  ;", "myHost    =    new   Validator . ValidationHost (  )     {", "@ Override", "public   void   addMessage ( PsiElement   context ,    String   message ,    int   type )     {", "addMessage ( context ,    message ,     ( type    =  =     ( ERROR )     ?    ErrorType . ERROR    :    type    =  =     ( WARNING )     ?    ErrorType . WARNING    :    ErrorType . INFO )  )  ;", "}", "@ Override", "public   void   addMessage ( final   PsiElement   context ,    final   String   message ,     @ NotNull", "final   ErrorType   type )     {", "final    . ValidationInfo   o    =    new    . ValidationInfo ( context ,    message ,    type )  ;", "results . add ( o )  ;", "}", "}  ;", "myHandler . setErrorReporter ( new   ErrorReporter ( myHandler )     {", "@ Override", "public   boolean   isStopOnUndeclaredResource (  )     {", "return   true ;", "}", "@ Override", "public   void   processError ( final   SAXParseException   e ,    final   ValidateXmlActionHandler . ProblemType   warning )     {", "try    {", "ApplicationManager . getApplication (  )  . runReadAction (  (  )     -  >     {", "if    (  ( e . getPublicId (  )  )     !  =    null )     {", "return ;", "}", "final   VirtualFile   errorFile    =    myHandler . getProblemFile ( e )  ;", "if    (  (  !  ( Comparing . equal ( errorFile ,    file . getVirtualFile (  )  )  )  )     &  &     ( errorFile    !  =    null )  )     {", "return ;", "}", "if    (  (  ( document . getLineCount (  )  )     <     ( e . getLineNumber (  )  )  )     |  |     (  ( e . getLineNumber (  )  )     <  =     0  )  )     {", "return ;", "}", "Validator . ValidationHost . ErrorType   problemType    =    getProblemType ( warning )  ;", "int   offset    =    Math . max (  0  ,     (  (  ( document . getLineStartOffset (  (  ( e . getLineNumber (  )  )     -     1  )  )  )     +     ( e . getColumnNumber (  )  )  )     -     2  )  )  ;", "if    ( offset    >  =     ( document . getTextLength (  )  )  )", "return ;", "PsiElement   currentElement    =    PsiDocumentManager . getInstance ( project )  . getPsiFile ( document )  . findElementAt ( offset )  ;", "PsiElement   originalElement    =    currentElement ;", "final   String   elementText    =    currentElement . getText (  )  ;", "if    ( elementText . equals (  \"  <  /  \"  )  )     {", "currentElement    =    currentElement . getNextSibling (  )  ;", "} else", "if    (  ( elementText . equals (  \"  >  \"  )  )     |  |     ( elementText . equals (  \"  =  \"  )  )  )     {", "currentElement    =    currentElement . getPrevSibling (  )  ;", "}", "String   localizedMessage    =    e . getLocalizedMessage (  )  ;", "int   endIndex    =    localizedMessage . indexOf (  '  :  '  )  ;", "if    (  ( endIndex    <     (  ( localizedMessage . length (  )  )     -     1  )  )     &  &     (  ( localizedMessage . charAt (  ( endIndex    +     1  )  )  )     =  =     '  /  '  )  )     {", "endIndex    =     -  1  ;", "}", "String   messageId    =     ( endIndex    !  =     (  -  1  )  )     ?    localizedMessage . substring (  0  ,    endIndex )     :     \"  \"  ;", "localizedMessage    =    localizedMessage . substring (  ( endIndex    +     1  )  )  . trim (  )  ;", "if    (  (  (  ( localizedMessage . startsWith (  . CANNOT _ FIND _ DECLARATION _ ERROR _ PREFIX )  )     |  |     ( localizedMessage . startsWith (  . ELEMENT _ ERROR _ PREFIX )  )  )     |  |     ( localizedMessage . startsWith (  . ROOT _ ELEMENT _ ERROR _ PREFIX )  )  )     |  |     ( localizedMessage . startsWith (  . CONTENT _ OF _ ELEMENT _ TYPE _ ERROR _ PREFIX )  )  )     {", "addProblemToTagName ( currentElement ,    originalElement ,    localizedMessage ,    warning )  ;", "} else", "if    ( localizedMessage . startsWith (  . VALUE _ ERROR _ PREFIX )  )     {", "addProblemToTagName ( currentElement ,    originalElement ,    localizedMessage ,    warning )  ;", "} else    {", "if    ( messageId . startsWith (  . ATTRIBUTE _ MESSAGE _ PREFIX )  )     {", "@ NonNls", "String   prefix    =     \" of   attribute    \"  ;", "final   int   i    =    localizedMessage . indexOf ( prefix )  ;", "if    ( i    !  =     (  -  1  )  )     {", "int   messagePrefixLength    =     ( prefix . length (  )  )     +    i ;", "final   int   nextQuoteIndex    =    localizedMessage . indexOf ( localizedMessage . charAt ( messagePrefixLength )  ,     ( messagePrefixLength    +     1  )  )  ;", "String   attrName    =     ( nextQuoteIndex    =  =     (  -  1  )  )     ?    null    :    localizedMessage . substring (  ( messagePrefixLength    +     1  )  ,    nextQuoteIndex )  ;", "XmlTag   parent    =    com . intellij . psi . util . PsiTreeUtil . getParentOfType ( originalElement ,     . class )  ;", "currentElement    =    parent . getAttribute ( attrName ,    null )  ;", "if    ( currentElement    !  =    null )     {", "currentElement    =     (  ( XmlAttribute )     ( currentElement )  )  . getValueElement (  )  ;", "}", "}", "if    ( currentElement    !  =    null )     {", "assertValidElement ( currentElement ,    originalElement ,    localizedMessage )  ;", "myHost . addMessage ( currentElement ,    localizedMessage ,    problemType )  ;", "} else    {", "addProblemToTagName ( originalElement ,    originalElement ,    localizedMessage ,    warning )  ;", "}", "} else", "if    ( localizedMessage . startsWith (  . ATTRIBUTE _ ERROR _ PREFIX )  )     {", "final   int   messagePrefixLength    =     . ATTRIBUTE _ ERROR _ PREFIX . length (  )  ;", "if    (  (  ( localizedMessage . charAt ( messagePrefixLength )  )     =  =     '  \"  '  )     |  |     (  ( localizedMessage . charAt ( messagePrefixLength )  )     =  =     '  \\  '  '  )  )     {", "final   int   nextQuoteIndex    =    localizedMessage . indexOf ( localizedMessage . charAt ( messagePrefixLength )  ,     ( messagePrefixLength    +     1  )  )  ;", "String   attrName    =     ( nextQuoteIndex    =  =     (  -  1  )  )     ?    null    :    localizedMessage . substring (  ( messagePrefixLength    +     1  )  ,    nextQuoteIndex )  ;", "XmlTag   parent    =    com . intellij . psi . util . PsiTreeUtil . getParentOfType ( originalElement ,     . class )  ;", "currentElement    =    parent . getAttribute ( attrName ,    null )  ;", "if    ( currentElement    !  =    null )     {", "currentElement    =    com . intellij . psi . impl . source . SourceTreeToPsiMap . treeElementToPsi ( XmlChildRole . ATTRIBUTE _ NAME _ FINDER . findChild ( com . intellij . psi . impl . source . SourceTreeToPsiMap . psiElementToTree ( currentElement )  )  )  ;", "}", "} else    {", "currentElement    =    com . intellij . psi . util . PsiTreeUtil . getParentOfType ( currentElement ,     . class ,    false )  ;", "}", "if    ( currentElement    !  =    null )     {", "assertValidElement ( currentElement ,    originalElement ,    localizedMessage )  ;", "myHost . addMessage ( currentElement ,    localizedMessage ,    problemType )  ;", "} else    {", "addProblemToTagName ( originalElement ,    originalElement ,    localizedMessage ,    warning )  ;", "}", "} else", "if    ( localizedMessage . startsWith (  . STRING _ ERROR _ PREFIX )  )     {", "if    ( currentElement    !  =    null )     {", "myHost . addMessage ( currentElement ,    localizedMessage ,    Validator . ValidationHost . ErrorType . WARNING )  ;", "}", "} else    {", "currentElement    =    getNodeForMessage (  ( currentElement    !  =    null    ?    currentElement    :    originalElement )  )  ;", "assertValidElement ( currentElement ,    originalElement ,    localizedMessage )  ;", "if    ( currentElement    !  =    null )     {", "myHost . addMessage ( currentElement ,    localizedMessage ,    problemType )  ;", "}", "}", "}", "}  )  ;", "}    catch    ( Exception   ex )     {", "if    ( ex   instanceof   ProcessCanceledException )", "throw    (  ( ProcessCanceledException )     ( ex )  )  ;", "if    ( ex   instanceof   XmlResourceResolver . IgnoredResourceException )", "throw    (  ( XmlResourceResolver . IgnoredResourceException )     ( ex )  )  ;", ". LOG . error ( ex )  ;", "}", "}", "}  )  ;", "myHandler . doValidate (  (  ( XmlFile )     ( file )  )  )  ;", "myFile    =    file ;", "myModificationStamp    =    myFile . getModificationStamp (  )  ;", "myInfos    =    new   WeakReference <  >  ( results )  ;", ". addAllInfos ( host ,    results )  ;", "}", "METHOD_END"], "methodName": ["runJaxpValidation"], "fileName": "com.intellij.xml.impl.ExternalDocumentValidator"}, {"methodBody": ["METHOD_START", "{", "IElementType   tokenType    =    iterator . getTokenType (  )  ;", "balance    =     0  ;", "count    =     0  ;", "while    ( balance    >  =     0  )     {", "iterator . retreat (  )  ;", "count +  +  ;", "if    ( iterator . atEnd (  )  )", "break ;", "tokenType    =    iterator . getTokenType (  )  ;", "if    (  ( tokenType    =  =     ( XmlTokenType . XML _ TAG _ END )  )     |  |     ( tokenType    =  =     ( XmlTokenType . XML _ EMPTY _ ELEMENT _ END )  )  )     {", "balance +  +  ;", "} else", "if    (  ( tokenType    =  =     ( XmlTokenType . XML _ END _ TAG _ START )  )     |  |     ( tokenType    =  =     ( XmlTokenType . XML _ START _ TAG _ START )  )  )     {", "balance -  -  ;", "}", "}", "while    (  ( count -  -  )     >     0  )", "iterator . advance (  )  ;", "return   tokenType    =  =     ( XmlTokenType . XML _ END _ TAG _ START )  ;", "}", "METHOD_END"], "methodName": ["findEndTagStart"], "fileName": "com.intellij.xml.impl.XmlBraceMatcher"}, {"methodBody": ["METHOD_START", "{", "String   tagName    =    getTagName ( text ,    iterator )  ;", "return    ( tagName    !  =    null )     &  &     ( HtmlUtisSingleHtmlTag ( tagName )  )  ;", "}", "METHOD_END"], "methodName": ["isEndOfSingleHtmlTag"], "fileName": "com.intellij.xml.impl.XmlBraceMatcher"}, {"methodBody": ["METHOD_START", "{", "return   fileType    =  =     ( StdFileTypes . HTML )  ;", "}", "METHOD_END"], "methodName": ["isFileTypeWithSingleHtmlTags"], "fileName": "com.intellij.xml.impl.XmlBraceMatcher"}, {"methodBody": ["METHOD_START", "{", "return    ( fileType    =  =     ( StdFileTypes . XML )  )     |  |     ( fileType    =  =     ( StdFileTypes . XHTML )  )  ;", "}", "METHOD_END"], "methodName": ["isStrictTagMatchingForFileType"], "fileName": "com.intellij.xml.impl.XmlBraceMatcher"}, {"methodBody": ["METHOD_START", "{", "return   tokenType 1     =  =     ( TokenType . WHITE _ SPACE )  ;", "}", "METHOD_END"], "methodName": ["isWhitespace"], "fileName": "com.intellij.xml.impl.XmlBraceMatcher"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( tokenType    =  =     ( XmlTokenType . XML _ START _ TAG _ START )  )     |  |     ( tokenType    =  =     ( XmlTokenType . XML _ TAG _ END )  )  )     |  |     ( tokenType    =  =     ( XmlTokenType . XML _ EMPTY _ ELEMENT _ END )  )  )     |  |     (  (  ( tokenType    =  =     ( XmlTokenType . XML _ TAG _ END )  )     &  &     ( isFileTypeWithSingleHtmlTags ( fileType )  )  )     &  &     ( isEndOfSingleHtmlTag ( text ,    iterator )  )  )  ;", "}", "METHOD_END"], "methodName": ["isXmlStructuralBrace"], "fileName": "com.intellij.xml.impl.XmlBraceMatcher"}, {"methodBody": ["METHOD_START", "{", "String   defaultValue    =    getDefaultValue (  )  ;", "if    ( Comparing . equal ( defaultValue ,    value )  )     {", "return   getDefaultValueDeclaration (  )  ;", "}", "return   isFixed (  )     ?    null    :    getedValueDeclaration ( attributeValue ,    value )  ;", "}", "METHOD_END"], "methodName": ["getValueDeclaration"], "fileName": "com.intellij.xml.impl.XmlEnumerationDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   new   PsiReference [  ]  {    new   XmlEnumeratedValueReference ( element ,    this )     }  ;", "}", "METHOD_END"], "methodName": ["getValueReferences"], "fileName": "com.intellij.xml.impl.XmlEnumerationDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   StringUtil . filterEmptyStrings ( getEnumeratedValues (  )  )  ;", "}", "METHOD_END"], "methodName": ["getValuesForCompletion"], "fileName": "com.intellij.xml.impl.XmlEnumerationDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   myDescription . getXmlName (  )  . getLocalName (  )  ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "com.intellij.xml.impl.dom.DomAttributeXmlDescriptor"}, {"methodBody": ["METHOD_START", "{", "final   String   localName    =    xmlName . getLocalName (  )  ;", "if    ( context   instanceof   XmlTag )     {", "final   XmlTag   tag    =     (  ( XmlTag )     ( context )  )  ;", "final   DomInvocationHandler   handler    =    DomManagerIgetDomManager ( context . getProject (  )  )  . getDomHandler ( tag )  ;", "if    ( handler    !  =    null )     {", "final   String   ns    =    handler . createEvaluatedXmlName ( xmlName )  . getNamespace ( tag ,    handler . getFile (  )  )  ;", "if    (  (  !  ( ns . equals ( XmlUtil . EMPTY _ URI )  )  )     &  &     (  !  ( ns . equals ( tag . getNamespace (  )  )  )  )  )     {", "final   String   prefix    =    tag . getPrefixByNamespace ( ns )  ;", "if    ( StringUtil . isNotEmpty ( prefix )  )     {", "return    ( prefix    +     \"  :  \"  )     +    localName ;", "}", "}", "}", "}", "return   localName ;", "}", "METHOD_END"], "methodName": ["getQualifiedAttributeName"], "fileName": "com.intellij.xml.impl.dom.DomAttributeXmlDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   BaseXmlElementDescriptorImpl . myElementDescriptorsMapCache . get ( null ,    this ,    context )  . get ( name )  ;", "}", "METHOD_END"], "methodName": ["getElementDescriptor"], "fileName": "com.intellij.xml.impl.dtd.BaseXmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return   getName (  )  ;", "}", "METHOD_END"], "methodName": ["getQualifiedName"], "fileName": "com.intellij.xml.impl.dtd.XmlAttributeDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "final   List < XmlAttlistDecl >    result    =    new   ArrayList <  >  (  )  ;", "XmlUtil . processXmlElements ( xmlElement ,    new   psi . scope . processor . FilterElementProcessor ( new   ClassFilter ( XmlAttlistDecl . class )  ,    result )  ,    false ,    false ,    XmlUtil . getContainingFile ( xmlElement )  )  ;", "return   result . toArray ( XmlAttlistDecl . EMPTY _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["doCollectAttlistDeclarations"], "fileName": "com.intellij.xml.impl.dtd.XmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "final   List < XmlAttlistDecl >    result    =    new   ArrayList <  >  (  )  ;", "for    ( final   XmlAttlistDecl   declaration    :    getAttlistDeclarations (  )  )     {", "final   String   name    =    declaration . getName (  )  ;", "if    (  ( name    !  =    null )     &  &     ( name . equals ( eName )  )  )     {", "result . add ( declaration )  ;", "}", "}", "return   result . toArray ( XmlAttlistDecl . EMPTY _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["findAttlistDeclarations"], "fileName": "com.intellij.xml.impl.dtd.XmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return   XmlElementDescriptorImpl . getCachedAttributeDeclarations (  (  ( XmlElement )     ( getDeclaration (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getAttlistDeclarations"], "fileName": "com.intellij.xml.impl.dtd.XmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( owner    =  =    null )", "return   com . intellij . psi . xml . XmlAttlistDecl . EMPTY _ ARRAY ;", "owner    =     (  ( XmlElement )     ( PsiTreeUtil . getParentOfType ( owner ,     . ourParentClassesToScanAttributes )  )  )  ;", "if    ( owner    =  =    null )", "return   com . intellij . psi . xml . XmlAttlistDecl . EMPTY _ ARRAY ;", "return    . myAttlistDeclCache . get (  . ourCachedAttlistKeys ,    owner ,    null )  . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getCachedAttributeDeclarations"], "fileName": "com.intellij.xml.impl.dtd.XmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "XmlElementDescriptor   element    =    null ;", "if    ( NSDescriptor   instanceof   XmlNSDescriptorImpl )     {", "element    =     (  ( XmlNSDescriptorImpl )     ( NSDescriptor )  )  . getElementDescriptor ( text )  ;", "} else", "if    ( NSDescriptor   instanceof   com . intellij . xml . util . XmlNSDescriptorSequence )     {", "final   List < XmlNSDescriptor >    sequence    =     (  ( com . intellij . xml . util . XmlNSDescriptorSequence )     ( NSDescriptor )  )  . getSequence (  )  ;", "for    ( XmlNSDescriptor   xmlNSDescriptor    :    sequence )     {", "if    ( xmlNSDescriptor   instanceof   XmlNSDescriptorImpl )     {", "element    =     (  ( XmlNSDescriptorImpl )     ( xmlNSDescriptor )  )  . getElementDescriptor ( text )  ;", "if    ( element    !  =    null )", "break ;", "}", "}", "} else    {", "element    =    null ;", "}", "return   element ;", "}", "METHOD_END"], "methodName": ["getElementDescriptor"], "fileName": "com.intellij.xml.impl.dtd.XmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =    XmlUtil . getContainingFile ( elementDecl )  ;", "if    ( file    =  =    null )     {", "return   null ;", "}", "final   XmlDocument   document    =    file . getDocument (  )  ;", "assert   document    !  =    null ;", "XmlNS   descriptor    =     (  ( XmlNS )     ( document . getMetaData (  )  )  )  ;", "return   descriptor    =  =    null    ?    document . getDefaultNS ( XmlUtil . EMPTY _ URI ,    false )     :    descriptor ;", "}", "METHOD_END"], "methodName": ["getNsDescriptorFrom"], "fileName": "com.intellij.xml.impl.dtd.XmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return   XmlNSDescriptorImpl . myCachedDeclsCache . get ( this )  . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["buildDeclarationMap"], "fileName": "com.intellij.xml.impl.dtd.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return   CachedValuesManager . getManager ( myElement . getProject (  )  )  . createCachedValue (  (  )     -  >     {", "final   List < XmlElementDecl >    result    =    new   ArrayList <  >  (  )  ;", "myElement . processElements ( new   FilterElementProcessor ( new   ClassFilter (  . class )  ,    result )  ,    getDeclaration (  )  )  ;", "final   Map < String ,    XmlElementDescriptor >    ret    =    new   LinkedHashMap <  >  (  (  ( int )     (  ( result . size (  )  )     *     1  .  5  )  )  )  ;", "Set < PsiFile >    dependencies    =    new   THashSet <  >  (  1  )  ;", "dependencies . add ( myDescriptorFile )  ;", "for    ( final   XmlElementDecl   xmlElementDecl    :    result )     {", "final   String   name    =    xmlElementDecl . getName (  )  ;", "if    ( name    !  =    null )     {", "if    (  !  ( ret . containsKey ( name )  )  )     {", "ret . put ( name ,    new   XmlElement ( xmlElementDecl )  )  ;", "PsiElement   dependingElement    =    xmlElementDecl . getUserData ( XmlElement . DEPENDING _ ELEMENT )  ;", "if    ( dependingElement    !  =    null )     {", "PsiFile   dependingElementContainingFile    =    dependingElement . getContainingFile (  )  ;", "if    ( dependingElementContainingFile    !  =    null )", "dependencies . add ( dependingElementContainingFile )  ;", "}", "}", "}", "}", "return   new   CachedValueProvider . Result <  >  ( ret ,    dependencies . toArray (  )  )  ;", "}  ,    false )  ;", "}", "METHOD_END"], "methodName": ["doBuildDeclarationMap"], "fileName": "com.intellij.xml.impl.dtd.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return   buildDeclarationMap (  )  . get ( name )  ;", "}", "METHOD_END"], "methodName": ["getElementDescriptor"], "fileName": "com.intellij.xml.impl.dtd.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "final   Collection < XmlElementDescriptor >    declarations    =    buildDeclarationMap (  )  . values (  )  ;", "return   declarations . toArray ( XmlElementDescriptor . EMPTY _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["getElements"], "fileName": "com.intellij.xml.impl.dtd.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return   myCanContainAttributeType ;", "}", "METHOD_END"], "methodName": ["getCanContainAttributeType"], "fileName": "com.intellij.xml.impl.schema.AnyXmlAttributeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   myAttributeName ;", "}", "METHOD_END"], "methodName": ["getDefaultName"], "fileName": "com.intellij.xml.impl.schema.AnyXmlAttributeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   myAttributeName ;", "}", "METHOD_END"], "methodName": ["getQualifiedName"], "fileName": "com.intellij.xml.impl.schema.AnyXmlAttributeDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    ( XmlNSDescriptorImpl . equalsToSchemaName ( tag ,     \" anyAttribute \"  )  )     {", "if    ( dependencies    !  =    null )     {", "dependencies . add ( tag . getContainingFile (  )  )  ;", "}", "String   ns    =    tag . getAttributeValue (  \" namespace \"  )  ;", ". CanContainAttributeType   canContainAttributeType    =     . CanContainAttributeType . CanContainButDoNotSkip ;", "if    (  \" skip \"  . equals ( tag . getAttributeValue (  \" processContents \"  )  )  )", "canContainAttributeType    =     . CanContainAttributeType . CanContainButSkip ;", "if    (  . OTHER _ NAMESPACE _ ATTR _ VALUE . equals ( ns )  )     {", "return    !  ( namespace . equals ( myDocumentDescriptor . getDefaultNamespace (  )  )  )     ?    canContainAttributeType    :     . CanContainAttributeType . CanNotContain ;", "} else", "if    (  \"  #  # any \"  . equals ( ns )  )     {", "return    . CanContainAttributeType . CanContainAny ;", "}", "return   canContainAttributeType ;", "} else", "if    ( XmlNSDescriptorImpl . equalsToSchemaName ( tag ,     \" attributeGroup \"  )  )     {", "String   ref    =    tag . getAttributeValue (  . REF _ ATTR _ NAME )  ;", "if    (  ( ref    !  =    null )     &  &     (  !  ( visited . contains ( ref )  )  )  )     {", "visited . add ( ref )  ;", "XmlTag   groupTag    =    myDocumentDescriptor . findAttributeGroup ( ref )  ;", "if    ( groupTag    !  =    null )     {", "if    ( dependencies    !  =    null )     {", "dependencies . add ( groupTag . getContainingFile (  )  )  ;", "}", "final    . CanContainAttributeType   containAttributeType    =     _ canContainAttribute ( namespace ,    groupTag ,    qName ,    visited ,    dependencies )  ;", "if    ( containAttributeType    !  =     (  . CanContainAttributeType . CanNotContain )  )", "return   containAttributeType ;", "}", "}", "} else", "if    ( XmlNSDescriptorImpl . equalsToSchemaName ( tag ,     \" attribute \"  )  )     {", "if    (  ( qName    !  =    null )     &  &     ( qName . equals ( tag . getAttributeValue (  . REF _ ATTR _ NAME )  )  )  )     {", "return    . CanContainAttributeType . CanContainButDoNotSkip ;", "}", "} else", "if    (  ( XmlNSDescriptorImpl . equalsToSchemaName ( tag ,     . RESTRICTION _ TAG _ NAME )  )     |  |     ( XmlNSDescriptorImpl . equalsToSchemaName ( tag ,     . EXTENSION _ TAG _ NAME )  )  )     {", "String   base    =    tag . getAttributeValue (  . BASE _ ATTR _ NAME )  ;", "if    (  ( base    !  =    null )     &  &     (  !  ( visited . contains ( base )  )  )  )     {", "visited . add ( base )  ;", "TypeDescriptor   descriptor    =    myDocumentDescriptor . findTypeDescriptor ( base )  ;", "if    ( descriptor   instanceof    )     {", "complexTypeDescriptor    =     (  (  )     ( descriptor )  )  ;", "if    ( dependencies    !  =    null )     {", "XmlTag   declaration    =    complexTypeDescriptor . getDeclaration (  )  ;", "dependencies . add ( declaration . getContainingFile (  )  )  ;", "}", "final    . CanContainAttributeType   containAttributeType    =    complexTypeDescriptor .  _ canContainAttribute ( namespace ,    complexTypeDescriptor . getDeclaration (  )  ,    qName ,    visited ,    dependencies )  ;", "if    ( containAttributeType    !  =     (  . CanContainAttributeType . CanNotContain )  )", "return   containAttributeType ;", "}", "}", "}", "final   XmlTag [  ]    subTags    =    tag . getSubTags (  )  ;", "for    ( XmlTag   subTag    :    subTags )     {", "final    . CanContainAttributeType   containAttributeType    =     _ canContainAttribute ( namespace ,    subTag ,    qName ,    visited ,    dependencies )  ;", "if    ( containAttributeType    !  =     (  . CanContainAttributeType . CanNotContain )  )", "return   containAttributeType ;", "}", "return    . CanContainAttributeType . CanNotContain ;", "}", "METHOD_END"], "methodName": ["_canContainAttribute"], "fileName": "com.intellij.xml.impl.schema.ComplexTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    ( visited . contains ( tag )  )", "return   false ;", "visited . add ( tag )  ;", "if    ( XmlNSDescriptorImpl . equalsToSchemaName ( tag ,     \" any \"  )  )     {", "if    (  ! restriction )     {", "myHasAnyInContentModel    =    true ;", "}", "if    (  . OTHER _ NAMESPACE _ ATTR _ VALUE . equals ( tag . getAttributeValue (  \" namespace \"  )  )  )     {", "return    ( namespace    =  =    null )     |  |     (  !  ( namespace . equals ( info . expectedDefaultNs )  )  )  ;", "}", "return   true ;", "} else", "if    ( XmlNSDescriptorImpl . equalsToSchemaName ( tag ,     \" group \"  )  )     {", "String   ref    =    tag . getAttributeValue (  . REF _ ATTR _ NAME )  ;", "if    ( ref    !  =    null )     {", "XmlTag   groupTag    =    info . documentDescriptor . findGroup ( ref )  ;", "if    ( groupTag    !  =    null )     {", "if    (  _ canContainTag ( localName ,    namespace ,    groupTag ,    context ,    visited ,     . getContextInfo ( info ,    ref )  ,    restriction )  )", "return   true ;", "}", "}", "} else", "if    (  ( XmlNSDescriptorImpl . equalsToSchemaName ( tag ,     . RESTRICTION _ TAG _ NAME )  )     |  |     ( XmlNSDescriptorImpl . equalsToSchemaName ( tag ,     . EXTENSION _ TAG _ NAME )  )  )     {", "String   base    =    tag . getAttributeValue (  . BASE _ ATTR _ NAME )  ;", "if    ( base    !  =    null )     {", "TypeDescriptor   descriptor    =    info . documentDescriptor . findTypeDescriptor ( base )  ;", "if    ( descriptor   instanceof    )     {", "complexTypeDescriptor    =     (  (  )     ( descriptor )  )  ;", "if    ( complexTypeDescriptor .  _ canContainTag ( localName ,    namespace ,    complexTypeDescriptor . myTag ,    context ,    visited ,     . getContextInfo ( info ,    base )  ,     ( restriction    |  |     ( XmlNSDescriptorImpl . equalsToSchemaName ( tag ,     . RESTRICTION _ TAG _ NAME )  )  )  )  )     {", "myHasAnyInContentModel    |  =    complexTypeDescriptor . myHasAnyInContentModel ;", "return   true ;", "}", "}", "}", "} else", "if    ( XmlNSDescriptorImpl . equalsToSchemaName ( tag ,     . ELEMENT _ TAG _ NAME )  )     {", "final   com . intellij . psi . xml . XmlAttribute   ref    =    tag . getAttribute (  . REF _ ATTR _ NAME )  ;", "XmlTag   descriptorTag    =    tag ;", "if    ( ref    !  =    null )     {", "com . intellij . psi . xml . XmlAttributeValue   element    =    ref . getValueElement (  )  ;", "final   com . intellij . psi . PsiElement   psiElement ;", "if    ( element    !  =    null )     {", "psiElement    =    com . intellij . psi . impl . source . resolve . reference . impl . providers . SchemaReferencesProvider . createTypeOrElementOrAttributeReference ( element )  . resolve (  )  ;", "if    ( psiElement   instanceof   XmlTag )", "descriptorTag    =     (  ( XmlTag )     ( psiElement )  )  ;", "}", "}", "if    (  . TRUE _ ATTR _ VALUE . equals ( descriptorTag . getAttributeValue (  \" abstract \"  )  )  )     {", "com . intellij . xml . XmlNSDescriptor    _ nsDescriptor    =    tag . getNSDescriptor ( namespace ,    true )  ;", "if    (  (  _ nsDescriptor    =  =    null )     &  &     ( context   instanceof   XmlTag )  )     {", "_ nsDescriptor    =     (  ( XmlTag )     ( context )  )  . getNSDescriptor ( namespace ,    true )  ;", "}", "final   XmlNSDescriptorImpl   nsDescriptor    =     (  _ nsDescriptor   instanceof   XmlNSDescriptorImpl )     ?     (  ( XmlNSDescriptorImpl )     (  _ nsDescriptor )  )     :    null ;", "final   com . intellij . xml . XmlElementDescriptor   descriptor    =     ( nsDescriptor    !  =    null )     ?    nsDescriptor . getElementDescriptor ( localName ,    namespace )     :    null ;", "final   String   name    =    descriptorTag . getAttributeValue (  . NAME _ ATTR _ NAME )  ;", "if    (  ( descriptor    !  =    null )     &  &     ( name    !  =    null )  )     {", "final   String   substitutionValue    =     (  ( XmlTag )     ( descriptor . getDeclaration (  )  )  )  . getAttributeValue (  \" substitutionGroup \"  )  ;", "if    (  ( substitutionValue    !  =    null )     &  &     ( name . equals ( com . intellij . xml . util . XmlUtil . findLocalNameByQualifiedName ( substitutionValue )  )  )  )     {", "return   true ;", "}", "}", "}", "}", "for    ( XmlTag   subTag    :    tag . getSubTags (  )  )     {", "if    (  _ canContainTag ( localName ,    namespace ,    subTag ,    context ,    visited ,    info ,    restriction )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["_canContainTag"], "fileName": "com.intellij.xml.impl.schema.ComplexTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "ComplexTypeDescriptor . removeAttributeDescriptor ( result ,    descriptor . getName (  )  ,    descriptor . myReferenceName )  ;", "result . add ( descriptor )  ;", "}", "METHOD_END"], "methodName": ["addAttributeDescriptor"], "fileName": "com.intellij.xml.impl.schema.ComplexTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  \" element \"  . equals ( tagName )  )     &  &     (  ( tag . getAttribute (  \" name \"  )  )     !  =    null )  )     {", "XmlElementDescriptor   element    =    myDocumentDescriptor . createElementDescriptor ( tag )  ;", "String   name    =     ( refName    =  =    null )     ?    element . getName (  )     :    refName ;", ". addElementDescriptor ( map ,    element ,    name )  ;", "}", "}", "METHOD_END"], "methodName": ["addElementDescriptor"], "fileName": "com.intellij.xml.impl.schema.ComplexTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "result . remove ( name )  ;", "result . put ( name ,    element )  ;", "}", "METHOD_END"], "methodName": ["addElementDescriptor"], "fileName": "com.intellij.xml.impl.schema.ComplexTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "mainLoop    :    while    ( true )     {", "for    ( final   XmlElementDescriptor   xmlElementDescriptor    :    result . values (  )  )     {", "XmlElementDescriptorImpl   descriptor    =     (  ( XmlElementDescriptorImpl )     ( xmlElementDescriptor )  )  ;", "final   XmlElementDescriptor [  ]    substitutes    =    nsDescriptor . getSubstitutes ( descriptor . getName (  )  ,    descriptor . getNamespace (  )  )  ;", "boolean   toContinue    =    false ;", "for    ( XmlElementDescriptor   substitute    :    substitutes )     {", "if    (  ( result . get ( substitute . getName (  )  )  )     =  =    null )     {", "toContinue    =    true ;", "result . put ( substitute . getName (  )  ,    substitute )  ;", "}", "}", "if    ( toContinue )", "continue   mainLoop ;", "}", "break ;", "}", "visited . add ( nsDescriptor )  ;", "for    ( XmlTag   tag    :    nsDescriptor . getTag (  )  . getSubTags (  )  )     {", "if    ( XmlNSDescriptorImpl . equalsToSchemaName ( tag ,     \" include \"  )  )     {", "XmlAttribute   location    =    tag . getAttribute (  \" schemaLocation \"  )  ;", "if    ( location    !  =    null )     {", "XmlAttributeValue   valueElement    =    location . getValueElement (  )  ;", "if    ( valueElement    !  =    null )     {", "PsiElement   element    =    new   FileReferenceSet ( valueElement )  . resolve (  )  ;", "if    ( element   instanceof   XmlFile )     {", "XmlDocument   document    =     (  ( XmlFile )     ( element )  )  . getDocument (  )  ;", "if    ( document    !  =    null )     {", "PsiMetaData   metaData    =    document . getMetaData (  )  ;", "if    (  ( metaData   instanceof   XmlNSDescriptorImpl )     &  &     (  !  ( visited . contains ( metaData )  )  )  )     {", ". addSubstitutionGroups ( result ,     (  ( XmlNSDescriptorImpl )     ( metaData )  )  ,    visited )  ;", "}", "}", "}", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["addSubstitutionGroups"], "fileName": "com.intellij.xml.impl.schema.ComplexTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    ( qName    =  =    null )     {", "return   myAnyAttributeCa . get ( namespace )  . getValue (  )  ;", "}", "return    _ canContainAttribute ( namespace ,    myTag ,    qName ,    new   gnu . trove . THashSet (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["canContainAttribute"], "fileName": "com.intellij.xml.impl.schema.ComplexTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return    _ canContainTag ( localName ,    namespace ,    myTag ,    context ,    new   HashSet <  >  (  5  )  ,    new   ComplexTypeDescriptor . CurrentContextInfo ( myDocumentDescriptor ,    myDocumentDescriptor . getDefaultNamespace (  )  )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["canContainTag"], "fileName": "com.intellij.xml.impl.schema.ComplexTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlSchemaTagsProcessor ( myDocumentDescriptor )     {", "@ Override", "protected   void   tagStarted ( XmlTag   tag ,    String   tagName ,    XmlTag   context ,     @ Nullable", "XmlTag   ref )     {", "String   refName    =     ( ref    =  =    null )     ?    null    :    ref . getAttributeValue (  . REF _ ATTR _ NAME )  ;", "addElementDescriptor ( tag ,    tagName ,    map ,    refName )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createProcessor"], "fileName": "com.intellij.xml.impl.schema.ComplexTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "final   List < XmlAttributeDescriptorImpl >    result    =    new   ArrayList <  >  (  )  ;", "XmlSchemaTagsProcessor   processor    =    new   XmlSchemaTagsProcessor ( myDocumentDescriptor ,     \" element \"  )     {", "@ Override", "protected   void   tagStarted ( XmlTag   tag ,    String   tagName ,    XmlTag   context ,    XmlTag   ref )     {", "if    (  . ATTRIBUTE _ TAG _ NAME . equals ( tagName )  )     {", "String   name    =    tag . getAttributeValue (  . NAME _ ATTR _ NAME )  ;", "if    ( name    =  =    null )", "return ;", "String   use    =    null ;", "if    (  . ATTRIBUTE _ TAG _ NAME . equals ( context . getLocalName (  )  )  )     {", "use    =    context . getAttributeValue (  \" use \"  )  ;", "}", "if    ( use    =  =    null )", "use    =    tag . getAttributeValue (  \" use \"  )  ;", "if    (  . PROHIBITED _ ATTR _ VALUE . equals ( use )  )     {", ". removeAttributeDescriptor ( result ,    name ,    null )  ;", "} else    {", "XmlAttributeDescriptorImpl   descriptor    =    myDocumentDescriptor . createAttributeDescriptor ( tag )  ;", "descriptor . myUse    =    use ;", "if    ( ref    !  =    null )     {", "descriptor . myReferenceName    =    ref . getAttributeValue (  . REF _ ATTR _ NAME )  ;", "}", ". addAttributeDescriptor ( result ,    descriptor )  ;", "}", "}", "}", "}  ;", "processor . startProcessing ( myTag )  ;", "return   result . toArray ( XmlAttributeDescriptor . EMPTY )  ;", "}", "METHOD_END"], "methodName": ["doCollectAttributes"], "fileName": "com.intellij.xml.impl.schema.ComplexTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    XmlElementDescriptor >    map    =    new   LinkedHashMap <  >  (  5  )  ;", "createProcessor ( map )  . startProcessing ( myTag )  ;", ". addSubstitutionGroups ( map ,    myDocumentDescriptor ,    new   HashSet <  >  (  )  )  ;", ". filterAbstractElements ( map )  ;", "return   map . values (  )  . toArray ( XmlElementDescriptor . EMPTY _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["doCollectElements"], "fileName": "com.intellij.xml.impl.schema.ComplexTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "for    ( Iterator < XmlElementDescriptor >    iterator    =    result . values (  )  . iterator (  )  ;    iterator . hasNext (  )  ;  )     {", "XmlElementDescriptorImpl   descriptor    =     (  ( XmlElementDescriptorImpl )     ( iterator . next (  )  )  )  ;", "if    ( descriptor . isAbstract (  )  )", "iterator . remove (  )  ;", "}", "}", "METHOD_END"], "methodName": ["filterAbstractElements"], "fileName": "com.intellij.xml.impl.schema.ComplexTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   ComplexTypeDescriptor . myAttributeDescriptorsCache . get ( null ,    this ,    context )  ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "com.intellij.xml.impl.schema.ComplexTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  \" simpleType \"  . equals ( myTag . getLocalName (  )  )  )     |  |     (  \" true \"  . equals ( myTag . getAttributeValue (  \" mixed \"  )  )  )  )     {", "return   XmlElement . CONTENT _ TYPE _ MIXED ;", "}", "if    (  ( getElements ( null )  . length )     >     0  )", "return   XmlElement . CONTENT _ TYPE _ CHILDREN ;", "for    ( XmlTag   tag    :    myTag . getSubTags (  )  )     {", "if    (  \" simpleContent \"  . equals ( tag . getLocalName (  )  )  )     {", "return   XmlElement . CONTENT _ TYPE _ MIXED ;", "}", "}", "return   XmlElement . CONTENT _ TYPE _ EMPTY ;", "}", "METHOD_END"], "methodName": ["getContentType"], "fileName": "com.intellij.xml.impl.schema.ComplexTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "XmlTag   rootTag    =    info . documentDescriptor . getTag (  )  ;", "XmlNSDescriptorImpl   nsDescriptor    =    XmlNSDescriptorImpl . getNSDescriptorToSearchIn ( rootTag ,    ref ,    info . documentDescriptor )  ;", "String   ns ;", "if    ( nsDescriptor    =  =     ( info . documentDescriptor )  )     {", "ns    =    rootTag . getNamespaceByPrefix ( XmlUtil . findPrefixByQualifiedName ( ref )  )  ;", "} else    {", "ns    =    nsDescriptor . getDefaultNamespace (  )  ;", "}", "if    (  ( Comparing . equal ( info . expectedDefaultNs ,    ns )  )     &  &     (  ( info . documentDescriptor )     =  =    nsDescriptor )  )", "return   info ;", "return   new    . CurrentContextInfo ( nsDescriptor ,    ns )  ;", "}", "METHOD_END"], "methodName": ["getContextInfo"], "fileName": "com.intellij.xml.impl.schema.ComplexTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   ComplexTypeDescriptor . myElementDescriptorsCache . get ( null ,    this ,    context )  ;", "}", "METHOD_END"], "methodName": ["getElements"], "fileName": "com.intellij.xml.impl.schema.ComplexTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   myDocumentDescriptor ;", "}", "METHOD_END"], "methodName": ["getNsDescriptor"], "fileName": "com.intellij.xml.impl.schema.ComplexTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   XmlElementsGroupProcessor . computeGroups ( myDocumentDescriptor ,    myTag )  ;", "}", "METHOD_END"], "methodName": ["getTopGroup"], "fileName": "com.intellij.xml.impl.schema.ComplexTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   myHasAnyInContentModel ;", "}", "METHOD_END"], "methodName": ["hasAnyInContentModel"], "fileName": "com.intellij.xml.impl.schema.ComplexTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "for    ( Iterator < XmlAttributeDescriptorImpl >    iterator    =    result . iterator (  )  ;    iterator . hasNext (  )  ;  )     {", "XmlAttributeDescriptorImpl   descriptor    =    iterator . next (  )  ;", "if    (  ( descriptor . getName (  )  . equals ( name )  )     &  &     (  ( referenceName    =  =    null )     |  |     ( referenceName . equals ( descriptor . myReferenceName )  )  )  )     {", "iterator . remove (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["removeAttributeDescriptor"], "fileName": "com.intellij.xml.impl.schema.ComplexTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "for    ( XmlNSDescriptorImpl   descriptor    :    myDescriptors )     {", "T   t    =    function . apply ( descriptor )  ;", "if    ( t    !  =    null )", "return   t ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getFirst"], "fileName": "com.intellij.xml.impl.schema.MultiFileNsDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    ( dcl . isWritable (  )  )     {", "final   VirtualFile   virtualFile    =    dcl . getContainingFile (  )  . getVirtualFile (  )  ;", "if    (  ( virtualFile    !  =    null )     &  &     (  ( ProRootManager . getInstance ( dcl . getPro (  )  )  . getFileIndex (  )  . getModuleForFile ( virtualFile )  )     !  =    null )  )     {", "dcl . setAttribute (  \" name \"  ,    name . substring (  (  ( name . indexOf (  '  :  '  )  )     +     1  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "com.intellij.xml.impl.schema.NamedObjectDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   NullElementDescriptor . INSTANCE ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "com.intellij.xml.impl.schema.NullElementDescriptor"}, {"methodBody": ["METHOD_START", "{", "XmlAttribute   name    =    SchemaDefinitionsSearch . getNameAttr ( xml )  ;", "if    (  ( name    =  =    null )     |  |     ( StringUtil . isEmptyOrSpaces ( name . getValue (  )  )  )  )", "return   null ;", "String   localName    =    name . getValue (  )  ;", "final   boolean   hasPrefix    =    localName . contains (  \"  :  \"  )  ;", "localName    =     ( hasPrefix )     ?    localName . substring (  (  ( localName . indexOf (  '  :  '  )  )     +     1  )  )     :    localName ;", "final   String   nsPrefix    =     ( hasPrefix )     ?    name . getValue (  )  . substring (  0  ,    name . getValue (  )  . indexOf (  '  :  '  )  )     :    null ;", "final   XmlFile   file    =    XmlUtil . getContainingFile ( xml )  ;", "if    ( file    =  =    null )", "return   null ;", "final   Project   project    =    file . getProject (  )  ;", "if    ( project    =  =    null )", "return   null ;", "final   Set < SchemaTypeInfo >    result    =    new   HashSet <  >  (  )  ;", "final   ArrayDeque < SchemaTypeInfo >    queue    =    new   ArrayDeque <  >  (  )  ;", "String   nsUri ;", "if    (  ! hasPrefix )     {", "nsUri    =    getDefaultNs ( file )  ;", "} else    {", "nsUri    =    XmlUtil . findNamespaceByPrefix ( nsPrefix ,    file . getRootTag (  )  )  ;", "}", "if    ( nsUri    =  =    null )", "return   null ;", "queue . add ( new   SchemaTypeInfo ( localName ,    true ,    nsUri )  )  ;", "final   BiFunction < String ,    String ,    List < Set < SchemaTypeInfo >  >  >    worker    =    SchemaTypeInheritanceIndex . getWorker ( project ,    file . getContainingFile (  )  . getVirtualFile (  )  )  ;", "while    (  !  ( queue . isEmpty (  )  )  )     {", "final   SchemaTypeInfo   info    =    queue . removeFirst (  )  ;", "final   List < Set < SchemaTypeInfo >  >    childrenOfType    =    worker . apply ( info . getNamespaceUri (  )  ,    info . getTagName (  )  )  ;", "for    ( Set < SchemaTypeInfo >    infos    :    childrenOfType )     {", "for    ( SchemaTypeInfo   typeInfo    :    infos )     {", "if    ( typeInfo . isIsTypeName (  )  )     {", "queue . add ( typeInfo )  ;", "}", "result . add ( typeInfo )  ;", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["gatherInheritors"], "fileName": "com.intellij.xml.impl.schema.SchemaDefinitionsSearch"}, {"methodBody": ["METHOD_START", "{", "return   ReadAction . compute (  (  )     -  >     {", "String   nsUri ;", "final   XmlTag   tag    =    file . getDocument (  )  . getRootTag (  )  ;", "XmlAttribute   xmlns    =    tag . getAttribute (  \" xmlns \"  ,    XmlUtil . XML _ SCHEMA _ URI )  ;", "xmlns    =     ( xmlns    =  =    null )     ?    tag . getAttribute (  \" xmlns \"  )     :    xmlns ;", "nsUri    =     ( xmlns    =  =    null )     ?    null    :    xmlns . getValue (  )  ;", "return   nsUri ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultNs"], "fileName": "com.intellij.xml.impl.schema.SchemaDefinitionsSearch"}, {"methodBody": ["METHOD_START", "{", "XmlAttribute   name    =    xml . getAttribute (  \" name \"  ,    XmlUtil . XML _ SCHEMA _ URI )  ;", "name    =     ( name    =  =    null )     ?    xml . getAttribute (  \" name \"  )     :    name ;", "return   name ;", "}", "METHOD_END"], "methodName": ["getNameAttr"], "fileName": "com.intellij.xml.impl.schema.SchemaDefinitionsSearch"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( SchemaDefinitionsSearch . isTypeElement ( xml )  )  )", "return   false ;", "final   XmlAttribute   name    =    SchemaDefinitionsSearch . getNameAttr ( xml )  ;", "if    ( name    =  =    null )", "return   false ;", "final   String   value    =    name . getValue (  )  ;", "if    ( value    =  =    null )", "return   false ;", "final   String   localName    =    XmlUtil . findLocalNameByQualifiedName ( value )  ;", "return    ( typeName . equals ( localName )  )     &  &     ( nsPrefix . equals ( XmlUtil . findPrefixByQualifiedName ( value )  )  )  ;", "}", "METHOD_END"], "methodName": ["isCertainTypeElement"], "fileName": "com.intellij.xml.impl.schema.SchemaDefinitionsSearch"}, {"methodBody": ["METHOD_START", "{", "final   String   localName    =    xml . getLocalName (  )  ;", "if    (  !  (  ( XmlUtil . XML _ SCHEMA _ URI . equals ( xml . getNamespace (  )  )  )     &  &     (  \" element \"  . equals ( localName )  )  )  )     {", "return   false ;", "}", "final   XmlAttribute   nameAttr    =     . getNameAttr ( xml )  ;", "if    (  ( nameAttr    =  =    null )     |  |     (  ( nameAttr . getValue (  )  )     =  =    null )  )", "return   false ;", "final   String   localTypeName    =    XmlUtil . findLocalNameByQualifiedName ( nameAttr . getValue (  )  )  ;", "final   String   prefix    =    XmlUtil . findPrefixByQualifiedName ( nameAttr . getValue (  )  )  ;", "if    (  (  !  ( typeName . equals ( localTypeName )  )  )     |  |     (  !  ( typeNsPrefix . equals ( prefix )  )  )  )     {", "return   false ;", "}", "final   XmlTag [  ]    tags    =    xml . getSubTags (  )  ;", "for    ( XmlTag   tag    :    tags )     {", "if    (  . isTypeElement (  (  ( XmlTagImpl )     ( tag )  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isElementWithEmbeddedType"], "fileName": "com.intellij.xml.impl.schema.SchemaDefinitionsSearch"}, {"methodBody": ["METHOD_START", "{", "final   String   localName    =    xml . getLocalName (  )  ;", "if    (  !  (  ( XmlUtil . XML _ SCHEMA _ URI . equals ( xml . getNamespace (  )  )  )     &  &     (  \" element \"  . equals ( localName )  )  )  )     {", "return   false ;", "}", "final   XmlTag [  ]    tags    =    xml . getSubTags (  )  ;", "for    ( XmlTag   tag    :    tags )     {", "if    (  . isTypeElement (  (  ( XmlTagImpl )     ( tag )  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isElementWithSomeEmbeddedType"], "fileName": "com.intellij.xml.impl.schema.SchemaDefinitionsSearch"}, {"methodBody": ["METHOD_START", "{", "final   String   localName    =    xml . getLocalName (  )  ;", "return    ( XmlUtil . XML _ SCHEMA _ URI . equals ( xml . getNamespace (  )  )  )     &  &     (  (  \" complexType \"  . equals ( localName )  )     |  |     (  \" simpleType \"  . equals ( localName )  )  )  ;", "}", "METHOD_END"], "methodName": ["isTypeElement"], "fileName": "com.intellij.xml.impl.schema.SchemaDefinitionsSearch"}, {"methodBody": ["METHOD_START", "{", "return   XmlUtil . XML _ SCHEMA _ URI . equals ( tag . getNamespace (  )  )  ;", "}", "METHOD_END"], "methodName": ["isFromSchemaNs"], "fileName": "com.intellij.xml.impl.schema.SchemaNSDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   myTag ;", "}", "METHOD_END"], "methodName": ["getDeclaration"], "fileName": "com.intellij.xml.impl.schema.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   myTag . getAttributeValue (  \" type \"  )  ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.intellij.xml.impl.schema.XmlAttributeDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "final   String   attributeValue    =    getType (  )  ;", "if    ( attributeValue    !  =    null )     {", "if    ( attributeValue . endsWith ( type )  )     {", "final   String   namespacePrefix    =    myTag . getNamespacePrefix (  )  ;", "if    (  ( namespacePrefix . length (  )  )     >     0  )     {", "return   attributeValue . equals (  (  ( namespacePrefix    +     \"  :  \"  )     +    type )  )  ;", "} else    {", "return   attributeValue . equals ( type )  ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasSimpleSchemaType"], "fileName": "com.intellij.xml.impl.schema.XmlAttributeDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "boolean   attributeShouldBeQualified    =    false ;", "String   contextNs    =    contextTag . getNamespace (  )  ;", "if    (  !  ( contextNs . equals ( targetNs )  )  )     {", "final   XmlElementDescriptor   xmlElementDescriptor    =    contextTag . getDescriptor (  )  ;", "if    ( xmlElementDescriptor   instanceof   XmlElementDescriptorImpl )     {", "final   XmlElementDescriptorImpl   elementDescriptor    =     (  ( XmlElementDescriptorImpl )     ( xmlElementDescriptor )  )  ;", "final   TypeDescriptor   type    =    elementDescriptor . getType (  )  ;", "if    ( type   instanceof   ComplexTypeDescriptor )     {", "final   ComplexTypeDescriptor   typeDescriptor    =     (  ( ComplexTypeDescriptor )     ( type )  )  ;", "if    (  ( myReferenceName )     !  =    null )     {", "return    ( myReferenceName . indexOf (  '  :  '  )  )     !  =     0  ;", "}", "[  ]    attributes    =     (  ( ComplexTypeDescriptor )     ( type )  )  . getAttributes ( contextTag )  ;", "if    ( ArrayUtil . contains ( this ,    attributes )  )     {", "return   false ;", "}", "attributeShouldBeQualified    =     ( typeDescriptor . canContainAttribute ( targetNs ,    null )  )     !  =     ( ComplexTypeDescriptor . CanContainAttributeType . CanNotContain )  ;", "}", "if    (  (  (  ! attributeShouldBeQualified )     &  &     (  ( contextNs . length (  )  )     =  =     0  )  )     &  &     (  ( targetNs . length (  )  )     >     0  )  )     {", "attributeShouldBeQualified    =     !  ( targetNs . equals ( elementDescriptor . getNamespace (  )  )  )  ;", "}", "}", "}", "return   attributeShouldBeQualified ;", "}", "METHOD_END"], "methodName": ["shouldBeQualified"], "fileName": "com.intellij.xml.impl.schema.XmlAttributeDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    o )", "return   true ;", "if    (  !  ( o   instanceof    )  )", "return   false ;", "final      that    =     (  (  )     ( o )  )  ;", "if    (  ( myType )     !  =    null    ?     !  ( myType . equals ( that . myType )  )     :     ( that . myType )     !  =    null )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.intellij.xml.impl.schema.XmlElementDescriptorByType"}, {"methodBody": ["METHOD_START", "{", "return    ( myType )     !  =    null    ?    myType . hashCode (  )     :     0  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.intellij.xml.impl.schema.XmlElementDescriptorByType"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["askParentDescriptorViaXsi"], "fileName": "com.intellij.xml.impl.schema.XmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "XmlAttributeDescriptor [  ]    descriptors    =    getAttributesDescriptors ( context )  ;", "for    ( XmlAttributeDescriptor   descriptor    :    descriptors )     {", "if    (  ( descriptor . getName (  )  . equals ( attributeName )  )     &  &     ( descriptor . getName ( context )  . equals ( qName )  )  )     {", "return   descriptor ;", "}", "}", "TypeDescriptor   type    =    getType ( context )  ;", "if    ( type   instanceof   ComplexTypeDescriptor )     {", "ComplexTypeDescriptor   descriptor    =     (  ( ComplexTypeDescriptor )     ( type )  )  ;", "final   ComplexTypeDescriptor . CanContainAttributeType   containAttributeType    =    descriptor . canContainAttribute ( namespace ,    qName )  ;", "if    ( containAttributeType    !  =     ( ComplexTypeDescriptor . CanContainAttributeType . CanNotContain )  )     {", "return   new   AnyXmlAttributeDescriptor ( attributeName ,    containAttributeType )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAttribute"], "fileName": "com.intellij.xml.impl.schema.XmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "final   String   localName    =    XmlUtil . findLocalNameByQualifiedName ( attributeName )  ;", "final   String   namespacePrefix    =    XmlUtil . findPrefixByQualifiedName ( attributeName )  ;", "final   String   namespace    =     ( namespacePrefix . isEmpty (  )  )     ?    getDefaultNamespace (  )     :    context . getNamespaceByPrefix ( namespacePrefix )  ;", "XmlAttributeDescriptor   attribute    =    getAttribute ( localName ,    namespace ,    context ,    attributeName )  ;", "if    ( attribute   instanceof   AnyXmlAttributeDescriptor )     {", "final   ComplexTypeDescriptor . CanContainAttributeType   containAttributeType    =     (  ( AnyXmlAttributeDescriptor )     ( attribute )  )  . getCanContainAttributeType (  )  ;", "if    (  ( containAttributeType    !  =     ( ComplexTypeDescriptor . CanContainAttributeType . CanContainAny )  )     &  &     (  !  ( namespace . isEmpty (  )  )  )  )     {", "final   XmlNSDescriptor   candidateNSDescriptor    =    context . getNSDescriptor ( namespace ,    true )  ;", "if    ( candidateNSDescriptor   instanceof   XmlNS )     {", "final   XmlNS   nsDescriptor    =     (  ( XmlNS )     ( candidateNSDescriptor )  )  ;", "final   XmlAttributeDescriptor   xmlAttributeDescriptor    =    nsDescriptor . getAttribute ( localName ,    namespace ,    context )  ;", "if    ( xmlAttributeDescriptor    !  =    null )", "return   xmlAttributeDescriptor ;", "else    {", "if    ( containAttributeType    =  =     ( ComplexTypeDescriptor . CanContainAttributeType . CanContainButDoNotSkip )  )     {", "attribute    =    null ;", "}", "}", "}", "}", "}", "return   attribute ;", "}", "METHOD_END"], "methodName": ["getAttributeDescriptorImpl"], "fileName": "com.intellij.xml.impl.schema.XmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   nsDescriptor    =    getNSDescriptor (  )  ;", "return   nsDescriptor   instanceof   XmlNS    ?     (  ( XmlNS )     ( nsDescriptor )  )  . getDefaultNamespace (  )     :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["getDefaultNamespace"], "fileName": "com.intellij.xml.impl.schema.XmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "final   String   localName    =    XmlUtil . findLocalNameByQualifiedName ( name )  ;", "final   String   namespacePrefix    =    XmlUtil . findPrefixByQualifiedName ( name )  ;", "final   String   namespace    =     ( namespacePrefix . isEmpty (  )  )     ?    getDefaultNamespace (  )     :    myDescriptorTag . getNamespaceByPrefix ( namespacePrefix )  ;", "return   get ( localName ,    namespace ,    null ,    name )  ;", "}", "METHOD_END"], "methodName": ["getElementDescriptor"], "fileName": "com.intellij.xml.impl.schema.XmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "XmlElementDescriptor [  ]    elements    =    getElementsDescriptorsImpl ( context )  ;", "for    ( XmlElementDescriptor   element 1     :    elements )     {", "final      element    =     (  (  )     ( element 1  )  )  ;", "final   String   namespaceByContext    =    element . getNamespaceByContext ( context )  ;", "if    ( element . getName (  )  . equals ( localName )  )     {", "if    (  (  (  (  ( namespace    =  =    null )     |  |     ( namespace . equals ( namespaceByContext )  )  )     |  |     ( namespaceByContext . equals ( XmlUtil . EMPTY _ URI )  )  )     |  |     ( element . getName ( context )  . equals ( fullName )  )  )     |  |     (  (  ( namespace . length (  )  )     =  =     0  )     &  &     ( element . getDefaultName (  )  . equals ( fullName )  )  )  )     {", "return   element ;", "} else    {", "final   XmlNSDescriptor   descriptor    =     ( context   instanceof   XmlTag )     ?     (  ( XmlTag )     ( context )  )  . getNSDescriptor ( namespace ,    true )     :    null ;", "if    ( descriptor   instanceof   XmlNSDescriptorImpl )     {", "if    (  (  ( XmlNSDescriptorImpl )     ( descriptor )  )  . getDefaultNamespace (  )  . equals ( namespaceByContext )  )     {", "return   element ;", "} else    {", "(  ( XmlNSDescriptorImpl )     ( descriptor )  )  . getSubstitutes ( localName ,    namespace )  ;", "}", "}", "}", "}", "}", "TypeDescriptor   type    =    getType ( context )  ;", "if    ( type   instanceof   ComplexTypeDescriptor )     {", "ComplexTypeDescriptor   descriptor    =     (  ( ComplexTypeDescriptor )     ( type )  )  ;", "if    ( descriptor . canContainTag ( localName ,    namespace ,    context )  )     {", "return   new   AnyXmlElementDescriptor ( this ,    getNSDescriptor (  )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getElementDescriptor"], "fileName": "com.intellij.xml.impl.schema.XmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   type    =    getType ( context )  ;", "if    ( type   instanceof   ComplexTypeDescriptor )     {", "ComplexTypeDescriptor   typeDescriptor    =     (  ( ComplexTypeDescriptor )     ( type )  )  ;", "[  ]    elements    =    typeDescriptor . getElements ( context )  ;", "if    (  ( context   instanceof   XmlTag )     &  &     (  ( elements . length )     >     0  )  )     {", "String [  ]    namespaces    =     (  ( XmlTag )     ( context )  )  . knownNamespaces (  )  ;", "if    (  ( namespaces . length )     >     1  )     {", "List <  >    result    =    new   ArrayList <  >  ( Arrays . asList ( elements )  )  ;", "for    ( String   namespace    :    namespaces )     {", "if    ( namespace . equals ( typeDescriptor . getNsDescriptor (  )  . getDefaultNamespace (  )  )  )     {", "continue ;", "}", "XmlNSDescriptor   descriptor    =     (  ( XmlTag )     ( context )  )  . getNSDescriptor ( namespace ,    false )  ;", "if    (  ( descriptor   instanceof   XmlNSDescriptorImpl )     &  &     (  (  ( XmlNSDescriptorImpl )     ( descriptor )  )  . hasSubstitutions (  )  )  )     {", "for    (    element    :    elements )     {", "String   name    =    XmlUtil . getLocalName ( element . getName ( context )  )  . toString (  )  ;", "String   s    =     (  ( XmlNSDescriptorImpl )     ( element . getNSDescriptor (  )  )  )  . getDefaultNamespace (  )  ;", "[  ]    substitutes    =     (  ( XmlNSDescriptorImpl )     ( descriptor )  )  . getSubstitutes ( name ,    s )  ;", "result . addAll ( Arrays . asList ( substitutes )  )  ;", "}", "}", "}", "return   result . toArray (  . EMPTY _ ARRAY )  ;", "}", "}", "return   elements ;", "}", "return    . EMPTY _ ARRAY ;", "}", "METHOD_END"], "methodName": ["getElementsDescriptorsImpl"], "fileName": "com.intellij.xml.impl.schema.XmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return   XmlUtil . findNamespacePrefixByURI (  (  ( XmlFile )     ( myDescriptorTag . getContainingFile (  )  )  )  ,    getNamespace (  )  )  ;", "}", "METHOD_END"], "methodName": ["getNS"], "fileName": "com.intellij.xml.impl.schema.XmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptor   nsDescriptor    =    getNSDescriptor (  )  ;", "if    (  ( context   instanceof   XmlTag )     &  &     ( nsDescriptor   instanceof   XmlNS )  )     {", "final   String   defaultNamespace    =     (  ( XmlNS )     ( nsDescriptor )  )  . getDefaultNamespace (  )  ;", "if    ( XmlUtil . XML _ SCHEMA _ URI . equals ( defaultNamespace )  )", "return   nsDescriptor ;", "final   XmlTag   tag    =     (  ( XmlTag )     ( context )  )  ;", "final   String   tagNs    =    tag . getNamespace (  )  ;", "if    ( tagNs . equals ( defaultNamespace )  )     {", "XmlNSDescriptor   previousDescriptor    =    nsDescriptor ;", "nsDescriptor    =    tag . getNSDescriptor ( tagNs ,    true )  ;", "if    ( nsDescriptor    =  =    null )", "nsDescriptor    =    previousDescriptor ;", "}", "}", "return   nsDescriptor ;", "}", "METHOD_END"], "methodName": ["getNSDescriptor"], "fileName": "com.intellij.xml.impl.schema.XmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "String   name    =    getName (  )  ;", "if    ( name    =  =    null )", "return   XmlUtil . EMPTY _ URI ;", "if    (  (  ( getNS (  )  )     =  =    null )     |  |     (  ( myTag )     =  =    null )  )", "return   XmlUtil . EMPTY _ URI ;", "final   String   namespacePrefix    =    XmlUtil . findPrefixByQualifiedName ( name )  ;", "return   namespacePrefix . isEmpty (  )     ?    getDefaultNamespace (  )     :    myTag . getNamespaceByPrefix ( namespacePrefix )  ;", "}", "METHOD_END"], "methodName": ["getNamespace"], "fileName": "com.intellij.xml.impl.schema.XmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return   getNamespace (  )  ;", "}", "METHOD_END"], "methodName": ["getNamespaceByContext"], "fileName": "com.intellij.xml.impl.schema.XmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return   getType ( null )  ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.intellij.xml.impl.schema.XmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "final   XmlNSDescriptor   nsDescriptor    =    getNSDescriptor ( context )  ;", "if    (  !  ( nsDescriptor   instanceof   XmlNSTypeDescriptorProvider )  )", "return   null ;", "TypeDescriptor   type    =     (  ( XmlNSTypeDescriptorProvider )     ( nsDescriptor )  )  . getTypeDescriptor ( myDescriptorTag )  ;", "if    ( type    =  =    null )     {", "String   substAttr    =    myDescriptorTag . getAttributeValue (  \" substitutionGroup \"  )  ;", "if    ( substAttr    !  =    null )     {", "final   String   namespacePrefix    =    XmlUtil . findPrefixByQualifiedName ( substAttr )  ;", "final   String   namespace    =     ( namespacePrefix . isEmpty (  )  )     ?    getDefaultNamespace (  )     :    myDescriptorTag . getNamespaceByPrefix ( namespacePrefix )  ;", "final   String   local    =    XmlUtil . findLocalNameByQualifiedName ( substAttr )  ;", "final      originalElement    =     (  (  )     (  (  ( XmlNSDescriptorImpl )     ( getNSDescriptor (  )  )  )  . getElementDescriptor ( local ,    namespace )  )  )  ;", "if    (  ( originalElement    !  =    null )     &  &     ( originalElement    !  =     ( this )  )  )     {", "type    =    originalElement . getType ( context )  ;", "}", "}", "} else", "if    (  ( context   instanceof   com . intellij . psi . xml . XmlTag )     &  &     ( nsDescriptor   instanceof   XmlNSDescriptorImpl )  )     {", "com . intellij . psi . xml . XmlTag   tag    =     (  ( com . intellij . psi . xml . XmlTag )     ( context )  )  ;", "if    (  !  ( tag . getNamespace (  )  . equals (  (  ( XmlNSDescriptorImpl )     ( nsDescriptor )  )  . getDefaultNamespace (  )  )  )  )     {", "XmlNSDescriptor   descriptor    =    tag . getNSDescriptor ( tag . getNamespace (  )  ,    true )  ;", "if    (  ( descriptor    !  =    nsDescriptor )     &  &     ( descriptor   instanceof   XmlNSTypeDescriptorProvider )  )     {", "TypeDescriptor   typeDescriptor    =     (  ( XmlNSTypeDescriptorProvider )     ( descriptor )  )  . getTypeDescriptor ( myDescriptorTag )  ;", "if    (  ( typeDescriptor    !  =    null )     &  &     (  ( typeDescriptor . getDeclaration (  )  )     !  =     ( type . getDeclaration (  )  )  )  )     {", "return   typeDescriptor ;", "}", "}", "}", "}", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.intellij.xml.impl.schema.XmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return   XmlElementDescriptorImpl . isAbstractDeclaration ( myDescriptorTag )  ;", "}", "METHOD_END"], "methodName": ["isAbstract"], "fileName": "com.intellij.xml.impl.schema.XmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return   Boolean . valueOf ( descriptorTag . getAttributeValue (  \" abstract \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isAbstractDeclaration"], "fileName": "com.intellij.xml.impl.schema.XmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "myValidator    =    validator ;", "}", "METHOD_END"], "methodName": ["setValidator"], "fileName": "com.intellij.xml.impl.schema.XmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( typeDescriptor . canContainAttribute ( ns ,    null )  )     !  =     ( ComplexTypeDescriptor . CanContainAttributeType . CanNotContain )  )     {", "final   XmlNSDescriptor   descriptor    =    context . getNSDescriptor ( ns ,    true )  ;", "if    ( descriptor   instanceof   XmlNS )     {", "XmlAttributeDescriptor [  ]    rootDescriptors    =     (  ( XmlNS )     ( descriptor )  )  . getRootAttributeDescriptors ( context )  ;", "attributeDescriptors    =    ArrayUtil . mergeArrays ( attributeDescriptors ,    rootDescriptors )  ;", "}", "}", "return   attributeDescriptors ;", "}", "METHOD_END"], "methodName": ["updateAttributeDescriptorsFromAny"], "fileName": "com.intellij.xml.impl.schema.XmlElementDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( tag    =  =    null )", "return    1  ;", "String   value    =    tag . getAttributeValue (  \" maxOccurs \"  )  ;", "if    ( value    =  =    null )", "return    1  ;", "if    (  \" unbounded \"  . equals ( value )  )", "return   Iger . MAX _ VALUE ;", "try    {", "return   Iger . parseInt ( value )  ;", "}    catch    ( NumberFormatException   e )     {", "return    1  ;", "}", "}", "METHOD_END"], "methodName": ["getMaxOccursImpl"], "fileName": "com.intellij.xml.impl.schema.XmlElementsGroupBase"}, {"methodBody": ["METHOD_START", "{", "if    ( tag    =  =    null )", "return    1  ;", "String   value    =    tag . getAttributeValue (  \" minOccurs \"  )  ;", "try    {", "return   value    =  =    null    ?     1     :    Iger . parseInt ( value )  ;", "}    catch    ( NumberFormatException   e )     {", "return    1  ;", "}", "}", "METHOD_END"], "methodName": ["getMinOccursImpl"], "fileName": "com.intellij.xml.impl.schema.XmlElementsGroupBase"}, {"methodBody": ["METHOD_START", "{", "mySubGroups . add ( group )  ;", "}", "METHOD_END"], "methodName": ["addSubGroup"], "fileName": "com.intellij.xml.impl.schema.XmlElementsGroupImpl"}, {"methodBody": ["METHOD_START", "{", "return   XmlElementsGroupImpl . TYPES . get ( tag . getLocalName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTagType"], "fileName": "com.intellij.xml.impl.schema.XmlElementsGroupImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( myGroups . empty (  )  )  )     {", "last    =    myGroups . peek (  )  ;", "if    ( last   instanceof   Impl )     {", "(  ( Impl )     ( last )  )  . addSubGroup ( group )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addSubGroup"], "fileName": "com.intellij.xml.impl.schema.XmlElementsGroupProcessor"}, {"methodBody": ["METHOD_START", "{", "XmlElementsGroupProcessor   processor    =    new   XmlElementsGroupProcessor ( descriptor )  ;", "processor . startProcessing ( tag )  ;", "return   processor . getRootGroup (  )  ;", "}", "METHOD_END"], "methodName": ["computeGroups"], "fileName": "com.intellij.xml.impl.schema.XmlElementsGroupProcessor"}, {"methodBody": ["METHOD_START", "{", "return   myGroups . get (  0  )  ;", "}", "METHOD_END"], "methodName": ["getRootGroup"], "fileName": "com.intellij.xml.impl.schema.XmlElementsGroupProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( file    !  =    null )     {", "final   XmlDocument   document    =    file . getDocument (  )  ;", ". collectDependencies (  ( document    !  =    null    ?    document . getRootTag (  )     :    null )  ,    file ,    visited )  ;", "}", "}", "METHOD_END"], "methodName": ["addDependency"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "final   String   localAttrName    =    XmlUtil . findLocalNameByQualifiedName ( fqn )  ;", "if    (  !  ( localAttrName . equals ( localName )  )  )", "return   false ;", "final   String   attrNamespace    =    context . getNamespaceByPrefix ( XmlUtil . findPrefixByQualifiedName ( fqn )  )  ;", "if    ( attrNamespace . equals ( namespace )  )", "return   true ;", "if    (  ( myTargetNamespace )     =  =    null )     {", "if    ( XmlUtil . EMPTY _ URI . equals ( attrNamespace )  )", "return   true ;", "} else    {", "if    ( myTargetNamespace . equals ( namespace )  )", "return   true ;", "return    ( context . get ( namespace ,    true )  )     =  =     ( this )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["checkElementNameEquivalence"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptorImpl . LOG . assertTrue ( context . isValid (  )  )  ;", "final   String   namespace    =    context . getNamespace (  )  ;", "if    (  ( namespace . length (  )  )     >     0  )     {", "return   XmlNSDescriptorImpl . checkSchemaNamespace ( namespace )  ;", "}", "return   StringUtil . startsWithConcatenation ( context . getName (  )  ,    XmlNSDescriptorImpl . XSD _ PREFIX ,     \"  :  \"  )  ;", "}", "METHOD_END"], "methodName": ["checkSchemaNamespace"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( XmlUtil . XML _ SCHEMA _ URI . equals ( namespace )  )     |  |     ( XmlUtil . XML _ SCHEMA _ URI 2  . equals ( namespace )  )  )     |  |     ( XmlUtil . XML _ SCHEMA _ URI 3  . equals ( namespace )  )  ;", "}", "METHOD_END"], "methodName": ["checkSchemaNamespace"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "final   String   namespace    =    context . getNamespaceByPrefix ( XmlUtil . findPrefixByQualifiedName ( name )  )  ;", "if    (  ( namespace . length (  )  )     >     0  )     {", "return    . checkSchemaNamespace ( namespace )  ;", "}", "return    . XSD _ PREFIX . equals ( XmlUtil . findPrefixByQualifiedName ( name )  )  ;", "}", "METHOD_END"], "methodName": ["checkSchemaNamespace"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( visited . contains ( myFile )  )", "return ;", "visited . add ( myFile )  ;", "if    ( myTag    =  =    null )", "return ;", "XmlTag [  ]    tags    =    myTag . getSubTags (  )  ;", "for    ( final   XmlTag   tag    :    tags )     {", "if    (  (  . equalsToSchemaName ( tag ,     . INCLUDE _ TAG _ NAME )  )     |  |     (  . equalsToSchemaName ( tag ,     . IMPORT _ TAG _ NAME )  )  )     {", "final   String   schemaLocation    =    tag . getAttributeValue (  \" schemaLocation \"  )  ;", "if    ( schemaLocation    !  =    null )     {", "final   XmlFile   xmlFile    =    XmlUtil . findNamespace ( myFile ,    schemaLocation )  ;", ". addDependency ( xmlFile ,    visited )  ;", "}", "} else", "if    (  . equalsToSchemaName ( tag ,     . REDEFINE _ TAG _ NAME )  )     {", ". myRedefinedDescriptorsInProcessing . set ( visited )  ;", "try    {", "final   XmlFile   file    =     . getRedefinedElementDescriptorFile ( tag )  ;", ". addDependency ( file ,    visited )  ;", "}    finally    {", ". myRedefinedDescriptorsInProcessing . set ( null )  ;", "}", "}", "}", "final   String   schemaLocationDeclaration    =    myTag . getAttributeValue (  \" schemaLocation \"  ,    XmlUtil . XML _ SCHEMA _ INSTANCE _ URI )  ;", "if    ( schemaLocationDeclaration    !  =    null )     {", "final   StringTokenizer   tokenizer    =    new   StringTokenizer ( schemaLocationDeclaration )  ;", "while    ( tokenizer . hasMoreTokens (  )  )     {", "final   String   uri    =    tokenizer . nextToken (  )  ;", "if    ( tokenizer . hasMoreTokens (  )  )     {", "PsiFile   resourceLocation    =    ExternalResourceManager . getInstance (  )  . getResourceLocation ( tokenizer . nextToken (  )  ,    myFile ,    null )  ;", "if    ( resourceLocation    =  =    null )", "resourceLocation    =    ExternalResourceManager . getInstance (  )  . getResourceLocation ( uri ,    myFile ,    null )  ;", "if    ( resourceLocation   instanceof   XmlFile )", ". addDependency (  (  ( XmlFile )     ( resourceLocation )  )  ,    visited )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["collectDependencies"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "final   CachedValue < TypeDescriptor >    value    =    CachedValuesManager . getManager ( tag . getProject (  )  )  . createCachedValue (  (  )     -  >     {", "final   String   name    =    tag . getAttributeValue (  \" name \"  )  ;", "if    (  (  (  ( name    !  =    null )     &  &     ( pair . first    !  =    null )  )     &  &     ( pair . first . first    !  =    null )  )     &  &     (  !  ( name . equals ( XmlUtil . findLocalNameByQualifiedName ( pair . first . first )  )  )  )  )     {", "myTypesMap . remove ( pair )  ;", "return   new   CachedValueProvider . Result <  >  ( null ,    PsiModificationTracker . MODIFICATION _ COUNT )  ;", "}", "final   ComplexTypeDescriptor   complexTypeDescriptor    =    new   ComplexTypeDescriptor ( this ,    tag )  ;", "return   new   CachedValueProvider . Result <  >  ( complexTypeDescriptor ,    tag )  ;", "}  ,    false )  ;", "myTypesMap . put ( pair ,    value )  ;", "return   value ;", "}", "METHOD_END"], "methodName": ["createAndPutTypesCachedValue"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "final   CachedValue < TypeDescriptor >    value    =    CachedValuesManager . getManager ( tag . getProject (  )  )  . createCachedValue (  (  )     -  >     {", "final   SimpleTypeDescriptor   simpleTypeDescriptor    =    new   SimpleTypeDescriptor ( tag )  ;", "return   new   CachedValueProvider . Result < TypeDescriptor >  ( simpleTypeDescriptor ,    tag )  ;", "}  ,    false )  ;", "myTypesMap . put ( pair ,    value )  ;", "return   value ;", "}", "METHOD_END"], "methodName": ["createAndPutTypesCachedValueSimpleType"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlAttributeDescriptorImpl ( tag )  ;", "}", "METHOD_END"], "methodName": ["createAttributeDescriptor"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlElementDescriptorImpl ( tag )  ;", "}", "METHOD_END"], "methodName": ["createElementDescriptor"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "for    ( final   XmlTag   tag    :    tags )     {", "if    (  . equalsToSchemaName ( tag ,     \" complexType \"  )  )     {", "if    ( name    =  =    null )     {", "CachedValue < TypeDescriptor >    value    =    createAndPutTypesCachedValue ( tag ,    pair )  ;", "return   value . getValue (  )  ;", "}", "String   nameAttribute    =    tag . getAttributeValue (  \" name \"  )  ;", "if    ( isSameName ( name ,    namespace ,    nameAttribute )  )     {", "CachedValue < TypeDescriptor >    cachedValue    =    createAndPutTypesCachedValue ( tag ,    pair )  ;", "return   cachedValue . getValue (  )  ;", "}", "} else", "if    (  . equalsToSchemaName ( tag ,     \" simpleType \"  )  )     {", "if    ( name    =  =    null )     {", "CachedValue < TypeDescriptor >    value    =    createAndPutTypesCachedValueSimpleType ( tag ,    pair )  ;", "return   value . getValue (  )  ;", "}", "String   nameAttribute    =    tag . getAttributeValue (  \" name \"  )  ;", "if    ( isSameName ( name ,    namespace ,    nameAttribute )  )     {", "CachedValue < TypeDescriptor >    cachedValue    =    createAndPutTypesCachedValue ( tag ,    pair )  ;", "return   cachedValue . getValue (  )  ;", "}", "} else", "if    (  (  . equalsToSchemaName ( tag ,     . INCLUDE _ TAG _ NAME )  )     |  |     (  (  . equalsToSchemaName ( tag ,     . IMPORT _ TAG _ NAME )  )     &  &     (  ( namespace    =  =    null )     |  |     (  !  ( namespace . equals ( getDefaultNamespace (  )  )  )  )  )  )  )     {", "final   String   schemaLocation    =    tag . getAttributeValue (  \" schemaLocation \"  )  ;", "if    ( schemaLocation    !  =    null )     {", "final   com . intellij . psi . xml . XmlFile   xmlFile    =    com . intellij . xml . util . XmlUtil . findNamespace ( rootTag . getContainingFile (  )  ,    schemaLocation )  ;", "if    ( xmlFile    !  =    null )     {", "final   com . intellij . psi . xml . XmlDocument   document    =    xmlFile . getDocument (  )  ;", "if    ( document    !  =    null )     {", "final   CachedValue < TypeDescriptor >    value    =    com . intellij . psi . util . CachedValuesManager . getManager ( tag . getProject (  )  )  . createCachedValue (  (  )     -  >     {", "final   String   currentName    =    tag . getAttributeValue (  \" name \"  )  ;", "if    (  (  (  ( currentName    !  =    null )     &  &     (  !  ( currentName . equals ( com . intellij . xml . util . XmlUtil . findLocalNameByQualifiedName ( name )  )  )  )  )     |  |     (  !  ( xmlFile . isValid (  )  )  )  )     |  |     (  ( xmlFile . getDocument (  )  )     =  =    null )  )     {", "myTypesMap . remove ( pair )  ;", "return   new   com . intellij . psi . util . CachedValueProvider . Result <  >  ( null ,    PsiModificationTracker . MODIFICATION _ COUNT )  ;", "}", "final   com . intellij . psi . xml . XmlDocument   document 1     =    xmlFile . getDocument (  )  ;", "final      nsDescriptor    =    findNSDescriptor ( tag ,    document 1  )  ;", "if    ( nsDescriptor    =  =    null )     {", "myTypesMap . remove ( pair )  ;", "return   new   com . intellij . psi . util . CachedValueProvider . Result <  >  ( null ,    PsiModificationTracker . MODIFICATION _ COUNT )  ;", "}", "final   XmlTag   rTag    =    document 1  . getRootTag (  )  ;", "final   TypeDescriptor   complexTypeDescriptor    =    nsDescriptor . findTypeDescriptorImpl ( rTag ,    name ,    namespace )  ;", "return   new   com . intellij . psi . util . CachedValueProvider . Result <  >  ( complexTypeDescriptor ,    rTag )  ;", "}  ,    false )  ;", "if    (  ( value . getValue (  )  )     !  =    null )     {", "myTypesMap . put ( pair ,    value )  ;", "return   value . getValue (  )  ;", "}", "}", "}", "}", "} else", "if    (  . equalsToSchemaName ( tag ,     . REDEFINE _ TAG _ NAME )  )     {", "final   XmlTag [  ]    subTags    =    tag . getSubTags (  )  ;", "TypeDescriptor   descriptor    =    doFindIn ( subTags ,    name ,    namespace ,    pair ,    rootTag )  ;", "if    ( descriptor    !  =    null )", "return   descriptor ;", "final      nsDescriptor    =     . getRedefinedElementDescriptor ( tag )  ;", "if    ( nsDescriptor    !  =    null )     {", "final   XmlTag   redefinedRootTag    =     (  ( com . intellij . psi . xml . XmlDocument )     ( nsDescriptor . getDeclaration (  )  )  )  . getRootTag (  )  ;", "descriptor    =    doFindIn ( redefinedRootTag . getSubTags (  )  ,    name ,    namespace ,    pair ,    redefinedRootTag )  ;", "if    ( descriptor    !  =    null )", "return   descriptor ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["doFindIn"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return    ( schemaName . equals ( tag . getLocalName (  )  )  )     &  &     ( XmlNSDescriptorImpl . checkSchemaNamespace ( tag )  )  ;", "}", "METHOD_END"], "methodName": ["equalsToSchemaName"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "final   XmlNSDescriptorImpl   nsDescriptor ;", "if    ( XmlNSDescriptorImpl . IMPORT _ TAG _ NAME . equals ( tag . getLocalName (  )  )  )     {", "final   XmlNSDescriptor   importedDescriptor    =     (  ( XmlNSDescriptor )     ( document . getMetaData (  )  )  )  ;", "nsDescriptor    =     ( importedDescriptor   instanceof   XmlNSDescriptorImpl )     ?     (  ( XmlNSDescriptorImpl )     ( importedDescriptor )  )     :    this ;", "} else    {", "nsDescriptor    =    this ;", "}", "return   nsDescriptor ;", "}", "METHOD_END"], "methodName": ["findNSDescriptor"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "XmlNSDescriptorImpl   nsDescriptor    =    XmlNSDescriptorImpl . getNSDescriptorToSearchIn ( rootTag ,    name ,    descriptor )  ;", "if    ( nsDescriptor    !  =    descriptor )     {", "final   XmlDocument   document    =     (  ( nsDescriptor . getDescriptorFile (  )  )     !  =    null )     ?    nsDescriptor . getDescriptorFile (  )  . getDocument (  )     :    null ;", "if    ( document    =  =    null )", "return   null ;", "return   XmlNSDescriptorImpl . findSpecialTag ( XmlUtil . findLocalNameByQualifiedName ( name )  ,    specialName ,    document . getRootTag (  )  ,    nsDescriptor ,    visited )  ;", "}", "if    ( visited    =  =    null )", "visited    =    new   HashSet <  >  (  1  )  ;", "else", "if    ( visited . contains ( rootTag )  )", "return   null ;", "visited . add ( rootTag )  ;", "XmlTag [  ]    tags    =    rootTag . getSubTags (  )  ;", "return   XmlNSDescriptorImpl . findSpecialTagIn ( tags ,    specialName ,    name ,    rootTag ,    descriptor ,    visited )  ;", "}", "METHOD_END"], "methodName": ["findSpecialTag"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "for    ( XmlTag   tag    :    tags )     {", "if    (  . equalsToSchemaName ( tag ,    specialName )  )     {", "String   attribute    =    tag . getAttributeValue (  \" name \"  )  ;", "if    (  ( name . equals ( attribute )  )     |  |     (  ( name . contains (  \"  :  \"  )  )     &  &     ( name . substring (  (  ( name . indexOf (  \"  :  \"  )  )     +     1  )  )  . equals ( attribute )  )  )  )     {", "return   tag ;", "}", "} else", "if    (  (  . equalsToSchemaName ( tag ,     . INCLUDE _ TAG _ NAME )  )     |  |     (  (  . equalsToSchemaName ( tag ,     . IMPORT _ TAG _ NAME )  )     &  &     ( rootTag . getNamespaceByPrefix ( com . intellij . xml . util . XmlUtil . findPrefixByQualifiedName ( name )  )  . equals ( tag . getAttributeValue (  \" namespace \"  )  )  )  )  )     {", "final   String   schemaLocation    =    tag . getAttributeValue (  \" schemaLocation \"  )  ;", "if    ( schemaLocation    !  =    null )     {", "final   com . intellij . psi . xml . XmlFile   xmlFile    =    com . intellij . xml . util . XmlUtil . findNamespace ( rootTag . getContainingFile (  )  ,    schemaLocation )  ;", "if    ( xmlFile    !  =    null )     {", "final   com . intellij . psi . xml . XmlDocument   document    =    xmlFile . getDocument (  )  ;", "if    ( document    !  =    null )     {", "final   XmlTag   rTag    =     . findSpecialTag ( name ,    specialName ,    document . getRootTag (  )  ,    descriptor ,    visited )  ;", "if    ( rTag    !  =    null )", "return   rTag ;", "}", "}", "}", "} else", "if    (  . equalsToSchemaName ( tag ,     . REDEFINE _ TAG _ NAME )  )     {", "XmlTag   rTag    =     . findSpecialTagIn ( tag . getSubTags (  )  ,    specialName ,    name ,    rootTag ,    descriptor ,    visited )  ;", "if    ( rTag    !  =    null )", "return   rTag ;", "final      nsDescriptor    =     . getRedefinedElementDescriptor ( tag )  ;", "if    ( nsDescriptor    !  =    null )     {", "final   XmlTag   redefinedRootTag    =     (  ( com . intellij . psi . xml . XmlDocument )     ( nsDescriptor . getDeclaration (  )  )  )  . getRootTag (  )  ;", "rTag    =     . findSpecialTagIn ( redefinedRootTag . getSubTags (  )  ,    specialName ,    name ,    redefinedRootTag ,    nsDescriptor ,    visited )  ;", "if    ( rTag    !  =    null )", "return   rTag ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findSpecialTagIn"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return   findTypeDescriptor ( qname ,    myTag )  ;", "}", "METHOD_END"], "methodName": ["findTypeDescriptor"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "String   namespace    =    context . getNamespaceByPrefix ( XmlUtil . findPrefixByQualifiedName ( qname )  )  ;", "String   localName    =    XmlUtil . findLocalNameByQualifiedName ( qname )  ;", "return   findType ( myTag ,    localName ,     ( namespace . isEmpty (  )     ?    getDefaultNamespace (  )     :    namespace )  )  ;", "}", "METHOD_END"], "methodName": ["findTypeDescriptor"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( rootTag    =  =    null )", "return   null ;", "return   RecursionManager . createGuard (  \" findDescriptor \"  )  . doPreventingRecursion ( rootTag ,    true ,     (  )     -  >     {", "responsibleDescriptor    =    this ;", "if    (  (  ( namespace    !  =    null )     &  &     (  ( namespace . length (  )  )     !  =     0  )  )     &  &     (  !  ( namespace . equals ( getDefaultNamespace (  )  )  )  )  )     {", "final   XmlNSDescriptor   nsDescriptor    =    rootTag . getNSDescriptor ( namespace ,    true )  ;", "if    ( nsDescriptor   instanceof    )     {", "responsibleDescriptor    =     (  (  )     ( nsDescriptor )  )  ;", "}", "}", "if    ( responsibleDescriptor    !  =     ( this )  )     {", "return   responsibleDescriptor . findTypeDescriptor ( name ,    namespace )  ;", "}", "final   Pair < QNameKey ,    XmlTag >    pair    =    com . intellij . openapi . util . Pair . create ( new   QNameKey ( name ,    namespace )  ,    rootTag )  ;", "final   CachedValue < TypeDescriptor >    descriptor    =    myTypesMap . get ( pair )  ;", "if    ( descriptor    !  =    null )     {", "TypeDescriptor   value    =    descriptor . getValue (  )  ;", "if    (  ( value    =  =    null )     |  |     (  ( value   instanceof   ComplexTypeDescriptor )     &  &     (  (  ( ComplexTypeDescriptor )     ( value )  )  . getDeclaration (  )  . isValid (  )  )  )  )     {", "return   value ;", "}", "}", "XmlTag [  ]    tags    =    rootTag . getSubTags (  )  ;", "return   doFindIn ( tags ,    name ,    namespace ,    pair ,    rootTag )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["findTypeDescriptorImpl"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myTag )     =  =    null )", "return   null ;", "XmlNSDescriptor   nsDescriptor    =    myTag . getNSDescriptor ( namespace ,    true )  ;", "if    (  ( nsDescriptor    !  =     ( this )  )     &  &     ( nsDescriptor   instanceof    )  )     {", "return    (  (  )     ( nsDescriptor )  )  . getAttributeImpl ( localName ,    namespace ,    visited )  ;", "}", "if    ( visited    =  =    null )", "visited    =    new   HashSet <  >  (  1  )  ;", "else", "if    ( visited . contains ( myTag )  )", "return   null ;", "visited . add ( myTag )  ;", "XmlTag [  ]    tags    =    myTag . getSubTags (  )  ;", "for    ( XmlTag   tag    :    tags )     {", "if    (  . equalsToSchemaName ( tag ,     . ATTRIBUTE _ TAG _ NAME )  )     {", "String   name    =    tag . getAttributeValue (  \" name \"  )  ;", "if    ( name    !  =    null )     {", "if    ( checkElementNameEquivalence ( localName ,    namespace ,    name ,    tag )  )     {", "return   createAttributeDescriptor ( tag )  ;", "}", "}", "} else", "if    (  (  . equalsToSchemaName ( tag ,     . INCLUDE _ TAG _ NAME )  )     |  |     (  (  . equalsToSchemaName ( tag ,     . IMPORT _ TAG _ NAME )  )     &  &     ( namespace . equals ( tag . getAttributeValue (  \" namespace \"  )  )  )  )  )     {", "final   String   schemaLocation    =    tag . getAttributeValue (  \" schemaLocation \"  )  ;", "if    ( schemaLocation    !  =    null )     {", "final   com . intellij . psi . xml . XmlFile   xmlFile    =    com . intellij . xml . util . XmlUtil . findNamespace ( myTag . getContainingFile (  )  ,    schemaLocation )  ;", "if    ( xmlFile    !  =    null )     {", "final   com . intellij . psi . xml . XmlDocument   includedDocument    =    xmlFile . getDocument (  )  ;", "if    ( includedDocument    !  =    null )     {", "final   com . intellij . psi . meta . PsiMetaData   data    =    includedDocument . getMetaData (  )  ;", "if    ( data   instanceof    )     {", "final   com . intellij . xml . XmlAttributeDescriptor   attributeDescriptor    =     (  (  )     ( data )  )  . getAttributeImpl ( localName ,    namespace ,    visited )  ;", "if    ( attributeDescriptor    !  =    null )     {", "final   com . intellij . psi . util . CachedValue < com . intellij . xml . XmlAttributeDescriptor >    value    =    com . intellij . psi . util . CachedValuesManager . getManager ( includedDocument . getProject (  )  )  . createCachedValue (  (  )     -  >     {", "Object [  ]    deps    =    attributeDescriptor . getDependences (  )  ;", "if    ( deps . length    =  =     0  )     {", ". LOG . error (  (  (  ( attributeDescriptor    +     \"     (  \"  )     +     ( attributeDescriptor . getClass (  )  )  )     +     \"  )    returned   no   dependencies \"  )  )  ;", "}", "return   new   com . intellij . psi . util . CachedValueProvider . Result <  >  ( attributeDescriptor ,    deps )  ;", "}  ,    false )  ;", "return   value . getValue (  )  ;", "}", "}", "}", "}", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAttributeImpl"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return    ( myTargetNamespace )     !  =    null    ?    myTargetNamespace    :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["getDefaultNamespace"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myTag )     =  =    null )", "return   null ;", "final   Type   type    =    findType ( qName ,    instanceTag )  ;", "if    (  !  ( type   instanceof   ComplexType )  )", "return   null ;", "return   new   XmlElementByType ( instanceTag ,     (  ( ComplexType )     ( type )  )  )  ;", "}", "METHOD_END"], "methodName": ["getDescriptorByType"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   parent    =    tag . getParent (  )  ;", "if    ( parent   instanceof   XmlTag )     {", "final   XmlElement   descriptor    =     (  ( XmlTag )     ( parent )  )  . get (  )  ;", "if    ( descriptor    !  =    null )", "element    =    descriptor . getElement ( tag ,     (  ( XmlTag )     ( parent )  )  )  ;", "}", "return   element ;", "}", "METHOD_END"], "methodName": ["getDescriptorFromParent"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( name    =  =    null )", "return   defaultNSDescriptor ;", "final   String   namespacePrefix    =    XmlUtil . findPrefixByQualifiedName ( name )  ;", "if    (  ( namespacePrefix . length (  )  )     >     0  )     {", "final   String   namespace    =    rootTag . getNamespaceByPrefix ( namespacePrefix )  ;", "final   XmlNSDescriptor   nsDescriptor    =    rootTag . getNSDescriptor ( namespace ,    true )  ;", "if    ( nsDescriptor   instanceof    )     {", "return    (  (  )     ( nsDescriptor )  )  ;", "}", "}", "return   defaultNSDescriptor ;", "}", "METHOD_END"], "methodName": ["getNSDescriptorToSearchIn"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "XmlFile   file    =    XmlNSDescriptorImpl . getRedefinedElementDescriptorFile ( parentTag )  ;", "if    ( file    !  =    null )     {", "final   XmlDocument   document    =    file . getDocument (  )  ;", "final   PsiMetaData   metaData    =     ( document    !  =    null )     ?    document . getMetaData (  )     :    null ;", "if    ( metaData   instanceof   XmlNSDescriptorImpl )", "return    (  ( XmlNSDescriptorImpl )     ( metaData )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getRedefinedElementDescriptor"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "final   String   schemaL    =    parentTag . getAttributeValue ( XmlUtil . SCHEMA _ LOCATION _ ATT )  ;", "if    ( schemaL    !  =    null )     {", "final   PsiReference [  ]    references    =    parentTag . getAttribute ( XmlUtil . SCHEMA _ LOCATION _ ATT ,    null )  . getValueElement (  )  . getReferences (  )  ;", "if    (  ( references . length )     >     0  )     {", "final   PsiElement   psiElement    =    references [  (  ( references . length )     -     1  )  ]  . resolve (  )  ;", "if    ( psiElement   instanceof   XmlFile )     {", "return    (  ( XmlFile )     ( psiElement )  )  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getRedefinedElementDescriptorFile"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "class   CollectAttributesProcessor   implements   PsiElementProcessor < XmlTag >     {", "final   List < XmlAttributeDescriptor >    result    =    new   ArrayList <  >  (  )  ;", "@ Override", "public   boolean   execute (  @ NotNull", "final   XmlTag   element )     {", "result . add ( createAttributeDescriptor ( element )  )  ;", "return   true ;", "}", "}", "CollectAttributesProcessor   processor    =    new   CollectAttributesProcessor (  )  ;", "processTagsInNamespace ( new   String [  ]  {     . ATTRIBUTE _ TAG _ NAME    }  ,    processor )  ;", "return   processor . result . toArray ( XmlAttributeDescriptor . EMPTY )  ;", "}", "METHOD_END"], "methodName": ["getRootAttributeDescriptors"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( initSubstitutes (  )  )  )     {", "return   XmlElementDescriptor . EMPTY _ ARRAY ;", "}", "Collection < XmlTag >    substitutions    =    mySubstitutions . get ( localName )  ;", "if    ( substitutions . isEmpty (  )  )", "return   XmlElementDescriptor . EMPTY _ ARRAY ;", "List < XmlElementDescriptor >    result    =    new   util . SmartList (  )  ;", "for    ( XmlTag   tag    :    substitutions )     {", "final   String   substAttr    =    tag . getAttributeValue (  \" substitutionGroup \"  )  ;", "if    (  ( substAttr    !  =    null )     &  &     ( checkElementNameEquivalence ( localName ,    namespace ,    substAttr ,    tag )  )  )     {", "result . add ( createElementDescriptor ( tag )  )  ;", "}", "}", "return   result . toArray ( XmlElementDescriptor . EMPTY _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["getSubstitutes"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return   myTag ;", "}", "METHOD_END"], "methodName": ["getTag"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "initSubstitutes (  )  ;", "return    (  ( mySubstitutions )     !  =    null )     &  &     (  ( mySubstitutions . size (  )  )     >     0  )  ;", "}", "METHOD_END"], "methodName": ["hasSubstitutions"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( mySubstitutions )     =  =    null )     &  &     (  ( myTag )     !  =    null )  )     {", "mySubstitutions    =    new   com . intellij . util . containers . MultiMap (  )  ;", "if    (  ( myTag )     =  =    null )", "return   false ;", "XmlTag [  ]    tags    =    myTag . getSubTags (  )  ;", "for    ( XmlTag   tag    :    tags )     {", "if    (  . equalsToSchemaName ( tag ,     . ELEMENT _ TAG _ NAME )  )     {", "final   String   substAttr    =    tag . getAttributeValue (  \" substitutionGroup \"  )  ;", "if    ( substAttr    !  =    null )     {", "String   substLocalName    =    XmlUtil . findLocalNameByQualifiedName ( substAttr )  ;", "mySubstitutions . putValue ( substLocalName ,    tag )  ;", "}", "}", "}", "}", "return    ( mySubstitutions )     !  =    null ;", "}", "METHOD_END"], "methodName": ["initSubstitutes"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( nameAttribute    !  =    null )     &  &     (  ( nameAttribute . equals ( name )  )     |  |     (  ( name . contains (  \"  :  \"  )  )     &  &     ( nameAttribute . equals ( name . substring (  (  ( name . indexOf (  \"  :  \"  )  )     +     1  )  )  )  )  )  )  )     &  &     (  (  ( namespace    =  =    null )     |  |     (  ( namespace . length (  )  )     =  =     0  )  )     |  |     ( namespace . equals ( getDefaultNamespace (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isSameName"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( myFile )     !  =    null )     &  &     ( getDeclaration (  )  . isValid (  )  )  ;", "}", "METHOD_END"], "methodName": ["isValid"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( visitedTags    =  =    null )", "visitedTags    =    new   HashSet <  >  (  3  )  ;", "else", "if    ( visitedTags . contains ( rootTag )  )", "return   true ;", "visitedTags . add ( rootTag )  ;", "XmlTag [  ]    tags    =    rootTag . getSubTags (  )  ;", "NextTag    :    for    ( XmlTag   tag    :    tags )     {", "for    ( String   tagName    :    tagNames )     {", "if    (  . equalsToSchemaName ( tag ,    tagName )  )     {", "final   String   name    =    tag . getAttributeValue (  \" name \"  )  ;", "if    ( name    !  =    null )     {", "if    (  !  ( processor . execute ( tag )  )  )     {", "return   false ;", "}", "}", "continue   NextTag ;", "}", "}", "if    (  . equalsToSchemaName ( tag ,     . INCLUDE _ TAG _ NAME )  )     {", "final   String   schemaLocation    =    tag . getAttributeValue (  \" schemaLocation \"  )  ;", "if    ( schemaLocation    !  =    null )     {", "final   XmlFile   xmlFile    =    XmlUtil . findNamespace ( rootTag . getContainingFile (  )  ,    schemaLocation )  ;", "if    ( xmlFile    !  =    null )     {", "final   XmlDocument   includedDocument    =    xmlFile . getDocument (  )  ;", "if    ( includedDocument    !  =    null )     {", "if    (  !  (  . processTagsInNamespaceInner ( includedDocument . getRootTag (  )  ,    tagNames ,    processor ,    visitedTags )  )  )", "return   false ;", "}", "}", "}", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["processTagsInNamespaceInner"], "fileName": "com.intellij.xml.impl.schema.XmlNSDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return   ArrayUtil . contains ( tagName ,    names )  ;", "}", "METHOD_END"], "methodName": ["checkTagName"], "fileName": "com.intellij.xml.impl.schema.XmlSchemaTagsProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( myVisited . contains ( tag )  )", "return ;", "myVisited . add ( tag )  ;", "if    (  !  ( XmlNSDescriptorImpl . checkSchemaNamespace ( tag )  )  )     {", "processTagWithSubTags ( tag ,    context ,    null )  ;", "return ;", "}", "String   tagName    =    tag . getLocalName (  )  ;", "if    (  . checkTagName ( tagName ,     \" element \"  ,     \" attribute \"  )  )     {", "XmlAttribute   ref    =    tag . getAttribute (  \" ref \"  )  ;", "if    ( ref    !  =    null )     {", "XmlTag   resolved    =     . resolveTagReference ( ref )  ;", "if    ( resolved    !  =    null )     {", "tagStarted ( resolved ,    resolved . getLocalName (  )  ,    tag ,    tag )  ;", "}", "} else    {", "tagStarted ( tag ,    tag . getLocalName (  )  ,    context ,    null )  ;", "}", "} else", "if    (  . checkTagName ( tagName ,     \" group \"  )  )     {", "String   value    =    tag . getAttributeValue (  \" ref \"  )  ;", "if    ( value    !  =    null )     {", "XmlTag   group    =    myNsDescriptor . findGroup ( value )  ;", "if    ( group    =  =    null )", "group    =     . resolveTagReference ( tag . getAttribute (  \" ref \"  )  )  ;", "processTagWithSubTags ( group ,    tag ,    tag )  ;", "}", "} else", "if    (  . checkTagName ( tagName ,     \" attributeGroup \"  )  )     {", "String   ref    =    tag . getAttributeValue (  \" ref \"  )  ;", "if    ( ref    =  =    null )", "return ;", "XmlTag   group ;", "XmlTag   parentTag    =    tag . getParentTag (  )  ;", "assert   parentTag    !  =    null ;", "if    (  ( XmlNSDescriptorImpl . equalsToSchemaName ( parentTag ,     \" attributeGroup \"  )  )     &  &     ( ref . equals ( parentTag . getAttributeValue (  \" name \"  )  )  )  )     {", "group    =     . resolveTagReference ( tag . getAttribute (  \" ref \"  )  )  ;", "if    ( group    =  =    null )", "group    =    myNsDescriptor . findAttributeGroup ( ref )  ;", "} else    {", "group    =    myNsDescriptor . findAttributeGroup ( ref )  ;", "if    ( group    =  =    null )", "group    =     . resolveTagReference ( tag . getAttribute (  \" ref \"  )  )  ;", "}", "processTagWithSubTags ( group ,    tag ,    null )  ;", "} else", "if    (  . checkTagName ( tagName ,     \" restriction \"  ,     \" extension \"  )  )     {", "processTagWithSubTags (  . resolveTagReference ( tag . getAttribute (  \" base \"  )  )  ,    tag ,    null )  ;", "processTagWithSubTags ( tag ,    context ,    null )  ;", "} else", "if    (  !  (  . checkTagName ( tagName ,    myTagsToIgnore )  )  )     {", "processTagWithSubTags ( tag ,    context ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["processTag"], "fileName": "com.intellij.xml.impl.schema.XmlSchemaTagsProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( tag    =  =    null )", "return ;", "tagStarted ( tag ,    tag . getLocalName (  )  ,    ctx ,    ref )  ;", "XmlTag [  ]    subTags    =    tag . getSubTags (  )  ;", "for    ( XmlTag   subTag    :    subTags )     {", "pTag ( subTag ,    tag )  ;", "}", "tagFinished ( tag )  ;", "}", "METHOD_END"], "methodName": ["processTagWithSubTags"], "fileName": "com.intellij.xml.impl.schema.XmlSchemaTagsProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( ref    !  =    null )     {", "AttributeValue   value    =    ref . getValueElement (  )  ;", "if    ( value    !  =    null )     {", "PsiReference [  ]    references    =    value . getReferences (  )  ;", "if    (  ( references . length )     >     0  )", "return   references [  0  ]  . resolve (  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["resolveReference"], "fileName": "com.intellij.xml.impl.schema.XmlSchemaTagsProcessor"}, {"methodBody": ["METHOD_START", "{", "PsiElement   element    =    XmlSchemaTagsProcessor . resolveReference ( ref )  ;", "return   element   instanceof   XmlTag    ?     (  ( XmlTag )     ( element )  )     :    null ;", "}", "METHOD_END"], "methodName": ["resolveTagReference"], "fileName": "com.intellij.xml.impl.schema.XmlSchemaTagsProcessor"}, {"methodBody": ["METHOD_START", "{", "try    {", ". PROCESSING _ FLAG . set ( Boolean . TRUE )  ;", "processTag ( tag ,    null )  ;", "}    finally    {", ". PROCESSING _ FLAG . set ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["startProcessing"], "fileName": "com.intellij.xml.impl.schema.XmlSchemaTagsProcessor"}, {"methodBody": ["METHOD_START", "{", "final   List < String >    list    =    new   com . intellij . util . SmartList (  )  ;", "processEnumeration ( null ,     (    element ,    s )     -  >     {", "list . add ( s )  ;", "return   true ;", "}  ,    forCompletion )  ;", "String   defaultValue    =    getDefaultValue (  )  ;", "if    ( defaultValue    !  =    null )     {", "list . add ( defaultValue )  ;", "}", "return   ArrayUtil . toStringArray ( list )  ;", "}", "METHOD_END"], "methodName": ["getEnumeratedValues"], "fileName": "com.intellij.xml.impl.schema.XsdEnumerationDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getDeclaration (  )  )     =  =    null )", "return   false ;", "XmlTag   contextTag    =     ( context    !  =    null )     ?    PsiTreeUtil . getContextOfType ( context ,    XmlTag . class ,    false )     :    null ;", "final   XmlElementDescriptorImpl   elementDescriptor    =     (  ( XmlElementDescriptorImpl )     ( XmlUtil . findXmlDescriptorByType ( getDeclaration (  )  ,    contextTag )  )  )  ;", "if    (  ( elementDescriptor    !  =    null )     &  &     (  ( elementDescriptor . getType (  )  )    instanceof   ComplexTypeDescriptor )  )     {", "TypeDescriptor   type    =    elementDescriptor . getType (  )  ;", "return   processImpl ( type . getDeclaration (  )  ,     (  ( ComplexTypeDescriptor )     ( type )  )  ,    processor ,    forCompletion )  ;", "}", "final   String   namespacePrefix    =    getDeclaration (  )  . getNamespacePrefix (  )  ;", "XmlTag   type    =    getDeclaration (  )  . findFirstSubTag (  (  (  ( namespacePrefix . length (  )  )     >     0     ?    namespacePrefix    +     \"  :  \"     :     \"  \"  )     +     \" simpleType \"  )  )  ;", "if    ( type    !  =    null )     {", "return   processImpl ( type ,    null ,    processor ,    forCompletion )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["processEnumeration"], "fileName": "com.intellij.xml.impl.schema.XsdEnumerationDescriptor"}, {"methodBody": ["METHOD_START", "{", "XmlAttribute   name    =    declaration . getAttribute (  \" name \"  )  ;", "if    (  (  ( name    !  =    null )     &  &     (  \" boolean \"  . equals ( name . getValue (  )  )  )  )     &  &     ( type    !  =    null )  )     {", "XmlNSDescriptorImpl   nsDescriptor    =    type . getNsDescriptor (  )  ;", "if    ( nsDescriptor    !  =    null )     {", "String   namespace    =    nsDescriptor . getDefaultNamespace (  )  ;", "if    ( XmlUtil . XML _ SCHEMA _ URI . equals ( namespace )  )     {", "XmlAttributeValue   valueElement    =    name . getValueElement (  )  ;", "pairProcessor . process ( valueElement ,     \" true \"  )  ;", "pairProcessor . process ( valueElement ,     \" false \"  )  ;", "if    (  ! forCompletion )     {", "pairProcessor . process ( valueElement ,     \"  1  \"  )  ;", "pairProcessor . process ( valueElement ,     \"  0  \"  )  ;", "}", "myExhaustiveEnum    =    true ;", "return   true ;", "}", "}", "}", "final   Ref < Boolean >    found    =    new   Ref ( Boolean . FALSE )  ;", "myExhaustiveEnum    =    XmlUtil . processValues ( declaration ,     (    tag )     -  >     {", "found . set ( Boolean . TRUE )  ;", "XmlAttribute   name 1     =    tag . getAttribute (  \" value \"  )  ;", "return    ( name 1     =  =    null )     |  |     ( pairProcessor . process ( tag ,    name 1  . getValue (  )  )  )  ;", "}  )  ;", "return   found . get (  )  ;", "}", "METHOD_END"], "methodName": ["processEnumerationImpl"], "fileName": "com.intellij.xml.impl.schema.XsdEnumerationDescriptor"}, {"methodBody": ["METHOD_START", "{", "ArrayList < IndexedRelevantResource < K ,    V >  >    all    =    new   ArrayList <  >  (  )  ;", "Collection < K >    allKeys    =    FileBasedIndex . getInstance (  )  . getAllKeys ( indexId ,    project )  ;", "for    ( K   key    :    allKeys )     {", "List < IndexedRelevantResource < K ,    V >  >    resources    =    IndexedRelevantResource . getResources ( indexId ,    key ,    module ,    project ,    null )  ;", "if    (  !  ( resources . isEmpty (  )  )  )     {", "if    ( chooser    =  =    null )     {", "all . add ( resources . get (  0  )  )  ;", "} else    {", "IndexedRelevantResource < K ,    V >    resource    =    chooser . fun ( resources )  ;", "if    ( resource    !  =    null )     {", "all . add ( resource )  ;", "}", "}", "}", "}", "return   all ;", "}", "METHOD_END"], "methodName": ["getAllResources"], "fileName": "com.intellij.xml.index.IndexedRelevantResource"}, {"methodBody": ["METHOD_START", "{", "return   myFile ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "com.intellij.xml.index.IndexedRelevantResource"}, {"methodBody": ["METHOD_START", "{", "return   myKey ;", "}", "METHOD_END"], "methodName": ["getKey"], "fileName": "com.intellij.xml.index.IndexedRelevantResource"}, {"methodBody": ["METHOD_START", "{", "return   myRelevance ;", "}", "METHOD_END"], "methodName": ["getRelevance"], "fileName": "com.intellij.xml.index.IndexedRelevantResource"}, {"methodBody": ["METHOD_START", "{", "if    ( project . isDefault (  )  )", "return   emptyList (  )  ;", "final   ArrayList <  < K ,    V >  >    resources    =    new   ArrayList <  >  (  )  ;", "final   ProjectFileIndex   fileIndex    =    ProjectRootManager . getInstance ( project )  . getFileIndex (  )  ;", "FileBasedIndex . getInstance (  )  . processValues ( indexId ,    key ,    null ,     (    file ,    value )     -  >     {", "ResourceRelevance   relevance    =    ResourceRelevance . getRelevance ( file ,    module ,    fileIndex ,    additionalScope )  ;", "resources . add ( new    <  >  ( file ,    key ,    value ,    relevance )  )  ;", "return   true ;", "}  ,    new   com . intellij . util . indexing . AdditionalIndexedRootsScope ( GlobalSearchScope . allScope ( project )  )  )  ;", "return   resources ;", "}", "METHOD_END"], "methodName": ["getResources"], "fileName": "com.intellij.xml.index.IndexedRelevantResource"}, {"methodBody": ["METHOD_START", "{", "return   myValue ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.intellij.xml.index.IndexedRelevantResource"}, {"methodBody": ["METHOD_START", "{", "boolean   inTest    =    fileIndex . isInTestSourceContent ( resource )  ;", "if    ( module    !  =    null )     {", "GlobalSearchScope   scope    =    module . getModuleRuntimeScope ( inTest )  ;", "Module   resourceModule    =    fileIndex . getModuleForFile ( resource )  ;", "if    (  (  (  ( resourceModule    !  =    null )     &  &     (  ( resourceModule    =  =    module )     |  |     ( scope . isSearchInModuleContent ( resourceModule )  )  )  )     |  |     ( scope . contains ( resource )  )  )     |  |     (  ( additionalScope    !  =    null )     &  &     ( additionalScope . contains ( resource )  )  )  )     {", "return   inTest    |  |     ( fileIndex . isInSource ( resource )  )     ?     . SOURCE    :     . LIBRARY ;", "}", "} else", "if    ( inTest    |  |     ( fileIndex . isInSource ( resource )  )  )     {", "return    . SOURCE ;", "} else", "if    ( fileIndex . isInLibraryClasses ( resource )  )     {", "return    . LIBRARY ;", "}", "ExternalResourceManagerEx   resourceManager    =     (  ( ExternalResourceManagerEx )     ( ExternalResourceManager . getInstance (  )  )  )  ;", "return   resourceManager . isUserResource ( resource )     ?     . MAPPED    :     . STANDARD ;", "}", "METHOD_END"], "methodName": ["getRelevance"], "fileName": "com.intellij.xml.index.ResourceRelevance"}, {"methodBody": ["METHOD_START", "{", "return   myNamespaceUri ;", "}", "METHOD_END"], "methodName": ["getNamespaceUri"], "fileName": "com.intellij.xml.index.SchemaTypeInfo"}, {"methodBody": ["METHOD_START", "{", "return   myTagName ;", "}", "METHOD_END"], "methodName": ["getTagName"], "fileName": "com.intellij.xml.index.SchemaTypeInfo"}, {"methodBody": ["METHOD_START", "{", "return   myIsTypeName ;", "}", "METHOD_END"], "methodName": ["isIsTypeName"], "fileName": "com.intellij.xml.index.SchemaTypeInfo"}, {"methodBody": ["METHOD_START", "{", "GlobalSearchScope   filter    =    XmlIndex . createFilter ( project )  ;", "return   FileBasedIndex . getInstance (  )  . getValues (  . NAME ,     . NsPlusTag . INSTANCE . encode ( Pair . create ( ns ,    name )  )  ,    filter )  ;", "}", "METHOD_END"], "methodName": ["getDirectChildrenOfType"], "fileName": "com.intellij.xml.index.SchemaTypeInheritanceIndex"}, {"methodBody": ["METHOD_START", "{", "return   new   SchemaTypeInheritanceIndex . MyWorker ( currentFile ,    project )  ;", "}", "METHOD_END"], "methodName": ["getWorker"], "fileName": "com.intellij.xml.index.SchemaTypeInheritanceIndex"}, {"methodBody": ["METHOD_START", "{", "final   ProjectFileIndex   fileIndex    =    ProjectRootManager . getInstance ( module . getProject (  )  )  . getFileIndex (  )  ;", "return   new   VirtualFileFilter (  )     {", "@ Override", "public   boolean   accept ( final   VirtualFile   file )     {", "Module   moduleForFile    =    fileIndex . getModuleForFile ( file )  ;", "if    ( moduleForFile    !  =    null )     {", "return   module . equals ( moduleForFile )  ;", "}", "if    ( fileIndex . isInLibraryClasses ( file )  )     {", "List < OrderEntry >    orderEntries    =    fileIndex . getOrderEntriesForFile ( file )  ;", "if    ( orderEntries . isEmpty (  )  )     {", "return   false ;", "}", "for    ( OrderEntry   orderEntry    :    orderEntries )     {", "Module   ownerModule    =    orderEntry . getOwnerModule (  )  ;", "if    ( ownerModule . equals ( module )  )     {", "return   true ;", "}", "}", "}", "final   VirtualFile   parent    =    file . getParent (  )  ;", "assert   parent    !  =    null ;", "return   parent . getName (  )  . equals (  \" standardSchemas \"  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createFilter"], "fileName": "com.intellij.xml.index.XmlIndex"}, {"methodBody": ["METHOD_START", "{", "final   GlobalSearchScope   projectScope    =    GlobalSearchScope . allScope ( project )  ;", "return   new   GlobalSearchScope ( project )     {", "@ Override", "public   int   pare (  @ NotNull", "VirtualFile   file 1  ,     @ NotNull", "VirtualFile   file 2  )     {", "return   projectScope . pare ( file 1  ,    file 2  )  ;", "}", "@ Override", "public   boolean   isSearchInModuleContent (  @ NotNull", "Module   aModule )     {", "return   true ;", "}", "@ Override", "public   boolean   contains (  @ NotNull", "VirtualFile   file )     {", "final   VirtualFile   parent    =    file . getParent (  )  ;", "return    ( parent    !  =    null )     &  &     (  ( parent . getName (  )  . equals (  \" standardSchemas \"  )  )     |  |     ( projectScope . contains ( file )  )  )  ;", "}", "@ Override", "public   boolean   isSearchInLibraries (  )     {", "return   true ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createFilter"], "fileName": "com.intellij.xml.index.XmlIndex"}, {"methodBody": ["METHOD_START", "{", "InputStream   stream    =    null ;", "try    {", "stream    =    file . getInputStream (  )  ;", "return   XsdBuilder . compute ( stream )  ;", "}    catch    ( IOException   e )     {", "return   null ;", "}    finally    {", "StreamUtil . closeStream ( stream )  ;", "}", "}", "METHOD_END"], "methodName": ["computeNamespace"], "fileName": "com.intellij.xml.index.XmlNamespaceIndex"}, {"methodBody": ["METHOD_START", "{", "PsiFile   psiFile    =    baseFile . getManager (  )  . findFile ( resourceFile )  ;", "return   psiFile   instanceof   XmlFile    ?     (  ( XmlFile )     ( psiFile )  )     :    null ;", "}", "METHOD_END"], "methodName": ["findSchemaFile"], "fileName": "com.intellij.xml.index.XmlNamespaceIndex"}, {"methodBody": ["METHOD_START", "{", "return   IndexedRelevantResource . getAllResources ( XmlNamespaceIndex . NAME ,    module ,    project ,    chooser )  ;", "}", "METHOD_END"], "methodName": ["getAllResources"], "fileName": "com.intellij.xml.index.XmlNamespaceIndex"}, {"methodBody": ["METHOD_START", "{", "if    (  ( DumbService . isDumb ( project )  )     |  |     (  ( context    !  =    null )     &  &     ( XmlUtil . isStubBuilding (  )  )  )  )     {", "return    . computeNamespace ( file )  ;", "}", "final   List < XsdNamespaceBuilder >    list    =    FileBasedIndex . getInstance (  )  . getValues (  . NAME ,    file . getUrl (  )  ,    XmlIndex . createFilter ( project )  )  ;", "return    ( list . size (  )  )     =  =     0     ?    null    :    list . get (  0  )  . getNamespace (  )  ;", "}", "METHOD_END"], "methodName": ["getNamespace"], "fileName": "com.intellij.xml.index.XmlNamespaceIndex"}, {"methodBody": ["METHOD_START", "{", "List < IndexedRelevantResource < String ,    XsdNamespaceBuilder >  >    resources    =    IndexedRelevantResource . getResources ( XmlNamespaceIndex . NAME ,    namespace ,    module ,    project ,    null )  ;", "Collections . sort ( resources )  ;", "return   resources ;", "}", "METHOD_END"], "methodName": ["getResourcesByNamespace"], "fileName": "com.intellij.xml.index.XmlNamespaceIndex"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  !  ( dtdUri . endsWith (  \"  . dtd \"  )  )  )     |  |     ( DumbService . isDumb ( baseFile . getProject (  )  )  )  )     |  |     ( XmlUtil . isStubBuilding (  )  )  )", "return   null ;", "String   dtdFileName    =    new   File ( dtdUri )  . getName (  )  ;", "List < IndexedRelevantResource < String ,    XsdNamespaceBuilder >  >    list    =     . getResourcesByNamespace ( dtdFileName ,    baseFile . getProject (  )  ,    ModuleUtilCore . findModuleForPsiElement ( baseFile )  )  ;", "if    ( list . isEmpty (  )  )     {", "return   null ;", "}", "IndexedRelevantResource < String ,    XsdNamespaceBuilder >    resource ;", "if    (  ( list . size (  )  )     >     1  )     {", "final   String [  ]    split    =    dtdUri . split (  \"  /  \"  )  ;", "resource    =    Collections . max ( list ,    new   Comparator < IndexedRelevantResource < String ,    XsdNamespaceBuilder >  >  (  )     {", "@ Override", "public   int   compare ( IndexedRelevantResource < String ,    XsdNamespaceBuilder >    o 1  ,    IndexedRelevantResource < String ,    XsdNamespaceBuilder >    o 2  )     {", "return    ( weight ( o 1  )  )     -     ( weight ( o 2  )  )  ;", "}", "int   weight ( IndexedRelevantResource < String ,    XsdNamespaceBuilder >    o 1  )     {", "VirtualFile   file    =    o 1  . getFile (  )  ;", "for    ( int   i    =     ( split . length )     -     1  ;     ( i    >  =     0  )     &  &     ( file    !  =    null )  ;    i -  -  )     {", "String   s    =    split [ i ]  ;", "if    (  !  ( s . equals ( file . getName (  )  )  )  )     {", "return    ( split . length )     -    i ;", "}", "file    =    file . getParent (  )  ;", "}", "return    0  ;", "}", "}  )  ;", "} else    {", "resource    =    list . get (  0  )  ;", "}", "return    . findSchemaFile ( resource . getFile (  )  ,    baseFile )  ;", "}", "METHOD_END"], "methodName": ["guessDtd"], "fileName": "com.intellij.xml.index.XmlNamespaceIndex"}, {"methodBody": ["METHOD_START", "{", "final   List < IndexedRelevantResource < String ,    XsdNamespaceBuilder >  >    resources    =    XmlNamespaceIndex . getResourcesByNamespace ( namespace ,    project ,    module )  ;", "if    ( resources . isEmpty (  )  )", "return   null ;", "if    (  ( resources . size (  )  )     =  =     1  )", "return   resources . get (  0  )  ;", "final   String   fileName    =     ( schemaLocation    =  =    null )     ?    null    :    new   File ( schemaLocation )  . getName (  )  ;", "IndexedRelevantResource < String ,    XsdNamespaceBuilder >    resource    =    Collections . max ( resources ,     (    o 1  ,    o 2  )     -  >     {", "if    ( fileName    !  =    null )     {", "int   i    =    Comparing . compare ( fileName . equals ( o 1  . getFile (  )  . getName (  )  )  ,    fileName . equals ( o 2  . getFile (  )  . getName (  )  )  )  ;", "if    ( i    !  =     0  )", "return   i ;", "}", "if    ( tagName    !  =    null )     {", "int   i    =    Comparing . compare ( o 1  . getValue (  )  . hasTag ( tagName )  ,    o 2  . getValue (  )  . hasTag ( tagName )  )  ;", "if    ( i    !  =     0  )", "return   i ;", "}", "int   i    =    o 1  . compareTo ( o 2  )  ;", "if    ( i    !  =     0  )", "return   i ;", "return    ( o 1  . getValue (  )  . getRating ( tagName ,    version )  )     -     ( o 2  . getValue (  )  . getRating ( tagName ,    version )  )  ;", "}  )  ;", "if    (  ( tagName    !  =    null )     &  &     (  !  ( resource . getValue (  )  . hasTag ( tagName )  )  )  )     {", "return   null ;", "}", "return   resource ;", "}", "METHOD_END"], "methodName": ["guessSchema"], "fileName": "com.intellij.xml.index.XmlNamespaceIndex"}, {"methodBody": ["METHOD_START", "{", "if    (  ( DumbService . isDumb ( file . getProject (  )  )  )     |  |     ( XmlUtil . isStubBuilding (  )  )  )", "return   null ;", "IndexedRelevantResource < String ,    XsdNamespaceBuilder >    resource    =     . guessSchema ( namespace ,    tagName ,    version ,    schemaLocation ,    ModuleUtilCore . findModuleForPsiElement ( file )  ,    file . getProject (  )  )  ;", "if    ( resource    =  =    null )", "return   null ;", "return    . findSchemaFile ( resource . getFile (  )  ,    file )  ;", "}", "METHOD_END"], "methodName": ["guessSchema"], "fileName": "com.intellij.xml.index.XmlNamespaceIndex"}, {"methodBody": ["METHOD_START", "{", "VirtualFile   file    =    myFixture . copyFileToProject (  \" spring - beans -  2  .  0  . xsd \"  )  ;", "final   Collection < String >    tags    =    XsdTagNameBuilder . computeTagNames ( file . getInputStream (  )  )  ;", "assertEquals (  2  2  ,    tags . size (  )  )  ;", "final   String   ns    =    XsdNamespaceBuilder . computeNamespace ( file . getInputStream (  )  )  ;", "assertEquals (  \" http :  /  / www . springframework . org / schema / beans \"  ,    ns )  ;", "final   VirtualFile   xsd    =    myFixture . copyFileToProject (  \" XML . xsd \"  )  ;", "final   String   namespace    =    XsdNamespaceBuilder . computeNamespace ( xsd . getInputStream (  )  )  ;", "assertEquals (  \" http :  /  / www . w 3  . org /  2  0  0  1  / XML \"  ,    namespace )  ;", "final   Collection < String >    xstags    =    XsdTagNameBuilder . computeTagNames ( xsd . getInputStream (  )  )  ;", "assertEquals (  6  9  ,    xstags . size (  )  )  ;", "assertTrue ( xstags . contains (  \" schema \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBuilder"], "fileName": "com.intellij.xml.index.XmlSchemaIndexTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . copyDirectoryToProject (  \"  \"  ,     \"  \"  )  ;", "String   namespace    =     \" http :  /  / www . liquibase . org / xml / ns / dbchangelog \"  ;", "List < IndexedRelevantResource < String ,    XsdNamespaceBuilder >  >    resources    =    XmlNamespaceIndex . getResourcesByNamespace ( namespace ,    getProject (  )  ,    myModule )  ;", "assertEquals (  2  ,    resources . size (  )  )  ;", "assertEquals (  \" dbchangelog -  3  .  3  . xsd \"  ,    XmlNamespaceIndex . guess ( namespace ,    null ,    null ,     \" http :  /  / www . liquibase . org / xml / ns / dbchangelog / dbchangelog -  3  .  3  . xsd \"  ,    myModule ,    getProject (  )  )  . getFile (  )  . getName (  )  )  ;", "assertEquals (  \" dbchangelog -  3  .  1  . xsd \"  ,    XmlNamespaceIndex . guess ( namespace ,    null ,    null ,     \" http :  /  / www . liquibase . org / xml / ns / dbchangelog / dbchangelog -  3  .  1  . xsd \"  ,    myModule ,    getProject (  )  )  . getFile (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGuessByLocation"], "fileName": "com.intellij.xml.index.XmlSchemaIndexTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . copyDirectoryToProject (  \"  \"  ,     \"  \"  )  ;", "final   List < IdRelevantResource < String ,    XsdNamespaceBuilder >  >    files    =    XmlNamespaceIgetResourcesByNamespace (  \" foo . dtd \"  ,    getProject (  )  ,    myModule )  ;", "assertEquals (  2  ,    files . size (  )  )  ;", "PsiFile   file    =    myFixture . configureByFile (  \" foo . xml \"  )  ;", "assertTrue ( XmlNamespaceIguessDtd (  \" foo :  /  / bar /  1  / foo . dtd \"  ,    file )  . getVirtualFile (  )  . getPath (  )  . endsWith (  \"  /  1  / foo . dtd \"  )  )  ;", "assertTrue ( XmlNamespaceIguessDtd (  \" foo :  /  / bar /  2  / foo . dtd \"  ,    file )  . getVirtualFile (  )  . getPath (  )  . endsWith (  \"  /  2  / foo . dtd \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGuessDTD"], "fileName": "com.intellij.xml.index.XmlSchemaIndexTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . copyDirectoryToProject (  \"  \"  ,     \"  \"  )  ;", "final   List < IndexedRelevantResource < String ,    XsdNamespaceBuilder >  >    files    =    XmlNamespaceIndex . getResourcesByNamespace (  . NS ,    getProject (  )  ,    myModule )  ;", "assertEquals (  2  ,    files . size (  )  )  ;", "IndexedRelevantResource < String ,    XsdNamespaceBuilder >    resource    =    XmlNamespaceIndex . guessSchema (  . NS ,     \" web - app \"  ,     \"  3  .  0  \"  ,    null ,    myModule ,    getProject (  )  )  ;", "assertNotNull ( resource )  ;", "XsdNamespaceBuilder   builder    =    resource . getValue (  )  ;", "assertEquals (  . NS ,    builder . getNamespace (  )  )  ;", "assertEquals (  \"  3  .  0  \"  ,    builder . getVersion (  )  )  ;", "assertEquals ( Collections . singletonList (  \" web - app \"  )  ,    builder . getTags (  )  )  ;", "resource    =    XmlNamespaceIndex . guessSchema (  . NS ,     \" web - app \"  ,     \"  2  .  5  \"  ,    null ,    myModule ,    getProject (  )  )  ;", "assertNotNull ( resource )  ;", "builder    =    resource . getValue (  )  ;", "assertEquals (  . NS ,    builder . getNamespace (  )  )  ;", "assertEquals (  \"  2  .  5  \"  ,    builder . getVersion (  )  )  ;", "assertEquals ( Collections . singletonList (  \" web - app \"  )  ,    builder . getTags (  )  )  ;", "resource    =    XmlNamespaceIndex . guessSchema (  . NS ,     \" foo - bar \"  ,     \"  2  .  5  \"  ,    null ,    myModule ,    getProject (  )  )  ;", "assertNull ( resource )  ;", "}", "METHOD_END"], "methodName": ["testNamespaceIndex"], "fileName": "com.intellij.xml.index.XmlSchemaIndexTest"}, {"methodBody": ["METHOD_START", "{", "DataExternalizer < XsdNamespaceBuilder >    externalizer    =    new   XmlNamespaceIndex (  )  . getValueExternalizer (  )  ;", "XsdNamespaceBuilder   builder    =    XsdNamespaceBuilder . computeNamespace ( new   StringReader (  \"  \"  )  )  ;", "ByteArrayOutputStream   out    =    new   ByteArrayOutputStream (  )  ;", "externalizer . save ( new   DataOutputStream ( out )  ,    builder )  ;", "XsdNamespaceBuilder   read    =    externalizer . read ( new   DataInputStream ( new   ByteArrayInputStream ( out . toByteArray (  )  )  )  )  ;", "assertEquals ( read ,    builder )  ;", "assertEquals ( read . hashCode (  )  ,    builder . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNullSerialization"], "fileName": "com.intellij.xml.index.XmlSchemaIndexTest"}, {"methodBody": ["METHOD_START", "{", "VirtualFile   file    =    myFixture . copyFileToProject (  \" XMLSchema . xsd \"  )  ;", "final   XsdNamespaceBuilder   builder    =    XsdNamespaceBuilder . computeNamespace ( new   InputStreamReader ( file . getInputStream (  )  )  )  ;", "assertEquals ( XmlUtil . XML _ SCHEMA _ URI ,    builder . getNamespace (  )  )  ;", "assertEquals (  \"  1  .  0  \"  ,    builder . getVersion (  )  )  ;", "assertEquals ( Collections . singletonList (  \" schema \"  )  ,    builder . getRootTags (  )  )  ;", "assertEquals (  4  1  ,    builder . getTags (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRootTags"], "fileName": "com.intellij.xml.index.XmlSchemaIndexTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . copyDirectoryToProject (  \"  \"  ,     \"  \"  )  ;", "final   Project   project    =    getProject (  )  ;", "final   Collection < String >    tags    =    XmlTagNamesIgetAllTagNames ( project )  ;", "assertTrue (  (  ( tags . size (  )  )     >     2  6  )  )  ;", "final   Collection < VirtualFile >    files    =    XmlTagNamesIgetFilesByTagName (  \" bean \"  ,    project )  ;", "assertEquals (  1  ,    files . size (  )  )  ;", "Module   module    =    ModuleUtilCore . findModuleForFile ( files . iterator (  )  . next (  )  ,    project )  ;", "assert   module    !  =    null ;", "final   Collection < VirtualFile >    files 1     =    FileBasedIgetInstance (  )  . getContainingFiles ( XmlTagNamesINAME ,     \" web - app \"  ,    module . getModuleContentScope (  )  )  ;", "assertEquals ( new   ArrayList ( files 1  )  . toString (  )  ,     2  ,    files 1  . size (  )  )  ;", "List < String >    names    =    new   ArrayList ( ContainerUtil . map ( files 1  ,     (    virtualFile )     -  >    virtualFile . getName (  )  )  )  ;", "Collections . sort ( names )  ;", "assertEquals ( Arrays . asList (  \" web - app _  2  _  5  . xsd \"  ,     \" web - app _  3  _  0  . xsd \"  )  ,    names )  ;", "}", "METHOD_END"], "methodName": ["testTagNameIndex"], "fileName": "com.intellij.xml.index.XmlSchemaIndexTest"}, {"methodBody": ["METHOD_START", "{", "VirtualFile   file    =    myFixture . copyFileToProject (  \" web - app _  2  _  5  . xsd \"  )  ;", "final   XsdNamespaceBuilder   builder    =    XsdNamespaceBuilder . computeNamespace ( new   InputStreamReader ( file . getInputStream (  )  )  )  ;", "assertEquals (  . NS ,    builder . getNamespace (  )  )  ;", "assertEquals (  \"  2  .  5  \"  ,    builder . getVersion (  )  )  ;", "assertEquals ( Collections . singletonList (  \" web - app \"  )  ,    builder . getTags (  )  )  ;", "}", "METHOD_END"], "methodName": ["testXsdNamespaceBuilder"], "fileName": "com.intellij.xml.index.XmlSchemaIndexTest"}, {"methodBody": ["METHOD_START", "{", "VirtualFile   file    =    myFixture . copyFileToProject (  \" Semantic . xsd \"  )  ;", "assert   file    !  =    null ;", "final   FileInputStream   is    =    new   FileInputStream ( new   File ( file . getPath (  )  )  )  ;", "final   MultiMap < SchemaTypeInfo ,    SchemaTypeInfo >    map    =    XsdComplexTypeInfoBuilder . parse ( is )  ;", "final   Collection < SchemaTypeInfo >    node    =    map . get ( new   SchemaTypeInfo (  \" tConversationNode \"  ,    true ,     . ourNs )  )  ;", "Assert . assertNotNull ( node )  ;", "Assert . assertEquals (  3  ,    node . size (  )  )  ;", "final   Set < SchemaTypeInfo >    expected    =    new   com . intellij . util . containers . hash . HashSet (  )  ;", "expected . add ( new   SchemaTypeInfo (  \" tConversation \"  ,    true ,     . ourNs )  )  ;", "expected . add ( new   SchemaTypeInfo (  \" tCallConversation \"  ,    true ,     . ourNs )  )  ;", "expected . add ( new   SchemaTypeInfo (  \" tSubConversation \"  ,    true ,     . ourNs )  )  ;", "for    ( SchemaTypeInfo   info    :    node )     {", "expected . remove ( info )  ;", "}", "Assert . assertTrue ( expected . isEmpty (  )  )  ;", "final   Collection < SchemaTypeInfo >    stringNode    =    map . get ( new   SchemaTypeInfo (  \" string \"  ,    true ,     \" http :  /  / www . w 3  . org /  2  0  0  1  / XMLSchema \"  )  )  ;", "Assert . assertNotNull ( stringNode )  ;", "Assert . assertEquals (  9  ,    stringNode . size (  )  )  ;", "Assert . assertTrue ( stringNode . contains ( new   SchemaTypeInfo (  \" tAdHocOrdering \"  ,    true ,     . ourNs )  )  )  ;", "Assert . assertTrue ( stringNode . contains ( new   SchemaTypeInfo (  \" tEventBasedGatewayType \"  ,    true ,     . ourNs )  )  )  ;", "final   Collection < SchemaTypeInfo >    baseNode    =    map . get ( new   SchemaTypeInfo (  \" tBaseElement \"  ,    true ,     . ourNs )  )  ;", "Assert . assertNotNull ( baseNode )  ;", "Assert . assertEquals (  3  9  ,    baseNode . size (  )  )  ;", "Assert . assertTrue ( baseNode . contains ( new   SchemaTypeInfo (  \" tAuditing \"  ,    true ,     . ourNs )  )  )  ;", "Assert . assertTrue ( baseNode . contains ( new   SchemaTypeInfo (  \" tDataInput \"  ,    true ,     . ourNs )  )  )  ;", "Assert . assertTrue ( baseNode . contains ( new   SchemaTypeInfo (  \" tDataOutput \"  ,    true ,     . ourNs )  )  )  ;", "Assert . assertTrue ( baseNode . contains ( new   SchemaTypeInfo (  \" tFlowElement \"  ,    true ,     . ourNs )  )  )  ;", "}", "METHOD_END"], "methodName": ["testBuilder"], "fileName": "com.intellij.xml.index.XmlSchemaTypeInheritanceTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . copyDirectoryToProject (  \"  \"  ,     \"  \"  )  ;", "final   Project   project    =    getProject (  )  ;", "final   List < Set < SchemaTypeInfo >  >    childrenOfType    =    Index . getWorker ( project ,    null )  . apply (  \" http :  /  / a . b . c \"  ,     \" baseSimpleType \"  )  ;", "Assert . assertNotNull ( childrenOfType )  ;", "final   Set < SchemaTypeInfo >    expected    =    new   com . intellij . util . containers . hash . HashSet (  )  ;", "expected . add ( new   SchemaTypeInfo (  \" extSimple 4  \"  ,    true ,     \" http :  /  / a . b . c \"  )  )  ;", "expected . add ( new   SchemaTypeInfo (  \" extSimple 1  \"  ,    true ,     \" http :  /  / a . b . c \"  )  )  ;", "expected . add ( new   SchemaTypeInfo (  \" extComplex 2  \"  ,    true ,     \" http :  /  / a . b . c \"  )  )  ;", "expected . add ( new   SchemaTypeInfo (  \" extComplex 2  \"  ,    true ,     \" http :  /  / a . b . c . d \"  )  )  ;", "for    ( Set < SchemaTypeInfo >    infos    :    childrenOfType )     {", "for    ( SchemaTypeInfo   info    :    infos )     {", "expected . remove ( info )  ;", "}", "}", "Assert . assertTrue ( expected . isEmpty (  )  )  ;", "final   List < Set < SchemaTypeInfo >  >    childrenOfSimple 4 Type    =    Index . getWorker ( project ,    null )  . apply (  \" http :  /  / a . b . c \"  ,     \" extSimple 4  \"  )  ;", "Assert . assertNotNull ( childrenOfSimple 4 Type )  ;", "final   Set < SchemaTypeInfo >    expectedSimple 4     =    new   com . intellij . util . containers . hash . HashSet (  )  ;", "expectedSimple 4  . add ( new   SchemaTypeInfo (  \" extSimple 5  \"  ,    true ,     \" http :  /  / a . b . c \"  )  )  ;", "expectedSimple 4  . add ( new   SchemaTypeInfo (  \" wiseElement \"  ,    false ,     \" http :  /  / a . b . c \"  )  )  ;", "for    ( Set < SchemaTypeInfo >    infos    :    childrenOfSimple 4 Type )     {", "for    ( SchemaTypeInfo   info    :    infos )     {", "expectedSimple 4  . remove ( info )  ;", "}", "}", "Assert . assertTrue ( expectedSimple 4  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["testIndex"], "fileName": "com.intellij.xml.index.XmlSchemaTypeInheritanceTest"}, {"methodBody": ["METHOD_START", "{", "return   FileBasedIndex . getInstance (  )  . getAllKeys ( XmlTagNamesIndex . NAME ,    project )  ;", "}", "METHOD_END"], "methodName": ["getAllTagNames"], "fileName": "com.intellij.xml.index.XmlTagNamesIndex"}, {"methodBody": ["METHOD_START", "{", "return   FileBasedIndex . getInstance (  )  . getContainingFiles ( XmlTagNamesIndex . NAME ,    tagName ,    XmlIndex . createFilter ( project )  )  ;", "}", "METHOD_END"], "methodName": ["getFilesByTagName"], "fileName": "com.intellij.xml.index.XmlTagNamesIndex"}, {"methodBody": ["METHOD_START", "{", "final   int   separatorIdx    =    value . indexOf (  '  :  '  )  ;", "final   String   ns    =     ( separatorIdx    <  =     0  )     ?     \"  \"     :    value . substring (  0  ,    separatorIdx )  ;", "final   String   element    =     ( separatorIdx    <  =     0  )     ?    value    :    value . substring (  ( separatorIdx    +     1  )  )  ;", "String   nsUri    =    myNameSpaceHelper . getNamespaces (  )  . get ( ns )  ;", "nsUri    =     ( nsUri    =  =    null )     ?    ns    :    nsUri ;", "return   new   Schema ( element ,    isType ,    nsUri )  ;", "}", "METHOD_END"], "methodName": ["createSchemaTypeInfo"], "fileName": "com.intellij.xml.index.XsdComplexTypeInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "return   myMap ;", "}", "METHOD_END"], "methodName": ["getMap"], "fileName": "com.intellij.xml.index.XsdComplexTypeInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "return   XsdComplexTypeInfoBuilder . parse ( new   InputStreamReader ( is )  )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "com.intellij.xml.index.XsdComplexTypeInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "try    {", "final      builder    =    new    (  )  ;", "final    . NameSpaceHelper   helper    =    new    . NameSpaceHelper (  )  ;", "builder . setNameSpaceHelper ( helper )  ;", "NanoXmlUtil . parse ( reader ,    builder ,    helper )  ;", "final   MultiMap < SchemaTypeInfo ,    SchemaTypeInfo >    map    =    builder . getMap (  )  ;", "return   map ;", "}    finally    {", "try    {", "if    ( reader    !  =    null )     {", "reader . close (  )  ;", "}", "}    catch    ( IOException   e )     {", "}", "}", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "com.intellij.xml.index.XsdComplexTypeInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "final   boolean   isAnonymous    =    XsdComplexTypeInfoBuilder . SIGN . equals ( typeName )  ;", "if    ( isAnonymous    &  &     (  ( myCurrentElementName )     !  =    null )  )     {", "myMap . putValue ( createSchemaTypeInfo ( value ,    true )  ,    createSchemaTypeInfo ( myCurrentElementName ,    false )  )  ;", "} else    {", "myMap . putValue ( createSchemaTypeInfo ( value ,    true )  ,    createSchemaTypeInfo ( typeName ,    true )  )  ;", "}", "}", "METHOD_END"], "methodName": ["putTypeDataToMap"], "fileName": "com.intellij.xml.index.XsdComplexTypeInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "myNameSpaceHelper    =    nameSpaceHelper ;", "}", "METHOD_END"], "methodName": ["setNameSpaceHelper"], "fileName": "com.intellij.xml.index.XsdComplexTypeInfoBuilder"}, {"methodBody": ["METHOD_START", "{", "return   XsdNamespaceBuilder . computeNamespace ( new   InputStreamReader ( is )  )  . getNamespace (  )  ;", "}", "METHOD_END"], "methodName": ["computeNamespace"], "fileName": "com.intellij.xml.index.XsdNamespaceBuilder"}, {"methodBody": ["METHOD_START", "{", "try    {", "final      builder    =    new    (  )  ;", "NanoXmlUtil . parse ( reader ,    builder )  ;", "HashSet < String >    tags    =    new   HashSet <  >  ( builder . getTags (  )  )  ;", "tags . removeAll ( builder . myReferencedTags )  ;", "builder . getRootTags (  )  . addAll ( tags )  ;", "return   builder ;", "}    finally    {", "try    {", "if    ( reader    !  =    null )     {", "reader . close (  )  ;", "}", "}    catch    ( IOException   e )     {", "}", "}", "}", "METHOD_END"], "methodName": ["computeNamespace"], "fileName": "com.intellij.xml.index.XsdNamespaceBuilder"}, {"methodBody": ["METHOD_START", "{", "return   myAttributes ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "com.intellij.xml.index.XsdNamespaceBuilder"}, {"methodBody": ["METHOD_START", "{", "return   myNamespace ;", "}", "METHOD_END"], "methodName": ["getNamespace"], "fileName": "com.intellij.xml.index.XsdNamespaceBuilder"}, {"methodBody": ["METHOD_START", "{", "int   rate    =     0  ;", "if    (  ( tag    !  =    null )     &  &     ( myTags . contains ( tag )  )  )     {", "rate    |  =     2  ;", "}", "if    (  ( version    !  =    null )     &  &     ( version . equals ( myVersion )  )  )     {", "rate    |  =     1  ;", "}", "return   rate ;", "}", "METHOD_END"], "methodName": ["getRating"], "fileName": "com.intellij.xml.index.XsdNamespaceBuilder"}, {"methodBody": ["METHOD_START", "{", "return   myRootTags ;", "}", "METHOD_END"], "methodName": ["getRootTags"], "fileName": "com.intellij.xml.index.XsdNamespaceBuilder"}, {"methodBody": ["METHOD_START", "{", "return   myTags ;", "}", "METHOD_END"], "methodName": ["getTags"], "fileName": "com.intellij.xml.index.XsdNamespaceBuilder"}, {"methodBody": ["METHOD_START", "{", "return   myVersion ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "com.intellij.xml.index.XsdNamespaceBuilder"}, {"methodBody": ["METHOD_START", "{", "return   myTags . contains ( tagName )  ;", "}", "METHOD_END"], "methodName": ["hasTag"], "fileName": "com.intellij.xml.index.XsdNamespaceBuilder"}, {"methodBody": ["METHOD_START", "{", "return   XsdTagNameBuilder . computeTagNames ( new   InputStreamReader ( is )  )  ;", "}", "METHOD_END"], "methodName": ["computeTagNames"], "fileName": "com.intellij.xml.index.XsdTagNameBuilder"}, {"methodBody": ["METHOD_START", "{", "try    {", "final      builder    =    new    (  )  ;", "NanoXmlUtil . parse ( reader ,    builder )  ;", "return   builder . myTagNames ;", "}    finally    {", "try    {", "if    ( reader    !  =    null )     {", "reader . close (  )  ;", "}", "}    catch    ( IOException   e )     {", "}", "}", "}", "METHOD_END"], "methodName": ["computeTagNames"], "fileName": "com.intellij.xml.index.XsdTagNameBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( file    !  =    null )     &  &     ( editor    !  =    null )  )     {", "int   offset    =    editor . getCaretModel (  )  . getOffset (  )  ;", "PsiReference   reference    =    file . findReferenceAt ( offset )  ;", "if    ( reference   instanceof   Possibleference )     {", "return    (  ( Possibleference )     ( reference )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getReference"], "fileName": "com.intellij.xml.refactoring.SchemaPrefixRenameHandler"}, {"methodBody": ["METHOD_START", "{", "EditorColorsManager   colorsManager    =    EditorColorsManager . getInstance (  )  ;", "final   TextAttributes   attributes    =    colorsManager . getGlobalScheme (  )  . getAttributes ( WRITE _ SEARCH _ RESULT _ ATTRIBUTES )  ;", "final   HighlightManager   highlightManager    =    HighlightManager . getInstance ( editor . getProject (  )  )  ;", "for    ( final   TextRange   range    :    ranges )     {", "highlightManager . addOccurrenceHighlight ( editor ,    range . getStartOffset (  )  ,    range . getEndOffset (  )  ,    attributes ,     0  ,    highlighters ,    null )  ;", "}", "for    ( RangeHighlighter   highlighter    :    highlighters )     {", "highlighter . setGreedyToLeft ( true )  ;", "highlighter . setGreedyToRight ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["addHighlights"], "fileName": "com.intellij.xml.refactoring.XmlTagInplaceRenamer"}, {"methodBody": ["METHOD_START", "{", "final   TemplateBuilderImpl   builder    =    new   TemplateBuilderImpl ( tag )  ;", "final   ASTNode   selected    =    pair . first ;", "final   ASTNode   other    =    pair . second ;", "builder . replaceElement ( selected . getPsi (  )  ,     . PRIMARY _ VARIABLE _ NAME ,    new   EmptyExpression (  )     {", "@ Override", "public   Result   calculateQuickResult ( final   ExpressionContext   context )     {", "return   new   TextResult ( selected . getText (  )  )  ;", "}", "@ Override", "public   Result   calculateResult ( final   ExpressionContext   context )     {", "return   new   TextResult ( selected . getText (  )  )  ;", "}", "}  ,    true )  ;", "if    ( other    !  =    null )     {", "builder . replaceElement ( other . getPsi (  )  ,     . OTHER _ VARIABLE _ NAME ,     . PRIMARY _ VARIABLE _ NAME ,    false )  ;", "}", "return   builder . buildInlineTemplate (  )  ;", "}", "METHOD_END"], "methodName": ["buildTemplate"], "fileName": "com.intellij.xml.refactoring.XmlTagInplaceRenamer"}, {"methodBody": ["METHOD_START", "{", "XmlTagInplaceRenamer . ourRenamersStack . pop (  )  ;", "if    (  ( myHighlighters )     !  =    null )     {", "Project   project    =    myEditor . getProject (  )  ;", "if    (  ( project    !  =    null )     &  &     (  !  ( project . isDisposed (  )  )  )  )     {", "final   HighlightManager   highlightManager    =    HighlightManager . getInstance ( project )  ;", "for    ( final   RangeHighlighter   highlighter    :    myHighlighters )     {", "highlightManager . removeSegmentHighlighter ( myEditor ,    highlighter )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["finish"], "fileName": "com.intellij.xml.refactoring.XmlTagInplaceRenamer"}, {"methodBody": ["METHOD_START", "{", "final   int   offset    =    myEditor . getCaretModel (  )  . getOffset (  )  ;", "final   ASTNode   node    =    tag . getNode (  )  ;", "assert   node    !  =    null ;", "final   ASTNode   startTagName    =    XmlChildRole . START _ TAG _ NAME _ FINDER . findChild ( node )  ;", "if    ( startTagName    =  =    null )", "return   null ;", "final   ASTNode   endTagName    =    XmlChildRole . CLOSING _ TAG _ NAME _ FINDER . findChild ( node )  ;", "final   ASTNode   selected    =     (  (  ( endTagName    =  =    null )     |  |     ( startTagName . getTextRange (  )  . contains ( offset )  )  )     |  |     ( startTagName . getTextRange (  )  . contains (  ( offset    -     1  )  )  )  )     ?    startTagName    :    endTagName ;", "final   ASTNode   other    =     ( selected    =  =    startTagName )     ?    endTagName    :    startTagName ;", "return   Pair . create ( selected ,    other )  ;", "}", "METHOD_END"], "methodName": ["getNamePair"], "fileName": "com.intellij.xml.refactoring.XmlTagInplaceRenamer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( XmlTagInplaceRenamer . ourRenamersStack . isEmpty (  )  )  )     {", "XmlTagInplaceRenamer . ourRenamersStack . peek (  )  . finish (  )  ;", "}", "final   XmlTagInplaceRenamer   renamer    =    new   XmlTagInplaceRenamer ( editor )  ;", "XmlTagInplaceRenamer . ourRenamersStack . push ( renamer )  ;", "renamer . rename ( tag )  ;", "}", "METHOD_END"], "methodName": ["rename"], "fileName": "com.intellij.xml.refactoring.XmlTagInplaceRenamer"}, {"methodBody": ["METHOD_START", "{", "final   Pair < ASTNode ,    ASTNode >    pair    =    getNamePair ( tag )  ;", "if    ( pair    =  =    null )", "return ;", "final   Project   project    =    myEditor . getProject (  )  ;", "if    ( project    !  =    null )     {", "final   List < TextRange >    highlightRanges    =    new   ArrayList <  >  (  )  ;", "highlightRanges . add ( pair . first . getTextRange (  )  )  ;", "if    (  ( pair . second )     !  =    null )     {", "highlightRanges . add ( pair . second . getTextRange (  )  )  ;", "}", "if    (  !  ( CommonRUtil . checkReadOnlyStatus ( project ,    tag )  )  )     {", "return ;", "}", "myHighlighters    =    new   ArrayList (  )  ;", "CommandProcessor . getInstance (  )  . executeCommand ( project ,     (  )     -  >    ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >     {", "final   int   offset    =    myEditor . getCaretModel (  )  . getOffset (  )  ;", "myEditor . getCaretModel (  )  . moveToOffset ( tag . getTextOffset (  )  )  ;", "final   Template   t    =    buildTemplate ( tag ,    pair )  ;", "TemplateManager . getInstance ( project )  . startTemplate ( myEditor ,    t ,    new   TemplateEditingAdapter (  )     {", "@ Override", "public   void   templateFinished ( final   Template   template ,    boolean   brokenOff )     {", "finish (  )  ;", "}", "@ Override", "public   void   templateCancelled ( final   Template   template )     {", "finish (  )  ;", "}", "}  ,     (    variableName ,    value )     -  >     (  ( value . length (  )  )     =  =     0  )     |  |     (  ( value . charAt (  (  ( value . length (  )  )     -     1  )  )  )     !  =     '     '  )  )  ;", "myEditor . getCaretModel (  )  . moveToOffset ( offset )  ;", "addHighlights ( highlightRanges ,    myEditor ,    myHighlighters )  ;", "}  )  ,    RBundle . message (  \" rename . title \"  )  ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["rename"], "fileName": "com.intellij.xml.refactoring.XmlTagInplaceRenamer"}, {"methodBody": ["METHOD_START", "{", "String   prefix    =    myNameSuggestionsField . getEnteredName (  )  ;", "final   PsiReference   reference    =    myTag . getReference (  )  ;", "if    ( reference   instanceof   TagNameReference )     {", "LookupElement [  ]    lookupItems    =    TagNameReferenceCompletionProvider . getTagNameVariants ( myTag ,    myTag . getNamespacePrefix (  )  )  ;", "editor . getCaretModel (  )  . moveToOffset ( prefix . length (  )  )  ;", "editor . getSelectionModel (  )  . removeSelection (  )  ;", "LookupManager . getInstance ( getProject (  )  )  . showLookup ( editor ,    lookupItems ,    prefix )  ;", "}", "}", "METHOD_END"], "methodName": ["completeVariable"], "fileName": "com.intellij.xml.refactoring.XmlTagRenameDialog"}, {"methodBody": ["METHOD_START", "{", "myNameSuggestionsField    =    new   com . intellij . refactoring . ui . NameSuggestionsField ( new   String [  ]  {    myTag . getName (  )     }  ,    myProject ,    FileTypes . PLAIN _ TEXT ,    myEditor )  ;", "myNameChangedListener    =     (  )     -  >    validateButtons (  )  ;", "myNameSuggestionsField . addDataChangedListener ( myNameChangedListener )  ;", "myNameSuggestionsField . getComponent (  )  . registerKeyboardAction ( new   ActionListener (  )     {", "@ Override", "public   void   actionPerformed ( ActionEvent   e )     {", "completeVariable ( myNameSuggestionsField . getEditor (  )  )  ;", "}", "}  ,    KeyStroke . getKeyStroke ( KeyEvent . VK _ SPACE ,    InputEvent . CTRL _ MASK )  ,    JComponent . WHEN _ IN _ FOCUSED _ WINDOW )  ;", "}", "METHOD_END"], "methodName": ["createNewNameComponent"], "fileName": "com.intellij.xml.refactoring.XmlTagRenameDialog"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    DescriptiveNameUtil . getDescriptiveName ( tag )  ;", "return    (  (  ( UsageViewUtil . getType ( tag )  )     +     \"     \"  )     +    name )  . trim (  )  ;", "}", "METHOD_END"], "methodName": ["getFullName"], "fileName": "com.intellij.xml.refactoring.XmlTagRenameDialog"}, {"methodBody": ["METHOD_START", "{", "return   myNameSuggestionsField . getEnteredName (  )  . trim (  )  ;", "}", "METHOD_END"], "methodName": ["getNewName"], "fileName": "com.intellij.xml.refactoring.XmlTagRenameDialog"}, {"methodBody": ["METHOD_START", "{", "final   XmlTagRenameDialog   dialog    =    new   XmlTagRenameDialog ( editor ,    element ,    tag )  ;", "dialog . show (  )  ;", "}", "METHOD_END"], "methodName": ["renameXmlTag"], "fileName": "com.intellij.xml.refactoring.XmlTagRenameDialog"}, {"methodBody": ["METHOD_START", "{", "return   EDITOR . getData ( context )  ;", "}", "METHOD_END"], "methodName": ["getEditor"], "fileName": "com.intellij.xml.refactoring.XmlTagRenameHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( context    !  =    null )     {", "final   Editor   editor    =     . getEditor ( context )  ;", "if    ( editor    !  =    null )     {", "final   int   offset    =    editor . getCaretModel (  )  . getOffset (  )  ;", "final   PsiFile   file    =    PSI _ FILE . getData ( context )  ;", "if    ( file   instanceof   XmlFile )     {", "return   file . getViewProvider (  )  . findElementAt ( offset )  ;", "}", "if    ( file    !  =    null )     {", "final   Language   language    =    PsiUtilCore . getLanguageAtOffset ( file ,    offset )  ;", "if    ( language    !  =     ( file . getLanguage (  )  )  )     {", "final   PsiFile   psiAtOffset    =    file . getViewProvider (  )  . getPsi ( language )  ;", "if    ( psiAtOffset   instanceof   XmlFile )     {", "return   psiAtOffset . findElementAt ( offset )  ;", "}", "}", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getElement"], "fileName": "com.intellij.xml.refactoring.XmlTagRenameHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isRenaming ( context )  )  )     {", "return ;", "}", "FeatureUsageTracker . getInstance (  )  . triggerFeatureUsed (  \" refactoring . rename \"  )  ;", "if    (  . isInplaceRenameAvailable ( editor )  )     {", "XmlTagInplaceRenamer . rename ( editor ,     (  ( XmlTag )     ( element . getParent (  )  )  )  )  ;", "} else    {", "XmlTagRenameDialog . renameXmlTag ( editor ,    element ,     (  ( XmlTag )     ( element . getParent (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "com.intellij.xml.refactoring.XmlTagRenameHandler"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement [  ]    elements    =    BaseRefactoringAction . getPsiElementArray ( context )  ;", "return    (  ( elements . length )     =  =     0  )     |  |     (  (  ( elements . length )     =  =     1  )     &  &     (  . shouldBeRenamedInplace ( project ,    elements )  )  )  ;", "}", "METHOD_END"], "methodName": ["isDeclarationOutOfProjectOrAbsent"], "fileName": "com.intellij.xml.refactoring.XmlTagRenameHandler"}, {"methodBody": ["METHOD_START", "{", "return   editor . getSettings (  )  . isVariableInplaceRenameEnabled (  )  ;", "}", "METHOD_END"], "methodName": ["isInplaceRenameAvailable"], "fileName": "com.intellij.xml.refactoring.XmlTagRenameHandler"}, {"methodBody": ["METHOD_START", "{", "boolean   inProject    =    PsiManager . getInstance ( project )  . isInProject ( elements [  0  ]  )  ;", "if    ( inProject    &  &     (  ( elements [  0  ]  )    instanceof    )  )     {", "XmlElementDescriptor   descriptor    =     (  (  )     ( elements [  0  ]  )  )  . getDescriptor (  )  ;", "return   descriptor   instanceof   AnyXmlElementDescriptor ;", "}", "return    ! inProject ;", "}", "METHOD_END"], "methodName": ["shouldBeRenamedInplace"], "fileName": "com.intellij.xml.refactoring.XmlTagRenameHandler"}, {"methodBody": ["METHOD_START", "{", "return   TreeStructureUtil . getPropertyName ( Html 5 SectionsNodeProvider . HTML 5  _ OUTLINE _ PROVIDER _ PROPERTY )  ;", "}", "METHOD_END"], "methodName": ["getHtml5OutlineModePropertyName"], "fileName": "com.intellij.xml.structureView.HtmlFileStructureTest"}, {"methodBody": ["METHOD_START", "{", "myPopupFixture . getPopup (  )  . setTreeActionState ( Html 5 SectionsNodeProvider . class ,    enabled )  ;", "myPopupFixture . update (  )  ;", "}", "METHOD_END"], "methodName": ["setHtml5OutlineMode"], "fileName": "com.intellij.xml.structureView.HtmlFileStructureTest"}, {"methodBody": ["METHOD_START", "{", "checkTree (  )  ;", "}", "METHOD_END"], "methodName": ["testEmpty"], "fileName": "com.intellij.xml.structureView.HtmlFileStructureTest"}, {"methodBody": ["METHOD_START", "{", "checkTree (  )  ;", "}", "METHOD_END"], "methodName": ["testImplicitSections"], "fileName": "com.intellij.xml.structureView.HtmlFileStructureTest"}, {"methodBody": ["METHOD_START", "{", "checkTree (  )  ;", "}", "METHOD_END"], "methodName": ["testMultipleRootTags"], "fileName": "com.intellij.xml.structureView.HtmlFileStructureTest"}, {"methodBody": ["METHOD_START", "{", "checkTree (  )  ;", "}", "METHOD_END"], "methodName": ["testNoSectioningRoot"], "fileName": "com.intellij.xml.structureView.HtmlFileStructureTest"}, {"methodBody": ["METHOD_START", "{", "checkTree (  )  ;", "}", "METHOD_END"], "methodName": ["testSimple"], "fileName": "com.intellij.xml.structureView.HtmlFileStructureTest"}, {"methodBody": ["METHOD_START", "{", "return   originalBlocks ;", "}", "METHOD_END"], "methodName": ["afterMerge"], "fileName": "com.intellij.xml.template.formatter.AbstractXmlTemplateFormattingModelBuilder"}, {"methodBody": ["METHOD_START", "{", "List < Block >    templateBlocks    =    new   ArrayList <  >  (  )  ;", "TemplateLanguageFileViewProvider   viewProvider    =     (  ( TemplateLanguageFileViewProvider )     ( templateFile . getViewProvider (  )  )  )  ;", "List < PsiElement >    templateElements    =    TemplateFormatUtil . findAllElementsInside ( range ,    viewProvider ,    true )  ;", "FormattingModel   localModel    =    createInternal ( templateFile ,    settings ,    xmlFormattingPolicy ,    templateElements ,    childrenIndent )  ;", "if    ( localModel    !  =    null )     {", "Block   rootBlock    =    localModel . getRootBlock (  )  ;", "if    ( rootBlock   instanceof   CompositeTemplateBlock )     {", "templateBlocks . addAll ( rootBlock . getSubBlocks (  )  )  ;", "} else    {", "templateBlocks . add ( rootBlock )  ;", "}", "}", "return   templateBlocks ;", "}", "METHOD_END"], "methodName": ["buildTemplateLanguageBlocksInside"], "fileName": "com.intellij.xml.template.formatter.AbstractXmlTemplateFormattingModelBuilder"}, {"methodBody": ["METHOD_START", "{", "Block   block    =    createDataLanguageRootBlock ( dataElement ,    language ,    settings ,    AbstractXmlTemplateFormattingModelBuilder . getPolicy ( settings ,    psiFile )  ,    psiFile ,    indent )  ;", "return   new   com . intellij . psi . formatter . DocumentBasedFormattingModel ( block ,    psiFile . getProject (  )  ,    settings ,    psiFile . getFileType (  )  ,    psiFile )  ;", "}", "METHOD_END"], "methodName": ["createDataLanguageFormattingModel"], "fileName": "com.intellij.xml.template.formatter.AbstractXmlTemplateFormattingModelBuilder"}, {"methodBody": ["METHOD_START", "{", "Block   block ;", "if    ( dataElement   instanceof   XmlTag )     {", "block    =    createXmlTagBlock ( dataElement . getNode (  )  ,    null ,    null ,    xmlFormattingPolicy ,    indent )  ;", "} else    {", "if    ( language . isKindOf ( XMLLanguage . INSTANCE )  )     {", "block    =    createXmlBlock ( dataElement . getNode (  )  ,    null ,    Alignment . createAlignment (  )  ,    xmlFormattingPolicy ,    indent ,    dataElement . getTextRange (  )  )  ;", "} else    {", "final   FormattingModelBuilder   builder    =    INSTANCE . forContext ( language ,    dataElement )  ;", "if    (  ( builder    !  =    null )     &  &     (  !  (  . isInsideXmlAttributeValue ( dataElement )  )  )  )     {", "FormattingModel   otherLanguageModel    =    builder . createModel ( dataElement ,    settings )  ;", "block    =    otherLanguageModel . getRootBlock (  )  ;", "} else    {", "block    =    new   ReadOnlyBlock ( dataElement . getNode (  )  )  ;", "}", "}", "}", "return   block ;", "}", "METHOD_END"], "methodName": ["createDataLanguageRootBlock"], "fileName": "com.intellij.xml.template.formatter.AbstractXmlTemplateFormattingModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   com . intellij . psi . formatter . DocumentBasedFormattingModel ( rootBlock ,    psiFile . getProject (  )  ,    settings ,    psiFile . getFileType (  )  ,    psiFile )  ;", "}", "METHOD_END"], "methodName": ["createDummyModel"], "fileName": "com.intellij.xml.template.formatter.AbstractXmlTemplateFormattingModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   TemplateSyntheticBlock ( subBlocks ,    parent ,    indent ,    policy ,    childIndent )  ;", "}", "METHOD_END"], "methodName": ["createSyntheticBlock"], "fileName": "com.intellij.xml.template.formatter.AbstractXmlTemplateFormattingModelBuilder"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   createInternal ( file ,    settings ,    xmlFormattingPolicy ,    elements ,    indent )  ;", "}    catch    ( FragmentedTemplateException   fte )     {", "assert    ( elements . size (  )  )     >     0  ;", "int   start    =    Integer . MAX _ VALUE ;", "int   end    =     -  1  ;", "for    ( PsiElement   element    :    elements )     {", "TextRange   range    =    element . getTextRange (  )  ;", "if    (  ( range . getStartOffset (  )  )     <    start )", "start    =    range . getStartOffset (  )  ;", "if    (  ( range . getEndOffset (  )  )     >    end )", "end    =    range . getEndOffset (  )  ;", "}", "return   createDummyModel ( new   CompositeTemplateBlock ( new   TextRange ( start ,    end )  )  ,    settings ,    file )  ;", "}", "}", "METHOD_END"], "methodName": ["createTemplateFormattingModel"], "fileName": "com.intellij.xml.template.formatter.AbstractXmlTemplateFormattingModelBuilder"}, {"methodBody": ["METHOD_START", "{", "List < PsiElement >    templateElements    =    TemplateFormatUtil . findAllTemplateLanguageElementsInside ( outerTemplateElement ,    viewProvider )  ;", "return   createTemplateFormattingModelInternal ( psiFile ,    settings ,     . getPolicy ( settings ,    psiFile )  ,    templateElements ,    indent )  ;", "}", "METHOD_END"], "methodName": ["createTemplateFormattingModel"], "fileName": "com.intellij.xml.template.formatter.AbstractXmlTemplateFormattingModelBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( elements . size (  )  )     =  =     0  )", "return   null ;", "List < Block >    templateBlocks    =    new   ArrayList <  >  (  )  ;", "for    ( PsiElement   element    :    elements )     {", "if    ( element   instanceof   PsiErrorElement )", "throw   new   FragmentedTemplateException (  (  ( PsiErrorElement )     ( element )  )  )  ;", "if    (  (  !  ( isMarkupLanguageElement ( element )  )  )     &  &     (  !  ( FormatterUtil . containsWhiteSpacesOnly ( element . getNode (  )  )  )  )  )     {", "templateBlocks . add ( createTemplateLanguageBlock ( element . getNode (  )  ,    settings ,    xmlFormattingPolicy ,    indent ,    null ,    null )  )  ;", "}", "}", "if    (  ( templateBlocks . size (  )  )     =  =     0  )", "return   null ;", "Block   topBlock    =     (  ( templateBlocks . size (  )  )     =  =     1  )     ?    templateBlocks . get (  0  )     :    new   CompositeTemplateBlock ( templateBlocks )  ;", "return   new   com . intellij . psi . formatter . DocumentBased ( topBlock ,    file . getProject (  )  ,    settings ,    file . getFileType (  )  ,    file )  ;", "}", "METHOD_END"], "methodName": ["createTemplateFormattingModelInternal"], "fileName": "com.intellij.xml.template.formatter.AbstractXmlTemplateFormattingModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   TemplateXmlBlock ( this ,    node ,    wrap ,    alignment ,    policy ,    indent ,    textRange )  ;", "}", "METHOD_END"], "methodName": ["createXmlBlock"], "fileName": "com.intellij.xml.template.formatter.AbstractXmlTemplateFormattingModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   TemplateXmlTagBlock ( this ,    node ,    wrap ,    alignment ,    policy ,    indent )  ;", "}", "METHOD_END"], "methodName": ["createXmlTagBlock"], "fileName": "com.intellij.xml.template.formatter.AbstractXmlTemplateFormattingModelBuilder"}, {"methodBody": ["METHOD_START", "{", "final   FormattingDocumentModelImpl   documentModel    =    FormattingDocumentModelImpl . createOn ( psiFile )  ;", "return   new   HtmlPolicy ( settings ,    documentModel )  ;", "}", "METHOD_END"], "methodName": ["getPolicy"], "fileName": "com.intellij.xml.template.formatter.AbstractXmlTemplateFormattingModelBuilder"}, {"methodBody": ["METHOD_START", "{", "XmlAttributeValue   value    =    PsiTreeUtil . getParentOfType ( element ,    XmlAttributeValue . class ,    true )  ;", "return   value    !  =    null ;", "}", "METHOD_END"], "methodName": ["isInsideXmlAttributeValue"], "fileName": "com.intellij.xml.template.formatter.AbstractXmlTemplateFormattingModelBuilder"}, {"methodBody": ["METHOD_START", "{", "int   templateLangRangeStart    =    Integer . MAX _ VALUE ;", "int   templateLangRangeEnd    =     -  1  ;", "int   rangeStart    =    Integer . MAX _ VALUE ;", "int   rangeEnd    =     -  1  ;", "PsiFile   templateFile    =    null ;", "List < Block >    pureMarkupBlocks    =    new   ArrayList <  >  (  )  ;", "for    ( Block   block    :    markupBlocks )     {", "TextRange   currRange    =    block . getTextRange (  )  ;", "rangeStart    =    Math . min ( currRange . getStartOffset (  )  ,    rangeStart )  ;", "rangeEnd    =    Math . max ( currRange . getEndOffset (  )  ,    rangeEnd )  ;", "boolean   isMarkupBlock    =    true ;", "if    ( block   instanceof   AnotherLanguageBlockWrapper )     {", "AnotherLanguageBlockWrapper   wrapper    =     (  ( AnotherLanguageBlockWrapper )     ( block )  )  ;", "PsiElement   otherLangElement    =    wrapper . getNode (  )  . getPsi (  )  ;", "if    ( isOuterLanguageElement ( otherLangElement )  )     {", "isMarkupBlock    =    false ;", "if    ( templateFile    =  =    null )     {", "FileViewProvider   provider    =    otherLangElement . getContainingFile (  )  . getViewProvider (  )  ;", "templateFile    =    provider . getPsi ( provider . getBaseLanguage (  )  )  ;", "}", "templateLangRangeStart    =    Math . min ( currRange . getStartOffset (  )  ,    templateLangRangeStart )  ;", "templateLangRangeEnd    =    Math . max ( currRange . getEndOffset (  )  ,    templateLangRangeEnd )  ;", "}", "}", "if    ( isMarkupBlock )     {", "pureMarkupBlocks . add ( block )  ;", "}", "}", "if    (  ( templateLangRangeEnd    >    templateLangRangeStart )     &  &     ( templateFile    !  =    null )  )     {", "List < Block >    templateBlocks    =    buildTemplateLanguageBlocksInside ( templateFile ,    new   TextRange ( templateLangRangeStart ,    templateLangRangeEnd )  ,    settings ,    xmlFormattingPolicy ,    childrenIndent )  ;", "if    ( pureMarkupBlocks . isEmpty (  )  )     {", "return   afterMerge ( templateBlocks ,    true ,    settings ,    xmlFormattingPolicy )  ;", "}", "return   afterMerge ( Util . mergeBlocks ( pureMarkupBlocks ,    templateBlocks ,    new   TextRange ( rangeStart ,    rangeEnd )  )  ,    false ,    settings ,    xmlFormattingPolicy )  ;", "}", "return   markupBlocks ;", "}", "METHOD_END"], "methodName": ["mergeWithTemplateBlocks"], "fileName": "com.intellij.xml.template.formatter.AbstractXmlTemplateFormattingModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   myErrorElement ;", "}", "METHOD_END"], "methodName": ["getErrorElement"], "fileName": "com.intellij.xml.template.formatter.FragmentedTemplateException"}, {"methodBody": ["METHOD_START", "{", "PsiElement   currElement    =    startElement ;", "int   lastOffset    =     -  1  ;", "while    (  ( currElement    !  =    null )     &  &     (  ( lastOffset    =    currElement . getTextRange (  )  . getEndOffset (  )  )     <  =     ( range . getEndOffset (  )  )  )  )     {", "boolean   isTemplateLanguage    =    currElement . getLanguage (  )  . is ( templateLanguage )  ;", "if    ( fromTemplate    =  =    isTemplateLanguage )     {", "targetList . add ( currElement )  ;", "}", "currElement    =    currElement . getNextSibling (  )  ;", "}", "if    (  ( currElement    !  =    null )     &  &     ( currElement . getTextRange (  )  . intersects ( range )  )  )     {", "PsiElement   child    =    currElement . getFirstChild (  )  ;", "if    ( child    !  =    null )     {", ". addElementSequence ( child ,    templateLanguage ,    range ,    targetList ,    fromTemplate )  ;", "}", "}", "return   new   com . intellij . openapi . util . Pair ( lastOffset ,    currElement )  ;", "}", "METHOD_END"], "methodName": ["addElementSequence"], "fileName": "com.intellij.xml.template.formatter.TemplateFormatUtil"}, {"methodBody": ["METHOD_START", "{", "try    {", "PsiFile   file    =    outerElement . getContainingFile (  )  ;", "FileViewProvider   viewProvider    =    outerElement . getContainingFile (  )  . getViewProvider (  )  ;", "if    ( viewProvider   instanceof   TemplateLanguageFileViewProvider )     {", "Language   language    =    outerElement . getLanguage (  )  ;", "FormattingModelBuilder   builder    =    INSTANCE . forContext ( language ,    outerElement )  ;", "if    ( builder   instanceof   AbstractXmltingModelBuilder )     {", "FormattingModel   model    =     (  ( AbstractXmltingModelBuilder )     ( builder )  )  . createtingModel ( file ,     (  ( TemplateLanguageFileViewProvider )     ( viewProvider )  )  ,    outerElement ,    settings ,    indent )  ;", "if    ( model    !  =    null )     {", "return   model . getRootBlock (  )  ;", "}", "}", "}", "}    catch    ( FragmentedTemplateException   e )     {", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["buildTemplateLanguageBlock"], "fileName": "com.intellij.xml.template.formatter.TemplateFormatUtil"}, {"methodBody": ["METHOD_START", "{", "int   lastOffset    =    startOffset ;", "TextRange   currRange    =    new   TextRange ( lastOffset ,    endOffset )  ;", "for    ( Block   block    :    blocks )     {", "if    (  ( lastOffset    =  =    endOffset )     |  |     (  ( block . getTextRange (  )  . getStartOffset (  )  )     >    endOffset )  )", "return   lastOffset ;", "if    ( currRange . contains ( block . getTextRange (  )  )  )     {", "result . add ( block )  ;", "if    (  ( parent    !  =    null )     &  &     ( block   instanceof   IndentInheritingBlock )  )     {", "(  ( IndentInheritingBlock )     ( block )  )  . setIndent ( parent . getIndent (  )  )  ;", "}", "lastOffset    =    block . getTextRange (  )  . getEndOffset (  )  ;", "currRange    =    new   TextRange ( lastOffset ,    endOffset )  ;", "} else", "if    (  ( currRange . intersects ( block . getTextRange (  )  )  )     &  &     (  . intersectsOneOf ( block . getTextRange (  )  ,    originalRanges )  )  )     {", "List < Block >    subBlocks    =    block . getSubBlocks (  )  ;", "if    (  ( block   instanceof   TemplateLanguageBlock )     &  &     (  (  ( TemplateLanguageBlock )     ( block )  )  . containsErrorElements (  )  )  )     {", "throw   new   FragmentedTemplateException (  )  ;", "}", "lastOffset    =     . fillGap ( block ,    originalRanges ,    subBlocks ,    result ,    lastOffset ,    endOffset ,     ( depth    +     1  )  )  ;", "currRange    =    new   TextRange ( lastOffset ,    endOffset )  ;", "}", "}", "return   lastOffset ;", "}", "METHOD_END"], "methodName": ["fillGap"], "fileName": "com.intellij.xml.template.formatter.TemplateFormatUtil"}, {"methodBody": ["METHOD_START", "{", "return   TemplateFormatUtil . fillGap ( null ,    originalRanges ,    blocks ,    result ,    startOffset ,    endOffset ,     0  )  ;", "}", "METHOD_END"], "methodName": ["fillGap"], "fileName": "com.intellij.xml.template.formatter.TemplateFormatUtil"}, {"methodBody": ["METHOD_START", "{", "return   TemplateFormatUtil . findAllElementsInside ( range ,    viewProvider ,    viewProvider . getBaseLanguage (  )  ,     ( fromTemplate    ?    viewProvider . getBaseLanguage (  )     :    viewProvider . getTemplateDataLanguage (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["findAllElementsInside"], "fileName": "com.intellij.xml.template.formatter.TemplateFormatUtil"}, {"methodBody": ["METHOD_START", "{", "List < PsiElement >    matchingElements    =    new   ArrayList <  >  (  )  ;", "PsiElement   currElement    =    viewProvider . findElementAt ( range . getStartOffset (  )  ,    language )  ;", "while    ( currElement   instanceof   OuterLanguageElement )     {", "currElement    =    currElement . getNextSibling (  )  ;", "}", "if    ( currElement    !  =    null )     {", "currElement    =     . findTopmostElementInRange ( currElement ,    range )  ;", "Pair < Integer ,    PsiElement >    result    =     . addElementSequence ( currElement ,    templateLanguage ,    range ,    matchingElements ,     ( templateLanguage    =  =    language )  )  ;", "int   lastOffset    =    result . first ;", "assert   lastOffset    >  =     0     :     \" Failed   to   process   elements   in   range :     \"     +    range ;", "if    ( lastOffset    <     ( range . getEndOffset (  )  )  )     {", "List < PsiElement >    moreElements    =     . findAllElementsInside ( new   TextRange ( lastOffset ,    range . getEndOffset (  )  )  ,    viewProvider ,    templateLanguage ,    language )  ;", "matchingElements . addAll ( moreElements )  ;", "}", "}", "return   matchingElements ;", "}", "METHOD_END"], "methodName": ["findAllElementsInside"], "fileName": "com.intellij.xml.template.formatter.TemplateFormatUtil"}, {"methodBody": ["METHOD_START", "{", "PsiFile   file    =    outerLangElement . getContainingFile (  )  ;", "if    (  ( file    !  =    null )     &  &     (  ( file . getViewProvider (  )  )    instanceof   TemplateLanguageFileViewProvider )  )     {", "TemplateLanguageFileViewProvider   viewProvider    =     (  ( TemplateLanguageFileViewProvider )     ( file . getViewProvider (  )  )  )  ;", "return    . findAllElementsInside ( outerLangElement . getTextRange (  )  ,    viewProvider ,    false )  ;", "}", "return    . EMPTY _ PSI _ ELEMENT _ LIST ;", "}", "METHOD_END"], "methodName": ["findAllMarkupLanguageElementsInside"], "fileName": "com.intellij.xml.template.formatter.TemplateFormatUtil"}, {"methodBody": ["METHOD_START", "{", "return   TemplateFormatUtil . findAllElementsInside ( outerLangElement . getTextRange (  )  ,    viewProvider ,    true )  ;", "}", "METHOD_END"], "methodName": ["findAllTemplateLanguageElementsInside"], "fileName": "com.intellij.xml.template.formatter.TemplateFormatUtil"}, {"methodBody": ["METHOD_START", "{", "PsiElement   currElement    =    original ;", "PsiElement   prevElement    =    original ;", "while    ( currElement    !  =    null )     {", "if    (  ( currElement   instanceof   PsiFile )     |  |     (  !  ( fitToRange . contains ( currElement . getTextRange (  )  )  )  )  )     {", "if    (  !  ( fitToRange . contains ( prevElement . getTextRange (  )  )  )  )     {", "return   original ;", "}", "return   prevElement ;", "}", "prevElement    =    currElement ;", "currElement    =    currElement . getParent (  )  ;", "}", "return   original ;", "}", "METHOD_END"], "methodName": ["findTopmostElementInRange"], "fileName": "com.intellij.xml.template.formatter.TemplateFormatUtil"}, {"methodBody": ["METHOD_START", "{", "return   TemplateFormatUtil . getBlockContaining ( blockList ,    originalRanges ,    range ,     0  )  ;", "}", "METHOD_END"], "methodName": ["getBlockContaining"], "fileName": "com.intellij.xml.template.formatter.TemplateFormatUtil"}, {"methodBody": ["METHOD_START", "{", "for    ( Block   block    :    blockList )     {", "if    ( block . getTextRange (  )  . contains ( range )  )     {", "if    (  . intersectsOneOf ( block . getTextRange (  )  ,    originalRanges )  )     {", "Block   containingBlock    =     . getBlockContaining ( block . getSubBlocks (  )  ,    originalRanges ,    range ,     ( depth    +     1  )  )  ;", "if    ( containingBlock    !  =    null )", "return   containingBlock ;", "}", "return   block ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getBlockContaining"], "fileName": "com.intellij.xml.template.formatter.TemplateFormatUtil"}, {"methodBody": ["METHOD_START", "{", "return    ( TemplateFormatUtil . rangesContain ( originalRanges ,     0  ,     (  ( originalRanges . size (  )  )     -     1  )  ,    blockRange . getStartOffset (  )  )  )     |  |     ( TemplateFormatUtil . rangesContain ( originalRanges ,     0  ,     (  ( originalRanges . size (  )  )     -     1  )  ,    blockRange . getEndOffset (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["intersectsOneOf"], "fileName": "com.intellij.xml.template.formatter.TemplateFormatUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( element   instanceof   PsiErrorElement )     {", "String   description    =     (  ( PsiErrorElement )     ( element )  )  . getErrorDescription (  )  ;", "for    ( String   ignorableMessage    :     . IGNORABLE _ ERROR _ MESSAGES )     {", "if    ( ignorableMessage . equals ( description )  )", "return   false ;", "}", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isErrorElement"], "fileName": "com.intellij.xml.template.formatter.TemplateFormatUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( blocksToMerge . isEmpty (  )  )", "return   originalBlocks ;", "List < Block >    result    =    new   ArrayList <  >  (  )  ;", "if    ( originalBlocks . isEmpty (  )  )     {", "for    ( Block   mergeCandidate    :    blocksToMerge )     {", "if    ( range . contains ( mergeCandidate . getTextRange (  )  )  )     {", "result . add ( mergeCandidate )  ;", "}", "}", "return   result ;", "}", "List < TextRange >    originalRanges    =    new   ArrayList <  >  (  )  ;", "for    ( Block   originalBlock    :    originalBlocks )     {", "originalRanges . add ( originalBlock . getTextRange (  )  )  ;", "}", "int   lastOffset    =    range . getStartOffset (  )  ;", "for    ( Iterator < Block >    originalBlockIterator    =    originalBlocks . iterator (  )  ;    originalBlockIterator . hasNext (  )  ;  )     {", "Block   originalBlock    =    originalBlockIterator . next (  )  ;", "int   startOffset    =    originalBlock . getTextRange (  )  . getStartOffset (  )  ;", "if    ( lastOffset    <    startOffset )     {", "lastOffset    =     . fillGap ( originalRanges ,    blocksToMerge ,    result ,    lastOffset ,    startOffset )  ;", "if    ( lastOffset    <    startOffset )     {", "lastOffset    =     . fillGap ( originalRanges ,    originalBlocks ,    result ,    lastOffset ,    startOffset )  ;", "}", "}", "Block   mergeableBlock    =     . getBlockContaining ( blocksToMerge ,    originalRanges ,    originalBlock . getTextRange (  )  )  ;", "if    ( mergeableBlock    !  =    null )     {", "if    (  ( mergeableBlock . getTextRange (  )  . getStartOffset (  )  )     >  =    lastOffset )     {", "result . add ( mergeableBlock )  ;", "lastOffset    =    mergeableBlock . getTextRange (  )  . getEndOffset (  )  ;", "}", "} else    {", "if    ( startOffset    >  =    lastOffset )     {", "result . add ( originalBlock )  ;", "originalBlockIterator . remove (  )  ;", "lastOffset    =    originalBlock . getTextRange (  )  . getEndOffset (  )  ;", "}", "}", "}", "if    ( lastOffset    <     ( range . getEndOffset (  )  )  )     {", "lastOffset    =     . fillGap ( originalRanges ,    blocksToMerge ,    result ,    lastOffset ,    range . getEndOffset (  )  )  ;", "if    ( lastOffset    <     ( range . getEndOffset (  )  )  )     {", ". fillGap ( originalRanges ,    originalBlocks ,    result ,    lastOffset ,    range . getEndOffset (  )  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["mergeBlocks"], "fileName": "com.intellij.xml.template.formatter.TemplateFormatUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( endIndex    <    startIndex )     |  |     (  ( ranges . size (  )  )     <  =    startIndex )  )     |  |     (  ( ranges . size (  )  )     <  =    endIndex )  )", "return   false ;", "int   startOffset    =    ranges . get ( startIndex )  . getStartOffset (  )  ;", "int   endOffset    =    ranges . get ( endIndex )  . getEndOffset (  )  ;", "if    (  ( offset    <    startOffset )     |  |     ( offset    >    endOffset )  )", "return   false ;", "if    ( startIndex    =  =    endIndex )", "return   true ;", "int   midIndex    =     ( endIndex    +    startIndex )     /     2  ;", "return    (  . rangesContain ( ranges ,    startIndex ,    midIndex ,    offset )  )     |  |     (  . rangesContain ( ranges ,     ( midIndex    +     1  )  ,    endIndex ,    offset )  )  ;", "}", "METHOD_END"], "methodName": ["rangesContain"], "fileName": "com.intellij.xml.template.formatter.TemplateFormatUtil"}, {"methodBody": ["METHOD_START", "{", "Block   templateLanguageBlock    =    myBuilder . createTemplateLanguageBlock ( child ,    mySettings ,    myXmlFormattingPolicy ,    getChildIndent ( child )  ,    getChildAlignment ( child )  ,    getChildWrap ( child )  )  ;", "if    ( templateLanguageBlock   instanceof   BlockWithParent )     {", "(  ( BlockWithParent )     ( templateLanguageBlock )  )  . setParent ( this )  ;", "}", "result . add ( templateLanguageBlock )  ;", "}", "METHOD_END"], "methodName": ["addBlocksForNonMarkupChild"], "fileName": "com.intellij.xml.template.formatter.TemplateLanguageBlock"}, {"methodBody": ["METHOD_START", "{", "final   List < Block >    markupBlocks    =    new   ArrayList <  >  (  )  ;", "List < PsiElement >    markupElements    =    TemplateFormatUtil . findAllMarkupLanguageElementsInside ( myNode . getPsi (  )  )  ;", "if    (  (  ( markupElements . size (  )  )     =  =     1  )     &  &     (  ( markupElements . get (  0  )  )    instanceof   XmlDocument )  )     {", "markupElements    =    getXmlDocumentChildren ( markupElements . get (  0  )  )  ;", "}", "boolean   mergeFromMarkup    =    false ;", "for    ( PsiElement   markupElement    :    markupElements )     {", "if    ( TemplateFormatUtil . isErrorElement ( markupElement )  )     {", "throw   new   FragmentedTemplateException (  (  ( PsiErrorElement )     ( markupElement )  )  )  ;", "}", "if    (  !  ( FormatterUtil . containsWhiteSpacesOnly ( markupElement . getNode (  )  )  )  )     {", "Block   rootBlock    =    myBuilder . createDataLanguageRootBlock ( markupElement ,    markupElement . getLanguage (  )  ,    mySettings ,    myXmlFormattingPolicy ,    myNode . getPsi (  )  . getContainingFile (  )  ,    getDefaultMarkupIndent (  )  )  ;", "PsiElement   parent    =    markupElement . getParent (  )  ;", "if    (  ! mergeFromMarkup )", "mergeFromMarkup    =     . isScriptBlock ( rootBlock )  ;", "if    (  ( parent   instanceof   PsiFile )     |  |     (  ( rootBlock   instanceof   TemplateXmlBlock )     &  &     (  (  ( TemplateXmlBlock )     ( rootBlock )  )  . isTextContainingTemplateElements (  )  )  )  )     {", "for    ( Block   block    :    rootBlock . getSubBlocks (  )  )     {", "if    (  . containsErrorElement ( block )  )     {", "throw   new   FragmentedTemplateException (  )  ;", "}", "markupBlocks . add ( block )  ;", "}", "} else    {", "markupBlocks . add ( rootBlock )  ;", "}", "}", "}", "List < Block >    result    =    new   ArrayList <  >  (  )  ;", "ASTNode   child    =    myNode . getFirstChildNode (  )  ;", "while    ( child    !  =    null )     {", "if    (  ( containsFatalError ( child . getPsi (  )  )  )     &  &     (  ( markupBlocks . size (  )  )     >     0  )  )     {", "throw   new   FragmentedTemplateException (  )  ;", "}", "if    (  (  !  ( FormatterUtil . containsWhiteSpacesOnly ( child )  )  )     &  &     (  ( child . getTextLength (  )  )     >     0  )  )     {", "if    (  !  ( myBuilder . isMarkupLanguageElement ( child . getPsi (  )  )  )  )     {", "addBlocksForNonMarkupChild ( result ,    child )  ;", "}", "}", "child    =    child . getTreeNext (  )  ;", "}", "if    (  ( markupBlocks . size (  )  )     >     0  )     {", "if    ( result . isEmpty (  )  )", "return   markupBlocks ;", "if    ( mergeFromMarkup )     {", "result    =    TemplateFormatUtil . mergeBlocks ( markupBlocks ,    result ,    myNode . getTextRange (  )  )  ;", "} else    {", "result    =    TemplateFormatUtil . mergeBlocks ( result ,    markupBlocks ,    myNode . getTextRange (  )  )  ;", "}", "for    ( Block   resultBlock    :    result )     {", "ASTNode   node    =     ( resultBlock   instanceof   ASTBlock )     ?     (  ( ASTBlock )     ( resultBlock )  )  . getNode (  )     :    null ;", "if    (  ( node    !  =    null )     &  &     ( resultBlock   instanceof   IndentInheritingBlock )  )     {", "(  ( IndentInheritingBlock )     ( resultBlock )  )  . setIndent ( getChildIndent ( node )  )  ;", "}", "if    ( resultBlock   instanceof   BlockWithParent )     {", "(  ( BlockWithParent )     ( resultBlock )  )  . setParent ( this )  ;", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["buildChildrenWithMerge"], "fileName": "com.intellij.xml.template.formatter.TemplateLanguageBlock"}, {"methodBody": ["METHOD_START", "{", "if    ( block   instanceof   ASTBlock )     {", "ASTNode   node    =     (  ( ASTBlock )     ( block )  )  . getNode (  )  ;", "if    ( node    !  =    null )     {", "return   FormatUtil . isErrorElement ( node . getPsi (  )  )  ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsErrorElement"], "fileName": "com.intellij.xml.template.formatter.TemplateLanguageBlock"}, {"methodBody": ["METHOD_START", "{", "return   myContainsErrorElements ;", "}", "METHOD_END"], "methodName": ["containsErrorElements"], "fileName": "com.intellij.xml.template.formatter.TemplateLanguageBlock"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["containsFatalError"], "fileName": "com.intellij.xml.template.formatter.TemplateLanguageBlock"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getChildAlignment"], "fileName": "com.intellij.xml.template.formatter.TemplateLanguageBlock"}, {"methodBody": ["METHOD_START", "{", "return   Wrap . createWrap ( NONE ,    false )  ;", "}", "METHOD_END"], "methodName": ["getChildWrap"], "fileName": "com.intellij.xml.template.formatter.TemplateLanguageBlock"}, {"methodBody": ["METHOD_START", "{", "return   Indent . getNormalIndent (  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultMarkupIndent"], "fileName": "com.intellij.xml.template.formatter.TemplateLanguageBlock"}, {"methodBody": ["METHOD_START", "{", "return   mySettings ;", "}", "METHOD_END"], "methodName": ["getSettings"], "fileName": "com.intellij.xml.template.formatter.TemplateLanguageBlock"}, {"methodBody": ["METHOD_START", "{", "List < PsiElement >    children    =    new   ArrayList <  >  (  )  ;", "PsiElement   child    =    xmlDocument . getFirstChild (  )  ;", "while    ( child    !  =    null )     {", "if    (  !  ( myBuilder . isOuterElement ( child )  )  )     {", "children . add ( child )  ;", "}", "child    =    child . getNextSibling (  )  ;", "}", "return   children ;", "}", "METHOD_END"], "methodName": ["getXmlDocumentChildren"], "fileName": "com.intellij.xml.template.formatter.TemplateLanguageBlock"}, {"methodBody": ["METHOD_START", "{", "return   myXmlFormattingPolicy ;", "}", "METHOD_END"], "methodName": ["getXmlFormattingPolicy"], "fileName": "com.intellij.xml.template.formatter.TemplateLanguageBlock"}, {"methodBody": ["METHOD_START", "{", "if    ( block   instanceof   TemplateXmlTagBlock )     {", "return    (  ( TemplateXmlTagBlock )     ( block )  )  . isScriptBlock (  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isScriptBlock"], "fileName": "com.intellij.xml.template.formatter.TemplateLanguageBlock"}, {"methodBody": ["METHOD_START", "{", "if    (  ( block   instanceof   TemplateXmlTagBlock )     |  |     ( block   instanceof   TemplateXmlBlock )  )", "return   true ;", "if    ( block   instanceof   ASTBlock )     {", "ASTNode   node    =     (  ( ASTBlock )     ( block )  )  . getNode (  )  ;", "return    ( node    !  =    null )     &  &     ( node . getPsi (  )  . getLanguage (  )  . isKindOf ( XMLLanguage . INSTANCE )  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isXmlBlock"], "fileName": "com.intellij.xml.template.formatter.TemplateSyntheticBlock"}, {"methodBody": ["METHOD_START", "{", "return   super . buildChildren (  )  ;", "}", "METHOD_END"], "methodName": ["buildChildrenNoMerge"], "fileName": "com.intellij.xml.template.formatter.TemplateXmlBlock"}, {"methodBody": ["METHOD_START", "{", "return   new   AnotherLanguageBlockWrapper ( child ,    myXmlFormattingPolicy ,    new   ReadOnlyBlock ( child )  ,    null ,    child . getStartOffset (  )  ,    child . getTextRange (  )  )  ;", "}", "METHOD_END"], "methodName": ["createTemplateFragmentWrapper"], "fileName": "com.intellij.xml.template.formatter.TemplateXmlBlock"}, {"methodBody": ["METHOD_START", "{", "if    ( isTextElement (  )  )     {", "( ASTNode   child    =    myNode . getFirstChildNode (  )  ;    child    !  =    null ;    child    =    child . getTreeNext (  )  )     {", "if    ( myBuilder . isOuterLanguageElement ( child . getPsi (  )  )  )", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isTextContainingTemplateElements"], "fileName": "com.intellij.xml.template.formatter.TemplateXmlBlock"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myNode . getPsi (  )  )    instanceof   PsiFile )     {", "List < Block >    patchedBlocks    =    new   ArrayList <  >  (  )  ;", "for    ( Block   block    :    originalBlocks )     {", "if    (  ( block    =  =     ( originalBlocks . get (  0  )  )  )     &  &     ( block   instanceof    )  )     {", "patchedBlocks . addAll (  (  (  )     ( block )  )  . buildChildrenNoMerge (  )  )  ;", "} else    {", "patchedBlocks . add ( block )  ;", "}", "}", "return   patchedBlocks ;", "} else    {", "return   originalBlocks ;", "}", "}", "METHOD_END"], "methodName": ["patchTopLevelChildBlocks"], "fileName": "com.intellij.xml.template.formatter.TemplateXmlBlock"}, {"methodBody": ["METHOD_START", "{", "return   HtmlUtil . isScriptTag ( getTag (  )  )  ;", "}", "METHOD_END"], "methodName": ["isScriptBlock"], "fileName": "com.intellij.xml.template.formatter.TemplateXmlTagBlock"}, {"methodBody": ["METHOD_START", "{", "FileReference   fileReference    =    null ;", "for    ( PsiReference   reference    :    references )     {", "if    ( reference   instanceof   FileReference )     {", "fileReference    =     (  ( FileReference )     ( reference )  )  . getFileReferenceSet (  )  . getLastReference (  )  ;", "break ;", "}", "}", "return   fileReference ;", "}", "METHOD_END"], "methodName": ["findFileReference"], "fileName": "com.intellij.xml.util.AnchorPathReferenceProvider"}, {"methodBody": ["METHOD_START", "{", "for    ( DynamicContextProvider   provider    :    Extensions . getExtensions ( EP _ NAME )  )     {", "final   int   dynamicOffset    =    provider . getOffset ( psiElement ,    offset ,    elementText )  ;", "if    ( dynamicOffset    !  =    offset )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isDynamic"], "fileName": "com.intellij.xml.util.AnchorPathReferenceProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( processor . execute ( element )  )  )", "return   false ;", "final   XmlTag [  ]    subTags    =    element . getSubTags (  )  ;", "for    ( XmlTag   subTag    :    subTags )     {", "if    (  !  (  .  _ processXmlElements ( subTag ,    processor )  )  )", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["_processXmlElements"], "fileName": "com.intellij.xml.util.AnchorReferenceImpl"}, {"methodBody": ["METHOD_START", "{", "final   String   attributeValue    =    xmlTag . getAttributeValue (  \" id \"  )  ;", "if    ( attributeValue    !  =    null )     {", "return   attributeValue ;", "}", "if    (  . ANCHOR _ ELEMENT _ NAME . equalsIgnoreCase ( xmlTag . getName (  )  )  )     {", "final   String   attributeValue 2     =    xmlTag . getAttributeValue (  \" name \"  )  ;", "if    ( attributeValue 2     !  =    null )     {", "return   attributeValue 2  ;", "}", "}", "if    (  . MAP _ ELEMENT _ NAME . equalsIgnoreCase ( xmlTag . getName (  )  )  )     {", "final   String   map _ anchor    =    xmlTag . getAttributeValue (  \" name \"  )  ;", "if    ( map _ anchor    !  =    null )     {", "return   map _ anchor ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAnchorValue"], "fileName": "com.intellij.xml.util.AnchorReferenceImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myFileReference )     !  =    null )     {", "final   PsiElement   psiElement    =    myFileReference . resolve (  )  ;", "return   psiElement   instanceof   XmlFile    ?     (  ( XmlFile )     ( psiElement )  )     :    null ;", "}", "final   PsiFile   containingFile    =    myElement . getContainingFile (  )  ;", "if    ( containingFile   instanceof   XmlFile )     {", "return    (  ( XmlFile )     ( containingFile )  )  ;", "} else    {", "final   XmlExtension   extension    =    XmlExtension . getExtensionByElement ( myElement )  ;", "return   extension    =  =    null    ?    null    :    extension . getContainingFile ( myElement )  ;", "}", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "com.intellij.xml.util.AnchorReferenceImpl"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =    getFile (  )  ;", "if    ( file    !  =    null )     {", "CachedValue < Map < String ,    XmlTag >  >    value    =    file . getUserData (  . ourCachedIdsKey )  ;", "if    ( value    =  =    null )     {", "value    =    CachedValuesManager . getManager ( file . getProject (  )  )  . createCachedValue ( new    . MapCachedValueProvider ( file )  ,    false )  ;", "file . putUserData (  . ourCachedIdsKey ,    value )  ;", "}", "return   value . getValue (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getIdMap"], "fileName": "com.intellij.xml.util.AnchorReferenceImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( AnchorReferenceImpl .  _ processXmlElements ( element ,    processor )  )  )", "return   false ;", "for    ( PsiElement   next    =    element . getNextSibling (  )  ;    next    !  =    null ;    next    =    next . getNextSibling (  )  )     {", "if    ( next   instanceof   XmlTag )     {", "if    (  !  ( AnchorReferenceImpl .  _ processXmlElements (  (  ( XmlTag )     ( next )  )  ,    processor )  )  )", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["processXmlElements"], "fileName": "com.intellij.xml.util.AnchorReferenceImpl"}, {"methodBody": ["METHOD_START", "{", "for    ( PsiReference   ref    :    element . getReferences (  )  )     {", "ProgressManager . checkCanceled (  )  ;", "if    ( XmlHighlightVisitor . hasBadResolve ( ref ,    true )  )     {", "if    (  ( ref . getElement (  )  )    instanceof   XmlElementContentSpec )     {", "final   String   image    =    ref . getCanonicalText (  )  ;", "if    (  ( image . equals (  \"  -  \"  )  )     |  |     ( image . equals (  \" O \"  )  )  )", "continue ;", "}", "holder . registerProblem ( ref )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doCheckRefs"], "fileName": "com.intellij.xml.util.CheckDtdReferencesInspection"}, {"methodBody": ["METHOD_START", "{", "String   tagName    =    tag . getName (  )  ;", "if    ( tag   instanceof   HtmlTag )", "tagName    =    tagName . toLowerCase (  )  ;", "Language   language    =    tag . getLanguage (  )  ;", "return    (  (  . ourTagsWithEmptyEndsNotAllowed . contains ( tagName )  )     &  &     (  ( language . isKindOf ( HTMLLanguage . INSTANCE )  )     |  |     ( language . isKindOf ( XHTMLLanguage . INSTANCE )  )  )  )     |  |     (  (  (  ( language . isKindOf ( HTMLLanguage . INSTANCE )  )     &  &     (  !  ( HtmlUtil . isSingleHtmlTag ( tag ,    false )  )  )  )     &  &     (  ( tagName . indexOf (  '  :  '  )  )     =  =     (  -  1  )  )  )     &  &     (  !  ( XmlExtension . isCollapsible ( tag )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isTagWithEmptyEndNotAllowed"], "fileName": "com.intellij.xml.util.CheckEmptyTagInspection"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    tag . getName (  )  . toLowerCase (  )  ;", "return    (  (  (  (  (  (  (  ( tag . getLanguage (  )  )     =  =     ( XMLLanguage . INSTANCE )  )     |  |     (  \" link \"  . equals ( name )  )  )     |  |     (  \" br \"  . equals ( name )  )  )     |  |     (  \" meta \"  . equals ( name )  )  )     |  |     (  \" img \"  . equals ( name )  )  )     |  |     (  \" input \"  . equals ( name )  )  )     |  |     (  \" hr \"  . equals ( name )  )  )     |  |     ( XmlExtens . isCollapsible ( tag )  )  ;", "}", "METHOD_END"], "methodName": ["isCollapsibleTag"], "fileName": "com.intellij.xml.util.CheckTagEmptyBodyInspection"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["createFix"], "fileName": "com.intellij.xml.util.CheckValidXmlInScriptBodyInspectionBase"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( FileModificationService . getInstance (  )  . prepareFileForWrite ( tag . getContainingFile (  )  )  )  )     {", "return ;", "}", "PsiDocumentManager . getInstance ( project )  . commitAllDocuments (  )  ;", "final   ASTNode   child    =    XmlChildRole . START _ TAG _ END _ FINDER . findChild ( tag . getNode (  )  )  ;", "if    ( child    =  =    null )", "return ;", "final   int   offset    =    child . getTextRange (  )  . getStartOffset (  )  ;", "VirtualFile   file    =    tag . getContainingFile (  )  . getVirtualFile (  )  ;", "final   Document   document    =    FileDocumentManager . getInstance (  )  . getDocument ( file )  ;", "WriteCommandAction . runWriteCommandAction ( project ,     (  )     -  >     {", "assert   document    !  =    null ;", "document . replaceString ( offset ,    tag . getTextRange (  )  . getEndOffset (  )  ,     \"  /  >  \"  )  ;", "PsiDocumentManager . getInstance ( project )  . commitDocument ( document )  ;", "CodeStyleManager . getInstance ( project )  . reformat ( tag )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["applyFix"], "fileName": "com.intellij.xml.util.CollapseTagIntention"}, {"methodBody": ["METHOD_START", "{", "int   offset    =    editor . getCaretModel (  )  . getOffset (  )  ;", "FileViewProvider   provider    =    file . getViewProvider (  )  ;", "for    ( Language   language    :    provider . getLanguages (  )  )     {", "PsiElement   element    =    provider . findElementAt ( offset ,    language )  ;", "XmlTag   tag    =    PsiTreeUgetParentOfType ( element ,    XmlTag . class )  ;", "if    (  ( tag    !  =    null )     &  &     (  ( XmlChildRole . START _ TAG _ END _ FINDER . findChild ( tag . getNode (  )  )  )     !  =    null )  )     {", "return   tag ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getTag"], "fileName": "com.intellij.xml.util.CollapseTagIntention"}, {"methodBody": ["METHOD_START", "{", "return   ColorIconCache . ourCache . get ( color )  . computeIfAbsent ( size ,     (    s )     -  >    new   ColorIcon ( s ,    color )  )  ;", "}", "METHOD_END"], "methodName": ["getIcon"], "fileName": "com.intellij.xml.util.ColorIconCache"}, {"methodBody": ["METHOD_START", "{", "return   ColorIconCache . INSTANCE ;", "}", "METHOD_END"], "methodName": ["getIconCache"], "fileName": "com.intellij.xml.util.ColorIconCache"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtil . isEmptyOrSpaces ( text )  )     {", "return   null ;", "}", "String   hexValue    =     (  ( text . charAt (  0  )  )     =  =     '  #  '  )     ?    text    :     . getHexCodeForColorName ( text . toLowerCase ( Locale . US )  )  ;", "if    ( hexValue    !  =    null )     {", "return   ColorUtil . fromHex ( hexValue ,    null )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "com.intellij.xml.util.ColorMap"}, {"methodBody": ["METHOD_START", "{", "return   ColorMap . ourHexCodeToColorNameMap . get ( hexString )  ;", "}", "METHOD_END"], "methodName": ["getColorNameForHexCode"], "fileName": "com.intellij.xml.util.ColorMap"}, {"methodBody": ["METHOD_START", "{", "StringTokenizer   tokenizer    =    new   StringTokenizer ( ColorMap . standardColorsString ,     \"  ,     \\ n \"  )  ;", "HashMap < String ,    String >    standardColors    =    new   HashMap <  >  (  )  ;", "while    ( tokenizer . hasMoreTokens (  )  )     {", "String   name    =    tokenizer . nextToken (  )  ;", "String   value    =    tokenizer . nextToken (  )  ;", "standardColors . put ( name ,    name )  ;", "ColorMap . ourColorNameToHexCodeMap . put ( name ,    value )  ;", "ColorMap . ourHexCodeToColorNameMap . put ( value ,    name )  ;", "}", "tokenizer    =    new   StringTokenizer ( ColorMap . colorsString ,     \"     \\ t \\ n \"  )  ;", "while    ( tokenizer . hasMoreTokens (  )  )     {", "String   name    =    tokenizer . nextToken (  )  ;", "String   hexValue    =    tokenizer . nextToken (  )  ;", "tokenizer . nextToken (  )  ;", "if    (  !  ( standardColors . containsKey ( name )  )  )     {", "ColorMap . ourColorNameToHexCodeMap . put ( name ,    hexValue )  ;", "ColorMap . ourHexCodeToColorNameMap . put ( hexValue ,    name )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["getColors"], "fileName": "com.intellij.xml.util.ColorMap"}, {"methodBody": ["METHOD_START", "{", "return   ColorMap . ourColorNameToHexCodeMap . get ( colorName )  ;", "}", "METHOD_END"], "methodName": ["getHexCodeForColorName"], "fileName": "com.intellij.xml.util.ColorMap"}, {"methodBody": ["METHOD_START", "{", "return   ColorMap . ourStandardColors . contains ( s )  ;", "}", "METHOD_END"], "methodName": ["isStandardColor"], "fileName": "com.intellij.xml.util.ColorMap"}, {"methodBody": ["METHOD_START", "{", "return   ColorMap . ourSystemColors . contains ( s )  ;", "}", "METHOD_END"], "methodName": ["isSystemColorName"], "fileName": "com.intellij.xml.util.ColorMap"}, {"methodBody": ["METHOD_START", "{", "final   Color   colorFromElement    =    UserColorLookup . getColorFromElement ( currentElement )  ;", "if    ( colorFromElement    !  =    null )     {", ". addColorPreviewAndCodeToLookup ( colorFromElement ,    buf )  ;", "}", "}", "METHOD_END"], "methodName": ["addColorPreviewAndCodeToLookup"], "fileName": "com.intellij.xml.util.ColorSampleLookupValue"}, {"methodBody": ["METHOD_START", "{", "if    ( color    =  =    null )", "return ;", "final   String   code    =     '  #  '     +     (  . toHex ( color )  )  ;", "final   String   colorName    =    ColorMap . getColorNameForHexCode ( code )  ;", "if    ( colorName    !  =    null )     {", "buf . append ( XmlBundle . message (  \" color . name \"  ,    colorName )  )  . append (  . BR )  ;", "}", "String   colorBox    =     (  \"  < div   style =  \\  \" border :     1 px   solid    #  0  0  0  0  0  0  ;    width :     5  0 px ;    height :     2  0 px ;    background - color :  \"     +    code )     +     \"  \\  \"  >  <  / div >  \"  ;", "buf . append ( XmlBundle . message (  \" color . preview \"  ,    colorBox )  )  . append (  . BR )  ;", "}", "METHOD_END"], "methodName": ["addColorPreviewAndCodeToLookup"], "fileName": "com.intellij.xml.util.ColorSampleLookupValue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ColorSampleLookupValue . ourColors )     =  =    null )     {", "synchronized ( ColorSampleLookupValue . class )     {", "if    (  ( ColorSampleLookupValue . ourColors )     =  =    null )     {", "List < ColorSampleLookupValue >    colorsList    =    new   LinkedList <  >  (  )  ;", "StringTokenizer   tokenizer    =    new   StringTokenizer ( ColorMap . systemColorsString ,     \"  \\ n \"  )  ;", "while    ( tokenizer . hasMoreTokens (  )  )     {", "String   name    =    tokenizer . nextToken (  )  ;", "colorsList . add ( new   ColorSampleLookupValue ( name ,    name ,    false )  )  ;", "tokenizer . nextToken (  )  ;", "}", "tokenizer    =    new   StringTokenizer ( ColorMap . standardColorsString ,     \"  ,     \\ n \"  )  ;", "HashMap < String ,    String >    standardColors    =    new   HashMap <  >  (  )  ;", "while    ( tokenizer . hasMoreTokens (  )  )     {", "String   name    =    tokenizer . nextToken (  )  ;", "String   value    =    tokenizer . nextToken (  )  ;", "standardColors . put ( name ,    name )  ;", "colorsList . add ( new   ColorSampleLookupValue ( name ,    value ,    true )  )  ;", "}", "tokenizer    =    new   StringTokenizer ( ColorMap . colorsString ,     \"     \\ t \\ n \"  )  ;", "while    ( tokenizer . hasMoreTokens (  )  )     {", "String   name    =    tokenizer . nextToken (  )  ;", "String   hexValue    =    tokenizer . nextToken (  )  ;", "tokenizer . nextToken (  )  ;", "if    (  !  ( standardColors . containsKey ( name )  )  )     {", "colorsList . add ( new   ColorSampleLookupValue ( name ,    hexValue ,    false )  )  ;", "}", "}", "ColorSampleLookupValue . ourColors    =    colorsList . toArray ( new   ColorSampleLookupValue [  0  ]  )  ;", "}", "}", "}", "return   ColorSampleLookupValue . ourColors ;", "}", "METHOD_END"], "methodName": ["getColors"], "fileName": "com.intellij.xml.util.ColorSampleLookupValue"}, {"methodBody": ["METHOD_START", "{", "return   myName ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.intellij.xml.util.ColorSampleLookupValue"}, {"methodBody": ["METHOD_START", "{", "return   myValue ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.intellij.xml.util.ColorSampleLookupValue"}, {"methodBody": ["METHOD_START", "{", "return   myIsStandard ;", "}", "METHOD_END"], "methodName": ["isIsStandard"], "fileName": "com.intellij.xml.util.ColorSampleLookupValue"}, {"methodBody": ["METHOD_START", "{", "final   StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <     3  ;    i +  +  )     {", "String   s    =    Integer . toHexString (  ( i    =  =     0     ?    c . getRed (  )     :    i    =  =     1     ?    c . getGreen (  )     :    c . getBlue (  )  )  )  ;", "if    (  ( s . length (  )  )     <     2  )     {", "sb . append (  '  0  '  )  ;", "}", "sb . append ( s )  ;", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toHex"], "fileName": "com.intellij.xml.util.ColorSampleLookupValue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( HTMLControls . ourControls )     =  =    null )     {", "HTMLControls . ourControls    =    HTMLControls . loadControls (  )  ;", "}", "return   HTMLControls . ourControls ;", "}", "METHOD_END"], "methodName": ["getControls"], "fileName": "com.intellij.xml.util.HTMLControls"}, {"methodBody": ["METHOD_START", "{", "Element   element ;", "try    {", "final   InputStream   stream    =     . class . getResourceAsStream (  \" HtmlControls . xml \"  )  ;", "final   byte [  ]    bytes    =    FileUtilRt . loadBytes ( stream )  ;", "stream . close (  )  ;", "final   UnsyncByteArrayInputStream   bytesStream    =    new   UnsyncByteArrayInputStream ( bytes )  ;", "element    =    JdomKt . loadElement ( CharsetToolkit . inputStreamSkippingBOM ( bytesStream )  )  ;", "bytesStream . close (  )  ;", "}    catch    ( Exception   e )     {", ". LOG . error ( e )  ;", "return   new    . Control [  0  ]  ;", "}", "if    (  !  ( element . getName (  )  . equals (  \" htmlControls \"  )  )  )     {", ". LOG . error (  \"    storage   is   broken \"  )  ;", "return   new    . Control [  0  ]  ;", "}", "return   XmlSerializer . deserialize ( element ,     . Control [  ]  . class )  ;", "}", "METHOD_END"], "methodName": ["loadControls"], "fileName": "com.intellij.xml.util.HTMLControls"}, {"methodBody": ["METHOD_START", "{", "HtmlLinkUtil . processInjectedContent ( tag ,    tagProcessor )  ;", "for    ( XmlTag   subTag    :    tag . getSubTags (  )  )     {", "HtmlLinkUtil . findLinkStylesheets ( subTag ,    tagProcessor )  ;", "}", "if    ( HtmlLinkUtil . LINK . equalsIgnoreCase ( tag . getName (  )  )  )     {", "tagProcessor . process ( tag )  ;", "}", "}", "METHOD_END"], "methodName": ["findLinkStylesheets"], "fileName": "com.intellij.xml.util.HtmlLinkUtil"}, {"methodBody": ["METHOD_START", "{", "final   PsiLanguageInjectionHost . InjectedPsiVisitor   injectedPsiVisitor    =     (    injectedPsi ,    places )     -  >     {", "if    ( injectedPsi   instanceof   XmlFile )     {", "final   XmlDocument   injectedDocument    =     (  ( XmlFile )     ( injectedPsi )  )  . getDocument (  )  ;", "if    ( injectedDocument    !  =    null )     {", "final   XmlTag   rootTag    =    injectedDocument . getRootTag (  )  ;", "if    ( rootTag    !  =    null )     {", "for    ( PsiElement   element 1     =    rootTag ;    element 1     !  =    null ;    element 1     =    element 1  . getNextSibling (  )  )     {", "if    ( element 1    instanceof   XmlTag )     {", "final   XmlTag   tag    =     (  ( XmlTag )     ( element 1  )  )  ;", "String   tagName    =    tag . getLocalName (  )  ;", "if    (  ( element 1    instanceof   HtmlTag )     |  |     (  ( tag . getNamespacePrefix (  )  . length (  )  )     >     0  )  )", "tagName    =    tagName . toLowerCase (  )  ;", "if    (  . LINK . equalsIgnoreCase ( tagName )  )     {", "tagProcessor . process (  (  ( XmlTag )     ( element 1  )  )  )  ;", "}", "}", "}", "}", "}", "}", "}  ;", "final   XmlText [  ]    texts    =    PsiTreeUtil . getChildrenOfType ( element ,    XmlText . class )  ;", "if    (  ( texts    !  =    null )     &  &     (  ( texts . length )     >     0  )  )     {", "for    ( final   XmlText   text    :    texts )     {", "for    ( PsiElement    _ element    :    text . getChildren (  )  )     {", "if    (  _ element   instanceof   PsiLanguageInjectionHost )     {", "InjectedLanguageManager . getInstance (  _ element . getProject (  )  )  . enumerate (  _ element ,    injectedPsiVisitor )  ;", "}", "}", "}", "}", "final   XmlComment [  ]    comments    =    PsiTreeUtil . getChildrenOfType ( element ,    XmlComment . class )  ;", "if    (  ( comments    !  =    null )     &  &     (  ( comments . length )     >     0  )  )     {", "for    ( final   XmlComment   comment    :    comments )     {", "if    ( comment   instanceof   PsiLanguageInjectionHost )     {", "InjectedLanguageManager . getInstance ( comment . getProject (  )  )  . enumerate ( comment ,    injectedPsiVisitor )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processInjectedContent"], "fileName": "com.intellij.xml.util.HtmlLinkUtil"}, {"methodBody": ["METHOD_START", "{", "final   XmlDocument   doc    =    HtmlUtil . getRealXmlDocument ( xhtmlFile . getDocument (  )  )  ;", "if    ( doc    =  =    null )", "return ;", "final   XmlTag   rootTag    =    doc . getRootTag (  )  ;", "if    ( rootTag    =  =    null )", "return ;", "if    (  . LINK . equalsIgnoreCase ( rootTag . getName (  )  )  )     {", "tagProcessor . process ( rootTag )  ;", "} else    {", ". findLinkStylesheets ( rootTag ,    tagProcessor )  ;", "}", "}", "METHOD_END"], "methodName": ["processLinks"], "fileName": "com.intellij.xml.util.HtmlLinkUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( doc    =  =    null )", "return   null ;", "final   PsiFile   containingFile    =    doc . getContainingFile (  )  ;", "final   PsiFile   templateFile    =    TemplateLanguageUgetTemplateFile ( containingFile )  ;", "if    ( templateFile   instanceof   XmlFile )     {", "return    (  ( XmlFile )     ( templateFile )  )  . getDocument (  )  ;", "}", "return   doc ;", "}", "METHOD_END"], "methodName": ["getRealXmlDocument"], "fileName": "com.intellij.xml.util.HtmlPsiUtil"}, {"methodBody": ["METHOD_START", "{", "String   name    =    descriptor . getName ( element )  ;", "if    (  ( name    !  =    null )     &  &     ( HtmlUtil . isOptionalEndForHtmlTag ( name )  )  )     {", "PsiElement   parent    =    element . getParent (  )  ;", "if    ( parent    !  =    null )     {", "parent    =    parent . getParent (  )  ;", "}", "if    ( parent   instanceof   HtmlTag )     {", "final   XmlElementDescriptor   parentDescriptor    =     (  ( HtmlTag )     ( parent )  )  . getDescriptor (  )  ;", "if    (  ( parentDescriptor    !  =    descriptor )     &  &     ( parentDescriptor    !  =    null )  )     {", "for    ( final   XmlElementDescriptor   elementsDescriptor    :    parentDescriptor . getElementsDescriptors (  (  ( XmlTag )     ( parent )  )  )  )     {", "if    ( HtmlUtil . isHtmlBlockTag ( elementsDescriptor . getName (  )  )  )     {", "variants . add ( elementsDescriptor )  ;", "}", "}", "}", "} else", "if    ( parent   instanceof   com . intellij . psi . impl . source . html . HtmlDocumentImpl )     {", "final   XmlNSDescriptor   nsDescriptor    =    descriptor . getNSDescriptor (  )  ;", "for    ( XmlElementDescriptor   elementDescriptor    :    nsDescriptor . getRootElementsDescriptors (  (  ( com . intellij . psi . xml . XmlDocument )     ( parent )  )  )  )     {", "if    (  ( HtmlUtil . isHtmlBlockTag ( elementDescriptor . getName (  )  )  )     &  &     (  !  ( variants . contains ( elementDescriptor )  )  )  )     {", "variants . add ( elementDescriptor )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["addHtmlSpecificCompletions"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( declarationTag   instanceof   HtmlTag )     {", "descriptors    =    ArrayUtil . mergeArrays ( descriptors ,     . getCustomAttributeDescriptors ( context )  )  ;", "return   descriptors ;", "}", "boolean   isJsfHtmlNamespace    =    false ;", "for    ( String   jsfHtmlUri    :    XmlUtil . JSF _ HTML _ URIS )     {", "if    (  ( declarationTag . getPrefixByNamespace ( jsfHtmlUri )  )     !  =    null )     {", "isJsfHtmlNamespace    =    true ;", "break ;", "}", "}", "if    (  ( isJsfHtmlNamespace    &  &     (  ( declarationTag . getNSDescriptor ( XmlUtil . XHTML _ URI ,    true )  )     !  =    null )  )     &  &     (  !  ( XmlUtil . JSP _ URI . equals ( declarationTag . getNamespace (  )  )  )  )  )     {", "descriptors    =    ArrayUtil . append ( descriptors ,    new   XmlAttributeDescriptorImpl (  )     {", "@ Override", "public   String   getName ( PsiElement   context )     {", "return    . JSFC ;", "}", "@ Override", "public   String   getName (  )     {", "return    . JSFC ;", "}", "}  ,    XmlAttributeDescriptor . class )  ;", "}", "return   descriptors ;", "}", "METHOD_END"], "methodName": ["appendHtmlSpecificAttributeCompletions"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "final   Set < String >    closingTags    =    HtmlUtil . AUTO _ CLOSE _ BY _ MAP . get ( tagName )  ;", "return    ( closingTags    !  =    null )     &  &     ( closingTags . contains ( childTagName )  )  ;", "}", "METHOD_END"], "methodName": ["canTerminate"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "PsiElement   child    =    element . getFirstChild (  )  ;", "while    ( child    !  =    null )     {", "if    ( child   instanceof   CompositeElement )     {", "return   HtmlUtil . containsOuterLanguageElements ( child )  ;", "} else", "if    ( child   instanceof   psi . templateLanguages . OuterLanguageElement )     {", "return   true ;", "}", "child    =    child . getNextSibling (  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsOuterLanguageElements"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "int   charPrefix    =    StringUtil . indexOf ( content ,    HtmlUtil . CHARSET )  ;", "do    {", "if    ( charPrefix    =  =     (  -  1  )  )", "return   null ;", "int   charsetPrefixEnd    =    charPrefix    +     ( HtmlUtil . CHARSET . length (  )  )  ;", "while    (  ( charsetPrefixEnd    <     ( content . length (  )  )  )     &  &     ( Character . isWhitespace ( content . charAt ( charsetPrefixEnd )  )  )  )", "+  + charsetPrefixEnd ;", "if    (  ( charsetPrefixEnd    <     ( content . length (  )  )  )     &  &     (  ( content . charAt ( charsetPrefixEnd )  )     =  =     '  =  '  )  )", "break ;", "charPrefix    =    StringUtil . indexOf ( content ,    HtmlUtil . CHARSET ,    charsetPrefixEnd )  ;", "}    while    ( true    )  ;", "final   Ref < String >    charsetNameRef    =    new   Ref (  )  ;", "try    {", "new   HtmlBuilderDriver ( content )  . build ( new   XmlBuilder (  )     {", "@ NonNls", "final   Set < String >    inTag    =    new   gnu . trove . THashSet (  )  ;", "boolean   metHttpEquiv    =    false ;", "boolean   metHttml 5 Charset    =    false ;", "@ Override", "public   void   doctype (  @ Nullable", "final   CharSequence   publicId ,     @ Nullable", "final   CharSequence   systemId ,    final   int   startOffset ,    final   int   endOffset )     {", "}", "@ Override", "public   XmlBuilder . ProcessingOrder   startTag ( final   CharSequence   localName ,    final   String   namespace ,    final   int   startoffset ,    final   int   endoffset ,    final   int   headerEndOffset )     {", "@ NonNls", "String   name    =    localName . toString (  )  . toLowerCase (  )  ;", "inTag . add ( name )  ;", "if    (  (  !  ( inTag . contains (  \" head \"  )  )  )     &  &     (  !  (  \" html \"  . equals ( name )  )  )  )", "terminate (  )  ;", "return   XmlBuilder . ProcessingOrder . TAGS _ AND _ ATTRIBUTES ;", "}", "private   void   terminate (  )     {", "throw   HtmlUtil . TerminateException . INSTANCE ;", "}", "@ Override", "public   void   endTag ( final   CharSequence   localName ,    final   String   namespace ,    final   int   startoffset ,    final   int   endoffset )     {", "@ NonNls", "final   String   name    =    localName . toString (  )  . toLowerCase (  )  ;", "if    (  (  (  \" meta \"  . equals ( name )  )     &  &     (  ( metHttpEquiv )     |  |     ( metHttml 5 Charset )  )  )     &  &     (  ( contentAttributeValue )     !  =    null )  )     {", "String   charsetName ;", "if    ( metHttpEquiv )     {", "int   start    =    contentAttributeValue . indexOf ( HtmlUtil . CHARSET _ PREFIX )  ;", "if    ( start    =  =     (  -  1  )  )", "return ;", "start    +  =    HtmlUtil . CHARSET _ PREFIX . length (  )  ;", "int   end    =    contentAttributeValue . indexOf (  '  ;  '  ,    start )  ;", "if    ( end    =  =     (  -  1  )  )", "end    =    contentAttributeValue . length (  )  ;", "charsetName    =    contentAttributeValue . substring ( start ,    end )  ;", "} else    {", "charsetName    =    StringUtil . stripQuotesAroundValue ( contentAttributeValue )  ;", "}", "charsetNameRef . set ( charsetName )  ;", "terminate (  )  ;", "}", "if    (  \" head \"  . equals ( name )  )     {", "terminate (  )  ;", "}", "inTag . remove ( name )  ;", "metHttpEquiv    =    false ;", "metHttml 5 Charset    =    false ;", "contentAttributeValue    =    null ;", "}", "private   String   contentAttributeValue ;", "@ Override", "public   void   attribute ( final   CharSequence   localName ,    final   CharSequence   v ,    final   int   startoffset ,    final   int   endoffset )     {", "@ NonNls", "final   String   name    =    localName . toString (  )  . toLowerCase (  )  ;", "if    ( inTag . contains (  \" meta \"  )  )     {", "@ NonNls", "String   value    =    v . toString (  )  . toLowerCase (  )  ;", "if    ( name . equals (  \" http - equiv \"  )  )     {", "metHttpEquiv    |  =    value . equals (  \" content - type \"  )  ;", "} else", "if    ( name . equals ( HtmlUtil . CHARSET )  )     {", "metHttml 5 Charset    =    true ;", "contentAttributeValue    =    value ;", "}", "if    ( name . equals (  \" content \"  )  )     {", "contentAttributeValue    =    value ;", "}", "}", "}", "@ Override", "public   void   textElement ( final   CharSequence   display ,    final   CharSequence   physical ,    final   int   startoffset ,    final   int   endoffset )     {", "}", "@ Override", "public   void   entityRef ( final   CharSequence   ref ,    final   int   startOffset ,    final   int   endOffset )     {", "}", "@ Override", "public   void   error ( String   message ,    int   startOffset ,    int   endOffset )     {", "}", "}  )  ;", "}    catch    ( HtmlUtil . TerminateException   ignored )     {", "}    catch    ( Exception   ignored )     {", "}", "String   name    =    charsetNameRef . get (  )  ;", "return   CharsetToolkit . forName ( name )  ;", "}", "METHOD_END"], "methodName": ["detectCharsetFromMetaTag"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "PsiElement   child    =    tag . getFirstChild (  )  ;", "while    ( child    !  =    null )     {", "if    ( child   instanceof   XmlAttribute )     {", "PsiElement   nameElement    =    child . getFirstChild (  )  ;", "if    (  (  ( nameElement    !  =    null )     &  &     (  ( nameElement . getNode (  )  . getElementType (  )  )     =  =     ( XmlTokenType . XML _ NAME )  )  )     &  &     ( name . equalsIgnoreCase ( nameElement . getText (  )  )  )  )     {", "return    (  ( XmlAttribute )     ( child )  )  ;", "}", "}", "child    =    child . getNextSibling (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAttributeByName"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "XmlAttribute   classAttribute    =    HtmlUtil . getAttributeByName ( tag ,    attrName )  ;", "if    (  ( classAttribute    !  =    null )     &  &     (  !  ( HtmlUtil . containsOuterLanguageElements ( classAttribute )  )  )  )     {", "String   value    =    classAttribute . getValue (  )  ;", "if    (  !  ( StringUtil . isEmptyOrSpaces ( value )  )  )", "return   value ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAttributeValue"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "String   entitiesString    =    HtmlUtil . getEntitiesString ( context ,    XmlEntitiesInspection . ATTRIBUTE _ SHORT _ NAME )  ;", "if    ( entitiesString    =  =    null )", "return   XmlAttributeDescriptor . EMPTY ;", "StringTokenizer   tokenizer    =    new   StringTokenizer ( entitiesString ,     \"  ,  \"  )  ;", "XmlAttributeDescriptor [  ]    descriptors    =    new   XmlAttributeDescriptor [ tokenizer . countTokens (  )  ]  ;", "int   index    =     0  ;", "while    ( tokenizer . hasMoreElements (  )  )     {", "final   String   customName    =    tokenizer . nextToken (  )  ;", "if    (  ( customName . length (  )  )     =  =     0  )", "continue ;", "descriptors [  ( index +  +  )  ]     =    new   XmlAttributeDescriptorImpl (  )     {", "@ Override", "public   String   getName ( PsiElement   context )     {", "return   customName ;", "}", "@ Override", "public   String   getName (  )     {", "return   customName ;", "}", "}  ;", "}", "return   descriptors ;", "}", "METHOD_END"], "methodName": ["getCustomAttributeDescriptors"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "String   entitiesString    =    HtmlUtil . getEntitiesString ( context ,    XmlEntitiesInspection . TAG _ SHORT _ NAME )  ;", "if    ( entitiesString    =  =    null )", "return   XmlElementDescriptor . EMPTY _ ARRAY ;", "StringTokenizer   tokenizer    =    new   StringTokenizer ( entitiesString ,     \"  ,  \"  )  ;", "XmlElementDescriptor [  ]    descriptors    =    new   XmlElementDescriptor [ tokenizer . countTokens (  )  ]  ;", "int   index    =     0  ;", "while    ( tokenizer . hasMoreElements (  )  )     {", "final   String   tagName    =    tokenizer . nextToken (  )  ;", "if    (  ( tagName . length (  )  )     =  =     0  )", "continue ;", "descriptors [  ( index +  +  )  ]     =    new   HtmlUtil . CustomXmlTagDescriptor ( tagName )  ;", "}", "return   descriptors ;", "}", "METHOD_END"], "methodName": ["getCustomTagDescriptors"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( context    =  =    null )", "return   null ;", "PsiFile   containingFile    =    context . getContainingFile (  )  . getOriginalFile (  )  ;", "final   InspectionProfile   profile    =    InspectionProjectProfileManager . getInstance ( context . getProject (  )  )  . getCurrentProfile (  )  ;", "XmlEntitiesInspection   inspection    =     (  ( XmlEntitiesInspection )     ( profile . getUnwrappedTool ( inspectionName ,    containingFile )  )  )  ;", "if    ( inspection    !  =    null )     {", "return   inspection . getAdditionalEntries (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getEntitiesString"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   root    =    file . getRootTag (  )  ;", "final   XmlTag   head    =     ( root    !  =    null )     ?    root . findFirstSubTag (  \" head \"  )     :    null ;", "final   XmlTag   base    =     ( head    !  =    null )     ?    head . findFirstSubTag (  \" base \"  )     :    null ;", "return   base    !  =    null    ?    base . getAttributeValue (  \" href \"  )     :    null ;", "}", "METHOD_END"], "methodName": ["getHrefBase"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "final   List < XmlAttributeValue >    result    =    new   ArrayList <  >  (  )  ;", "file . acceptChildren ( new   XmlRecursiveElementWalkingVisitor (  )     {", "@ Override", "public   void   visitXmlTag ( XmlTag   tag )     {", "XmlAttribute   attribute    =    null ;", "if    (  \" link \"  . equalsIgnoreCase ( tag . getName (  )  )  )     {", "attribute    =    tag . getAttribute (  \" href \"  )  ;", "} else", "if    (  (  \" script \"  . equalsIgnoreCase ( tag . getName (  )  )  )     |  |     (  \" img \"  . equalsIgnoreCase ( tag . getName (  )  )  )  )     {", "attribute    =    tag . getAttribute (  \" src \"  )  ;", "}", "if    ( attribute    !  =    null )", "result . add ( attribute . getValueElement (  )  )  ;", "super . visitXmlTag ( tag )  ;", "}", "@ Override", "public   void   visitElement ( PsiElement   element )     {", "if    (  ( element . getLanguage (  )  )    instanceof   XMLLanguage )     {", "super . visitElement ( element )  ;", "}", "}", "}  )  ;", "return   result . isEmpty (  )     ?    Collections . emptyList (  )     :    result ;", "}", "METHOD_END"], "methodName": ["getIncludedPathsElements"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   HtmlPsiUtil . getRealXmlDocument ( doc )  ;", "}", "METHOD_END"], "methodName": ["getRealXmlDocument"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( tag    =  =    null )", "return   null ;", "StringBuilder   builder    =    new   StringBuilder ( tag . getLocalName (  )  )  ;", "String   idValue    =     . getAttributeValue ( tag ,     . ID _ ATTRIBUTE _ NAME )  ;", "if    ( idValue    !  =    null )     {", "builder . append (  '  #  '  )  . append ( idValue )  ;", "}", "String   classValue    =     . getAttributeValue ( tag ,     . CLASS _ ATTRIBUTE _ NAME )  ;", "if    ( classValue    !  =    null )     {", "for    ( String   className    :     . splitClassNames ( classValue )  )     {", "builder . append (  '  .  '  )  . append ( className )  ;", "}", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getTagPresentation"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "return    ( HtmlUtil . isHtmlFile ( file )  )     |  |     (  ( file . getViewProvider (  )  )    instanceof   TemplateLanguageFileViewProvider )  ;", "}", "METHOD_END"], "methodName": ["hasHtml"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( url . startsWith (  \" http :  /  /  \"  )  )     |  |     ( url . startsWith (  \" https :  /  /  \"  )  )  )     |  |     ( url . startsWith (  \"  /  /  \"  )  )  )     |  |     ( url . startsWith (  \" ftp :  /  /  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["hasHtmlPrefix"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "XmlDocument   doc    =    PsiTreeUtil . getParentOfType ( context ,    XmlDocument . class )  ;", "if    ( doc    =  =    null )     {", "return   false ;", "}", "XmlProlog   prolog    =    doc . getProlog (  )  ;", "XmlDoctype   doctype    =     ( prolog    !  =    null )     ?    prolog . getDoctype (  )     :    null ;", "return    ( doctype    !  =    null )     &  &     (  !  (  . isHtml 5 Doctype ( doctype )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasNonHtml5Doctype"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( descriptor . isEnumerated (  )  )     {", "final   String [  ]    values    =    descriptor . getEnumeratedValues (  )  ;", "if    ( values    =  =    null )     {", "return   false ;", "}", "if    (  ( values . length )     =  =     2  )     {", "return    (  ( values [  0  ]  . isEmpty (  )  )     &  &     ( values [  1  ]  . equals ( descriptor . getName (  )  )  )  )     |  |     (  ( values [  1  ]  . isEmpty (  )  )     &  &     ( values [  0  ]  . equals ( descriptor . getName (  )  )  )  )  ;", "} else", "if    (  ( values . length )     =  =     1  )     {", "return   descriptor . getName (  )  . equals ( values [  0  ]  )  ;", "}", "}", "return    ( context    !  =    null )     &  &     (  . isCustomBooleanAttribute ( descriptor . getName (  )  ,    context )  )  ;", "}", "METHOD_END"], "methodName": ["isBooleanAttribute"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "final   String   entitiesString    =    HtmlUtil . getEntitiesString ( context ,    XmlEntitiesInspection . BOOLEAN _ ATTRIBUTE _ SHORT _ NAME )  ;", "if    ( entitiesString    !  =    null )     {", "StringTokenizer   tokenizer    =    new   StringTokenizer ( entitiesString ,     \"  ,  \"  )  ;", "while    ( tokenizer . hasMoreElements (  )  )     {", "if    ( tokenizer . nextToken (  )  . equalsIgnoreCase ( attributeName )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isCustomBooleanAttribute"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   attributeName . startsWith ( HtmlUtil . HTML 5  _ DATA _ ATTR _ PREFIX )  ;", "}", "METHOD_END"], "methodName": ["isCustomHtml5Attribute"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "XmlDocument   doc    =    PsiTreeUtil . getParentOfType ( context ,    XmlDocument . class )  ;", "if    (  ( doc    =  =    null )     &  &     ( context    !  =    null )  )     {", "return   Html 5 SchemaProvider . getHtml 5 SchemaLocation (  )  . equals ( ExternalResourceManagerEx . getInstanceEx (  )  . getDefaultHtmlDoctype ( context . getProject (  )  )  )  ;", "}", "return    . isHtml 5 Document ( doc )  ;", "}", "METHOD_END"], "methodName": ["isHtml5Context"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( doctype . getDtdUri (  )  )     =  =    null )     &  &     (  ( doctype . getPublicId (  )  )     =  =    null )  )     &  &     (  ( doctype . getMarkupDecl (  )  )     =  =    null )  ;", "}", "METHOD_END"], "methodName": ["isHtml5Doctype"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( doc    =  =    null )     {", "return   false ;", "}", "XmlProlog   prolog    =    doc . getProlog (  )  ;", "XmlDoctype   doctype    =     ( prolog    !  =    null )     ?    prolog . getDoctype (  )     :    null ;", "if    (  !  (  . isHtmlTagContainingFile ( doc )  )  )     {", "return   false ;", "}", "final   PsiFile   htmlFile    =    doc . getContainingFile (  )  ;", "final   String   htmlFileFullName ;", "if    ( htmlFile    !  =    null )     {", "final   VirtualFile   vFile    =    htmlFile . getVirtualFile (  )  ;", "if    ( vFile    !  =    null )     {", "htmlFileFullName    =    vFile . getPath (  )  ;", "} else    {", "htmlFileFullName    =    htmlFile . getName (  )  ;", "}", "} else    {", "htmlFileFullName    =     \" unknown \"  ;", "}", "if    ( doctype    =  =    null )     {", ". LOG . debug (  (  (  \" DOCTYPE   for    \"     +    htmlFileFullName )     +     \"    is   null \"  )  )  ;", "return   Html 5 SchemaProvider . getHtml 5 SchemaLocation (  )  . equals ( ExternalResourceManagerEx . getInstanceEx (  )  . getDefaultHtmlDoctype ( doc . getProject (  )  )  )  ;", "}", "final   boolean   html 5 Doctype    =     . isHtml 5 Doctype ( doctype )  ;", "final   String   doctypeDescription    =     (  (  (  (  (  (  \" text :     \"     +     ( doctype . getText (  )  )  )     +     \"  ,    dtdUri :     \"  )     +     ( doctype . getDtdUri (  )  )  )     +     \"  ,    publicId :     \"  )     +     ( doctype . getPublicId (  )  )  )     +     \"  ,    markupDecl :     \"  )     +     ( doctype . getMarkupDecl (  )  )  ;", ". LOG . debug (  (  (  (  (  (  \" DOCTYPE   for    \"     +    htmlFileFullName )     +     \"  ;     \"  )     +    doctypeDescription )     +     \"  ;    HTML 5  :     \"  )     +    html 5 Doctype )  )  ;", "return   html 5 Doctype ;", "}", "METHOD_END"], "methodName": ["isHtml5Document"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   HtmlUtil . HTML 5  _ TAGS _ SET . contains ( tagName )  ;", "}", "METHOD_END"], "methodName": ["isHtml5Tag"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   HtmlUtil . BLOCK _ TAGS _ MAP . contains ( tagName . toLowerCase ( Locale . US )  )  ;", "}", "METHOD_END"], "methodName": ["isHtmlBlockTag"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   HtmlUtil . BLOCK _ TAGS _ MAP . contains ( tagName )  ;", "}", "METHOD_END"], "methodName": ["isHtmlBlockTagL"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "FileType   fileType    =    file . getFileType (  )  ;", "return    ( fileType    =  =     ( FileType . INSTANCE )  )     |  |     ( fileType    =  =     ( XFileType . INSTANCE )  )  ;", "}", "METHOD_END"], "methodName": ["isHtmlFile"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "Language   language    =    element . getLanguage (  )  ;", "return    ( language . isKindOf ( HTMLLanguage . INSTANCE )  )     |  |     ( language    =  =     ( XHTMLLanguage . INSTANCE )  )  ;", "}", "METHOD_END"], "methodName": ["isHtmlFile"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  ( tag . getLanguage (  )  )     !  =     ( HTMLLanguage . INSTANCE )  )", "return   false ;", "XmlDocument   doc    =    PsiTreeUtil . getParentOfType ( tag ,    XmlDocument . class )  ;", "String   doctype    =    null ;", "if    ( doc    !  =    null )     {", "doctype    =    X . getDtdUri ( doc )  ;", "}", "doctype    =     ( doctype    =  =    null )     ?    ExternalResourceManagerEx . getInstanceEx (  )  . getDefaultHtmlDoctype ( tag . getProject (  )  )     :    doctype ;", "return    ( X . XHTML 4  _ SCHEMA _ LOCATION . equals ( doctype )  )     |  |     (  !  ( StringUtil . containsIgnoreCase ( doctype ,     \" xhtml \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isHtmlTag"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( element    =  =    null )     {", "return   false ;", "}", "final   PsiFile   containingFile    =    element . getContainingFile (  )  ;", "if    ( containingFile    !  =    null )     {", "final   XmlTag   tag    =    PsiTreeUgetParentOfType ( element ,    XmlTag . class ,    false )  ;", "if    ( tag   instanceof   HtmlTag )     {", "return   true ;", "}", "final   XmlDocument   document    =    PsiTreeUgetParentOfType ( element ,    XmlDocument . class ,    false )  ;", "if    ( document   instanceof   HtmlDocumentImpl )     {", "return   true ;", "}", "final   FileViewProvider   provider    =    containingFile . getViewProvider (  )  ;", "Language   language ;", "if    ( provider   instanceof   TemplateLanguageFileViewProvider )     {", "language    =     (  ( TemplateLanguageFileViewProvider )     ( provider )  )  . getTemplateDataLanguage (  )  ;", "} else    {", "language    =    provider . getBaseLanguage (  )  ;", "}", "return   language    =  =     ( XHTMLLanguage . INSTANCE )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isHtmlTagContainingFile"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   HtmlUtil . INLINE _ ELEMENTS _ CONTAINER _ MAP . contains ( tagName . toLowerCase ( Locale . US )  )  ;", "}", "METHOD_END"], "methodName": ["isInlineTagContainer"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   HtmlUtil . INLINE _ ELEMENTS _ CONTAINER _ MAP . contains ( tagName )  ;", "}", "METHOD_END"], "methodName": ["isInlineTagContainerL"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   HtmlUtil . OPTIONAL _ END _ TAGS _ MAP . contains ( tagName . toLowerCase ( Locale . US )  )  ;", "}", "METHOD_END"], "methodName": ["isOptionalEndForHtmlTag"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   HtmlUtil . OPTIONAL _ END _ TAGS _ MAP . contains ( tagName )  ;", "}", "METHOD_END"], "methodName": ["isOptionalEndForHtmlTagL"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   declaration    =    descriptor . getDeclaration (  )  ;", "final   PsiFile   file    =     ( declaration    !  =    null )     ?    declaration . getContainingFile (  )     :    null ;", "final   String   name    =     ( file    !  =    null )     ?    file . getName (  )     :    null ;", "return    \" meta . rnc \"  . equals ( name )  ;", "}", "METHOD_END"], "methodName": ["isOwnHtmlAttribute"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   HtmlUtil . POSSIBLY _ INLINE _ TAGS _ MAP . contains ( tagName )  ;", "}", "METHOD_END"], "methodName": ["isPossiblyInlineTag"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "return    ( tag    !  =    null )     &  &     ( tag . getLocalName (  )  . equalsIgnoreCase ( HtmlUtil . SCRIPT _ TAG _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["isScriptTag"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   Registry . is (  \" html . prefer . short . notation . of . boolean . attributes \"  ,    true )  ;", "}", "METHOD_END"], "methodName": ["isShortNotationOfBooleanAttributePreferred"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "final   XmlExtension   extension    =    XmlExtension . getExtensionByElement ( tag )  ;", "final   String   name    =    tag . getName (  )  ;", "boolean   result    =     . EMPTY _ TAGS _ MAP . contains (  ( lowerCase    ?    name . toLowerCase ( Locale . US )     :    name )  )  ;", "return   result    &  &     (  ( extension    =  =    null )     |  |     (  !  ( extension . isSingleTagException ( name )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isSingleHtmlTag"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   HtmlUtil . EMPTY _ TAGS _ MAP . contains ( tagName . toLowerCase ( Locale . US )  )  ;", "}", "METHOD_END"], "methodName": ["isSingleHtmlTag"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   HtmlUtil . EMPTY _ TAGS _ MAP . contains ( tagName )  ;", "}", "METHOD_END"], "methodName": ["isSingleHtmlTagL"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "return    ( tagName    !  =    null )     &  &     (  \" br \"  . equalsIgnoreCase ( tagName )  )  ;", "}", "METHOD_END"], "methodName": ["isTagWithoutAttributes"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "final   boolean   oldValue    =    HtmlUtil . isShortNotationOfBooleanAttributePreferred (  )  ;", "final   RegistryValue   registryValue    =    Registry . get (  \" html . prefer . short . notation . of . boolean . attributes \"  )  ;", "registryValue . setValue ( value )  ;", "Disposer . register ( parent ,    new   Disposable (  )     {", "@ Override", "public   void   dispose (  )     {", "registryValue . setValue ( oldValue )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["setShortNotationOfBooleanAttributeIsPreferred"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   classAttributeValue    !  =    null    ?    StringUtil . tokenize ( classAttributeValue ,     \"     \\ t ,  \"  )     :    Collections . emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["splitClassNames"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "Language   language    =    file . getLanguage (  )  ;", "while    ( language    !  =    null )     {", "if    (  \" JavaScript \"  . equals ( language . getID (  )  )  )", "return   true ;", "if    (  \" Dart \"  . equals ( language . getID (  )  )  )", "return   true ;", "language    =    language . getBaseLanguage (  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["supportsXmlTypedHandlers"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "XmlElementDescriptor   descriptor    =    context . getDescriptor (  )  ;", "if    ( descriptor    !  =    null )     {", "XmlNSDescriptor   nsDescriptor    =    descriptor . getNSDescriptor (  )  ;", "XmlFile   descriptorFile    =     ( nsDescriptor    !  =    null )     ?    nsDescriptor . getDescriptorFile (  )     :    null ;", "String   descriptorPath    =     ( descriptorFile    !  =    null )     ?    descriptorFile . getVirtualFile (  )  . getPath (  )     :    null ;", "return    ( Comparing . equal (  5 SchemaProvider . get 5 SchemaLocation (  )  ,    descriptorPath )  )     |  |     ( Comparing . equal (  5 SchemaProvider . getXhtml 5 SchemaLocation (  )  ,    descriptorPath )  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["tagHasHtml5Schema"], "fileName": "com.intellij.xml.util.HtmlUtil"}, {"methodBody": ["METHOD_START", "{", "T   element    =    myRef . get (  )  ;", "if    ( element    !  =    null )     {", "return   element ;", "}", "element    =     (  ( T )     ( myOriginal . retrieve (  )  )  )  ;", "if    ( element    =  =    null )     {", "throw   new   PsiInvalidElementAccessException ( this )  ;", "}", "myRef    =    new   reference . SoftReference ( element )  ;", "return   element ;", "}", "METHOD_END"], "methodName": ["getOriginal"], "fileName": "com.intellij.xml.util.IncludedXmlElement"}, {"methodBody": ["METHOD_START", "{", "XmlTag [  ]    result    =    new   XmlTag [ original . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( original . length )  ;    i +  +  )     {", "result [ i ]     =    new    ( original [ i ]  ,    this )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["wrapTags"], "fileName": "com.intellij.xml.util.IncludedXmlTag"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   included    =    XmlIncludeHandler . resolveXIncludeFile ( xincludeTag )  ;", "final   XmlDocument   document    =     ( included    !  =    null )     ?    included . getDocument (  )     :    null ;", "final   XmlTag   rootTag    =     ( document    !  =    null )     ?    document . getRootTag (  )     :    null ;", "if    ( rootTag    !  =    null )     {", "final   String   xpointer    =    xincludeTag . getAttributeValue (  \" xpointer \"  ,    XmlPsiUtil . XINCLUDE _ URI )  ;", "final   XmlTag [  ]    includeTag    =     . extractXpointer ( rootTag ,    xpointer )  ;", "PsiElement [  ]    result    =    new   PsiElement [ includeTag . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( includeTag . length )  ;    i +  +  )     {", "result [ i ]     =    new   IncludedXmlTag ( includeTag [ i ]  ,    xincludeTag . getParentTag (  )  )  ;", "}", "return   result ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["computeInclusion"], "fileName": "com.intellij.xml.util.InclusionProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( xpointer    !  =    null )     {", "Matcher   matcher    =    XPOINTER _ PATTERN . matcher ( xpointer )  ;", "if    ( matcher . matches (  )  )     {", "String   pointer    =    matcher . group (  1  )  ;", "matcher    =    CHILDREN _ PATTERN . matcher ( pointer )  ;", "if    (  ( matcher . matches (  )  )     &  &     ( matcher . group (  1  )  . equals ( rootTag . getName (  )  )  )  )     {", "return   rootTag . getSubTags (  )  ;", "}", "}", "}", "return   new   XmlTag [  ]  {    rootTag    }  ;", "}", "METHOD_END"], "methodName": ["extractXpointer"], "fileName": "com.intellij.xml.util.InclusionProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( XmlUtil . isStubBuilding (  )  )", "return   com . intellij . psi . PsiElement . EMPTY _ ARRAY ;", "return   CachedValuesManager . getCachedValue ( xincludeTag ,    new    ( xincludeTag )  )  ;", "}", "METHOD_END"], "methodName": ["getIncludedTags"], "fileName": "com.intellij.xml.util.InclusionProvider"}, {"methodBody": ["METHOD_START", "{", "TagSetRuleProvider . TagsRuleMap   ruleMap    =    map . get ( namespace )  ;", "if    ( ruleMap    =  =    null )     {", "ruleMap    =    new   TagSetRuleProvider . TagsRuleMap (  )  ;", "initMap ( ruleMap ,    namespace )  ;", "map . put ( namespace ,    ruleMap )  ;", "}", "String   tagName    =    tag . getLocalName (  )  ;", "XmlTagRuleProvider . Rule [  ]    rules    =    ruleMap . get ( tagName )  ;", "if    ( rules    =  =    null )", "return   XmlTagRuleProvider . Rule . EMPTY _ ARRAY ;", "return   rules ;", "}", "METHOD_END"], "methodName": ["getTagRule"], "fileName": "com.intellij.xml.util.TagSetRuleProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( element   instanceof   XmlToken )  )", "return   null ;", "return   Map . get ( element . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["getColorFromElement"], "fileName": "com.intellij.xml.util.UserColorLookup"}, {"methodBody": ["METHOD_START", "{", "Project   project    =    context . getProject (  )  ;", "Editor   editor    =    context . getEditor (  )  ;", "int   startOffset    =    context . getStartOffset (  )  ;", "context . getDocument (  )  . deleteString ( startOffset ,    context . getTailOffset (  )  )  ;", "PsiElement   element    =    context . getFile (  )  . findElementAt ( editor . getCaretModel (  )  . getOffset (  )  )  ;", "Color   myColorAtCaret    =     ( element   instanceof   XmlToken )     ?     . getColorFromElement ( element )     :    null ;", "context . setLaterRunnable (  (  )     -  >     {", "if    (  ( editor . isDisposed (  )  )     |  |     ( project . isDisposed (  )  )  )", "return ;", "List < ColorPickerListener >    listeners    =    ColorPickerListenerFactory . createListenersFor ( element )  ;", "Color   color    =    ColorChooser . chooseColor ( WindowManager . getInstance (  )  . suggestParentWindow ( project )  ,    XmlBundle . message (  \" choose . color . dialog . title \"  )  ,    myColorAtCaret ,    true ,    listeners ,    true )  ;", "if    ( color    !  =    null )     {", "WriteCommandAction . runWriteCommandAction ( project ,     (  )     -  >     {", "editor . getCaretModel (  )  . moveToOffset ( startOffset )  ;", "EditorModificationUtil . insertStringAtCaret ( editor ,    colorToStringConverter . fun ( color )  )  ;", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["handleUserSelection"], "fileName": "com.intellij.xml.util.UserColorLookup"}, {"methodBody": ["METHOD_START", "{", "final   String   text    =    XmlDeclareIdInCommentAction . getUncommentedText ( comment )  ;", "if    ( text    =  =    null )", "return   null ;", "if    ( text . startsWith (  \"  @ declare   id =  \\  \"  \"  )  )     {", "final   String   result    =    text . substring (  (  (  \"  @ declare   id =  \\  \"  \"  . length (  )  )     -     1  )  )  ;", "return   StringUtil . unquoteString ( result )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getImplicitlyDeclaredId"], "fileName": "com.intellij.xml.util.XmlDeclareIdInCommentAction"}, {"methodBody": ["METHOD_START", "{", "final   PsiFile   psiFile    =    comment . getContainingFile (  )  ;", "final   Language   language    =    psiFile . getViewProvider (  )  . getBaseLanguage (  )  ;", "final   er   commenter    =    INSTANCE . forLanguage ( language )  ;", "if    ( commenter    !  =    null )     {", "String   text    =    comment . getText (  )  ;", "final   String   prefix    =    commenter . getBlockPrefix (  )  ;", "if    (  ( prefix    !  =    null )     &  &     ( text . startsWith ( prefix )  )  )     {", "text    =    text . substring ( prefix . length (  )  )  ;", "final   String   suffix    =    commenter . getBlockSuffix (  )  ;", "if    (  ( suffix    !  =    null )     &  &     (  ( text . length (  )  )     >     ( suffix . length (  )  )  )  )     {", "return   text . substring (  0  ,     (  ( text . length (  )  )     -     ( suffix . length (  )  )  )  )  . trim (  )  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getUncommentedText"], "fileName": "com.intellij.xml.util.XmlDeclareIdInCommentAction"}, {"methodBody": ["METHOD_START", "{", "if    (  ( refHolder . isValidatable ( tag . getParent (  )  )  )     &  &     ( refHolder . isDuplicateIdAttributeValue ( value )  )  )     {", "holder . registerProblem ( value ,    XmlErrorMessages . message (  \" duplicate . id . reference \"  )  ,    GENERIC _ ERROR ,    ElementManipulators . getValueTextRange ( value )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkValue"], "fileName": "com.intellij.xml.util.XmlDuplicatedIdInspection"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlEnumeratedValueReferenceProvider < XmlTag >  (  )     {", "@ Override", "protected   Object   getDescriptor ( XmlTag   element )     {", "return   element . getDescriptor (  )  ;", "}", "@ Override", "protected   PsiElement   getHost ( XmlTag   element )     {", "XmlText [  ]    textElements    =    element . getValue (  )  . getTextElements (  )  ;", "return   ArrayUtil . getFirstElement ( textElements )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["forTags"], "fileName": "com.intellij.xml.util.XmlEnumeratedValueReferenceProvider"}, {"methodBody": ["METHOD_START", "{", "PsiElement   parent    =    element . getParent (  )  ;", "return   parent   instanceof   XmlAttribute    ?     (  ( XmlAttribute )     ( parent )  )  . getDescriptor (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "com.intellij.xml.util.XmlEnumeratedValueReferenceProvider"}, {"methodBody": ["METHOD_START", "{", "return   element ;", "}", "METHOD_END"], "methodName": ["getHost"], "fileName": "com.intellij.xml.util.XmlEnumeratedValueReferenceProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( element   instanceof   XmlTag )     {", "XmlTag   xmlTag    =     (  ( XmlTag )     ( element )  )  ;", "if    (  ( xmlTag . getParent (  )  )    instanceof   XmlDocument )", "return   false ;", "if    (  ( xmlTag . getLocalName (  )  . equals (  . INCLUDE _ TAG _ NAME )  )     &  &     (  ( xmlTag . getAttributeValue (  \" href \"  )  )     !  =    null )  )     {", "if    ( xmlTag . getNamespace (  )  . equals ( XmlPsiUtil . XINCLUDE _ URI )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isXInclude"], "fileName": "com.intellij.xml.util.XmlIncludeHandler"}, {"methodBody": ["METHOD_START", "{", "final   XmlAttribute   hrefAttribute    =    xincludeTag . getAttribute (  \" href \"  ,    null )  ;", "if    ( hrefAttribute    =  =    null )", "return   null ;", "final   XmlAttributeValue   xmlAttributeValue    =    hrefAttribute . getValueElement (  )  ;", "if    ( xmlAttributeValue    =  =    null )", "return   null ;", "List < PsiReference >    references    =    Arrays . asList ( xmlAttributeValue . getReferences (  )  )  ;", "if    (  ( references . size (  )  )     >     0  )     {", "Collections . sort ( references ,     (    reference 1  ,    reference 2  )     -  >     ( reference 2  . getRangeInElement (  )  . getStartOffset (  )  )     -     ( reference 1  . getRangeInElement (  )  . getStartOffset (  )  )  )  ;", "PsiElement   target    =    references . get (  0  )  . resolve (  )  ;", "if    ( target   instanceof   XmlFile )     {", "return    (  ( XmlFile )     ( target )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["resolveXIncludeFile"], "fileName": "com.intellij.xml.util.XmlIncludeHandler"}, {"methodBody": ["METHOD_START", "{", "sequence . add ( descriptor )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.intellij.xml.util.XmlNSDescriptorSequence"}, {"methodBody": ["METHOD_START", "{", "return   sequence ;", "}", "METHOD_END"], "methodName": ["getSequence"], "fileName": "com.intellij.xml.util.XmlNSDescriptorSequence"}, {"methodBody": ["METHOD_START", "{", "XmlEntityDecl . EntityContextType   type    =    XmlEntityDecl . EntityContextType . GENERIC _ XML ;", "PsiElement   temp    =    ref ;", "while    ( temp    !  =    null )     {", "if    ( temp   instanceof   XmlAttributeDecl )     {", "type    =    XmlEntityDecl . EntityContextType . ATTRIBUTE _ SPEC ;", "} else", "if    ( temp   instanceof   psi . xml . XmlElementDecl )     {", "type    =    XmlEntityDecl . EntityContextType . ELEMENT _ CONTENT _ SPEC ;", "} else", "if    ( temp   instanceof   psi . xml . XmlAttlistDecl )     {", "type    =    XmlEntityDecl . EntityContextType . ATTLIST _ SPEC ;", "} else", "if    ( temp   instanceof   XmlEntityDecl )     {", "type    =    XmlEntityDecl . EntityContextType . ENTITY _ DECL _ CONTENT ;", "} else", "if    ( temp   instanceof   psi . xml . XmlEnumeratedType )     {", "type    =    XmlEntityDecl . EntityContextType . ENUMERATED _ TYPE ;", "} else", "if    ( temp   instanceof   psi . xml . XmlAttributeValue )     {", "type    =    XmlEntityDecl . EntityContextType . ATTR _ VALUE ;", "} else    {", "temp    =    temp . getContext (  )  ;", "continue ;", "}", "break ;", "}", "return   type ;", "}", "METHOD_END"], "methodName": ["getContextType"], "fileName": "com.intellij.xml.util.XmlPsiUtil"}, {"methodBody": ["METHOD_START", "{", "CachedValue < PsiElement >    value    =    entityRef . getUserData ( XmlPsiUtil . PARSED _ DECL _ KEY )  ;", "if    ( value    =  =    null )     {", "value    =    CachedValuesManager . getManager ( entityDecl . getProject (  )  )  . createCachedValue (  (  )     -  >     {", "final   PsiElement   res    =    entityDecl . parse ( targetFile ,    type ,    entityRef )  ;", "if    ( res    =  =    null )", "return   new   CachedValueProvider . Result <  >  ( res ,    targetFile )  ;", "if    (  !  ( entityDecl . isInternalReference (  )  )  )", "psi . impl . source . xml . XmlEntityCache . copyEntityCaches ( res . getContainingFile (  )  ,    targetFile )  ;", "return   new   CachedValueProvider . Result <  >  ( res ,    res . getUserData ( XmlElement . DEPENDING _ ELEMENT )  ,    entityDecl ,    targetFile ,    entityRef )  ;", "}  ,    false )  ;", "value    =     (  ( XmlEntityRefImpl )     ( entityRef )  )  . putUserDataIfAbsent ( XmlPsiUtil . PARSED _ DECL _ KEY ,    value )  ;", "}", "return   value . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["parseEntityDecl"], "fileName": "com.intellij.xml.util.XmlPsiUtil"}, {"methodBody": ["METHOD_START", "{", "XmlEntityDecl . EntityContextType   type    =    XmlPsiUtil . getContextType ( ref )  ;", "{", "final   XmlEntityDecl   entityDecl    =    ref . resolve ( targetFile )  ;", "if    ( entityDecl    !  =    null )", "return   XmlPsiUtil . parseEntityDecl ( entityDecl ,    targetFile ,    type ,    ref )  ;", "}", "PsiElement   e    =    ref ;", "while    ( e    !  =    null )     {", "if    (  ( e . getUserData ( XmlElement . INCLUDING _ ELEMENT )  )     !  =    null )     {", "e    =    e . getUserData ( XmlElement . INCLUDING _ ELEMENT )  ;", "final   PsiFile   f    =    e . getContainingFile (  )  ;", "if    ( f    !  =    null )     {", "final   XmlEntityDecl   entityDecl    =    ref . resolve ( targetFile )  ;", "if    ( entityDecl    !  =    null )", "return   XmlPsiUtil . parseEntityDecl ( entityDecl ,    targetFile ,    type ,    ref )  ;", "}", "continue ;", "}", "if    ( e   instanceof   PsiFile )     {", "PsiFile   refFile    =     (  ( PsiFile )     ( e )  )  ;", "final   XmlEntityDecl   entityDecl    =    ref . resolve ( refFile )  ;", "if    ( entityDecl    !  =    null )", "return   XmlPsiUtil . parseEntityDecl ( entityDecl ,    targetFile ,    type ,    ref )  ;", "break ;", "}", "e    =    e . getParent (  )  ;", "}", "final   PsiElement   element    =    ref . getUserData ( XmlElement . DEPENDING _ ELEMENT )  ;", "if    ( element   instanceof   XmlFile )     {", "final   XmlEntityDecl   entityDecl    =    ref . resolve (  (  ( PsiFile )     ( element )  )  )  ;", "if    ( entityDecl    !  =    null )", "return   XmlPsiUtil . parseEntityDecl ( entityDecl ,    targetFile ,    type ,    ref )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["parseEntityRef"], "fileName": "com.intellij.xml.util.XmlPsiUtil"}, {"methodBody": ["METHOD_START", "{", "final   XmlPsiUtil . XmlElementProcessor   p    =    new   XmlPsiUtil . XmlElementProcessor ( processor ,    element . getContainingFile (  )  )  ;", "final   boolean   wideFlag    =    false ;", "for    ( PsiElement   child    =    element . getFirstChild (  )  ;    child    !  =    null ;    child    =    child . getNextSibling (  )  )     {", "if    (  (  !  ( p . processElement ( child ,    deepFlag ,    wideFlag ,    true )  )  )     &  &     (  ! wideFlag )  )", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["processXmlElementChildren"], "fileName": "com.intellij.xml.util.XmlPsiUtil"}, {"methodBody": ["METHOD_START", "{", "return   XmlPsiUtil . processXmlElements ( element ,    processor ,    deepFlag ,    false )  ;", "}", "METHOD_END"], "methodName": ["processXmlElements"], "fileName": "com.intellij.xml.util.XmlPsiUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( element    =  =    null )", "return   true ;", "PsiFile   baseFile    =     ( element . isValid (  )  )     ?    element . getContainingFile (  )     :    null ;", "return    . processXmlElements ( element ,    processor ,    deepFlag ,    wideFlag ,    baseFile )  ;", "}", "METHOD_END"], "methodName": ["processXmlElements"], "fileName": "com.intellij.xml.util.XmlPsiUtil"}, {"methodBody": ["METHOD_START", "{", "return   XmlPsiUtil . processXmlElements ( element ,    processor ,    deepFlag ,    wideFlag ,    baseFile ,    true )  ;", "}", "METHOD_END"], "methodName": ["processXmlElements"], "fileName": "com.intellij.xml.util.XmlPsiUtil"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlPsiUtil . XmlElementProcessor ( processor ,    baseFile )  . processXmlElements ( element ,    deepFlag ,    wideFlag ,    processIncludes )  ;", "}", "METHOD_END"], "methodName": ["processXmlElements"], "fileName": "com.intellij.xml.util.XmlPsiUtil"}, {"methodBody": ["METHOD_START", "{", "myUsedNamespaces . add ( ns )  ;", "}", "METHOD_END"], "methodName": ["addUsedNamespace"], "fileName": "com.intellij.xml.util.XmlRefCountHolder"}, {"methodBody": ["METHOD_START", "{", "myUsedPrefixes . add ( prefix )  ;", "}", "METHOD_END"], "methodName": ["addUsedPrefix"], "fileName": "com.intellij.xml.util.XmlRefCountHolder"}, {"methodBody": ["METHOD_START", "{", "return   XmlRefCountHolder . CACHE . get ( XmlRefCountHolder . xmlRefCountHolderKey ,    file ,    null )  . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getRefCountHolder"], "fileName": "com.intellij.xml.util.XmlRefCountHolder"}, {"methodBody": ["METHOD_START", "{", "return    (  ( myId 2 AttributeListMap . get ( idRef )  )     !  =    null )     |  |     ( myAdditionallyDeclaredIds . contains ( idRef )  )  ;", "}", "METHOD_END"], "methodName": ["hasIdDeclaration"], "fileName": "com.intellij.xml.util.XmlRefCountHolder"}, {"methodBody": ["METHOD_START", "{", "return   myPossiblyDuplicateIds . contains ( value )  ;", "}", "METHOD_END"], "methodName": ["isDuplicateIdAttributeValue"], "fileName": "com.intellij.xml.util.XmlRefCountHolder"}, {"methodBody": ["METHOD_START", "{", "return   myIdReferences . contains ( value )  ;", "}", "METHOD_END"], "methodName": ["isIdReferenceValue"], "fileName": "com.intellij.xml.util.XmlRefCountHolder"}, {"methodBody": ["METHOD_START", "{", "return   myUsedPrefixes . contains ( prefix )  ;", "}", "METHOD_END"], "methodName": ["isInUse"], "fileName": "com.intellij.xml.util.XmlRefCountHolder"}, {"methodBody": ["METHOD_START", "{", "return   myUsedNamespaces . contains ( ns )  ;", "}", "METHOD_END"], "methodName": ["isUsedNamespace"], "fileName": "com.intellij.xml.util.XmlRefCountHolder"}, {"methodBody": ["METHOD_START", "{", "return    !  ( myDoNotValidateParentsList . contains ( element )  )  ;", "}", "METHOD_END"], "methodName": ["isValidatable"], "fileName": "com.intellij.xml.util.XmlRefCountHolder"}, {"methodBody": ["METHOD_START", "{", "myAdditionallyDeclaredIds . add ( id )  ;", "}", "METHOD_END"], "methodName": ["registerAdditionalId"], "fileName": "com.intellij.xml.util.XmlRefCountHolder"}, {"methodBody": ["METHOD_START", "{", "List < Pair < XmlAttributeValue ,    Boolean >  >    list    =    myId 2 AttributeListMap . get ( id )  ;", "if    ( list    =  =    null )     {", "list    =    new   ArrayList (  )  ;", "myId 2 AttributeListMap . put ( id ,    list )  ;", "} else", "if    (  ! soft )     {", "final   boolean   html    =    HtmlUtil . isHtmlFile ( attributeValue )  ;", "final   boolean   html 5     =    HtmlUtil . isHtml 5 Context ( attributeValue )  ;", "List < XmlAttributeValue >    notSoft    =    util . containers . ContainerUtil . mapNotNull ( list ,     (  ( util . NullableFunction < Pair < XmlAttributeValue ,    Boolean >  ,    XmlAttributeValue >  )     (  (    pair )     -  >     {", "if    ( html 5     &  &     (  !  (  \" id \"  . equalsIgnoreCase (  (  ( XmlAttribute )     ( pair . first . getParent (  )  )  )  . getName (  )  )  )  )  )     {", "return   null ;", "}", "if    ( html    &  &     (  ( pair . first . getParent (  )  . getParent (  )  )     =  =     ( attributeValue . getParent (  )  . getParent (  )  )  )  )     {", "return   null ;", "}", "return   pair . second    ?    null    :    pair . first ;", "}  )  )  )  ;", "if    (  !  ( notSoft . isEmpty (  )  )  )     {", "myPossiblyDuplicateIds . addAll ( notSoft )  ;", "myPossiblyDuplicateIds . add ( attributeValue )  ;", "}", "}", "list . add ( new   Pair ( attributeValue ,    soft )  )  ;", "}", "METHOD_END"], "methodName": ["registerId"], "fileName": "com.intellij.xml.util.XmlRefCountHolder"}, {"methodBody": ["METHOD_START", "{", "myIdReferences . add ( value )  ;", "}", "METHOD_END"], "methodName": ["registerIdReference"], "fileName": "com.intellij.xml.util.XmlRefCountHolder"}, {"methodBody": ["METHOD_START", "{", "PsiElement   parent    =    element . getParent (  )  ;", "if    ( parent   instanceof   Text )     {", "parent    =    parent . getParent (  )  ;", "}", "myDoNotValidateParentsList . add ( parent )  ;", "}", "METHOD_END"], "methodName": ["registerOuterLanguageElement"], "fileName": "com.intellij.xml.util.XmlRefCountHolder"}, {"methodBody": ["METHOD_START", "{", "PsiFile   baseFile    =    resolve ( null ,    baseSystemId )  ;", "if    ( baseFile    !  =    null )", "return   baseFile ;", "File   workingFile    =    new   File (  \"  \"  )  ;", "String   workingDir    =    workingFile . getAbsoluteFile (  )  . getAbsolutePath (  )  . replace ( File . separatorChar ,     '  /  '  )  ;", "String   id    =    StringUtil . replace ( baseSystemId ,    workingDir ,    myFile . getVirtualFile (  )  . getParent (  )  . getPath (  )  )  ;", "VirtualFile   vFile    =    UriUtil . findRelative ( id ,    myFile )  ;", "if    ( vFile    =  =    null )     {", "vFile    =    UriUtil . findRelative ( baseSystemId ,    myFile )  ;", "}", "if    ( vFile    =  =    null )     {", "try    {", "vFile    =    VirtualFileManager . getInstance (  )  . findFileByUrl ( VfsUtilCore . convertFromUrl ( new   URL ( baseSystemId )  )  )  ;", "}    catch    ( MalformedURLException   ignore )     {", "}", "}", "if    (  (  ( vFile    !  =    null )     &  &     (  !  ( vFile . isDirectory (  )  )  )  )     &  &     (  !  (  ( vFile . getFileSystem (  )  )    instanceof   HttpFileSystem )  )  )     {", "baseFile    =    PsiManager . getInstance ( myProject )  . findFile ( vFile )  ;", "}", "return   baseFile ;", "}", "METHOD_END"], "methodName": ["getBaseFile"], "fileName": "com.intellij.xml.util.XmlResourceResolver"}, {"methodBody": ["METHOD_START", "{", "return   myExternalResourcesMap . get ( baseId )  ;", "}", "METHOD_END"], "methodName": ["getPathByPublicId"], "fileName": "com.intellij.xml.util.XmlResourceResolver"}, {"methodBody": ["METHOD_START", "{", "return   ArrayUtil . toStringArray ( myExternalResourcesMap . values (  )  )  ;", "}", "METHOD_END"], "methodName": ["getResourcePaths"], "fileName": "com.intellij.xml.util.XmlResourceResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( XmlResourceResolver . LOG . isDebugEnabled (  )  )     {", "XmlResourceResolver . LOG . debug (  (  (  (  (  (  (  \" enter :    resolveEntity ( baseSystemId =  '  \"     +    baseSystemId )     +     \"  '    systemId =  '  \"  )     +     _ systemId )     +     \"  ,  \"  )     +     ( this )  )     +     \"  '  )  \"  )  )  ;", "}", "if    (  _ systemId    =  =    null )", "return   null ;", "if    (  ( myStopOnUnDeclaredResource )     &  &     ( ExternalResourceManagerEx . getInstanceEx (  )  . isIgnoredResource (  _ systemId )  )  )     {", "throw   new   XmlResourceResolver . IgnoredResourceException (  )  ;", "}", "final   int   length    =    XmlUtil . getPrefixLength (  _ systemId )  ;", "final   String   systemId    =     _ systemId . substring ( length )  ;", "final   Computable < PsiFile >    action    =     (  )     -  >     {", "PsiFile   baseFile    =    null ;", "if    ( baseSystemId    !  =    null )     {", "baseFile    =    getBaseFile ( baseSystemId )  ;", "}", "if    ( baseFile    =  =    null )     {", "baseFile    =    myFile ;", "}", "String   version    =    null ;", "String   tagName    =    null ;", "if    ( baseFile    =  =     ( myFile )  )     {", "XmlTag   rootTag    =    myFile . getRootTag (  )  ;", "if    ( rootTag    !  =    null )     {", "tagName    =    rootTag . getLocalName (  )  ;", "version    =    rootTag . getAttributeValue (  \" version \"  )  ;", "}", "}", "String   resource    =     (  ( ExternalResourceManagerEx )     ( ExternalResourceManager . getInstance (  )  )  )  . getUserResource ( myProject ,    systemId ,    version )  ;", "if    ( resource    !  =    null )     {", "XmlFile   file    =    XmlUtil . findXmlFile ( myFile ,    resource )  ;", "if    ( file    !  =    null )", "return   file ;", "}", "PsiFile   byLocation    =    resolveByLocation ( myFile ,    systemId )  ;", "if    ( byLocation    !  =    null )", "return   byLocation ;", "PsiFile   psiFile    =    ExternalResourceManager . getInstance (  )  . getResourceLocation ( systemId ,    baseFile ,    version )  ;", "if    ( psiFile    =  =    null )     {", "psiFile    =    XmlUtil . findXmlFile ( baseFile ,    systemId )  ;", "}", "if    ( psiFile    =  =    null )     {", "psiFile    =    XmlNamespaceIndex . guessSchema ( systemId ,    tagName ,    version ,    null ,    myFile )  ;", "if    ( psiFile    =  =    null )     {", "psiFile    =    XmlNamespaceIndex . guessDtd ( systemId ,    myFile )  ;", "}", "}", "if    (  ( psiFile    =  =    null )     &  &     ( baseSystemId    !  =    null )  )     {", "String   fullUrl    =     ( baseSystemId . substring (  0  ,     (  ( baseSystemId . lastIndexOf (  '  /  '  )  )     +     1  )  )  )     +    systemId ;", "psiFile    =    XmlUtil . findXmlFile ( baseFile ,    fullUrl )  ;", "}", "if    ( XmlResourceResolver . LOG . isDebugEnabled (  )  )     {", "XmlResourceResolver . LOG . debug (  (  (  (  (  (  (  \" before   relative   file   checking :  \"     +    psiFile )     +     \"  ,  \"  )     +    systemId )     +     \"  ,  \"  )     +    baseSystemId )     +     \"  )  \"  )  )  ;", "}", "if    (  ( psiFile    =  =    null )     &  &     ( baseSystemId    =  =    null )  )     {", "File   workingFile    =    new   File (  \"  \"  )  ;", "String   workingDir    =     ( workingFile . getAbsoluteFile (  )  . getAbsolutePath (  )  . replace ( File . separatorChar ,     '  /  '  )  )     +     \"  /  \"  ;", "String   relativePath    =    StringUtil . replace ( systemId ,    workingDir ,     \"  \"  )  ;", "if    ( relativePath . equals ( systemId )  )     {", "relativePath    =    systemId . substring (  (  ( systemId . lastIndexOf (  '  /  '  )  )     +     1  )  )  ;", "}", "if    ( XmlResourceResolver . LOG . isDebugEnabled (  )  )     {", "XmlResourceResolver . LOG . debug (  (  (  (  (  \" next   to   relative   file   checking :  \"     +    relativePath )     +     \"  ,  \"  )     +     ( myExternalResourcesMap . size (  )  )  )     +     \"  )  \"  )  )  ;", "}", "for    ( String   path    :    getResourcePaths (  )  )     {", "if    ( XmlResourceResolver . LOG . isDebugEnabled (  )  )     {", "XmlResourceResolver . LOG . debug (  (  \" Finding   file   by   url :  \"     +    path )  )  ;", "}", "VirtualFile   file    =    VirtualFileManager . getInstance (  )  . findFileByUrl ( path )  ;", "if    ( file    =  =    null )", "continue ;", "if    ( XmlResourceResolver . LOG . isDebugEnabled (  )  )     {", "XmlResourceResolver . LOG . debug (  (  (  (  \" Finding    \"     +    relativePath )     +     \"    relative   to :  \"  )     +     ( file . getPath (  )  )  )  )  ;", "}", "final   VirtualFile   relativeFile    =    UriUtil . findRelativeFile ( relativePath ,    file )  ;", "if    ( XmlResourceResolver . LOG . isDebugEnabled (  )  )     {", "XmlResourceResolver . LOG . debug (  (  \" Found    \"     +     ( relativeFile    !  =    null    ?    relativeFile . getPath (  )     :     \" null \"  )  )  )  ;", "}", "if    ( relativeFile    !  =    null )     {", "psiFile    =    PsiManager . getInstance ( myProject )  . findFile ( relativeFile )  ;", "if    ( psiFile    !  =    null )", "break ;", "}", "}", "}", "if    ( XmlResourceResolver . LOG . isDebugEnabled (  )  )     {", "XmlResourceResolver . LOG . debug (  (  (  \" resolveEntity :    psiFile =  '  \"     +     ( psiFile    !  =    null    ?    psiFile . getVirtualFile (  )     :    null )  )     +     \"  '  \"  )  )  ;", "}", "return   psiFile ;", "}  ;", "final   PsiFile   psiFile    =    ApplicationManager . getApplication (  )  . runReadAction ( action )  ;", "if    ( psiFile    !  =    null )     {", "final   VirtualFile   file    =    psiFile . getVirtualFile (  )  ;", "if    ( file    !  =    null )     {", "final   String   url    =    file . getUrl (  )  ;", "if    ( XmlResourceResolver . LOG . isDebugEnabled (  )  )     {", "XmlResourceResolver . LOG . debug (  (  (  (  (  (  \" Adding   external   resource   ref :  \"     +    systemId )     +     \"  ,  \"  )     +    url )     +     \"  ,  \"  )     +     ( this )  )  )  ;", "}", "myExternalResourcesMap . put ( systemId ,    url )  ;", "}", "}", "return   psiFile ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "com.intellij.xml.util.XmlResourceResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( baseFile   instanceof   XmlFile )     {", "XmlTag   tag    =     (  ( XmlFile )     ( baseFile )  )  . getRootTag (  )  ;", "if    ( tag    !  =    null )     {", "XmlAttribute   attribute    =    tag . getAttribute (  \" schemaLocation \"  ,    XmlUtil . XML _ SCHEMA _ INSTANCE _ URI )  ;", "if    ( attribute    !  =    null )     {", "XmlAttributeValue   element    =    attribute . getValueElement (  )  ;", "if    ( element    !  =    null )     {", "PsiReference [  ]    references    =    element . getReferences (  )  ;", "for    ( PsiReference   reference    :    references )     {", "if    ( location . equals ( reference . getCanonicalText (  )  )  )     {", "PsiElement   r    =    reference . r (  )  ;", "return   r   instanceof   PsiFile    ?     (  ( PsiFile )     ( r )  )     :    null ;", "}", "}", "}", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["resolveByLocation"], "fileName": "com.intellij.xml.util.XmlResourceResolver"}, {"methodBody": ["METHOD_START", "{", "myStopOnUnDeclaredResource    =    stopOnUnDeclaredResource ;", "}", "METHOD_END"], "methodName": ["setStopOnUnDeclaredResource"], "fileName": "com.intellij.xml.util.XmlResourceResolver"}, {"methodBody": ["METHOD_START", "{", "return   XmlTagRuleProviderBase . getXmlElement ( XmlChildRole . ATTRIBUTE _ NAME _ FINDER ,    attribute )  ;", "}", "METHOD_END"], "methodName": ["getAttributeNameElement"], "fileName": "com.intellij.xml.util.XmlTagRuleProviderBase"}, {"methodBody": ["METHOD_START", "{", "return   XmlTagRuleProviderBase . getXmlElement ( XmlChildRole . START _ TAG _ NAME _ FINDER ,    tag )  ;", "}", "METHOD_END"], "methodName": ["getTagNameElement"], "fileName": "com.intellij.xml.util.XmlTagRuleProviderBase"}, {"methodBody": ["METHOD_START", "{", "ASTNode   tagNode    =    tag . getNode (  )  ;", "if    ( tagNode    =  =    null )", "return   null ;", "ASTNode   nameElement    =    roleFin . findChild ( tagNode )  ;", "if    ( nameElement    =  =    null )", "return   null ;", "return   nameElement . getPsi (  )  ;", "}", "METHOD_END"], "methodName": ["getXmlElement"], "fileName": "com.intellij.xml.util.XmlTagRuleProviderBase"}, {"methodBody": ["METHOD_START", "{", "return    (    tag )     -  >     ( tag . getAttribute ( attrName )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["ifAttrPresent"], "fileName": "com.intellij.xml.util.XmlTagRuleProviderBase"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlTagRuleProviderBase . InvalidAttrEffect ( attrName ,    text ,    ProblemHighlightType . GENERIC _ ERROR _ OR _ WARNING )  ;", "}", "METHOD_END"], "methodName": ["invalid"], "fileName": "com.intellij.xml.util.XmlTagRuleProviderBase"}, {"methodBody": ["METHOD_START", "{", "return    (  ( XmlTagRuleProviderBase . getXmlElement ( XmlChildRole . EMPTY _ TAG _ END _ FINDER ,    tag )  )     !  =    null )     |  |     (  ( XmlTagRuleProviderBase . getXmlElement ( XmlChildRole . CLOSING _ TAG _ START _ FINDER ,    tag )  )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["isClosedTag"], "fileName": "com.intellij.xml.util.XmlTagRuleProviderBase"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlTagRuleProviderBase . RequireAttributeOneOf ( attributeNames )  ;", "}", "METHOD_END"], "methodName": ["requireAttr"], "fileName": "com.intellij.xml.util.XmlTagRuleProviderBase"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlTagRuleProviderBase . ConditionRule ( condition ,    effect )  ;", "}", "METHOD_END"], "methodName": ["rule"], "fileName": "com.intellij.xml.util.XmlTagRuleProviderBase"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlTagRuleProviderBase . ShouldHaveParams (  )  ;", "}", "METHOD_END"], "methodName": ["shouldHaveParams"], "fileName": "com.intellij.xml.util.XmlTagRuleProviderBase"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlTagRuleProviderBase . InvalidAttrEffect ( attrName ,     (  (  \" Attribute    '  \"     +    attrName )     +     \"  '    is   unused \"  )  ,    ProblemHighlightType . LIKE _ UNUSED _ SYMBOL )  ;", "}", "METHOD_END"], "methodName": ["unused"], "fileName": "com.intellij.xml.util.XmlTagRuleProviderBase"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlTagRuleProviderBase . InvalidAttrEffect ( attrName ,    text ,    ProblemHighlightType . LIKE _ UNUSED _ SYMBOL )  ;", "}", "METHOD_END"], "methodName": ["unused"], "fileName": "com.intellij.xml.util.XmlTagRuleProviderBase"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlTagRuleProviderBase . InvalidAllExpectSome ( text ,    ProblemHighlightType . LIKE _ UNUSED _ SYMBOL ,    attrNames )  ;", "}", "METHOD_END"], "methodName": ["unusedAll"], "fileName": "com.intellij.xml.util.XmlTagRuleProviderBase"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlTagRuleProviderBase . ConditionRule ( XmlTagRuleProviderBase . ifAttrPresent ( attrPresent )  ,    new   XmlTagRuleProviderBase . InvalidAllExpectSome (  (  (  \" The   attribute   is   unused   because   the   attribute    \"     +    attrPresent )     +     \"    is   present \"  )  ,    ProblemHighlightType . LIKE _ UNUSED _ SYMBOL ,    ArrayUtil . append ( attrUnused ,    attrPresent )  )  )  ;", "}", "METHOD_END"], "methodName": ["unusedAllIfPresent"], "fileName": "com.intellij.xml.util.XmlTagRuleProviderBase"}, {"methodBody": ["METHOD_START", "{", "XmlTagRuleProviderBase . Effect [  ]    effects    =    new   XmlTagRuleProviderBase . Effect [ attrUnused . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( effects . length )  ;    i +  +  )     {", "effects [ i ]     =    XmlTagRuleProviderBase . unused ( attrUnused [ i ]  ,     (  (  (  (  \" The   attribute    '  \"     +     ( attrUnused [ i ]  )  )     +     \"  '    is   unused   because   the   attribute    '  \"  )     +    attrPresent )     +     \"  '    is   present \"  )  )  ;", "}", "return   new   XmlTagRuleProviderBase . ConditionRule ( XmlTagRuleProviderBase . ifAttrPresent ( attrPresent )  ,    effects )  ;", "}", "METHOD_END"], "methodName": ["unusedIfPresent"], "fileName": "com.intellij.xml.util.XmlTagRuleProviderBase"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "builder . append (  '  <  '  )  . append ( tagName )  ;", "if    ( StringUtil . isEmpty ( tagValue )  )     {", "builder . append (  \"  /  >  \"  )  ;", "} else    {", "builder . append (  '  >  '  )  . append (  . getCDATAQuote ( tagValue )  )  . append (  \"  <  /  \"  )  . append ( tagName )  . append (  '  >  '  )  ;", "}", "return   builder ;", "}", "METHOD_END"], "methodName": ["composeTagText"], "fileName": "com.intellij.xml.util.XmlTagUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( text    =  =    null )", "return   null ;", "String   offensiveChars    =     \"  <  >  &  \\ n \"  ;", "final      textLength    =    text . length (  )  ;", "if    (  ( textLength    >     0  )     &  &     (  ( Character . isWhitespace ( text . charAt (  0  )  )  )     |  |     ( Character . isWhitespace ( text . charAt (  ( textLength    -     1  )  )  )  )  )  )     {", "return    (  \"  <  !  [ CDATA [  \"     +    text )     +     \"  ]  ]  >  \"  ;", "}", "for    (    i    =     0  ;    i    <     ( offensiveChars . length (  )  )  ;    i +  +  )     {", "char   c    =    offensiveChars . charAt ( i )  ;", "if    (  ( text . indexOf ( c )  )     !  =     (  -  1  )  )     {", "return    (  \"  <  !  [ CDATA [  \"     +    text )     +     \"  ]  ]  >  \"  ;", "}", "}", "return   text ;", "}", "METHOD_END"], "methodName": ["getCDATAQuote"], "fileName": "com.intellij.xml.util.XmlTagUtil"}, {"methodBody": ["METHOD_START", "{", "return   XmlTagUtil . ourCharacterEntities . get ( entityName )  ;", "}", "METHOD_END"], "methodName": ["getCharacterByEntityName"], "fileName": "com.intellij.xml.util.XmlTagUtil"}, {"methodBody": ["METHOD_START", "{", "Set < String >    strings    =    XmlTagUtil . ourCharacterEntities . keySet (  )  ;", "return   ArrayUtil . toStringArray ( strings )  ;", "}", "METHOD_END"], "methodName": ["getCharacterEntityNames"], "fileName": "com.intellij.xml.util.XmlTagUtil"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   node    =    tag . getNode (  )  ;", "if    ( node    =  =    null )", "return   null ;", "ASTNode   current    =    node . getLastChildNode (  )  ;", "ASTNode   prev    =    current ;", "while    ( current    !  =    null )     {", "final   IElementType   elementType    =    prev . getElementType (  )  ;", "if    (  (  ( elementType    =  =     ( okenType . XML _ NAME )  )     |  |     ( elementType    =  =     ( okenType . XML _ TAG _ NAME )  )  )     &  &     (  ( current . getElementType (  )  )     =  =     ( okenType . XML _ END _ TAG _ START )  )  )     {", "return    (  ( oken )     ( prev . getPsi (  )  )  )  ;", "}", "prev    =    current ;", "current    =    current . getTreePrev (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getEndTagNameElement"], "fileName": "com.intellij.xml.util.XmlTagUtil"}, {"methodBody": ["METHOD_START", "{", "XmlToken   tagName    =    XmlTagUtil . getEndTagNameElement ( tag )  ;", "return   XmlTagUtil . getTagRange ( tagName ,    XmlTokenType . XML _ END _ TAG _ START )  ;", "}", "METHOD_END"], "methodName": ["getEndTagRange"], "fileName": "com.intellij.xml.util.XmlTagUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( text    =  =    null )", "return   null ;", "String   offensiveChars    =     \"  <  >  &  \"  ;", "for    (    i    =     0  ;    i    <     ( offensiveChars . length (  )  )  ;    i +  +  )     {", "char   c    =    offensiveChars . charAt ( i )  ;", "if    (  ( text . indexOf ( c )  )     !  =     (  -  1  )  )     {", "return    (  \"  <  !  [ CDATA [  \"     +    text )     +     \"  ]  ]  >  \"  ;", "}", "}", "return   text ;", "}", "METHOD_END"], "methodName": ["getInlineQuote"], "fileName": "com.intellij.xml.util.XmlTagUtil"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   node    =    tag . getNode (  )  ;", "if    ( node    =  =    null )", "return   null ;", "ASTNode   current    =    node . getFirstChildNode (  )  ;", "IElementType   elementType ;", "while    (  (  ( current    !  =    null )     &  &     (  ( elementType    =    current . getElementType (  )  )     !  =     ( okenType . XML _ NAME )  )  )     &  &     ( elementType    !  =     ( okenType . XML _ TAG _ NAME )  )  )     {", "current    =    current . getTreeNext (  )  ;", "}", "return   current    =  =    null    ?    null    :     (  ( oken )     ( current . getPsi (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getStartTagNameElement"], "fileName": "com.intellij.xml.util.XmlTagUtil"}, {"methodBody": ["METHOD_START", "{", "XmlToken   tagName    =    XmlTagUtil . getStartTagNameElement ( tag )  ;", "return   XmlTagUtil . getTagRange ( tagName ,    XmlTokenType . XML _ START _ TAG _ START )  ;", "}", "METHOD_END"], "methodName": ["getStartTagRange"], "fileName": "com.intellij.xml.util.XmlTagUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( tagName    =  =    null )     {", "return   null ;", "}", "PsiElement   s    =    tagName . getPrevSibling (  )  ;", "while    (  ( s    !  =    null )     &  &     (  ( s . getNode (  )  . getElementType (  )  )     !  =    tagStart )  )     {", "s    =    s . getPrevSibling (  )  ;", "}", "PsiElement   f    =    tagName . getNextSibling (  )  ;", "while    (  ( f    !  =    null )     &  &     (  !  (  (  ( f . getNode (  )  . getElementType (  )  )     =  =     ( XmlTokenType . XML _ TAG _ END )  )     |  |     (  ( f . getNode (  )  . getElementType (  )  )     =  =     ( XmlTokenType . XML _ EMPTY _ ELEMENT _ END )  )  )  )  )     {", "f    =    f . getNextSibling (  )  ;", "}", "if    (  ( s    !  =    null )     &  &     ( f    !  =    null )  )     {", "return   new   openapi . util . TextRange ( s . getTextRange (  )  . getStartOffset (  )  ,    f . getTextRange (  )  . getEndOffset (  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getTagRange"], "fileName": "com.intellij.xml.util.XmlTagUtil"}, {"methodBody": ["METHOD_START", "{", "XmlTagValue   tagValue    =    tag . getValue (  )  ;", "final   String   text    =    tagValue . getText (  )  ;", "final   String   trimmed    =    text . trim (  )  ;", "final   int   index    =    text . indexOf ( trimmed )  ;", "final   int   startOffset    =     (  ( tagValue . getTextRange (  )  . getStartOffset (  )  )     -     ( tag . getTextRange (  )  . getStartOffset (  )  )  )     +    index ;", "return   new   TextRange ( startOffset ,     ( startOffset    +     ( trimmed . length (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getTrimmedValueRange"], "fileName": "com.intellij.xml.util.XmlTagUtil"}, {"methodBody": ["METHOD_START", "{", "return   XmlUtil . addChildTag ( parent ,    child ,     (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["addChildTag"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( parent . getSubTags (  )  . length )     =  =     0  )     &  &     ( parent . getText (  )  . endsWith (  \"  /  >  \"  )  )  )     {", "final   ElementFactory   factory    =    ElementFactory . getInstance ( parent . getProject (  )  )  ;", "final   String   name    =    parent . getName (  )  ;", "final   String   text    =    parent . getText (  )  ;", "final   Tag   tag    =    factory . createTagFromText (  (  (  (  ( text . substring (  0  ,     (  ( text . length (  )  )     -     2  )  )  )     +     \"  >  <  /  \"  )     +    name )     +     \"  >  \"  )  )  ;", "parent    =     (  ( Tag )     ( parent . replace ( tag )  )  )  ;", "}", "final   ElementDescriptor   parentDescriptor    =    parent . getDescriptor (  )  ;", "final   Tag [  ]    subTags    =    parent . getSubTags (  )  ;", "if    (  ( parentDescriptor    =  =    null )     |  |     (  ( subTags . length )     =  =     0  )  )", "return    (  ( Tag )     ( parent . add ( child )  )  )  ;", "int   subTagNum    =     -  1  ;", "for    ( ElementDescriptor   childElementDescriptor    :    parentDescriptor . getElementsDescriptors ( parent )  )     {", "final   String   childElementName    =    childElementDescriptor . getName (  )  ;", "int   prevSubTagNum    =    subTagNum ;", "while    (  ( subTagNum    <     (  ( subTags . length )     -     1  )  )     &  &     ( subTags [  ( subTagNum    +     1  )  ]  . getName (  )  . equals ( childElementName )  )  )     {", "subTagNum +  +  ;", "}", "if    ( childElementName . equals ( child . getLocalName (  )  )  )     {", "subTagNum    =     (  ( index    =  =     (  -  1  )  )     |  |     ( index    >     ( subTagNum    -    prevSubTagNum )  )  )     ?    subTagNum    :    prevSubTagNum    +    index ;", "return    (  ( Tag )     ( subTagNum    =  =     (  -  1  )     ?    parent . addBefore ( child ,    subTags [  0  ]  )     :    parent . addAfter ( child ,    subTags [ subTagNum ]  )  )  )  ;", "}", "}", "return    (  ( Tag )     ( parent . add ( child )  )  )  ;", "}", "METHOD_END"], "methodName": ["addChildTag"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "return    (  \" jsfc \"  . equals ( name )  )     &  &     ( XmlUtil . isJsfHtmlScheme ( tag )  )  ;", "}", "METHOD_END"], "methodName": ["attributeFromTemplateFramework"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   XmlUtil . processEnumerationValues ( element ,     (    xmlTag )     -  >     {", "variants . add ( xmlTag . getAttributeValue ( XmlUtil . VALUE _ ATTR _ NAME )  )  ;", "return   true ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["collectEnumerationValues"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( tag    =  =    null )     {", "return ;", "}", "final   String   tagName    =    tag . getName (  )  ;", "List <  . MyAttributeInfo >    list    =    attributesMap . get ( tagName )  ;", "if    ( list    =  =    null )     {", "list    =    new   ArrayList <  >  (  )  ;", "final   XmlAttribute [  ]    attributes    =    tag . getAttributes (  )  ;", "for    ( final   XmlAttribute   attribute    :    attributes )     {", "list . add ( new    . MyAttributeInfo ( attribute . getName (  )  )  )  ;", "}", "} else    {", "final   XmlAttribute [  ]    attributes    =    tag . getAttributes (  )  . clone (  )  ;", "ContainerUtil . sort ( list )  ;", "Arrays . sort ( attributes ,    Comparator . comparing ( XmlAttribute :  : getName )  )  ;", "final   Iterator <  . MyAttributeInfo >    iter    =    list . iterator (  )  ;", "list    =    new   ArrayList <  >  (  )  ;", "int   index    =     0  ;", "while    ( iter . hasNext (  )  )     {", "final    . MyAttributeInfo   info    =    iter . next (  )  ;", "boolean   requiredFlag    =    false ;", "while    (  ( attributes . length )     >    index )     {", "if    (  ( info . compareTo ( attributes [ index ]  )  )     !  =     0  )     {", "if    (  ( info . compareTo ( attributes [ index ]  )  )     <     0  )     {", "break ;", "}", "if    (  ( attributes [ index ]  . getValue (  )  )     !  =    null )", "list . add ( new    . MyAttributeInfo ( attributes [ index ]  . getName (  )  ,    false )  )  ;", "index +  +  ;", "} else    {", "requiredFlag    =    true ;", "index +  +  ;", "break ;", "}", "}", "info . myRequired    &  =    requiredFlag ;", "list . add ( info )  ;", "}", "while    (  ( attributes . length )     >    index )     {", "if    (  ( attributes [ index ]  . getValue (  )  )     !  =    null )     {", "list . add ( new    . MyAttributeInfo ( attributes [  ( index +  +  )  ]  . getName (  )  ,    false )  )  ;", "} else    {", "index +  +  ;", "}", "}", "}", "attributesMap . put ( tagName ,    list )  ;", "final   List < String >    tags    =     (  ( tagsMap . get ( tagName )  )     !  =    null )     ?    tagsMap . get ( tagName )     :    new   ArrayList <  >  (  )  ;", "tagsMap . put ( tagName ,    tags )  ;", "PsiFile   file    =     ( tag . isValid (  )  )     ?    tag . getContainingFile (  )     :    null ;", ". processXmlElements ( tag ,    new   FilterElementProcessor ( XmlTagFilter . INSTANCE )     {", "@ Override", "public   void   add ( PsiElement   element )     {", "XmlTag   tag    =     (  ( XmlTag )     ( element )  )  ;", "if    (  !  ( tags . contains ( tag . getName (  )  )  )  )     {", "tags . add ( tag . getName (  )  )  ;", "}", ". computeTag ( tag ,    tagsMap ,    attributesMap ,    processIncludes )  ;", "}", "}  ,    false ,    false ,    file ,    processIncludes )  ;", "}", "METHOD_END"], "methodName": ["computeTag"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "String   qname ;", "final   String   prefix    =    xmlTag . getPrefixByNamespace ( namespace )  ;", "if    (  ( prefix    !  =    null )     &  &     (  !  ( prefix . isEmpty (  )  )  )  )     {", "qname    =     ( prefix    +     \"  :  \"  )     +    localName ;", "} else    {", "qname    =    localName ;", "}", "try    {", "String   tagStart    =    qname    +     (  (  (  !  ( StringUtil . isEmpty ( namespace )  )  )     &  &     (  ( xmlTag . getPrefixByNamespace ( namespace )  )     =  =    null )  )     &  &     (  !  (  ( StringUtil . isEmpty ( xmlTag . getNamespacePrefix (  )  )  )     &  &     ( namespace . equals ( xmlTag . getNamespace (  )  )  )  )  )     ?     (  \"    xmlns =  \\  \"  \"     +    namespace )     +     \"  \\  \"  \"     :     \"  \"  )  ;", "Language   language    =    xmlTag . getLanguage (  )  ;", "if    (  !  ( language   instanceof   HTMLLanguage )  )", "language    =    lang . xml . XMLLanguage . INSTANCE ;", "XmlTag   retTag ;", "if    ( bodyText    !  =    null )     {", "retTag    =    XmlElementFactory . getInstance ( xmlTag . getProject (  )  )  . createTagFromText (  (  (  (  (  (  (  \"  <  \"     +    tagStart )     +     \"  >  \"  )     +    bodyText )     +     \"  <  /  \"  )     +    qname )     +     \"  >  \"  )  ,    language )  ;", "if    ( enforceNamespacesDeep )     {", "retTag . acceptChildren ( new   XmlRecursiveElementVisitor (  )     {", "@ Override", "public   void   visitXmlTag ( XmlTag   tag )     {", "final   String   namespacePrefix    =    tag . getNamespacePrefix (  )  ;", "if    ( namespacePrefix . isEmpty (  )  )     {", "String   qname ;", "if    (  ( prefix    !  =    null )     &  &     (  !  ( prefix . isEmpty (  )  )  )  )     {", "qname    =     ( prefix    +     \"  :  \"  )     +     ( tag . getLocalName (  )  )  ;", "} else    {", "qname    =    tag . getLocalName (  )  ;", "}", "try    {", "tag . setName ( qname )  ;", "}    catch    ( IncorrectOperationException   e )     {", "XmlUtil . LOG . error ( e )  ;", "}", "}", "super . visitXmlTag ( tag )  ;", "}", "}  )  ;", "}", "} else    {", "retTag    =    XmlElementFactory . getInstance ( xmlTag . getProject (  )  )  . createTagFromText (  (  (  \"  <  \"     +    tagStart )     +     \"  /  >  \"  )  ,    language )  ;", "}", "return   retTag ;", "}    catch    ( IncorrectOperationException   e )     {", "XmlUtil . LOG . error ( e )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["createChildTag"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( text . isEmpty (  )  )", "return   text ;", "if    (  (  ( text . charAt (  0  )  )     !  =     '  &  '  )     |  |     (  ( text . length (  )  )     <     3  )  )     {", "if    (  (  ( textdexOf (  '  <  '  )  )     <     0  )     &  &     (  ( textdexOf (  '  >  '  )  )     <     0  )  )", "return   text ;", "return   text . replaceAll (  \"  <  !  \\  \\  [ CDATA \\  \\  [  \"  ,     \"  \"  )  . replaceAll (  \"  \\  \\  ]  \\  \\  ]  >  \"  ,     \"  \"  )  ;", "}", "if    ( text . equals (  \"  & lt ;  \"  )  )     {", "return    \"  <  \"  ;", "}", "if    ( text . equals (  \"  & gt ;  \"  )  )     {", "return    \"  >  \"  ;", "}", "if    ( text . equals (  \"  & nbsp ;  \"  )  )     {", "return    \"  \\ u 0  0 a 0  \"  ;", "}", "if    ( text . equals (  \"  & amp ;  \"  )  )     {", "return    \"  &  \"  ;", "}", "if    ( text . equals (  \"  & apos ;  \"  )  )     {", "return    \"  '  \"  ;", "}", "if    ( text . equals (  \"  & quot ;  \"  )  )     {", "return    \"  \\  \"  \"  ;", "}", "if    (  ( text . startsWith (  \"  & quot ;  \"  )  )     &  &     ( text . endsWith (  \"  & quot ;  \"  )  )  )     {", "return    (  \"  \\  \"  \"     +     ( text . substg (  6  ,     (  ( text . length (  )  )     -     6  )  )  )  )     +     \"  \\  \"  \"  ;", "}", "if    ( text . startsWith (  \"  &  #  \"  )  )     {", "text    =    text . substg (  3  ,     (  ( text . length (  )  )     -     1  )  )  ;", "try    {", "return   Stg . valueOf (  (  ( char )     ( Integer . parseInt ( text )  )  )  )  ;", "}    catch    ( NumberFormatException   e )     {", "}", "}", "return   text ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "for    ( T   t    :    elements )     {", "final   String   name    =    provider . getName ( t )  ;", "if    ( name    =  =    null )", "continue ;", "final   String   nameKey    =    provider . getNameKey ( t ,    name )  ;", "if    ( presentNames . containsKey ( nameKey )  )     {", "final   T   psiElement    =    presentNames . get ( nameKey )  ;", "final   String   message    =    ErrorMessages . message (  \" duplicate . declaration \"  ,    nameKey )  ;", "if    ( psiElement    !  =    null )     {", "presentNames . put ( nameKey ,    null )  ;", "host . addMessage ( provider . getNodeForMessage ( psiElement )  ,    message ,    ERROR )  ;", "}", "host . addMessage ( provider . getNodeForMessage ( t )  ,    message ,    ERROR )  ;", "} else    {", "presentNames . put ( nameKey ,    t )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doDuplicationCheckForElements"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   StringUtil . escapeXml ( text )  ;", "}", "METHOD_END"], "methodName": ["escape"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "XmlTag   newTag    =    XmlElementFactory . getInstance ( tag . getProject (  )  )  . createTagFromText (  (  (  (  (  '  <  '     +     ( tag . getName (  )  )  )     +     \"  >  <  /  \"  )     +     ( tag . getName (  )  )  )     +     '  >  '  )  )  ;", "ASTNode   node    =    tag . getNode (  )  ;", "if    (  !  ( node   instanceof   CompositeElement )  )", "return ;", "CompositeElement   compositeElement    =     (  ( CompositeElement )     ( node )  )  ;", "final   LeafElement   emptyTagEnd    =     (  ( LeafElement )     ( XmlChildRole . EMPTY _ TAG _ END _ FINDER . findChild ( compositeElement )  )  )  ;", "if    ( emptyTagEnd    =  =    null )", "return ;", "compositeElement . removeChild ( emptyTagEnd )  ;", "PsiElement [  ]    children    =    newTag . getChildren (  )  ;", "compositeElement . addChildren ( children [  2  ]  . getNode (  )  ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["expandTag"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   XmlCharsetDetector . extractXmlEncodingFromProlog ( content )  ;", "}", "METHOD_END"], "methodName": ["extractXmlEncodingFromProlog"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   XmlCharsetDetector . extractXmlEncodingFromProlog ( text )  ;", "}", "METHOD_END"], "methodName": ["extractXmlEncodingFromProlog"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag [  ]    forTags    =    insideRoot . findSubTags ( forTag )  ;", "for    ( XmlTag   tag    :    forTags )     {", "final   XmlTag [  ]    allTags    =    tag . findSubTags ( subTag )  ;", "for    ( XmlTag   curTag    :    allTags )     {", "if    (  ( curTag . getName (  )  . equals ( subTag )  )     &  &     ( curTag . getValue (  )  . getTrimmedText (  )  . equalsIgnoreCase ( withValue )  )  )     {", "return   tag ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["find"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "final   XmlElementDescriptor   descriptor    =    tag . getDescriptor (  )  ;", "final   XmlNSDescriptor   nsDescriptor    =     ( descriptor    !  =    null )     ?    descriptor . getNSDescriptor (  )     :    null ;", "XmlFile   descriptorFile    =     ( nsDescriptor    !  =    null )     ?    nsDescriptor . getDescriptorFile (  )     :     ( containingFile . getDocument (  )  . getProlog (  )  . getDoctype (  )  )     !  =    null    ?    containingFile    :    null ;", "if    (  ( nsDescriptor    !  =    null )     &  &     (  ( descriptorFile    =  =    null )     |  |     ( descriptorFile . getName (  )  . equals (  (  ( containingFile . getName (  )  )     +     \"  . dtd \"  )  )  )  )  )     {", "descriptorFile    =    containingFile ;", "}", "return   descriptorFile ;", "}", "METHOD_END"], "methodName": ["findDescriptorFile"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   name    =  =    null    ?    null    :    name . substring (  (  ( name . indexOf (  '  :  '  )  )     +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["findLocalNameByQualifiedName"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "final   List < IndexedRelevantResource < String ,    XsdNamespaceBuilder >  >    resources    =    XmlNamespaceIndex . getResourcesByNamespace ( namespace ,    project ,    module )  ;", "final   PsiManager   psiManager    =    PsiManager . getInstance ( project )  ;", "return   ContainerUmapNotNull ( resources ,     (  ( NullableFunction < IndexedRelevantResource < String ,    XsdNamespaceBuilder >  ,    XmlFile >  )     (  (    resource )     -  >     {", "PsiFile   file    =    psiManager . findFile ( resource . getFile (  )  )  ;", "return   file   instanceof   XmlFile    ?     (  ( XmlFile )     ( file )  )     :    null ;", "}  )  )  )  ;", "}", "METHOD_END"], "methodName": ["findNSFilesByURI"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "final   String   location    =    ExternalResourceManager . getInstance (  )  . getResourceLocation ( nsLocation ,    base . getProject (  )  )  ;", "if    (  !  ( location . equals ( nsLocation )  )  )     {", "return    . findXmlFile ( base ,    location )  ;", "}", "final   XmlFile   xmlFile    =    XmlSchemaProvider . findSchema ( location ,    base )  ;", "return   xmlFile    =  =    null    ?     . findXmlFile ( base ,    location )     :    xmlFile ;", "}", "METHOD_END"], "methodName": ["findNamespace"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "final   String   location    =    ExternalResourceManager . getInstance (  )  . getResourceLocation ( nsLocation ,    base . getProject (  )  )  ;", "return    . findXmlFile ( base ,    location )  ;", "}", "METHOD_END"], "methodName": ["findNamespaceByLocation"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   contextTag . getNamespaceByPrefix ( prefix )  ;", "}", "METHOD_END"], "methodName": ["findNamespaceByPrefix"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "while    (  (  !  ( xmlElement   instanceof   XmlTag )  )     &  &     ( xmlElement    !  =    null )  )     {", "final   PsiElement   parent    =    xmlElement . getParent (  )  ;", "if    (  !  ( parent   instanceof   XmlElement )  )", "return   null ;", "xmlElement    =     (  ( XmlElement )     ( parent )  )  ;", "}", "if    ( xmlElement    !  =    null )     {", "XmlTag   tag    =     (  ( XmlTag )     ( xmlElement )  )  ;", "while    ( tag    !  =    null )     {", "for    ( XmlAttribute   attribute    :    tag . getAttributes (  )  )     {", "if    (  ( attribute . isNamespaceDeclaration (  )  )     &  &     ( attribute . getLocalName (  )  . equals ( nsName )  )  )     {", "return   attribute ;", "}", "}", "tag    =    tag . getParentTag (  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findNamespaceDeclaration"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    file . getRootTag (  )  ;", "if    ( tag    =  =    null )", "return   null ;", "for    ( XmlAttribute   attribute    :    tag . getAttributes (  )  )     {", "if    (  ( attribute . getName (  )  . startsWith (  \" xmlns :  \"  )  )     &  &     ( uri . equals ( attribute . getValue (  )  )  )  )     {", "return   attribute . getName (  )  . substring (  \" xmlns :  \"  . length (  )  )  ;", "}", "if    (  (  \" xmlns \"  . equals ( attribute . getName (  )  )  )     &  &     ( uri . equals ( attribute . getValue (  )  )  )  )", "return    \"  \"  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findNamespacePrefixByURI"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( file    =  =    null )", "return   ArrayUEMPTY _ STRING _ ARRAY ;", "final   XmlDocument   document    =    file . getDocument (  )  ;", "if    ( document    =  =    null )", "return   ArrayUEMPTY _ STRING _ ARRAY ;", "final   XmlTag   tag    =    document . getRootTag (  )  ;", "if    ( tag    =  =    null )", "return   ArrayUEMPTY _ STRING _ ARRAY ;", "XmlAttribute [  ]    attributes    =    tag . getAttributes (  )  ;", "List < String >    result    =    new   ArrayList <  >  (  )  ;", "for    ( XmlAttribute   attribute    :    attributes )     {", "if    (  ( attribute . getName (  )  . startsWith (  \" xmlns :  \"  )  )     &  &     ( attribute . getValue (  )  . equals ( uri )  )  )     {", "result . add ( attribute . getName (  )  . substring (  \" xmlns :  \"  . length (  )  )  )  ;", "}", "if    (  (  \" xmlns \"  . equals ( attribute . getName (  )  )  )     &  &     ( attribute . getValue (  )  . equals ( uri )  )  )", "result . add (  \"  \"  )  ;", "}", "return   ArrayUtoStringArray ( result )  ;", "}", "METHOD_END"], "methodName": ["findNamespacesByURI"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "final   int   prefixEnd    =    name . indexOf (  '  :  '  )  ;", "if    ( prefixEnd    >     0  )     {", "return   name . substring (  0  ,    prefixEnd )  ;", "}", "return    \"  \"  ;", "}", "METHOD_END"], "methodName": ["findPrefixByQualifiedName"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "PsiElement   currentElement    =     _ element ;", "final   XmlEntityRef   lastEntityRef    =    PsiTreeUtil . getParentOfType ( currentElement ,    XmlEntityRef . class )  ;", "while    (  !  ( currentElement   instanceof   XmlFile )  )     {", "PsiElement   dependingElement    =    currentElement . getUserData ( XmlElement . DEPENDING _ ELEMENT )  ;", "if    ( dependingElement    =  =    null )", "dependingElement    =    currentElement . getContext (  )  ;", "currentElement    =    dependingElement ;", "if    ( dependingElement    =  =    null )", "break ;", "}", "if    ( currentElement    !  =    null )     {", "final   String   name    =     _ element . getName (  )  ;", "if    (  _ element   instanceof   XmlEntityDecl )     {", "final   XmlEntityDecl   cachedEntity    =    XmlEntityCache . getCachedEntity (  (  ( PsiFile )     ( currentElement )  )  ,    name )  ;", "if    ( cachedEntity    !  =    null )", "return   cachedEntity ;", "}", "final   PsiNamedElement [  ]    result    =    new   PsiNamedElement [  1  ]  ;", ". processXmlElements (  (  ( XmlFile )     ( currentElement )  )  ,    new   PsiElementProcessor (  )     {", "@ Override", "public   boolean   execute (  @ NotNull", "final   PsiElement   element )     {", "if    ( element   instanceof   PsiNamedElement )     {", "final   String   elementName    =     (  ( PsiNamedElement )     ( element )  )  . getName (  )  ;", "if    (  (  ( elementName . equals ( name )  )     &  &     (  _ element . getClass (  )  . isInstance ( element )  )  )     |  |     (  (  ( lastEntityRef    !  =    null )     &  &     ( element   instanceof   XmlEntityDecl )  )     &  &     ( elementName . equals ( lastEntityRef . getText (  )  . substring (  1  ,     (  ( lastEntityRef . getTextLength (  )  )     -     1  )  )  )  )  )  )     {", "result [  0  ]     =     (  ( PsiNamedElement )     ( element )  )  ;", "return   false ;", "}", "}", "return   true ;", "}", "}  ,    true )  ;", "return   result [  0  ]  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findRealNamedElement"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( base   instanceof   PsiFile )     {", "PsiFile   baseFile    =     (  ( PsiFile )     ( base )  )  ;", "VirtualFile   file    =    UriUfindRelative ( uri ,    baseFile . getOriginalFile (  )  )  ;", "if    ( file    =  =    null )", "return   null ;", "return   base . getManager (  )  . findFile ( file )  ;", "} else", "if    ( base   instanceof   PsiDirectory )     {", "PsiDirectory   baseDir    =     (  ( PsiDirectory )     ( base )  )  ;", "VirtualFile   file    =    UriUfindRelative ( uri ,    baseDir )  ;", "if    ( file    =  =    null )", "return   null ;", "return   base . getManager (  )  . findFile ( file )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findRelativeFile"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "PsiElement   elementAtStart    =    file . findElementAt ( startOffset )  ;", "PsiElement   elementAtEnd    =    file . findElementAt (  ( endOffset    -     1  )  )  ;", "if    ( elementAtStart   instanceof   PsiWhiteSpace )     {", "startOffset    =    elementAtStart . getTextRange (  )  . getEndOffset (  )  ;", "elementAtStart    =    file . findElementAt ( startOffset )  ;", "}", "if    ( elementAtEnd   instanceof   PsiWhiteSpace )     {", "endOffset    =    elementAtEnd . getTextRange (  )  . getStartOffset (  )  ;", "elementAtEnd    =    file . findElementAt (  ( endOffset    -     1  )  )  ;", "}", "if    (  ( elementAtStart    =  =    null )     |  |     ( elementAtEnd    =  =    null )  )", "return   null ;", "XmlTagChild   first    =    PsiTreeUgetParentOfType ( elementAtStart ,    XmlTagChild . class )  ;", "if    ( first    =  =    null )", "return   null ;", "if    (  ( first . getTextRange (  )  . getStartOffset (  )  )     !  =    startOffset )     {", "PsiElement   elementAt    =    file . findElementAt ( first . getTextRange (  )  . getStartOffset (  )  )  ;", "if    (  (  !  ( elementAt   instanceof   PsiWhiteSpace )  )     |  |     (  ( elementAt . getTextRange (  )  . getEndOffset (  )  )     !  =    startOffset )  )", "return   null ;", "}", "XmlTagChild   last    =    first ;", "while    (  ( last    !  =    null )     &  &     (  ( last . getTextRange (  )  . getEndOffset (  )  )     <    endOffset )  )     {", "last    =    PsiTreeUgetNextSiblingOfType ( last ,    XmlTagChild . class )  ;", "}", "if    ( last    =  =    null )", "return   null ;", "if    (  ( last . getTextRange (  )  . getEndOffset (  )  )     !  =     ( elementAtEnd . getTextRange (  )  . getEndOffset (  )  )  )     {", "PsiElement   elementAt    =    file . findElementAt (  (  ( last . getTextRange (  )  . getEndOffset (  )  )     -     1  )  )  ;", "if    (  (  !  ( elementAt   instanceof   PsiWhiteSpace )  )     |  |     (  ( elementAt . getTextRange (  )  . getStartOffset (  )  )     !  =    endOffset )  )     {", "return   null ;", "}", "}", "return   Pair . create ( first ,    last )  ;", "}", "METHOD_END"], "methodName": ["findTagChildrenInRange"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   XmlUtil . findXmlDescriptorByType ( xmlTag ,    null )  ;", "}", "METHOD_END"], "methodName": ["findXmlDescriptorByType"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "String   type    =    xmlTag . getAttributeValue (  \" type \"  ,    XmlUtil . XML _ SCHEMA _ INSTANCE _ URI )  ;", "if    ( type    =  =    null )     {", "String   ns    =    xmlTag . getNamespace (  )  ;", "if    (  ( XmlUtil . ourSchemaUrisList . indexOf ( ns )  )     >  =     0  )     {", "type    =    xmlTag . getAttributeValue (  \" type \"  ,    null )  ;", "}", "}", "XmlElementDescriptor   elementDescriptor    =    null ;", "if    ( type    !  =    null )     {", "final   String   namespaceByPrefix    =    XmlUtil . findNamespaceByPrefix ( XmlUtil . findPrefixByQualifiedName ( type )  ,    xmlTag )  ;", "XmlNSDescriptor   typeDecr    =    xmlTag . getNSDescriptor ( namespaceByPrefix ,    true )  ;", "if    (  ( typeDecr    =  =    null )     &  &     ( namespaceByPrefix . isEmpty (  )  )  )     {", "if    ( context    !  =    null )", "typeDecr    =    context . getNSDescriptor (  \"  \"  ,    true )  ;", "if    ( typeDecr    =  =    null )     {", "final   PsiFile   containingFile    =    xmlTag . getContainingFile (  )  ;", "if    ( containingFile   instanceof   XmlFile )     {", "final   XmlDocument   document    =     (  ( XmlFile )     ( containingFile )  )  . getDocument (  )  ;", "if    ( document    !  =    null )", "typeDecr    =     (  ( XmlNSDescriptor )     ( document . getMetaData (  )  )  )  ;", "}", "}", "}", "if    ( typeDecr   instanceof   XmlNSDescriptorImpl )     {", "final   XmlNSDescriptorImpl   schemaDescriptor    =     (  ( XmlNSDescriptorImpl )     ( typeDecr )  )  ;", "elementDescriptor    =    schemaDescriptor . getDescriptorByType ( type ,    xmlTag )  ;", "}", "}", "return   elementDescriptor ;", "}", "METHOD_END"], "methodName": ["findXmlDescriptorByType"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "PsiFile   result    =    null ;", "if    ( ApplicationManager . getApplication (  )  . isUnitTestMode (  )  )     {", "String   data    =    base . getOriginalFile (  )  . getUserData (  . TEST _ PATH )  ;", "if    ( data    !  =    null )     {", "String   filePath    =     ( data    +     \"  /  \"  )     +    uri ;", "final   VirtualFile   path    =    StandardFileSystems . local (  )  . findFileByPath ( filePath . replace ( File . separatorChar ,     '  /  '  )  )  ;", "if    ( path    !  =    null )     {", "result    =    base . getManager (  )  . findFile ( path )  ;", "}", "}", "}", "if    ( result    =  =    null )     {", "result    =     . findRelativeFile ( uri ,    base )  ;", "}", "if    ( result   instanceof   XmlFile )     {", "return    (  ( XmlFile )     ( result )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findXmlFile"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( info . myName . contains ( DUMMY _ IDENTIFIER _ TRIMMED )  )", "return    \"  \"  ;", "return    (  (  ( info . myName )     +     \"     \"  )     +     \" CDATA \"  )     +     ( info . myRequired    ?     \"     # REQUIRED \"     :     \"     # IMPLIED \"  )  ;", "}", "METHOD_END"], "methodName": ["generateAttributeDTD"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    List < String >  >    tags    =    new   LinkedHashMap <  >  (  )  ;", "final   Map < String ,    List <  . MyAttributeInfo >  >    attributes    =    new   LinkedHashMap <  >  (  )  ;", "try    {", "XmlEntityRefImpl . setNoEntityExpandOutOfDocument ( doc ,    true )  ;", "final   XmlTag   rootTag    =    doc . getRootTag (  )  ;", ". computeTag ( rootTag ,    tags ,    attributes ,    full )  ;", "for    ( PsiElement   element    =     ( rootTag    !  =    null )     ?    rootTag . getNextSibling (  )     :    null ;    element    !  =    null ;    element    =    element . getNextSibling (  )  )     {", "if    ( element   instanceof   XmlTag )     {", ". computeTag (  (  ( XmlTag )     ( element )  )  ,    tags ,    attributes ,    full )  ;", "}", "}", "}    finally    {", "XmlEntityRefImpl . setNoEntityExpandOutOfDocument ( doc ,    false )  ;", "}", "final   StringBuilder   buffer    =    new   StringBuilder (  )  ;", "for    ( final   String   tagName    :    tags . keySet (  )  )     {", "buffer . append (  . generateElementDTD ( tagName ,    tags . get ( tagName )  ,    attributes . get ( tagName )  )  )  ;", "}", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["generateDocumentDTD"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  ( name    =  =    null )     |  |     (  \"  \"  . equals ( name )  )  )", "return    \"  \"  ;", "if    ( name . contains ( DUMMY _ IDENTIFIER _ TRIMMED )  )", "return    \"  \"  ;", "@ NonNls", "final   StringBuilder   buffer    =    new   StringBuilder (  )  ;", "buffer . append (  \"  <  ! ELEMENT    \"  )  . append ( name )  . append (  \"     \"  )  ;", "if    ( tags . isEmpty (  )  )     {", "buffer . append (  \"  (  # PCDATA )  >  \\ n \"  )  ;", "} else    {", "buffer . append (  \"  (  \"  )  ;", "final   Iterator < String >    iter    =    tags . iterator (  )  ;", "while    ( iter . hasNext (  )  )     {", "final   String   tagName    =    iter . next (  )  ;", "buffer . append ( tagName )  ;", "if    ( iter . hasNext (  )  )     {", "buffer . append (  \"  |  \"  )  ;", "} else    {", "buffer . append (  \"  )  *  \"  )  ;", "}", "}", "buffer . append (  \"  >  \\ n \"  )  ;", "}", "if    (  !  ( attributes . isEmpty (  )  )  )     {", "buffer . append (  \"  <  ! ATTLIST    \"  )  . append ( name )  ;", "for    ( final    . MyAttributeInfo   info    :    attributes )     {", "buffer . append (  \"  \\ n             \"  )  . append (  . generateAttributeDTD ( info )  )  ;", "}", "buffer . append (  \"  >  \\ n \"  )  ;", "}", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["generateElementDTD"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "for    ( XmlAttribute   attribute    :    tag . getAttributes (  )  )     {", "if    ( name . equals ( attribute . getName (  )  )  )", "return   attribute . getValue (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAttributeValue"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    (  ( text . charAt (  1  )  )     !  =     '  #  '  )     {", "text    =    text . substring (  1  ,     (  ( text . length (  )  )     -     1  )  )  ;", "return   XmlTagUtil . getCharacterByEntityName ( text )  ;", "}", "text    =    text . substring (  2  ,     (  ( text . length (  )  )     -     1  )  )  ;", "}    catch    ( StringIndexOutOfBoundsException   e )     {", ". LOG . error (  (  (  \" Cannot   parse   ref :     '  \"     +    text )     +     \"  '  \"  )  ,    e )  ;", "}", "try    {", "int   code ;", "if    ( StringUtil . startsWithChar ( text ,     ' x '  )  )     {", "text    =    text . substring (  1  )  ;", "code    =    Integer . parseInt ( text ,     1  6  )  ;", "} else    {", "code    =    Integer . parseInt ( text )  ;", "}", "return    (  ( char )     ( code )  )  ;", "}    catch    ( NumberFormatException   e )     {", "return    0  ;", "}    catch    ( NullPointerException   e )     {", ". LOG . error (  (  (  \" Cannot   parse   ref :     '  \"     +    text )     +     \"  '  \"  )  ,    e )  ;", "return    0  ;", "}", "}", "METHOD_END"], "methodName": ["getCharFromEntityRef"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   firstChild    =    comment . getFirstChild (  )  ;", "if    ( firstChild    !  =    null )     {", "final   PsiElement   nextSibling    =    firstChild . getNextSibling (  )  ;", "if    ( nextSibling   instanceof   XmlToken )     {", "final   XmlToken   token    =     (  ( XmlToken )     ( nextSibling )  )  ;", "if    (  ( token . getTokenType (  )  )     =  =     ( XmlTokenType . XML _ COMMENT _ CHARACTERS )  )     {", "return   token . getText (  )  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getCommentText"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "while    (  (  !  ( element   instanceof   XmlFile )  )     &  &     ( element    !  =    null )  )     {", "final   PsiElement   context    =    element . getContext (  )  ;", "if    ( context    =  =    null )     {", "final   XmlExtension   extension    =    XmlExtension . getExtensionByElement ( element )  ;", "if    ( extension    !  =    null )     {", "element    =    extension . getContainingFile ( element )  ;", "}", "} else    {", "if    ( element    =  =    context )     {", ". LOG . error (  (  \" Context =  = element :     \"     +     ( element . getClass (  )  )  )  )  ;", "return   null ;", "}", "element    =    context ;", "}", "}", "return    (  ( XmlFile )     ( element )  )  ;", "}", "METHOD_END"], "methodName": ["getContainingFile"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   file    =    XmlUtil . getContainingFile ( document )  ;", "final   XmlTag   tag    =    document . getRootTag (  )  ;", "if    ( tag    =  =    null )", "return   null ;", "@ NotNull", "final   XmlFileNSInfoProvider [  ]    nsProviders    =    Extensions . getExtensions ( XmlFileNSInfoProvider . EP _ NAME )  ;", "if    ( file    !  =    null )     {", "NextProvider    :    for    ( XmlFileNSInfoProvider   nsProvider    :    nsProviders )     {", "final   String [  ]  [  ]    pairs    =    nsProvider . getDefaultNamespaces ( file )  ;", "if    (  ( pairs    !  =    null )     &  &     (  ( pairs . length )     >     0  )  )     {", "for    ( final   String [  ]    nsMapping    :    pairs )     {", "if    (  (  (  ( nsMapping    =  =    null )     |  |     (  ( nsMapping . length )     !  =     2  )  )     |  |     (  ( nsMapping [  0  ]  )     =  =    null )  )     |  |     (  ( nsMapping [  1  ]  )     =  =    null )  )     {", "XmlUtil . LOG . debug (  (  (  (  \" NSInfoProvider    \"     +    nsProvider )     +     \"    gave   wrong   info   about    \"  )     +     ( file . getVirtualFile (  )  )  )  )  ;", "continue   NextProvider ;", "}", "}", "return   pairs ;", "}", "}", "}", "String   namespace    =    XmlUtil . getDtdUri ( document )  ;", "if    ( namespace    !  =    null )     {", "boolean   overrideNamespaceFromDocType    =    false ;", "if    ( file    !  =    null )     {", "for    ( XmlFileNSInfoProvider   provider    :    nsProviders )     {", "try    {", "if    ( provider . overrideNamespaceFromDocType ( file )  )     {", "overrideNamespaceFromDocType    =    true ;", "break ;", "}", "}    catch    ( AbstractMethodError   ignored )     {", "}", "}", "}", "if    (  ! overrideNamespaceFromDocType )", "return   new   String [  ]  [  ]  {    new   String [  ]  {     \"  \"  ,    namespace    }     }  ;", "}", "if    (  \" taglib \"  . equals ( tag . getName (  )  )  )     {", "return   new   String [  ]  [  ]  {    new   String [  ]  {     \"  \"  ,    XmlUtil . TAGLIB _  1  _  2  _ URI    }     }  ;", "}", "if    ( file    !  =    null )     {", "final   Language   language    =    file . getLanguage (  )  ;", "if    (  ( language . isKindOf ( HTMLLanguage . INSTANCE )  )     |  |     ( language    =  =     ( XHTMLLanguage . INSTANCE )  )  )     {", "return   new   String [  ]  [  ]  {    new   String [  ]  {     \"  \"  ,    XmlUtil . XHTML _ URI    }     }  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDefaultNamespaces"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "final   String   doctype    =    ExternalResourceManagerEx . getInstanceEx (  )  . getDefaultHtmlDoctype ( project )  ;", "return   Html 5 SchemaProvider . getHtml 5 SchemaLocation (  )  . equals ( doctype )     ?    Html 5 SchemaProvider . getXhtml 5 SchemaLocation (  )     :    doctype ;", "}", "METHOD_END"], "methodName": ["getDefaultXhtmlNamespace"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "PsiElement   parent    =    tag . getParent (  )  ;", "if    ( parent   instanceof   Tag )     {", "Tag   parentTag    =     (  ( Tag )     ( parent )  )  ;", "final   ElementDescriptor   parentDescriptor    =    parentTag . getDescriptor (  )  ;", "if    ( parentDescriptor    !  =    null )     {", "return   Extension . getExtension ( tag . getContainingFile (  )  )  . getElementDescriptor ( tag ,    parentTag ,    parentDescriptor )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDescriptorFromContext"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( doctype    !  =    null )     {", "String   docType    =    doctype . getDtdUri (  )  ;", "if    ( docType    =  =    null )     {", "final   String   publicId    =    doctype . getPublicId (  )  ;", "if    (  (  (  ( PsiTreeUtil . getParentOfType ( doctype ,    XmlDocument . class )  )    instanceof   HtmlDocumentImpl )     &  &     ( publicId    !  =    null )  )     &  &     ( publicId . contains (  \"  -  /  / W 3 C /  / DTD    \"  )  )  )     {", "return   XmlUtil . guessDtdByPublicId ( publicId )  ;", "} else", "if    ( HtmlUtil . isHtml 5 Doctype ( doctype )  )     {", "docType    =     (  ( doctype . getLanguage (  )  )    instanceof   com . intellij . lang . html . HTMLLanguage )     ?    Html 5 SchemaProvider . getHtml 5 SchemaLocation (  )     :    Html 5 SchemaProvider . getXhtml 5 SchemaLocation (  )  ;", "}", "}", "return   docType ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDtdUri"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "XmlProlog   prolog    =    document . getProlog (  )  ;", "if    ( prolog    !  =    null )     {", "return    . getDtdUri ( prolog . getDoctype (  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDtdUri"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "final   XmlEntityDecl   decl    =    entityRef . resolve ( entityRef . getContainingFile (  )  )  ;", "if    ( decl    !  =    null )     {", "final   XmlAttributeValue   valueElement    =    decl . getValueElement (  )  ;", "if    ( valueElement    !  =    null )     {", "final   String   value    =    valueElement . getValue (  )  ;", "if    ( value    !  =    null )     {", "return   value ;", "}", "}", "}", "return   entityRef . getText (  )  ;", "}", "METHOD_END"], "methodName": ["getEntityValue"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "int   pos    =    StringUtil . indexOf ( tagName ,     '  :  '  )  ;", "if    ( pos    =  =     (  -  1  )  )     {", "return   tagName ;", "}", "return   tagName . subSequence (  ( pos    +     1  )  ,    tagName . length (  )  )  ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( s . startsWith ( XmlUtil . TAG _ DIR _ NS _ PREFIX )  )", "return   XmlUtil . TAG _ DIR _ NS _ PREFIX . length (  )  ;", "if    ( s . startsWith ( XmlUtil . FILE )  )", "return   XmlUtil . FILE . length (  )  ;", "if    ( s . startsWith ( XmlUtil . CLASSPATH )  )", "return   XmlUtil . CLASSPATH . length (  )  ;", "return    0  ;", "}", "METHOD_END"], "methodName": ["getPrefixLength"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "while    ( tag    !  =    null )     {", "String   schemaLocation    =    tag . getAttributeValue (  . SCHEMA _ LOCATION _ ATT ,     . XML _ SCHEMA _ INSTANCE _ URI )  ;", "if    ( schemaLocation    !  =    null )     {", "StringTokenizer   tokenizer    =    new   StringTokenizer ( schemaLocation )  ;", "int   i    =     0  ;", "while    ( tokenizer . hasMoreTokens (  )  )     {", "String   token    =    tokenizer . nextToken (  )  ;", "if    (  (  (  ( i    %     2  )     =  =     0  )     &  &     ( namespace . equals ( token )  )  )     &  &     ( tokenizer . hasMoreTokens (  )  )  )     {", "return   tokenizer . nextToken (  )  ;", "}", "i +  +  ;", "}", "}", "tag    =    tag . getParentTag (  )  ;", "}", "return   namespace ;", "}", "METHOD_END"], "methodName": ["getSchemaLocation"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "XmlElementDescriptor   descriptor    =    tag . getDescriptor (  )  ;", "if    ( descriptor   instanceof   XmlElementDescriptorImpl )     {", "final   TypeDescriptor   type    =     (  ( XmlElementDescriptorImpl )     ( descriptor )  )  . getType ( tag )  ;", "if    ( type   instanceof   ComplexTypeDescriptor )     {", "final   XmlTag [  ]    simpleContent    =    new   XmlTag [  1  ]  ;", ". processXmlElements (  (  ( ComplexTypeDescriptor )     ( type )  )  . getDeclaration (  )  ,    new   PsiElementProcessor (  )     {", "@ Override", "public   boolean   execute (  @ NotNull", "final   PsiElement   element )     {", "if    ( element   instanceof   XmlTag )     {", "final   XmlTag   tag    =     (  ( XmlTag )     ( element )  )  ;", "@ NonNls", "final   String   s    =     (  ( XmlTag )     ( element )  )  . getLocalName (  )  ;", "if    (  (  ( s . equals (  . XSD _ SIMPLE _ CONTENT _ TAG )  )     |  |     (  ( s . equals (  \" restriction \"  )  )     &  &     (  \" string \"  . equals (  . findLocalNameByQualifiedName ( tag . getAttributeValue (  \" base \"  )  )  )  )  )  )     &  &     ( tag . getNamespace (  )  . equals (  . XML _ SCHEMA _ URI )  )  )     {", "simpleContent [  0  ]     =    tag ;", "return   false ;", "}", "}", "return   true ;", "}", "}  ,    true )  ;", "return   simpleContent [  0  ]  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getSchemaSimpleContent"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "int   off    =     0  ;", "while    ( true )     {", "off    +  =    xmlTag . getStartOffsetInParent (  )  ;", "final   PsiElement   parent    =    xmlTag . getParent (  )  ;", "if    (  !  ( parent   instanceof   XmlTag )  )", "break ;", "xmlTag    =     (  ( XmlTag )     ( parent )  )  ;", "}", "return   off ;", "}", "METHOD_END"], "methodName": ["getStartOffsetInFile"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   subTag    =    tag . findFirstSubTag ( subTagName )  ;", "if    ( subTag    !  =    null )     {", "return   subTag . getValue (  )  . getTrimmedText (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getSubTagValue"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( xmlTag    =  =    null )", "return   null ;", "String   targetNamespace    =    xmlTag . getAttributeValue (  . TARGET _ NAMESPACE _ ATTR _ NAME ,     . XML _ SCHEMA _ URI )  ;", "if    ( targetNamespace    =  =    null )", "targetNamespace    =    xmlTag . getAttributeValue (  . TARGET _ NAMESPACE _ ATTR _ NAME ,     . XML _ SCHEMA _ URI 2  )  ;", "if    ( targetNamespace    =  =    null )", "targetNamespace    =    xmlTag . getAttributeValue (  . TARGET _ NAMESPACE _ ATTR _ NAME ,     . XML _ SCHEMA _ URI 3  )  ;", "return   targetNamespace ;", "}", "METHOD_END"], "methodName": ["getTargetSchemaNsFromTag"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( element    =  =    null )     {", "return   null ;", "}", "PsiElement [  ]    children    =    element . getChildren (  )  ;", "for    ( PsiElement   child    :    children )     {", "if    ( child   instanceof   Token )     {", "Token   token    =     (  ( Token )     ( child )  )  ;", "if    (  ( token . getTokenType (  )  )     =  =    type )     {", "return   token ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getTokenOfType"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   XmlUtil . findNamespacePrefixByURI ( file ,    XmlUtil . XML _ SCHEMA _ INSTANCE _ URI )  ;", "}", "METHOD_END"], "methodName": ["getXsiNamespace"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( id . contains (  \" XHTML \"  )  )     {", "if    ( id . contains (  \"  1  .  1  \"  )  )     {", "if    ( id . contains (  \" Basic \"  )  )     {", "return    \" http :  /  / www . w 3  . org / TR / xhtml - basic / xhtml - basic 1  1  . dtd \"  ;", "}", "return    \" http :  /  / www . w 3  . org / TR / xhtml 1  1  / DTD / xhtml 1  1  . dtd \"  ;", "} else    {", "if    ( id . contains (  \" Strict \"  )  )     {", "return    \" http :  /  / www . w 3  . org / TR / xhtml 1  / DTD / xhtml 1  - strict . dtd \"  ;", "} else", "if    ( id . contains (  \" Frameset \"  )  )     {", "return    \" http :  /  / www . w 3  . org / TR / xhtml 1  / DTD / xhtml 1  - frameset . dtd \"  ;", "} else", "if    ( id . contains (  \" Transitional \"  )  )     {", "return    \" http :  /  / www . w 3  . org / TR / xhtml 1  / DTD / xhtml 1  - transitional . dtd \"  ;", "}", "}", "} else", "if    ( id . contains (  \" HTML \"  )  )     {", "if    ( id . contains (  \" Strict \"  )  )     {", "return    \" http :  /  / www . w 3  . org / TR / html 4  / strict . dtd \"  ;", "} else", "if    ( id . contains (  \" Frameset \"  )  )     {", "return    \" http :  /  / www . w 3  . org / TR / html 4  / frameset . dtd \"  ;", "}", "return    . HTML 4  _ LOOSE _ URI ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["guessDtdByPublicId"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( file   instanceof   XmlFile )     {", "final   XmlFile   xmlFile    =     (  ( XmlFile )     ( file )  )  ;", "final   XmlDocument   document    =    xmlFile . getDocument (  )  ;", "if    ( document    !  =    null )     {", "final   XmlTag   tag    =    document . getRootTag (  )  ;", "if    (  (  ( tag    !  =    null )     &  &     (  \" project \"  . equals ( tag . getName (  )  )  )  )     &  &     (  ( tag . getContext (  )  )    instanceof   XmlDocument )  )     {", "if    (  ( tag . getAttributeValue (  \" default \"  )  )     !  =    null )     {", "return   true ;", "}", "VirtualFile   vFile    =    xmlFile . getOriginalFile (  )  . getVirtualFile (  )  ;", "if    (  ( vFile    !  =    null )     &  &     (  ( vFile . getUserData (  . ANT _ FILE _ SIGN )  )     !  =    null )  )     {", "return   true ;", "}", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isAntFile"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "for    ( String   jsfHtmlUri    :    XmlUtil . JSF _ HTML _ URIS )     {", "if    (  ( tag . getNSDescriptor ( jsfHtmlUri ,    true )  )     !  =    null )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isJsfHtmlScheme"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( unquotedValue . length (  )  )  ;     +  + i )     {", "final   char   ch    =    unquotedValue . charAt ( i )  ;", "if    (  (  (  !  ( Character . isJavaIdentifierPart ( ch )  )  )     &  &     ( ch    !  =     '  :  '  )  )     &  &     ( ch    !  =     '  -  '  )  )     {", "final   XmlFile   file    =    PsiTreeUtil . getParentOfType ( context ,    XmlFile . class )  ;", "if    ( file    !  =    null )     {", "XmlTag   tag    =    file . getRootTag (  )  ;", "return    ( tag    !  =    null )     &  &     (  !  (  . tagFromTemplateFramework ( tag )  )  )  ;", "}", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isSimpleValue"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   XmlUtil . BUILDING _ DOM _ STUBS . get (  )  ;", "}", "METHOD_END"], "methodName": ["isStubBuilding"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "final   XmlNSDescriptor   nsDescriptor    =    xmlTag . getNSDescriptor ( xmlTag . getNamespace (  )  ,    false )  ;", "final   XmlElementDescriptor   descriptor    =     ( nsDescriptor    !  =    null )     ?    nsDescriptor . getElementDescriptor ( xmlTag )     :    null ;", "return    ( descriptor    !  =    null )     &  &     (  !  ( descriptor   instanceof   AnyXmlElementDescriptor )  )  ;", "}", "METHOD_END"], "methodName": ["isTagDefinedByNamespace"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "final   boolean   surelyUrl    =     ( HtmlUtil . hasHtmlPrefix ( s )  )     |  |     ( s . startsWith ( XmlUtil . URN )  )  ;", "if    ( surelyUrl )", "return   surelyUrl ;", "int   protocolIndex    =    s . indexOf (  \"  :  /  \"  )  ;", "if    (  ( protocolIndex    >     1  )     &  &     (  !  ( s . regionMatches (  0  ,     \" classpath \"  ,     0  ,    protocolIndex )  )  )  )", "return   true ;", "return    ( ExternalResourceManager . getInstance (  )  . getResourceLocation ( s ,    project )  )     !  =    s ;", "}", "METHOD_END"], "methodName": ["isUrlText"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( Character . isLetter ( c )  )     |  |     ( Character . isDigit ( c )  )  )     |  |     ( c    =  =     '  :  '  )  )     |  |     ( c    =  =     '  _  '  )  )     |  |     ( c    =  =     '  -  '  )  )     |  |     ( c    =  =     '  .  '  )  ;", "}", "METHOD_END"], "methodName": ["isValidTagNameChar"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "return    ( XmlUtil . XSLT _ URI . equals ( ns )  )     |  |     ( XmlUtil . XINCLUDE _ URI . equals ( ns )  )  ;", "}", "METHOD_END"], "methodName": ["nsFromTemplateFramework"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "boolean   exhaustiveEnum    =    true ;", "for    ( final   XmlTag   tag    :    element . getSubTags (  )  )     {", "@ NonNls", "final   String   localName    =    tag . getLocalName (  )  ;", "if    ( localName . equals (  . ENUMERATION _ TAG _ NAME )  )     {", "final   String   attributeValue    =    tag . getAttributeValue (  . VALUE _ ATTR _ NAME )  ;", "if    ( attributeValue    !  =    null )     {", "if    (  !  ( tagProcessor . process ( tag )  )  )     {", "return   exhaustiveEnum ;", "}", "}", "} else", "if    ( localName . equals (  \" union \"  )  )     {", "exhaustiveEnum    =    false ;", ". processEnumerationValues ( tag ,    tagProcessor )  ;", "} else", "if    (  !  (  . doNotVisitTags . contains ( localName )  )  )     {", "exhaustiveEnum    &  =     . processEnumerationValues ( tag ,    tagProcessor )  ;", "}", "}", "return   exhaustiveEnum ;", "}", "METHOD_END"], "methodName": ["processEnumerationValues"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   XmlPsiUtil . processXmlElementChildren ( element ,    processor ,    deepFlag )  ;", "}", "METHOD_END"], "methodName": ["processXmlElementChildren"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   XmlPsiUtil . processXmlElements ( element ,    processor ,    deepFlag )  ;", "}", "METHOD_END"], "methodName": ["processXmlElements"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   XmlPsiUtil . processXmlElements ( element ,    processor ,    deepFlag ,    wideFlag )  ;", "}", "METHOD_END"], "methodName": ["processXmlElements"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   XmlPsiUtil . processXmlElements ( element ,    processor ,    deepFlag ,    wideFlag ,    baseFile )  ;", "}", "METHOD_END"], "methodName": ["processXmlElements"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   XmlPsiUtil . processXmlElements ( element ,    processor ,    deepFlag ,    wideFlag ,    baseFile ,    processIncludes )  ;", "}", "METHOD_END"], "methodName": ["processXmlElements"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "ASTNode   child    =    XmlChildRole . START _ TAG _ END _ FINDER . findChild ( tag . getNode (  )  )  ;", "if    ( child    =  =    null )     {", "CodeStyleManager . getInstance ( tag . getProject (  )  )  . reformat ( tag )  ;", "} else    {", "CodeStyleManager . getInstance ( tag . getProject (  )  )  . reformatRange ( tag ,    tag . getTextRange (  )  . getStartOffset (  )  ,    child . getTextRange (  )  . getEndOffset (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["reformatTagStart"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "XmlUtil . registerXmlAttributeValueReferenceProvider ( registrar ,    attributeNames ,    elementFilter ,    caseSensitive ,    provider ,    DEFAULT _ PRIORITY )  ;", "}", "METHOD_END"], "methodName": ["registerXmlAttributeValueReferenceProvider"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( attributeNames    =  =    null )     {", "registrar . registerReferenceProvider ( XmlPatterns . xmlAttributeValue (  )  . and ( new   psi . filters . position . FilterPattern ( elementFilter )  )  ,    provider ,    priority )  ;", "return ;", "}", "final   StringPattern   namePattern    =     ( caseSensitive )     ?    StandardPatterns . string (  )  . oneOf ( attributeNames )     :    StandardPatterns . string (  )  . oneOfIgnoreCase ( attributeNames )  ;", "registrar . registerReferenceProvider ( XmlPatterns . xmlAttributeValue (  )  . withLocalName ( namePattern )  . and ( new   psi . filters . position . FilterPattern ( elementFilter )  )  ,    provider ,    priority )  ;", "}", "METHOD_END"], "methodName": ["registerXmlAttributeValueReferenceProvider"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "XmlUtil . registerXmlAttributeValueReferenceProvider ( registrar ,    attributeNames ,    elementFilter ,    true ,    provider )  ;", "}", "METHOD_END"], "methodName": ["registerXmlAttributeValueReferenceProvider"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( names    =  =    null )     {", "registrar . registerReferenceProvider ( XmlPatterns . xmlTag (  )  . and ( new   psi . filters . position . FilterPattern ( elementFilter )  )  ,    provider ,    DEFAULT _ PRIORITY )  ;", "return ;", "}", "final   StringPattern   namePattern    =     ( caseSensitive )     ?    StandardPatterns . string (  )  . oneOf ( names )     :    StandardPatterns . string (  )  . oneOfIgnoreCase ( names )  ;", "registrar . registerReferenceProvider ( XmlPatterns . xmlTag (  )  . withLocalName ( namePattern )  . and ( new   psi . filters . position . FilterPattern ( elementFilter )  )  ,    provider ,    DEFAULT _ PRIORITY )  ;", "}", "METHOD_END"], "methodName": ["registerXmlTagReferenceProvider"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( tag   instanceof   XmlTag )     {", "(  ( XmlTag )     ( tag )  )  . getValue (  )  . setText ( value )  ;", "return   tag ;", "} else", "if    ( tag   instanceof   psi . xml . XmlAttribute )     {", "psi . xml . XmlAttribute   attr    =     (  ( psi . xml . XmlAttribute )     ( tag )  )  ;", "attr . setValue ( value )  ;", "return   attr ;", "} else    {", "throw   new   util . IncorrectOperationException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setNewValue"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "final   String   ns    =    tag . getNamespace (  )  ;", "return    . nsFromTemplateFramework ( ns )  ;", "}", "METHOD_END"], "methodName": ["tagFromTemplateFramework"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "return    (  \"  <  &  >  \\ u 0  0 a 0  \"  . indexOf ( ch )  )     >  =     0  ;", "}", "METHOD_END"], "methodName": ["toCode"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( str . length (  )  )  ;    i +  +  )     {", "if    (  . toCode ( str . charAt ( i )  )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["toCode"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   tagValue    =  =    null    ?    null    :    tagValue . replaceAll (  \"  \\ n \\  \\ s *  \"  ,     \"  \\ n \"  )  ;", "}", "METHOD_END"], "methodName": ["trimLeadingSpacesInMultilineTagValue"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "return   StringUtil . unescapeXml ( text )  ;", "}", "METHOD_END"], "methodName": ["unescape"], "fileName": "com.intellij.xml.util.XmlUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( tag    =  =    null )", "return   null ;", "String   contextName    =    tag . getName (  )  ;", "for    ( final   HtmlAttribute   attribute    :    attributes )     {", "if    ( attribute . isValidParentTagName ( contextName )  )     {", "return   attribute ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findHtmlAttributeInContext"], "fileName": "com.intellij.xml.util.documentation.CompositeAttributeTagDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   description ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "com.intellij.xml.util.documentation.EntityDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   dtd ;", "}", "METHOD_END"], "methodName": ["getDtd"], "fileName": "com.intellij.xml.util.documentation.EntityDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   helpRef ;", "}", "METHOD_END"], "methodName": ["getHelpRef"], "fileName": "com.intellij.xml.util.documentation.EntityDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.intellij.xml.util.documentation.EntityDescriptor"}, {"methodBody": ["METHOD_START", "{", "this . description    =    description ;", "}", "METHOD_END"], "methodName": ["setDescription"], "fileName": "com.intellij.xml.util.documentation.EntityDescriptor"}, {"methodBody": ["METHOD_START", "{", "this . dtd    =    dtd ;", "}", "METHOD_END"], "methodName": ["setDtd"], "fileName": "com.intellij.xml.util.documentation.EntityDescriptor"}, {"methodBody": ["METHOD_START", "{", "this . helpRef    =    helpRef ;", "}", "METHOD_END"], "methodName": ["setHelpRef"], "fileName": "com.intellij.xml.util.documentation.EntityDescriptor"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "com.intellij.xml.util.documentation.EntityDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   mySetOfParentTags ;", "}", "METHOD_END"], "methodName": ["getSetOfParentTags"], "fileName": "com.intellij.xml.util.documentation.HtmlAttributeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   myType ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.intellij.xml.util.documentation.HtmlAttributeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   myHasDefaultValue ;", "}", "METHOD_END"], "methodName": ["isHasDefaultValue"], "fileName": "com.intellij.xml.util.documentation.HtmlAttributeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   myParentSetIsExclusionSet ;", "}", "METHOD_END"], "methodName": ["isParentSetIsExclusionSet"], "fileName": "com.intellij.xml.util.documentation.HtmlAttributeDescriptor"}, {"methodBody": ["METHOD_START", "{", "boolean   containsInSet    =     ( Arrays . binarySearch ( mySetOfParentTags ,    str )  )     >  =     0  ;", "return   containsInSet    =  =     (  !  ( myParentSetIsExclusionSet )  )  ;", "}", "METHOD_END"], "methodName": ["isValidParentTagName"], "fileName": "com.intellij.xml.util.documentation.HtmlAttributeDescriptor"}, {"methodBody": ["METHOD_START", "{", "this . myHasDefaultValue    =    hasDefaultValue ;", "}", "METHOD_END"], "methodName": ["setHasDefaultValue"], "fileName": "com.intellij.xml.util.documentation.HtmlAttributeDescriptor"}, {"methodBody": ["METHOD_START", "{", "myParentSetIsExclusionSet    =     _ parentSetIsExclusionSet ;", "}", "METHOD_END"], "methodName": ["setParentSetIsExclusionSet"], "fileName": "com.intellij.xml.util.documentation.HtmlAttributeDescriptor"}, {"methodBody": ["METHOD_START", "{", "mySetOfParentTags    =     _ setOfParentTags ;", "}", "METHOD_END"], "methodName": ["setSetOfParentTags"], "fileName": "com.intellij.xml.util.documentation.HtmlAttributeDescriptor"}, {"methodBody": ["METHOD_START", "{", "this . myType    =    type ;", "}", "METHOD_END"], "methodName": ["setType"], "fileName": "com.intellij.xml.util.documentation.HtmlAttributeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   HtmlDescriptorsTable . ourAttributeTable . get ( attributeName )  ;", "}", "METHOD_END"], "methodName": ["getAttributeDescriptor"], "fileName": "com.intellij.xml.util.documentation.HtmlDescriptorsTable"}, {"methodBody": ["METHOD_START", "{", "return   HtmlDescriptorsTable . ourTagTable . get ( tagName )  ;", "}", "METHOD_END"], "methodName": ["getTagDescriptor"], "fileName": "com.intellij.xml.util.documentation.HtmlDescriptorsTable"}, {"methodBody": ["METHOD_START", "{", "final   Document   document    =    JDOMUtil . loadDocument ( HtmlDescriptorsTable . class . getResourceAsStream ( resourceName )  )  ;", "final   List   elements    =    document . getRootElement (  )  . getChildren ( HtmlDescriptorsTable . TAG _ ELEMENT _ NAME )  ;", "final   String   baseHtmlExtDocUrl    =    document . getRootElement (  )  . getAttribute ( HtmlDescriptorsTable . BASE _ HELP _ REF _ ATTR )  . getValue (  )  ;", "for    ( Object   object    :    elements )     {", "final   Element   element    =     (  ( Element )     ( object )  )  ;", "String   htmlTagName    =    element . getAttributeValue ( HtmlDescriptorsTable . NAME _ ATTR )  ;", "htmlTagNames . add ( htmlTagName )  ;", "HtmlTagDescriptor   value    =    new   HtmlTagDescriptor (  )  ;", "HtmlDescriptorsTable . ourTagTable . put ( htmlTagName ,    value )  ;", "value . setHelpRef (  ( baseHtmlExtDocUrl    +     ( element . getAttributeValue ( HtmlDescriptorsTable . HELPREF _ ATTR )  )  )  )  ;", "value . setDescription ( element . getAttributeValue ( HtmlDescriptorsTable . DESCRIPTION _ ATTR )  )  ;", "value . setName ( htmlTagName )  ;", "value . setHasStartTag ( element . getAttribute ( HtmlDescriptorsTable . STARTTAG _ ATTR )  . getBooleanValue (  )  )  ;", "value . setHasEndTag ( element . getAttribute ( HtmlDescriptorsTable . ENDTAG _ ATTR )  . getBooleanValue (  )  )  ;", "value . setEmpty ( element . getAttribute ( HtmlDescriptorsTable . EMPTY _ ATTR )  . getBooleanValue (  )  )  ;", "String   attributeValue    =    element . getAttributeValue ( HtmlDescriptorsTable . DTD _ ATTR )  ;", "if    (  ( attributeValue . length (  )  )     >     0  )     {", "value . setDtd ( attributeValue . charAt (  0  )  )  ;", "}", "}", "final   List   attributes    =    document . getRootElement (  )  . getChildren ( HtmlDescriptorsTable . ATTRIBUTE _ ELEMENT _ NAME )  ;", "for    ( Object   attribute    :    attributes )     {", "final   Element   element    =     (  ( Element )     ( attribute )  )  ;", "String   attrName    =    element . getAttributeValue ( HtmlDescriptorsTable . NAME _ ATTR )  ;", "HtmlAttributeDescriptor   value    =    new   HtmlAttributeDescriptor (  )  ;", "HtmlAttributeDescriptor   previousDescriptor    =    HtmlDescriptorsTable . ourAttributeTable . get ( attrName )  ;", "if    ( previousDescriptor    =  =    null )     {", "HtmlDescriptorsTable . ourAttributeTable . put ( attrName ,    value )  ;", "} else    {", "CompositeAttributeTagDescriptor   parentDescriptor ;", "if    (  !  ( previousDescriptor   instanceof   CompositeAttributeTagDescriptor )  )     {", "parentDescriptor    =    new   CompositeAttributeTagDescriptor (  )  ;", "HtmlDescriptorsTable . ourAttributeTable . put ( attrName ,    parentDescriptor )  ;", "parentDescriptor . attributes . add ( previousDescriptor )  ;", "} else    {", "parentDescriptor    =     (  ( CompositeAttributeTagDescriptor )     ( previousDescriptor )  )  ;", "}", "parentDescriptor . attributes . add ( value )  ;", "}", "value . setHelpRef (  ( baseHtmlExtDocUrl    +     ( element . getAttributeValue ( HtmlDescriptorsTable . HELPREF _ ATTR )  )  )  )  ;", "value . setDescription ( element . getAttributeValue ( HtmlDescriptorsTable . DESCRIPTION _ ATTR )  )  ;", "value . setName ( attrName )  ;", "String   attributeValue    =    element . getAttributeValue ( HtmlDescriptorsTable . DTD _ ATTR )  ;", "if    (  ( attributeValue . length (  )  )     >     0  )     {", "value . setDtd ( attributeValue . charAt (  0  )  )  ;", "}", "value . setType ( element . getAttributeValue ( HtmlDescriptorsTable . TYPE _ ATTR )  )  ;", "value . setHasDefaultValue ( element . getAttribute ( HtmlDescriptorsTable . DEFAULT _ ATTR )  . getBooleanValue (  )  )  ;", "StringTokenizer   tokenizer    =    new   StringTokenizer ( element . getAttributeValue ( HtmlDescriptorsTable . RELATED _ TAGS _ ATTR )  ,     \"  ,  \"  )  ;", "int   tokenCount    =    tokenizer . countTokens (  )  ;", "for    ( int   i    =     0  ;    i    <    tokenCount ;     +  + i )     {", "final   String   s    =    tokenizer . nextToken (  )  ;", "if    ( s . equals (  \"  !  \"  )  )     {", "value . setParentSetIsExclusionSet ( true )  ;", "} else    {", "if    (  ( value . getSetOfParentTags (  )  )     =  =    null )     {", "value . setSetOfParentTags ( new   String [ tokenCount    -     ( value . isParentSetIsExclusionSet (  )     ?     1     :     0  )  ]  )  ;", "}", "value . getSetOfParentTags (  )  [  ( i    -     ( value . isParentSetIsExclusionSet (  )     ?     1     :     0  )  )  ]     =    s ;", "}", "}", "Arrays . sort ( value . getSetOfParentTags (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["loadHtmlElements"], "fileName": "com.intellij.xml.util.documentation.HtmlDescriptorsTable"}, {"methodBody": ["METHOD_START", "{", "String   key    =    text . toLowerCase ( Locale . US )  ;", "final   HtmlTagDescriptor   descriptor    =    HtmlDescriptorsTable . getTagDescriptor ( key )  ;", "if    (  ( descriptor    !  =    null )     &  &     (  !  ( isAttributeContext ( context )  )  )  )     {", "try    {", "final   XmlTag   tagFromText    =    XmlElementFactory . getInstance ( psiManager . getProject (  )  )  . createTagFromText (  (  (  (  (  \"  <  \"     +    key )     +     \"    xmlns =  \\  \"  \"  )     +     ( XmlUtil . XHTML _ URI )  )     +     \"  \\  \"  /  >  \"  )  )  ;", "final   XmlElementDescriptor   tagDescriptor    =    tagFromText . getDescriptor (  )  ;", "return   tagDescriptor    !  =    null    ?    tagDescriptor . getDeclaration (  )     :    null ;", "}    catch    ( IncorrectOperationException   ignore )     {", "}", "} else    {", "XmlTag   tagContext    =    findTagContext ( context )  ;", "HtmlAttributeDescriptor   myAttributeDescriptor    =     . getDescriptor ( key ,    tagContext )  ;", "if    (  ( myAttributeDescriptor    !  =    null )     &  &     ( tagContext    !  =    null )  )     {", "XmlElementDescriptor   tagDescriptor    =    tagContext . getDescriptor (  )  ;", "XmlAttributeDescriptor   attributeDescriptor    =     ( tagDescriptor    !  =    null )     ?    tagDescriptor . getAttributeDescriptor ( text ,    tagContext )     :    null ;", "return   attributeDescriptor    !  =    null    ?    attributeDescriptor . getDeclaration (  )     :    null ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["createNavigationElementHTML"], "fileName": "com.intellij.xml.util.documentation.HtmlDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "boolean   isTag    =    true ;", "PsiElement   nameElement    =    null ;", "String   key    =    null ;", "if    ( element   instanceof   XmlElementDecl )     {", "nameElement    =     (  ( XmlElementDecl )     ( element )  )  . getNameElement (  )  ;", "} else", "if    ( element   instanceof   com . intellij . psi . xml . XmlAttributeDecl )     {", "nameElement    =     (  ( com . intellij . psi . xml . XmlAttributeDecl )     ( element )  )  . getNameElement (  )  ;", "isTag    =    false ;", "} else", "if    ( element   instanceof   XmlTag )     {", "final   XmlTag   xmlTag    =     (  ( XmlTag )     ( element )  )  ;", "final   com . intellij . psi . meta . PsiMetaData   metaData    =    xmlTag . getMetaData (  )  ;", "key    =     ( metaData    !  =    null )     ?    metaData . getName (  )     :    null ;", "isTag    =    xmlTag . getLocalName (  )  . equals (  . ELEMENT _ ELEMENT _ NAME )  ;", "} else", "if    (  ( element . getParent (  )  )    instanceof   com . intellij . psi . xml . XmlAttributeValue )     {", "isTag    =    false ;", "key    =     (  ( com . intellij . psi . xml . XmlAttribute )     ( element . getParent (  )  . getParent (  )  )  )  . getName (  )  ;", "} else", "if    ( element   instanceof   com . intellij . psi . xml . XmlAttributeValue )     {", "isTag    =    false ;", "final   com . intellij . psi . xml . XmlAttribute   xmlAttribute    =     (  ( com . intellij . psi . xml . XmlAttribute )     ( element . getParent (  )  )  )  ;", "key    =    xmlAttribute . getName (  )  ;", "} else", "if    ( element   instanceof   com . intellij . psi . xml . XmlAttribute )     {", "final   com . intellij . psi . xml . XmlAttribute   xmlAttribute    =     (  ( com . intellij . psi . xml . XmlAttribute )     ( element )  )  ;", "isTag    =    false ;", "key    =    xmlAttribute . getName (  )  ;", "} else", "if    ( element   instanceof   com . intellij . psi . xml . XmlElement )     {", "nameElement    =    element ;", "isTag    =     !  (  ( element . getParent (  )  )    instanceof   com . intellij . psi . xml . XmlAttribute )  ;", "} else    {", "nameElement    =    element ;", "if    ( context    !  =    null )     {", "String   text    =    element . getText (  )  ;", "isTag    =     ( text    !  =    null )     &  &     ( text . startsWith ( context . getName (  )  )  )  ;", "}", "}", "if    ( nameElement    !  =    null )     {", "key    =    nameElement . getText (  )  ;", "}", "key    =    StringUtil . notNullize ( key )  . toLowerCase ( Locale . US )  ;", "int   dotIndex    =    key . indexOf (  '  .  '  )  ;", "if    ( dotIndex    >     0  )     {", "key    =    key . substring (  0  ,    dotIndex )  ;", "}", "if    ( isTag )     {", "return   HtmlDescriptorsTable . getTagDescriptor ( key )  ;", "} else    {", "return    . getDescriptor ( key ,    context )  ;", "}", "}", "METHOD_END"], "methodName": ["findDocumentationDescriptor"], "fileName": "com.intellij.xml.util.documentation.HtmlDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( context   instanceof   PsiWhiteSpace )     {", "PsiEle   prevSibling    =    context . getPrevSibling (  )  ;", "if    ( prevSibling   instanceof   XmlTag )", "return    (  ( XmlTag )     ( prevSibling )  )  ;", "}", "return   PsiTreeUtil . getParentOfType ( context ,    XmlTag . class ,    false )  ;", "}", "METHOD_END"], "methodName": ["findTagContext"], "fileName": "com.intellij.xml.util.documentation.HtmlDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "final   EntityDescriptor   descriptor    =    HtmlDocumentationProvider . findDocumentationDescriptor ( element ,    context )  ;", "if    ( descriptor    !  =    null )     {", "return   HtmlDocumentationProvider . generateJavaDoc ( descriptor ,    omitHtmlSpecifics ,    originalElement )  ;", "}", "if    ( element   instanceof   XmlEntityDecl )     {", "final   XmlEntityDecl   entityDecl    =     (  ( XmlEntityDecl )     ( element )  )  ;", "return   new   XmlDocumentationProvider (  )  . findDocRightAfterElement ( element ,    entityDecl . getName (  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["generateDocForHtml"], "fileName": "com.intellij.xml.util.documentation.HtmlDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   buf    =    new   StringBuilder (  )  ;", "final   boolean   isTag    =    descriptor   instanceof   HtmlTagDescriptor ;", "if    ( isTag )     {", "DocumentationUtil . formatEntityName ( XmlBundle . message (  \" xml . message \"  )  ,    descriptor . getName (  )  ,    buf )  ;", "} else    {", "DocumentationUtil . formatEntityName ( XmlBundle . message (  \" xml . message \"  )  ,    descriptor . getName (  )  ,    buf )  ;", "}", "buf . append ( XmlBundle . message (  \" xml . message \"  )  )  . append (  . NBSP )  . append ( descriptor . getDescription (  )  )  . append (  . BR )  ;", "if    ( isTag )     {", "final   HtmlTagDescriptor   tagDescriptor    =     (  ( HtmlTagDescriptor )     ( descriptor )  )  ;", "if    (  ! omitHtmlSpecifics )     {", "boolean   hasStartTag    =    tagDescriptor . isHasStartTag (  )  ;", "if    (  ! hasStartTag )     {", "buf . append ( XmlBundle . message (  \" xml . message \"  )  )  . append (  . BR )  ;", "}", "if    (  (  !  ( tagDescriptor . isEmpty (  )  )  )     &  &     (  !  ( tagDescriptor . isHasEndTag (  )  )  )  )     {", "buf . append ( XmlBundle . message (  \" xml . message \"  )  )  . append (  . BR )  ;", "}", "}", "if    ( tagDescriptor . isEmpty (  )  )     {", "buf . append ( XmlBundle . message (  \" xml . message \"  )  )  . append (  . BR )  ;", "}", "} else    {", "final   HtmlAttributeDescriptor   attributeDescriptor    =     (  ( HtmlAttributeDescriptor )     ( descriptor )  )  ;", "buf . append ( XmlBundle . message (  \" xml . message \"  ,    attributeDescriptor . getType (  )  )  )  . append (  . BR )  ;", "if    (  !  ( attributeDescriptor . isHasDefaultValue (  )  )  )", "buf . append ( XmlBundle . message (  \" xml . message \"  )  )  . append (  . BR )  ;", "}", "char   dtdId    =    descriptor . getDtd (  )  ;", "boolean   deprecated    =    dtdId    =  =     ( EntityDescriptor . LOOSE _ DTD )  ;", "if    ( deprecated )     {", "buf . append ( XmlBundle . message (  \" xml . message \"  ,    true )  )  . append (  . BR )  ;", "}", "if    ( dtdId    =  =     ( EntityDescriptor . LOOSE _ DTD )  )     {", "buf . append ( XmlBundle . message (  \" xml . message \"  )  )  ;", "} else", "if    ( dtdId    =  =     ( EntityDescriptor . FRAME _ DTD )  )     {", "buf . append ( XmlBundle . message (  \" xml . message \"  )  )  ;", "} else    {", "buf . append ( XmlBundle . message (  \" xml . message \"  )  )  ;", "}", "if    (  ! isTag )     {", "ColorSampleLookupValue . addColorPreviewAndCodeToLookup ( element ,    buf )  ;", "}", "if    ( element    !  =    null )     {", "buf . append ( XmlDocumentationProvider . generateHtmlAdditionalDocTemplate ( element )  )  ;", "}", "return   buf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["generateJavaDoc"], "fileName": "com.intellij.xml.util.documentation.HtmlDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "HtmlAttributeDescriptor   attributeDescriptor    =    HtmlDescriptorsTable . getAttributeDescriptor ( name )  ;", "if    ( attributeDescriptor   instanceof   CompositeAttributeTagDescriptor )     {", "return    (  ( CompositeAttributeTagDescriptor )     ( attributeDescriptor )  )  . findHtmlAttributeInContext ( context )  ;", "}", "return   attributeDescriptor ;", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "com.intellij.xml.util.documentation.HtmlDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( myUseStyleProvider )  )", "return   null ;", "if    (  ( myStyleProvider )     =  =    null )     {", "Language   cssLanguage    =    Language . findLanguageByID (  \" CSS \"  )  ;", "if    ( cssLanguage    !  =    null )     {", "myStyleProvider    =    INSTANCE . forLanguage ( cssLanguage )  ;", "}", "}", "return   myStyleProvider ;", "}", "METHOD_END"], "methodName": ["getStyleProvider"], "fileName": "com.intellij.xml.util.documentation.HtmlDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "final   EntityDescriptor   descriptor    =    HtmlDocumentationProvider . findDocumentationDescriptor ( element ,    context )  ;", "if    ( descriptor    !  =    null )     {", "return   descriptor . getHelpRef (  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getUrlForHtml"], "fileName": "com.intellij.xml.util.documentation.HtmlDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( context   instanceof   XmlAttribute )", "return   true ;", "if    ( context   instanceof   PsiWhiteSpace )     {", "PsiEle   prevSibling    =    context . getPrevSibling (  )  ;", "if    ( prevSibling   instanceof   XmlAttribute )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isAttributeContext"], "fileName": "com.intellij.xml.util.documentation.HtmlDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "HtmlDocumentationProvider . ourScriptProvider    =    provider ;", "}", "METHOD_END"], "methodName": ["registerScriptDocumentationProvider"], "fileName": "com.intellij.xml.util.documentation.HtmlDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "return   empty ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "com.intellij.xml.util.documentation.HtmlTagDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   hasEndTag ;", "}", "METHOD_END"], "methodName": ["isHasEndTag"], "fileName": "com.intellij.xml.util.documentation.HtmlTagDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   hasStartTag ;", "}", "METHOD_END"], "methodName": ["isHasStartTag"], "fileName": "com.intellij.xml.util.documentation.HtmlTagDescriptor"}, {"methodBody": ["METHOD_START", "{", "this . empty    =    empty ;", "}", "METHOD_END"], "methodName": ["setEmpty"], "fileName": "com.intellij.xml.util.documentation.HtmlTagDescriptor"}, {"methodBody": ["METHOD_START", "{", "this . hasEndTag    =    hasEndTag ;", "}", "METHOD_END"], "methodName": ["setHasEndTag"], "fileName": "com.intellij.xml.util.documentation.HtmlTagDescriptor"}, {"methodBody": ["METHOD_START", "{", "this . hasStartTag    =    hasStartTag ;", "}", "METHOD_END"], "methodName": ["setHasStartTag"], "fileName": "com.intellij.xml.util.documentation.HtmlTagDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( MimeTypeDictionary . ourContentTypes )     =  =    null )     {", "MimeTypeDictionary . ourContentTypes    =    MimeTypeDictionary . loadContentTypes (  )  ;", "}", "return   MimeTypeDictionary . ourContentTypes ;", "}", "METHOD_END"], "methodName": ["getContentTypes"], "fileName": "com.intellij.xml.util.documentation.MimeTypeDictionary"}, {"methodBody": ["METHOD_START", "{", "final   TreeSet < String >    result    =    new   TreeSet <  >  (  )  ;", "result . add (  \"  *  /  *  \"  )  ;", ". readMediaTypes ( result ,     \" application \"  )  ;", ". readMediaTypes ( result ,     \" audio \"  )  ;", ". readMediaTypes ( result ,     \" image \"  )  ;", ". readMediaTypes ( result ,     \" message \"  )  ;", ". readMediaTypes ( result ,     \" model \"  )  ;", ". readMediaTypes ( result ,     \" multipart \"  )  ;", ". readMediaTypes ( result ,     \" text \"  )  ;", ". readMediaTypes ( result ,     \" video \"  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["loadContentTypes"], "fileName": "com.intellij.xml.util.documentation.MimeTypeDictionary"}, {"methodBody": ["METHOD_START", "{", "final   InputStream   stream    =    MimeTypeDictionary . class . getResourceAsStream (  (  (  \" mimeTypes /  \"     +    category )     +     \"  . csv \"  )  )  ;", "String   csv    =     \"  \"  ;", "try    {", "csv    =     ( stream    !  =    null )     ?    FileUtil . loadTextAndClose ( stream )     :     \"  \"  ;", "}    catch    ( IOException   e )     {", "Logger . getInstance ( MimeTypeDictionary . class )  . error ( e )  ;", "}", "final   String [  ]    lines    =    StringUtil . splitByLines ( csv )  ;", "for    ( String   line    :    lines )     {", "if    ( line    =  =     ( lines [  0  ]  )  )", "continue ;", "final   String [  ]    split    =    line . split (  \"  ,  \"  )  ;", "if    (  ( split . length )     >     1  )     {", "result . add (  (  !  ( split [  1  ]  . isEmpty (  )  )     ?    split [  1  ]     :    MimeTypeDictionary . withCategory ( category ,    split [  0  ]  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["readMediaTypes"], "fileName": "com.intellij.xml.util.documentation.MimeTypeDictionary"}, {"methodBody": ["METHOD_START", "{", "final   int   whitespacePosition    =    name . indexOf (  '     '  )  ;", "return    ( category    +     \"  /  \"  )     +     ( whitespacePosition    >     0     ?    name . substring (  0  ,    whitespacePosition )     :    name )  ;", "}", "METHOD_END"], "methodName": ["withCategory"], "fileName": "com.intellij.xml.util.documentation.MimeTypeDictionary"}, {"methodBody": ["METHOD_START", "{", "if    ( context   instanceof   PsiWhiteSpace )     {", "PsiEle   parent    =    context . getParent (  )  ;", "if    ( parent   instanceof   XmlText )     {", "PsiEle   prevSibling    =    parent . getPrevSibling (  )  ;", "if    ( prevSibling   instanceof   XmlTag )", "return    (  ( XmlTag )     ( prevSibling )  )  ;", "} else", "if    ( parent   instanceof   XmlTag )     {", "return    (  ( XmlTag )     ( parent )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findTagBeforeWhiteSpace"], "fileName": "com.intellij.xml.util.documentation.XHtmlDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "return   StringUtil . escapeXml ( result )  . replaceAll (  \"  & apos ;  \"  ,     \"  '  \"  )  . replaceAll (  \"  \\ n \"  ,     \"  < br >  \\ n \"  )  ;", "}", "METHOD_END"], "methodName": ["escapeDocumentationTextText"], "fileName": "com.intellij.xml.util.documentation.XmlDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "final   XmlFile   containingXmlFile    =    XmlUtil . getContainingFile ( element )  ;", "final   XmlTag   nearestTag    =    PsiTreeUtil . getParentOfType ( element ,    XmlTag . class ,    false )  ;", "final   XmlFile   xmlFile    =     (  ( nearestTag    !  =    null )     &  &     ( containingXmlFile    !  =    null )  )     ?    XmlUtil . findDescriptorFile ( nearestTag ,    containingXmlFile )     :    containingXmlFile ;", "if    ( xmlFile    !  =    null )     {", "final   PsiElement [  ]    result    =    new   PsiElement [  1  ]  ;", "XmlUtil . processXmlElements ( xmlFile ,    new   PsiElementProcessor (  )     {", "@ Override", "public   boolean   execute (  @ NotNull", "final   PsiElement   element )     {", "if    ( element   instanceof   XmlEntityDecl )     {", "final   XmlEntityDecl   entityDecl    =     (  ( XmlEntityDecl )     ( element )  )  ;", "if    (  ( entityDecl . isInternalReference (  )  )     &  &     ( name . equals ( entityDecl . getName (  )  )  )  )     {", "result [  0  ]     =    entityDecl ;", "return   false ;", "}", "} else", "if    ( element   instanceof   psi . xml . XmlElementDecl )     {", "final   psi . xml . XmlElementDecl   entityDecl    =     (  ( psi . xml . XmlElementDecl )     ( element )  )  ;", "if    ( name . equals ( entityDecl . getName (  )  )  )     {", "result [  0  ]     =    entityDecl ;", "return   false ;", "}", "}", "return   true ;", "}", "}  ,    true )  ;", "return   result [  0  ]  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findDeclWithName"], "fileName": "com.intellij.xml.util.documentation.XmlDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "PsiElement   uncleElement    =    parent . getNextSibling (  )  ;", "if    (  ( uncleElement   instanceof   PsiWhiteSpace )     &  &     (  ( uncleElement . getText (  )  . indexOf (  '  \\ n '  )  )     =  =     (  -  1  )  )  )", "uncleElement    =    uncleElement . getNextSibling (  )  ;", "if    ( uncleElement   instanceof   PsiComment )     {", "return   formatDocFromComment ( uncleElement ,    referenceName )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findDocRightAfterElement"], "fileName": "com.intellij.xml.util.documentation.XmlDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "final   Ref < XmlTag >    enumerationTag    =    new   Ref (  )  ;", "Processor < XmlTag >    processor    =     (    xmlTag )     -  >     {", "if    ( text . equals ( xmlTag . getAttributeValue ( XmlUtil . VALUE _ ATTR _ NAME )  )  )     {", "enumerationTag . set ( xmlTag )  ;", "}", "return   true ;", "}  ;", "XmlUtil . processEnumerationValues ( tag ,    processor )  ;", "if    (  ( enumerationTag . get (  )  )     =  =    null )     {", "final   XmlElementDescriptorImpl   elementDescriptor    =     (  ( XmlElementDescriptorImpl )     ( XmlUtil . findXmlDescriptorByType ( tag ,    null )  )  )  ;", "TypeDescriptor   type    =     ( elementDescriptor    !  =    null )     ?    elementDescriptor . getType (  )     :    null ;", "if    ( type   instanceof   ComplexTypeDescriptor )     {", "XmlUtil . processEnumerationValues (  (  ( ComplexTypeDescriptor )     ( type )  )  . getDeclaration (  )  ,    processor )  ;", "}", "}", "return   enumerationTag . get (  )  ;", "}", "METHOD_END"], "methodName": ["findEnumerationValue"], "fileName": "com.intellij.xml.util.documentation.XmlDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "PsiElement   curElement    =    element ;", "while    (  ( curElement    !  =    null )     &  &     (  !  ( curElement   instanceof   XmlComment )  )  )     {", "curElement    =    curElement . getPrevSibling (  )  ;", "if    (  ( curElement   instanceof   XmlText )     &  &     ( StringUtil . isEmptyOrSpaces ( curElement . getText (  )  )  )  )     {", "continue ;", "}", "if    (  (  (  !  ( curElement   instanceof   PsiWhiteSpace )  )     &  &     (  !  ( curElement   instanceof   XmlProlog )  )  )     &  &     (  !  ( curElement   instanceof   XmlComment )  )  )     {", "curElement    =    null ;", "break ;", "}", "}", "return   curElement ;", "}", "METHOD_END"], "methodName": ["findPreviousComment"], "fileName": "com.intellij.xml.util.documentation.XmlDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "String   text    =    curElement . getText (  )  ;", "text    =    text . substring (  \"  <  !  -  -  \"  . length (  )  ,     (  ( text . length (  )  )     -     (  \"  -  -  >  \"  . length (  )  )  )  )  . trim (  )  ;", "text    =     . escapeDocumentationTextText ( text )  ;", "return   generateDoc ( text ,    name ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["formatDocFromComment"], "fileName": "com.intellij.xml.util.documentation.XmlDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( str    =  =    null )", "return   null ;", "StringBuilder   buf    =    new   StringBuilder (  (  ( str . length (  )  )     +     2  0  )  )  ;", "DocumentationUtil . formatEntityName (  ( typeName    =  =    null    ?    XmlBundle . message (  \" xml . message \"  )     :    typeName )  ,    name ,    buf )  ;", "final   String   indent    =     \"        \"  ;", "final   StringBuilder   builder    =    buf . append ( XmlBundle . message (  \" xml . message \"  )  )  . append ( indent )  . append ( Ht . NBSP )  . append ( str )  ;", "if    ( version    !  =    null )     {", "builder . append ( Ht . BR )  . append ( XmlBundle . message (  \" xml . message \"  )  )  . append ( indent )  . append ( Ht . NBSP )  . append ( version )  ;", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["generateDoc"], "fileName": "com.intellij.xml.util.documentation.XmlDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   buf    =    new   StringBuilder (  )  ;", "final   PsiFile   containingFile    =    element . getContainingFile (  )  ;", "if    ( containingFile    !  =    null )     {", "final   XmlTag   tag    =    PsiTreeUtil . getParentOfType ( element ,    XmlTag . class ,    false )  ;", "boolean   append ;", "if    ( tag   instanceof   HtmlTag )     {", "append    =    true ;", "} else    {", "final   FileViewProvider   provider    =    containingFile . getViewProvider (  )  ;", "Language   language ;", "if    ( provider   instanceof   TemplateLanguageFileViewProvider )     {", "language    =     (  ( TemplateLanguageFileViewProvider )     ( provider )  )  . getTemplateDataLanguage (  )  ;", "} else    {", "language    =    provider . getBaseLanguage (  )  ;", "}", "append    =    language    =  =     ( XHTMLLanguage . INSTANCE )  ;", "}", "if    ( tag    !  =    null )     {", "EntityDescriptor   descriptor    =    HtmlDescriptorsTable . getTagDescriptor ( tag . getName (  )  )  ;", "if    (  ( descriptor    !  =    null )     &  &    append )     {", "buf . append (  \"  < br >  \"  )  ;", "buf . append ( XmlBundle . message (  \" html . quickdoc . additional . template \"  ,    descriptor . getHelpRef (  )  ,     (  (  . BASE _ SITEPOINT _ URL )     +     ( tag . getName (  )  )  )  )  )  ;", "}", "}", "}", "return   buf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["generateHtmlAdditionalDocTemplate"], "fileName": "com.intellij.xml.util.documentation.XmlDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "XmlElementDescriptor   descriptor    =    element . getUserData ( XmlDocumentationProvider . DESCRIPTOR _ KEY )  ;", "XmlTag   contextTag    =    null ;", "XmlAttribute   contextAttribute ;", "if    (  (  ( descriptor    =  =    null )     &  &     ( originalElement    !  =    null )  )     &  &     (  ( contextAttribute    =    PsiTreeUtil . getParentOfType ( originalElement ,    XmlAttribute . class )  )     !  =    null )  )     {", "final   XmlAttributeDescriptor   attributeDescriptor    =    contextAttribute . getDescriptor (  )  ;", "if    ( attributeDescriptor   instanceof   XmlAttributeDescriptorImpl )     {", "final   XmlElementDescriptorImpl   elementDescriptor    =     (  ( XmlElementDescriptorImpl )     ( XmlUtil . findXmlDescriptorByType (  (  ( XmlTag )     ( attributeDescriptor . getDeclaration (  )  )  )  ,    contextAttribute . getParent (  )  )  )  )  ;", "TypeDescriptor   type    =     ( elementDescriptor    !  =    null )     ?    elementDescriptor . getType ( contextAttribute )     :    null ;", "if    ( type   instanceof   ComplexTypeDescriptor )     {", "return    (  ( ComplexTypeDescriptor )     ( type )  )  . getDeclaration (  )  ;", "}", "}", "}", "if    (  (  ( descriptor    =  =    null )     &  &     ( originalElement    !  =    null )  )     &  &     (  ( contextTag    =    PsiTreeUtil . getParentOfType ( originalElement ,    XmlTag . class )  )     !  =    null )  )     {", "descriptor    =    contextTag . getDescriptor (  )  ;", "}", "if    ( descriptor   instanceof   XmlElementDescriptorImpl )     {", "TypeDescriptor   type    =     (  ( XmlElementDescriptorImpl )     ( descriptor )  )  . getType ( contextTag )  ;", "if    ( type   instanceof   ComplexTypeDescriptor )     {", "return    (  ( ComplexTypeDescriptor )     ( type )  )  . getDeclaration (  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getComplexOrSimpleTypeDefinition"], "fileName": "com.intellij.xml.util.documentation.XmlDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "return   entityManager . getDeclaredEntities (  )  ;", "}", "METHOD_END"], "methodName": ["getEntities"], "fileName": "org.apache.xerces.impl.XercesAccessor"}, {"methodBody": ["METHOD_START", "{", "if    ( o   instanceof   CompositeDescriptor )     {", "for    ( DElementPattern   pattern    :     (  ( CompositeDescriptor )     ( o )  )  . getElementPatterns (  )  )     {", "if    (  . isHtml ( pattern )  )", "return   true ;", "}", "} else", "if    ( o   instanceof   RngElementDescriptor )     {", "return    . isHtml (  (  ( RngElementDescriptor )     ( o )  )  . getElementPattern (  )  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isHtml"], "fileName": "org.intellij.html.RelaxedHtmlFromRngElementDescriptor"}, {"methodBody": ["METHOD_START", "{", "for    ( QName   name    :    pattern . getName (  )  . listNames (  )  )     {", "if    ( XmlUtil . XHTML _ URI . equals ( name . getNamespaceURI (  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isHtml"], "fileName": "org.intellij.html.RelaxedHtmlFromRngElementDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   new   Class [  ]  {    RngDomInspection . class ,    UnusedDefineInspection . class    }  ;", "}", "METHOD_END"], "methodName": ["getInspectionClasses"], "fileName": "org.intellij.plugins.relaxNG.ApplicationLoader"}, {"methodBody": ["METHOD_START", "{", "final   ActionManager   mgr    =    ActionManager . getInstance (  )  ;", "final   AnAction   validateAction    =    mgr . getAction (  . VALIDATE _ XML )  ;", "mgr . unregisterAction (  . VALIDATE _ XML )  ;", "mgr . registerAction (  . VALIDATE _ XML ,    new   ValidateAction ( validateAction )  )  ;", "}", "METHOD_END"], "methodName": ["installValidateXmlAction"], "fileName": "org.intellij.plugins.relaxNG.ApplicationLoader"}, {"methodBody": ["METHOD_START", "{", "final   MetaDataRegistrar   registrar    =    MetaDataRegistrar . getInstance (  )  ;", "registrar . registerMetaData ( new   com . intellij . psi . filters . AndFilter ( new   NamespaceFilter (  . RNG _ NAMESPACE )  ,    new   ClassFilter ( XmlDocument . class )  )  ,    RngNsDescriptor . class )  ;", "registrar . registerMetaData ( new   ClassFilter ( RncDocument . class )  ,    RngNsDescriptor . class )  ;", "registrar . registerMetaData ( new   ElementFilter (  )     {", "@ Override", "public   boolean   isAcceptable ( Object   element ,    PsiElement   context )     {", "if    ( element   instanceof   XmlTag )     {", "final   XmlTag   tag    =     (  ( XmlTag )     ( element )  )  ;", "final   DomElement   domElement    =    DomManager . getDomManager ( tag . getProject (  )  )  . getDomElement ( tag )  ;", "return   domElement   instanceof   RngDefine ;", "}", "return   false ;", "}", "@ Override", "public   boolean   isClassAcceptable ( Class   hintClass )     {", "return   XmlTag . class . isAssignableFrom ( hintClass )  ;", "}", "}  ,    RngDefineMetaData . class )  ;", "}", "METHOD_END"], "methodName": ["registerMetaData"], "fileName": "org.intellij.plugins.relaxNG.ApplicationLoader"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" attr - combine . xml \"  ,     \" foo \"  ,     \" bar \"  )  ;", "}", "METHOD_END"], "methodName": ["testAttrCombine"], "fileName": "org.intellij.plugins.relaxNG.AttributeCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" attribute - completion -  1  . xml \"  ,    new   String [  ]  {     \" foo \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeCompletion1"], "fileName": "org.intellij.plugins.relaxNG.AttributeCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" attribute - completion -  2  . xml \"  ,    new   String [  ]  {     \"  1  .  0  \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeCompletion2"], "fileName": "org.intellij.plugins.relaxNG.AttributeCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" attribute - completion -  3  . xml \"  ,     \"  1  .  0  \"  ,     \"  2  .  0  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeCompletion3"], "fileName": "org.intellij.plugins.relaxNG.AttributeCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" attribute - completion -  4  . xml \"  ,     \"  1  .  0  \"  ,     \"  2  .  0  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeCompletion4"], "fileName": "org.intellij.plugins.relaxNG.AttributeCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" attribute - completion -  5  . xml \"  ,     \" foo \"  ,     \" bar \"  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeCompletion5"], "fileName": "org.intellij.plugins.relaxNG.AttributeCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" attribute - completion -  6  . xml \"  ,     \" p : foo \"  ,     \" p : bar \"  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeCompletion6"], "fileName": "org.intellij.plugins.relaxNG.AttributeCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" element - completion -  1  . xml \"  ,    new   String [  ]  {     \" foo \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testElementCompletion1"], "fileName": "org.intellij.plugins.relaxNG.ElementCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" element - completion -  2  . xml \"  ,     \" foo \"  ,     \" bar \"  ,     \" baz \"  )  ;", "}", "METHOD_END"], "methodName": ["testElementCompletion2"], "fileName": "org.intellij.plugins.relaxNG.ElementCompletionTest"}, {"methodBody": ["METHOD_START", "{", "final   WebEditorOptions   options    =    WebEditorOptions . getInstance (  )  ;", "final   boolean   oldValue    =    options . isAutomaticallyInsertRequiredAttributes (  )  ;", "try    {", "options . setAutomaticallyInsertRequiredAttributes ( false )  ;", "doTes (  \" element - completion -  3  \"  ,     \" xml \"  )  ;", "}    finally    {", "options . setAutomaticallyInsertRequiredAttributes ( oldValue )  ;", "}", "}", "METHOD_END"], "methodName": ["testElementCompletion3"], "fileName": "org.intellij.plugins.relaxNG.ElementCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" element - completion - root . xml \"  ,     \" bar \"  ,     \" baz \"  ,     \" completion -  1  \"  ,     \" completion -  2  \"  ,     \" completion -  3  \"  ,     \" foo \"  ,     \" x \"  )  ;", "}", "METHOD_END"], "methodName": ["testElementCompletionRoot"], "fileName": "org.intellij.plugins.relaxNG.ElementCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doExternalToolHighlighting ( s )  ;", "}", "METHOD_END"], "methodName": ["doTestHighlighting"], "fileName": "org.intellij.plugins.relaxNG.ExternalRncParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestHighlighting (  \" escaped . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testParseEscaped"], "fileName": "org.intellij.plugins.relaxNG.ExternalRncParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestHighlighting (  \" escaped - broken -  1  . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testParseEscapedBroken1"], "fileName": "org.intellij.plugins.relaxNG.ExternalRncParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestHighlighting (  \" escaped - broken -  2  . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testParseEscapedBroken2"], "fileName": "org.intellij.plugins.relaxNG.ExternalRncParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestHighlighting (  \" escaped - broken -  3  . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testParseEscapedBroken3"], "fileName": "org.intellij.plugins.relaxNG.ExternalRncParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestHighlighting (  \" escaped - broken -  4  . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testParseEscapedBroken4"], "fileName": "org.intellij.plugins.relaxNG.ExternalRncParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestHighlighting (  \" escaped - broken -  5  . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testParseEscapedBroken5"], "fileName": "org.intellij.plugins.relaxNG.ExternalRncParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestHighlighting (  \" simple . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testParseSimple"], "fileName": "org.intellij.plugins.relaxNG.ExternalRncParsingTest"}, {"methodBody": ["METHOD_START", "{", "final   TestFixtureBuilder < IdeaProjectTestFixture >    builder    =    factory . createFixtureBuilder ( getName (  )  )  ;", "final   EmptyModuleFixtureBuilder   moduleBuilder    =    builder . addModule ( EmptyModuleFixtureBuilder . class )  ;", "final   IdeaProjectTestFixture   fixture    =    builder . getFixture (  )  ;", "final   CodeInsightTestFixture   testFixture    =    factory . createCodeInsightFixture ( fixture )  ;", "final   String   root    =    testFixture . getTempDirPath (  )  ;", "moduleBuilder . addContentRoot ( root )  ;", "moduleBuilder . addSourceRoot (  \"  /  \"  )  ;", "return   testFixture ;", "}", "METHOD_END"], "methodName": ["createContentFixture"], "fileName": "org.intellij.plugins.relaxNG.HighlightingTestBase"}, {"methodBody": ["METHOD_START", "{", "final   TestFixtureBuilder < IdeaProjectTestFixture >    builder    =    factory . createLightFixtureBuilder (  )  ;", "final   IdeaProjectTestFixture   fixture    =    builder . getFixture (  )  ;", "return   factory . createCodeInsightFixture ( fixture )  ;", "}", "METHOD_END"], "methodName": ["createFixture"], "fileName": "org.intellij.plugins.relaxNG.HighlightingTestBase"}, {"methodBody": ["METHOD_START", "{", "final   PsiFile   file    =    myTestFixture . getFile (  )  ;", "final   Document   doc    =    myTestFixture . getEditor (  )  . getDocument (  )  ;", "ExpectedData   data    =    new   ExpectedData ( doc ,    true ,    checkWeakWarnings ,    false ,    file )  ;", "data . init (  )  ;", "PsiDocumentManager . getInstance ( myTestFixture . getProject (  )  )  . commitAllDocuments (  )  ;", "Collection < HighlightInfo >    highlights 1     =    do ( includeExternalToolPass )  ;", "data . checkResult ( highlights 1  ,    doc . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["doCustomHighlighting"], "fileName": "org.intellij.plugins.relaxNG.HighlightingTestBase"}, {"methodBody": ["METHOD_START", "{", "myTestFixture . configureByFile ( name )  ;", "doCustom ( checkWeakWarnings ,    includeExternalToolPass )  ;", "}", "METHOD_END"], "methodName": ["doCustomHighlighting"], "fileName": "org.intellij.plugins.relaxNG.HighlightingTestBase"}, {"methodBody": ["METHOD_START", "{", "doCustomHighlighting ( name ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["doExternalToolHighlighting"], "fileName": "org.intellij.plugins.relaxNG.HighlightingTestBase"}, {"methodBody": ["METHOD_START", "{", "final   Project   project    =    myTestFixture . getProject (  )  ;", "PsiDocumentManager . getInstance ( project )  . commitAllDocuments (  )  ;", "final   Editor   editor    =    myTestFixture . getEditor (  )  ;", "int [  ]    ignore    =     (  ( externalToolPass    =  =    null )     |  |    externalToolPass )     ?    new   int [  ]  {    Pass . LINE _ MARKERS ,    Pass . LOCAL _ INSPECTIONS ,    Pass . POPUP _ HINTS ,    Pass . UPDATE _ ALL ,    Pass . UPDATE _ FOLDING    }     :    new   int [  ]  {    Pass . EXTERNAL _ TOOLS    }  ;", "return   CodeInsightTestFixtureImpl . instantiateAndRun ( myTestFixture . getFile (  )  ,    editor ,    ignore ,    false )  ;", "}", "METHOD_END"], "methodName": ["doHighlighting"], "fileName": "org.intellij.plugins.relaxNG.HighlightingTestBase"}, {"methodBody": ["METHOD_START", "{", "doCustomHighlighting ( s ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["doHighlightingTest"], "fileName": "org.intellij.plugins.relaxNG.HighlightingTestBase"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion ( before ,     \" xml \"  )  ;", "}", "METHOD_END"], "methodName": ["doTestCompletion"], "fileName": "org.intellij.plugins.relaxNG.HighlightingTestBase"}, {"methodBody": ["METHOD_START", "{", "myTestFixture . testCompletion (  (  ( name    +     \"  .  \"  )     +    ext )  ,     (  ( name    +     \"  _ after .  \"  )     +    ext )  )  ;", "}", "METHOD_END"], "methodName": ["doTestCompletion"], "fileName": "org.intellij.plugins.relaxNG.HighlightingTestBase"}, {"methodBody": ["METHOD_START", "{", "myTestFixture . testCompletionVariants ( before ,    variants )  ;", "}", "METHOD_END"], "methodName": ["doTestCompletion"], "fileName": "org.intellij.plugins.relaxNG.HighlightingTestBase"}, {"methodBody": ["METHOD_START", "{", "final   PsiReference   psiReference    =    myTestFixture . getReferenceAtCaretPositionWithAssertion (  (  ( file    +     \"  .  \"  )     +    ext )  )  ;", "assertNull (  \" Reference \"  ,    psiReference . resolve (  )  )  ;", "assertTrue (  (  ( psiReference . getClass (  )  . getName (  )  )     +     \"    is   not   a   QuickFixProvider \"  )  ,     ( psiReference   instanceof   LocalQuickFixProvider )  )  ;", "final   LocalQuickFix [  ]    fixes    =     (  ( LocalQuickFixProvider )     ( psiReference )  )  . getQuickFixes (  )  ;", "assertTrue (  \" One   action   expected \"  ,     (  ( fixes    !  =    null )     &  &     (  ( fixes . length )     =  =     1  )  )  )  ;", "final   Project   project    =    myTestFixture . getProject (  )  ;", "final   ProblemDescriptor   problemDescriptor    =    InspectionManager . getInstance ( project )  . createProblemDescriptor ( psiReference . getElement (  )  ,     \" foo \"  ,    fixes ,    GENERIC _ ERROR _ OR _ WARNING ,    true )  ;", "WriteCommandAction . writeCommandAction ( project ,    myTestFixture . getFile (  )  )  . run (  (  )     -  >     {", "fixes [  0  ]  . applyFix ( project ,    problemDescriptor )  ;", "}  )  ;", "myTestFixture . checkResultByFile (  (  ( file    +     \"  _ after .  \"  )     +    ext )  )  ;", "}", "METHOD_END"], "methodName": ["doTestQuickFix"], "fileName": "org.intellij.plugins.relaxNG.HighlightingTestBase"}, {"methodBody": ["METHOD_START", "{", "myTestFixture . testRename (  (  ( name    +     \"  .  \"  )     +    ext )  ,     (  ( name    +     \"  _ after .  \"  )     +    ext )  ,    newName )  ;", "}", "METHOD_END"], "methodName": ["doTestRename"], "fileName": "org.intellij.plugins.relaxNG.HighlightingTestBase"}, {"methodBody": ["METHOD_START", "{", "return    ( PlatformTestUtil . getCommunityPath (  )  )     +     \"  / xml / relaxng / testData /  \"  ;", "}", "METHOD_END"], "methodName": ["getTestDataBasePath"], "fileName": "org.intellij.plugins.relaxNG.HighlightingTestBase"}, {"methodBody": ["METHOD_START", "{", "ExternalResourceManagerEx . getInstanceEx (  )  . addIgnoredResources ( Collections . singletonList (  \" urn : test : undefined \"  )  ,    getTestRootDisposable (  )  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.intellij.plugins.relaxNG.HighlightingTestBase"}, {"methodBody": ["METHOD_START", "{", "return   FileUtil . toSystemDependentName (  (  ( HighlightingTestBase . getTestDataBasePath (  )  )     +    relativeTestDataPath )  )  ;", "}", "METHOD_END"], "methodName": ["toAbsolutePath"], "fileName": "org.intellij.plugins.relaxNG.HighlightingTestBase"}, {"methodBody": ["METHOD_START", "{", "doTest ( true )  ;", "}", "METHOD_END"], "methodName": ["testFollowing"], "fileName": "org.intellij.plugins.relaxNG.RncAnnotationParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( true )  ;", "}", "METHOD_END"], "methodName": ["testFollowingIncomplete"], "fileName": "org.intellij.plugins.relaxNG.RncAnnotationParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( true )  ;", "}", "METHOD_END"], "methodName": ["testGrammarLevel"], "fileName": "org.intellij.plugins.relaxNG.RncAnnotationParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( true )  ;", "}", "METHOD_END"], "methodName": ["testNested"], "fileName": "org.intellij.plugins.relaxNG.RncAnnotationParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( true )  ;", "}", "METHOD_END"], "methodName": ["testSimple1"], "fileName": "org.intellij.plugins.relaxNG.RncAnnotationParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( true )  ;", "}", "METHOD_END"], "methodName": ["testSimple2"], "fileName": "org.intellij.plugins.relaxNG.RncAnnotationParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" complete - keyword -  1  \"  ,     \" rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteKeyword1"], "fileName": "org.intellij.plugins.relaxNG.RncCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" complete - keyword -  2  \"  ,     \" rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteKeyword2"], "fileName": "org.intellij.plugins.relaxNG.RncCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" complete - ref -  1  \"  ,     \" rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteRef1"], "fileName": "org.intellij.plugins.relaxNG.RncCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" complete - ref -  2  \"  ,     \" rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteRef2"], "fileName": "org.intellij.plugins.relaxNG.RncCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" complete - ref -  3  \"  ,     \" rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteRef3"], "fileName": "org.intellij.plugins.relaxNG.RncCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" complete - ref -  4  \"  ,     \" rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteRef4"], "fileName": "org.intellij.plugins.relaxNG.RncCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doExternalToolHighlighting (  \" addressbook . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testAddressBook"], "fileName": "org.intellij.plugins.relaxNG.RncExternalHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doExternalToolHighlighting (  \" missing - content . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testMissingContent"], "fileName": "org.intellij.plugins.relaxNG.RncExternalHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doExternalToolHighlighting (  \" missing - start . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testMissingStart"], "fileName": "org.intellij.plugins.relaxNG.RncExternalHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doExternalToolHighlighting (  \" rng - schema . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testRngSchema"], "fileName": "org.intellij.plugins.relaxNG.RncExternalHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doExternalToolHighlighting (  \" undefined - ref - ok . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testUndefinedRef"], "fileName": "org.intellij.plugins.relaxNG.RncExternalHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" annotation . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testAnnotation"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" bad - parent - ref -  1  . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testBadParentRef1"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestQuickFix (  \" create - datatypes - prefix -  1  \"  ,     \" rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testCreateDatatypesPrefix"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestQuickFix (  \" create - definition -  1  \"  ,     \" rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testCreateDefintion1"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestQuickFix (  \" create - definition -  2  \"  ,     \" rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testCreateDefintion2"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestQuickFix (  \" create - ns - prefix -  1  \"  ,     \" rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testCreateNsPrefix"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" datatype - prefix . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testDatatypePrefix"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" docbook . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testDocbook"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" fo / datatype . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testFoDatatype"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" fo / elements . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testFoElements"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" fo / main . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testFoMain"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" ns - prefix . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testNsPrefix"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" ns - prefix - keyword . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testNsPrefixKeyword"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" parent - ref . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testParentRef"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" ref -  3  . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testRef3"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" rng - schema . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testRngSchema"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" undefined - ref . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testUndefinedRef"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" unresolved - datatype - prefix -  1  . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testUnresolvedDatatypePrefix1"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" unresolved - datatype - prefix -  2  . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testUnresolvedDatatypePrefix2"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" unresolved - external . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testUnresolvedExternal"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" unresolved - include . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testUnresolvedInclude"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" unresolved - ns - prefix -  1  . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testUnresolvedNsPrefix1"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" unresolved - ns - prefix -  2  . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testUnresolvedNsPrefix2"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" unresolved - ns - prefix -  3  . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testUnresolvedNsPrefix3"], "fileName": "org.intellij.plugins.relaxNG.RncHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" backward - include - ref . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testBackwardIncludeRef"], "fileName": "org.intellij.plugins.relaxNG.RncIndexHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "myTestFixture . configureByFiles (  \" include 1  . rnc \"  ,     \" include 1  _  1  . rnc \"  ,     \" include 1  _  2  . rnc \"  )  ;", "doCustom ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testInclude1"], "fileName": "org.intellij.plugins.relaxNG.RncIndexHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" suppressed - unused - define . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testInspectionSuppressedUnusedDefine"], "fileName": "org.intellij.plugins.relaxNG.RncIndexHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" unused - define . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testInspectionUnusedDefine"], "fileName": "org.intellij.plugins.relaxNG.RncIndexHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" used - define . rnc \"  )  ;", "}", "METHOD_END"], "methodName": ["testInspectionUsedDefine"], "fileName": "org.intellij.plugins.relaxNG.RncIndexHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( true )  ;", "}", "METHOD_END"], "methodName": ["testDatatype"], "fileName": "org.intellij.plugins.relaxNG.RncParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( true )  ;", "}", "METHOD_END"], "methodName": ["testDocbook"], "fileName": "org.intellij.plugins.relaxNG.RncParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( true )  ;", "}", "METHOD_END"], "methodName": ["testElements"], "fileName": "org.intellij.plugins.relaxNG.RncParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( true )  ;", "}", "METHOD_END"], "methodName": ["testExternal"], "fileName": "org.intellij.plugins.relaxNG.RncParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( true )  ;", "}", "METHOD_END"], "methodName": ["testMain"], "fileName": "org.intellij.plugins.relaxNG.RncParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( true )  ;", "}", "METHOD_END"], "methodName": ["testProperties"], "fileName": "org.intellij.plugins.relaxNG.RncParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( true )  ;", "}", "METHOD_END"], "methodName": ["testRelaxNG"], "fileName": "org.intellij.plugins.relaxNG.RncParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTestRename ( name ,     \" rnc \"  ,    newName )  ;", "}", "METHOD_END"], "methodName": ["doTestRename"], "fileName": "org.intellij.plugins.relaxNG.RncRenameTest"}, {"methodBody": ["METHOD_START", "{", "doTestRename (  \" rename - datatype - prefix -  1  \"  ,     \" bar \"  )  ;", "}", "METHOD_END"], "methodName": ["testRenameDatatypePrefix1"], "fileName": "org.intellij.plugins.relaxNG.RncRenameTest"}, {"methodBody": ["METHOD_START", "{", "doTestRename (  \" rename - definition -  1  \"  ,     \" bar \"  )  ;", "}", "METHOD_END"], "methodName": ["testRenameDefinition1"], "fileName": "org.intellij.plugins.relaxNG.RncRenameTest"}, {"methodBody": ["METHOD_START", "{", "doTestRename (  \" rename - definition -  2  \"  ,     \" element \"  )  ;", "}", "METHOD_END"], "methodName": ["testRenameDefinition2"], "fileName": "org.intellij.plugins.relaxNG.RncRenameTest"}, {"methodBody": ["METHOD_START", "{", "doTestRename (  \" rename - definition -  3  \"  ,     \" bar \"  )  ;", "}", "METHOD_END"], "methodName": ["testRenameDefinition3"], "fileName": "org.intellij.plugins.relaxNG.RncRenameTest"}, {"methodBody": ["METHOD_START", "{", "myTestFixture . copyFileToProject (  \" rename - in - include - ref . rnc \"  )  ;", "final   Project   project    =    myTestFixture . getProject (  )  ;", "final   RefactoringFactory   factory    =    RefactoringFactory . getInstance ( project )  ;", "String   fullPath    =     (  ( myTestFixture . getTempDirPath (  )  )     +     \"  /  \"  )     +     \" rename - in - include - ref . rnc \"  ;", "final   VirtualFile   copy    =    LocalFileSystem . getInstance (  )  . refreshAndFindFileByPath ( fullPath . replace ( File . separatorChar ,     '  /  '  )  )  ;", "assert   copy    !  =    null    :     (  \" file    \"     +    fullPath )     +     \"    not   found \"  ;", "final   PsiFile   file    =    PsiManager . getInstance ( project )  . findFile ( copy )  ;", "assertNotNull ( file )  ;", "myTestFixture . configureByFile (  \" rename - in - include . rnc \"  )  ;", "final   Refactoring   refactoring    =    factory . create ( file ,     \" rename - after . rnc \"  )  ;", "refactoring . setPreviewUsages ( false )  ;", "refactoring . setSearchInComments ( false )  ;", "refactoring . setSearchInNonJavaFiles ( true )  ;", "refactoring . run (  )  ;", "myTestFixture . checkResultByFile (  \" rename - in - include _ after . rnc \"  )  ;", "assertEquals (  \" rename - after . rnc \"  ,    file . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRenameIncludedFile"], "fileName": "org.intellij.plugins.relaxNG.RncRenameTest"}, {"methodBody": ["METHOD_START", "{", "doTestRename (  \" rename - ns - prefix -  1  \"  ,     \" bar \"  )  ;", "}", "METHOD_END"], "methodName": ["testRenameNsPrefix1"], "fileName": "org.intellij.plugins.relaxNG.RncRenameTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" complete - ref -  1  . rng \"  ,    new   String [  ]  {     \" start . element \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteRef1"], "fileName": "org.intellij.plugins.relaxNG.RngCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" complete - ref -  2  . rng \"  ,    new   String [  ]  {     \" start . element \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteRef2"], "fileName": "org.intellij.plugins.relaxNG.RngCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" complete - ref -  3  . rng \"  ,    new   String [  ]  {     \" included . start . element \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteRef3"], "fileName": "org.intellij.plugins.relaxNG.RngCompletionTest"}, {"methodBody": ["METHOD_START", "{", "CamelHumpMatcher . forceStartMatching ( getTestRootDisposable (  )  )  ;", "doTest (  \" complete - ref -  4  \"  ,     \" rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteRef4"], "fileName": "org.intellij.plugins.relaxNG.RngCompletionTest"}, {"methodBody": ["METHOD_START", "{", "if    ( tag . getNamespace (  )  . equals ( ApplicationLoader . RNG _ NAMESPACE )  )     {", "final   StringBuilder   sb    =    new   StringBuilder (  )  ;", "sb . append ( kind )  . append (  \"  :     < b >  \"  )  . append ( localName )  . append (  \"  <  / b >  < br >  \"  )  ;", "final   XmlTag [  ]    docTags    =    tag . findSubTags (  \" documentation \"  ,     . COMPATIBILITY _ ANNOTATIONS _  1  _  0  )  ;", "for    ( XmlTag   docTag    :    docTags )     {", "sb . append ( docTag . getValue (  )  . getTrimmedText (  )  )  ;", "sb . append (  \"  \\ n \"  )  ;", "}", "final   XmlTag   nextTag    =    PsiTreeUtil . getNextSiblingOfType ( tag ,    XmlTag . class )  ;", "if    ( nextTag    !  =    null )     {", "if    (  (  \" documentation \"  . equals ( nextTag . getLocalName (  )  )  )     &  &     (  . COMPATIBILITY _ ANNOTATIONS _  1  _  0  . equals ( nextTag . getNamespace (  )  )  )  )     {", "sb . append ( nextTag . getValue (  )  . getTrimmedText (  )  )  ;", "}", "}", "return   sb ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDocumentationFromTag"], "fileName": "org.intellij.plugins.relaxNG.RngDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.intellij.plugins.relaxNG.RngDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( sb    =  =    null )", "turn   null ;", "String   s    =    sb . toString (  ) placeAll (  \"  \\ n \"  ,     \"  < br >  \"  )  ;", "if    (  !  ( s . startsWith (  \"  < html >  \"  )  )  )     {", "s    =    XmlStringUtil . wrapInHtml ( s )  ;", "}", "turn   s ;", "}", "METHOD_END"], "methodName": ["makeDocumentation"], "fileName": "org.intellij.plugins.relaxNG.RngDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "doExternalToolHighlighting (  \" bad - element . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testBadElement"], "fileName": "org.intellij.plugins.relaxNG.RngHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" bad - include . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testBadInclude"], "fileName": "org.intellij.plugins.relaxNG.RngHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" bad - ns - prefix . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testBadNsPrefix"], "fileName": "org.intellij.plugins.relaxNG.RngHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" bad - parent - ref -  1  . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testBadParentRef1"], "fileName": "org.intellij.plugins.relaxNG.RngHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "myTestFixture . copyFileToProject (  \" bad - parent - ref -  1  . rng \"  )  ;", "do (  \" bad - parent - ref -  2  . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testBadParentRef2"], "fileName": "org.intellij.plugins.relaxNG.RngHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" bad - ref . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testBadRef"], "fileName": "org.intellij.plugins.relaxNG.RngHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" bad - ref -  2  . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testBadRef2"], "fileName": "org.intellij.plugins.relaxNG.RngHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" bad - ref -  3  . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testBadRef3"], "fileName": "org.intellij.plugins.relaxNG.RngHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" bad - ref -  4  . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testBadRef4"], "fileName": "org.intellij.plugins.relaxNG.RngHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestQuickFix (  \" create - definition -  1  \"  ,     \" rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testCreateDefinition1"], "fileName": "org.intellij.plugins.relaxNG.RngHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestQuickFix (  \" create - definition -  2  \"  ,     \" rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testCreateDefinition2"], "fileName": "org.intellij.plugins.relaxNG.RngHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "myTestFixture . copyFileToProject (  \" include . rng \"  )  ;", "do (  \" good - include . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testInclude"], "fileName": "org.intellij.plugins.relaxNG.RngHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "myTestFixture . copyFileToProject (  \" include . rng \"  )  ;", "do (  \" good - include - ref -  1  . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testIncludedRef1"], "fileName": "org.intellij.plugins.relaxNG.RngHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doCustomHighlighting (  \" missing - start - element . rng \"  ,    false ,    true )  ;", "}", "METHOD_END"], "methodName": ["testMissingStartElement"], "fileName": "org.intellij.plugins.relaxNG.RngHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "myTestFixture . copyFileToProject (  \" included - grammar . rng \"  )  ;", "doCustom (  \" missing - start - element - and - include . rng \"  ,    false ,    true )  ;", "}", "METHOD_END"], "methodName": ["testMissingStartElementAndInclude"], "fileName": "org.intellij.plugins.relaxNG.RngHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" parent - ref -  1  . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testParentRef1"], "fileName": "org.intellij.plugins.relaxNG.RngHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "myTestFixture . copyFileToProject (  \" include . rng \"  )  ;", "do (  \" parent - ref -  2  . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testParentRef2"], "fileName": "org.intellij.plugins.relaxNG.RngHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" ref -  1  . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testRef1"], "fileName": "org.intellij.plugins.relaxNG.RngHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" ref -  2  . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testRef2"], "fileName": "org.intellij.plugins.relaxNG.RngHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" ref -  3  . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testRef3"], "fileName": "org.intellij.plugins.relaxNG.RngHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "myTestFixture . copyFileToProject (  \" include . rng \"  )  ;", "final   PsiReference   ref    =    myTestFixture . getReferenceAtCaretPositionWithAssertion (  \" resolve - include - ref -  1  . rng \"  )  ;", "final   PsiElement   element    =    ref . resolve (  )  ;", "assertTrue (  ( element   instanceof   XmlTag )  )  ;", "assertNotSame ( element . getContainingFile (  )  ,    ref . getElement (  )  . getContainingFile (  )  )  ;", "assertEquals (  0  ,     (  ( XmlTag )     ( element )  )  . getSubTags (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testResolveIncludedRef1"], "fileName": "org.intellij.plugins.relaxNG.RngHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "myTestFixture . copyFileToProject (  \" include . rng \"  )  ;", "final   PsiReference   ref    =    myTestFixture . getReferenceAtCaretPositionWithAssertion (  \" resolve - include - ref -  2  . rng \"  )  ;", "assertTrue (  \" PolyVariantRef \"  ,     ( ref   instanceof   PsiPolyVariantReference )  )  ;", "final   PsiElement   element    =    ref . resolve (  )  ;", "assertNull ( element )  ;", "final   ResolveResult [  ]    results    =     (  ( PsiPolyVariantReference )     ( ref )  )  . multiResolve ( false )  ;", "assertEquals (  2  ,    results . length )  ;", "for    ( ResolveResult   result    :    results )     {", "PsiElement   e    =    result . getElement (  )  ;", "assertTrue (  ( e   instanceof   XmlTag )  )  ;", "final   int   contentLength    =     (  ( XmlTag )     ( e )  )  . getSubTags (  )  . length ;", "if    (  ( e . getContainingFile (  )  )     =  =     ( ref . getElement (  )  . getContainingFile (  )  )  )     {", "assertEquals (  1  ,    contentLength )  ;", "} else    {", "assertEquals (  0  ,    contentLength )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testResolveIncludedRef2"], "fileName": "org.intellij.plugins.relaxNG.RngHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" simple . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleSchema"], "fileName": "org.intellij.plugins.relaxNG.RngHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "myTestFixture . testCompletionTyping (  \" html 5  _  1  . xml \"  ,     \"  \\ n \"  ,     \" html 5  _  1  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testHtml5_1"], "fileName": "org.intellij.plugins.relaxNG.RngHtml5CompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" html 5  _  1  0  \"  )  ;", "}", "METHOD_END"], "methodName": ["testHtml5_10"], "fileName": "org.intellij.plugins.relaxNG.RngHtml5CompletionTest"}, {"methodBody": ["METHOD_START", "{", "myTestFixture . testCompletionTyping (  \"  / html 5  _  1  1  . xml \"  ,     \"  \\ n \"  ,     \"  / html 5  _  1  1  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testHtml5_11"], "fileName": "org.intellij.plugins.relaxNG.RngHtml5CompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" html 5  _  1  2  \"  )  ;", "}", "METHOD_END"], "methodName": ["testHtml5_12"], "fileName": "org.intellij.plugins.relaxNG.RngHtml5CompletionTest"}, {"methodBody": ["METHOD_START", "{", "myTestFixture . testCompletionTyping (  \"  / html 5  _  1  3  . xml \"  ,     \"  \\ n \"  ,     \"  / html 5  _  1  3  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testHtml5_13"], "fileName": "org.intellij.plugins.relaxNG.RngHtml5CompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" html 5  _  1  4  \"  )  ;", "}", "METHOD_END"], "methodName": ["testHtml5_14"], "fileName": "org.intellij.plugins.relaxNG.RngHtml5CompletionTest"}, {"methodBody": ["METHOD_START", "{", "myTestFixture . testCompletionTyping (  \"  / html 5  _  1  5  . xml \"  ,     \"  \\ n \"  ,     \"  / html 5  _  1  5  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testHtml5_15"], "fileName": "org.intellij.plugins.relaxNG.RngHtml5CompletionTest"}, {"methodBody": ["METHOD_START", "{", "myTestFixture . testCompletionTyping (  \" html 5  _  1  6  . xml \"  ,     \"  \\ n \"  ,     \" html 5  _  1  6  _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testHtml5_16"], "fileName": "org.intellij.plugins.relaxNG.RngHtml5CompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" html 5  _  2  \"  )  ;", "}", "METHOD_END"], "methodName": ["testHtml5_2"], "fileName": "org.intellij.plugins.relaxNG.RngHtml5CompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" html 5  _  3  \"  )  ;", "}", "METHOD_END"], "methodName": ["testHtml5_3"], "fileName": "org.intellij.plugins.relaxNG.RngHtml5CompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" html 5  _  4  \"  )  ;", "}", "METHOD_END"], "methodName": ["testHtml5_4"], "fileName": "org.intellij.plugins.relaxNG.RngHtml5CompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" html 5  _  5  \"  )  ;", "}", "METHOD_END"], "methodName": ["testHtml5_5"], "fileName": "org.intellij.plugins.relaxNG.RngHtml5CompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" html 5  _  6  \"  )  ;", "}", "METHOD_END"], "methodName": ["testHtml5_6"], "fileName": "org.intellij.plugins.relaxNG.RngHtml5CompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" html 5  _  7  \"  )  ;", "}", "METHOD_END"], "methodName": ["testHtml5_7"], "fileName": "org.intellij.plugins.relaxNG.RngHtml5CompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" html 5  _  8  \"  )  ;", "}", "METHOD_END"], "methodName": ["testHtml5_8"], "fileName": "org.intellij.plugins.relaxNG.RngHtml5CompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestCompletion (  \" html 5  _  9  \"  )  ;", "}", "METHOD_END"], "methodName": ["testHtml5_9"], "fileName": "org.intellij.plugins.relaxNG.RngHtml5CompletionTest"}, {"methodBody": ["METHOD_START", "{", "myTestFixture . testCompletionTyping (  \" html 5  _ overwritten _ attributes . xml \"  ,     \" a \\ n \"  ,     \" html 5  _ overwritten _ attributes _ after . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testHtml5_overwritten_attributes"], "fileName": "org.intellij.plugins.relaxNG.RngHtml5CompletionTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" backward - include - ref . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testBackwardIncludeRef"], "fileName": "org.intellij.plugins.relaxNG.RngIndexHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doCustomHighlighting (  \" included - grammar . rng \"  ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testIncludedGrammarWithoutStart"], "fileName": "org.intellij.plugins.relaxNG.RngIndexHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" used - define -  1  . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testInspectionDefine1"], "fileName": "org.intellij.plugins.relaxNG.RngIndexHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" used - define -  2  . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testInspectionDefine2"], "fileName": "org.intellij.plugins.relaxNG.RngIndexHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" used - define -  3  - include . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testInspectionDefine3"], "fileName": "org.intellij.plugins.relaxNG.RngIndexHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" unused - define -  1  . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testInspectionUnusedDefine1"], "fileName": "org.intellij.plugins.relaxNG.RngIndexHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" unused - define -  2  . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testInspectionUnusedDefine2"], "fileName": "org.intellij.plugins.relaxNG.RngIndexHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" backward - with - include . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testUnrelatedBackwardIncludeRef"], "fileName": "org.intellij.plugins.relaxNG.RngIndexHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestRename ( name ,     \" rng \"  ,    newName )  ;", "}", "METHOD_END"], "methodName": ["doTestRename"], "fileName": "org.intellij.plugins.relaxNG.RngRenameTest"}, {"methodBody": ["METHOD_START", "{", "doTestRename (  \" rename - ref -  1  \"  ,     \" start \"  )  ;", "}", "METHOD_END"], "methodName": ["testRenameRef1"], "fileName": "org.intellij.plugins.relaxNG.RngRenameTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" attribute - choice -  1  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeChoice1"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" attribute - choice -  2  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeChoice2"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" attribute - choice -  3  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeChoice3"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" rnc / bad - element . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testBadElementRnc"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" docbook . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testDocBookSchema"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" mybook . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testDocbookExample"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" fixed - attribute _  1  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testFixedAttribute"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" fixed - attribute _  2  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testFixedAttributeIllegal"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" rnc / fo / mybook . fo \"  )  ;", "}", "METHOD_END"], "methodName": ["testFoFromDocbook"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" Html 5  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testHtml5"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" Html 5  _  2  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testHtml5_2"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" rnc / missing - attribute . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testMissingAttributeRnc"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" nested - composite . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testNestedComposite"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" nested - fragment . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testNestedFragment"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "myTestFixture . copyFileToProject (  \" jpdl -  3  .  1  . xsd \"  )  ;", "do (  \" nested - fragment -  2  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testNestedFragment2"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" optional - attribute _  1  . xml \"  )  ;", "doHighlightingTest (  \" optional - attribute _  2  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testOptionalAttribute"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" optional - element _  1  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testOptionalElement"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" relaxng . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testRngSchema"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" simple - attribute _  1  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleAttribute"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" simple - attribute _  2  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleAttributeMissing"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" simple - element _  1  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleElement"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" token - datatype . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testTokenDatatype"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" rnc / valid - rnc - include . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testValidIncludeRnc"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" rnc / valid - rnc . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testValidRnc"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" value - choice -  1  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testValueChoice1"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" value - choice -  2  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testValueChoice2"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" rnc / fo / fo - test . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testXslFoRncSchema"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doHighlightingTest (  \" xslt . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testXsltSchema"], "fileName": "org.intellij.plugins.relaxNG.RngXmlHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doExternalToolHighlighting ( name )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "org.intellij.plugins.relaxNG.RngXmlValidationTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" cdata - test . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testCDATA"], "fileName": "org.intellij.plugins.relaxNG.RngXmlValidationTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" entity - test -  1  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testEntityRef1"], "fileName": "org.intellij.plugins.relaxNG.RngXmlValidationTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" entity - test -  2  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testEntityRef2"], "fileName": "org.intellij.plugins.relaxNG.RngXmlValidationTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" entity - test -  3  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testEntityRef3"], "fileName": "org.intellij.plugins.relaxNG.RngXmlValidationTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" invalid - element . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testInvalidElement"], "fileName": "org.intellij.plugins.relaxNG.RngXmlValidationTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" invalid - element - rnc . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testInvalidElementRnc"], "fileName": "org.intellij.plugins.relaxNG.RngXmlValidationTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" missing - element . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testMissingElement"], "fileName": "org.intellij.plugins.relaxNG.RngXmlValidationTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" missing - element - rnc . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testMissingElementRnc"], "fileName": "org.intellij.plugins.relaxNG.RngXmlValidationTest"}, {"methodBody": ["METHOD_START", "{", "myTestFixture . testHighlighting (  \" broken - rnc . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testPartiallyBrokenRnc"], "fileName": "org.intellij.plugins.relaxNG.RngXmlValidationTest"}, {"methodBody": ["METHOD_START", "{", "myTestFixture . testHighlighting (  \" broken - rng . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testPartiallyBrokenRng"], "fileName": "org.intellij.plugins.relaxNG.RngXmlValidationTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" text - content . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testTextContent"], "fileName": "org.intellij.plugins.relaxNG.RngXmlValidationTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" xslt . rng \"  )  ;", "}", "METHOD_END"], "methodName": ["testValidDocument"], "fileName": "org.intellij.plugins.relaxNG.RngXmlValidationTest"}, {"methodBody": ["METHOD_START", "{", "final   TextRange   rangeInElement    =    reference . getRangeInElement (  )  ;", "final   TextRange   range    =    TextRange . from (  (  ( reference . getElement (  )  . getTextRange (  )  . getStartOffset (  )  )     +     ( rangeInElement . getStartOffset (  )  )  )  ,    rangeInElement . getLength (  )  )  ;", "final   Annotation   annotation ;", "if    ( reference   instanceof   EmptyResolveMessageProvider )     {", "final   String   s    =     (  ( EmptyResolveMessageProvider )     ( reference )  )  . getUnresolvedMessagePattern (  )  ;", "annotation    =    myHolder . createErrorAnnotation ( range ,    MessageFormat . format ( s ,    reference . getCanonicalText (  )  )  )  ;", "} else    {", "annotation    =    myHolder . createErrorAnnotation ( range ,     \" Cannot   resolve   symbol \"  )  ;", "}", "annotation . setHighlightType ( LIKE _ UNKNOWN _ SYMBOL )  ;", "if    ( reference   instanceof   LocalQuickFixProvider )     {", "LocalQuickFix [  ]    fixes    =     (  ( LocalQuickFixProvider )     ( reference )  )  . getQuickFixes (  )  ;", "if    ( fixes    !  =    null )     {", "InspectionManager   inspectionManager    =    InspectionManager . getInstance ( reference . getElement (  )  . getProject (  )  )  ;", "for    ( LocalQuickFix   fix    :    fixes )     {", "ProblemDescriptor   descriptor    =    inspectionManager . createProblemDescriptor ( reference . getElement (  )  ,    annotation . getMessage (  )  ,    fix ,    LIKE _ UNKNOWN _ SYMBOL ,    true )  ;", "annotation . registerFix ( fix ,    null ,    null ,    descriptor )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["addError"], "fileName": "org.intellij.plugins.relaxNG.compact.ReferenceAnnotator"}, {"methodBody": ["METHOD_START", "{", "for    ( PsiReference   reference    :    references )     {", "if    (  !  ( reference . isSoft (  )  )  )     {", "if    (  ( reference . resolve (  )  )     =  =    null )     {", "if    ( reference   instanceof   PsiPolyVariantReference )     {", "final   PsiPolyVariantReference   pvr    =     (  ( PsiPolyVariantReference )     ( reference )  )  ;", "if    (  ( pvr . multiResolve ( false )  . length )     =  =     0  )     {", "addError ( reference )  ;", "}", "} else    {", "addError ( reference )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["checkReferences"], "fileName": "org.intellij.plugins.relaxNG.compact.ReferenceAnnotator"}, {"methodBody": ["METHOD_START", "{", "return    ( PsiTreeUtil . getPrevSiblingOfType ( context . getParent (  )  ,    RncDefine . class )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["afterPattern"], "fileName": "org.intellij.plugins.relaxNG.compact.RncCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   next    =    PsiTreeUtil . skipWhitespacesForward ( context )  ;", "if    (  ( next    !  =    null )     &  &     ( EscapeUtil . unescapeText ( next )  . equals (  \"  =  \"  )  )  )     {", "return   new   String [  ]  {     \" start \"     }  ;", "}", "if    ( RncCompletionContributor . DEFAULT _ PATTERN . accepts ( context )  )     {", "return   new   String [  ]  {     \" namespace \"     }  ;", "} else", "if    ( RncCompletionContributor . DECL _ PATTERN . accepts ( context )  )     {", "return   com . intellij . util . ArrayUtil . EMPTY _ STRING _ ARRAY ;", "} else", "if    (  (  ( context . getParent (  )  )    instanceof   psi . RncDefine )     &  &     (  ( context . getParent (  )  . getFirstChild (  )  )     =  =    context )  )     {", "if    ( RncCompletionContributor . DEFINE _ PATTERN . accepts ( context )  )     {", "return   com . intellij . util . ArrayUtil . EMPTY _ STRING _ ARRAY ;", "}", "if    ( RncCompletionContributor . TOP _ LEVEL . accepts ( context )  )     {", "if    (  !  ( RncCompletionContributor . afterPattern ( context )  )  )     {", "return   com . intellij . util . ArrayUtil . mergeArrays ( RncCompletionContributor . DECL _ KEYWORDS ,    com . intellij . util . ArrayUtil . mergeArrays ( RncCompletionContributor . GRAMMAR _ CONTENT _ KEYWORDS ,    RncCompletionContributor . PATTERN _ KEYWORDS )  )  ;", "}", "}", "return   RncCompletionContributor . GRAMMAR _ CONTENT _ KEYWORDS ;", "}", "return   RncCompletionContributor . PATTERN _ KEYWORDS ;", "}", "METHOD_END"], "methodName": ["getKeywords"], "fileName": "org.intellij.plugins.relaxNG.compact.RncCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "return   RncFileType . INSTANCE ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.intellij.plugins.relaxNG.compact.RncFileType"}, {"methodBody": ["METHOD_START", "{", "assert    !  ( RncTokenTypes . ourTokenTypes . isEmpty (  )  )  ;", "final   IElementType   type    =    RncTokenTypes . ourTokenTypes . get ( i )  ;", "assert   type    !  =    null    :     \" Unknown   token   kind :     \"     +    i ;", "return   type ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.intellij.plugins.relaxNG.compact.RncTokenTypes"}, {"methodBody": ["METHOD_START", "{", "assert    !  ( RncTokenTypes . ourTokenTypes . isEmpty (  )  )  ;", "final   Ref < IElementType >    ref    =    new   Ref (  )  ;", "RncTokenTypes . ourTokenTypes . forEachValue (  (    iElementType )     -  >     {", "if    ( iElementType . toString (  )  . equals ( name )  )     {", "ref . set ( iElementType )  ;", "return   false ;", "}", "return   true ;", "}  )  ;", "return   ref . get (  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.intellij.plugins.relaxNG.compact.RncTokenTypes"}, {"methodBody": ["METHOD_START", "{", "if    (  ( node    !  =    null )     &  &     ( tokens . contains ( node . getElementType (  )  )  )  )     {", "final   ASTNode   start    =    node ;", "ASTNode   end    =    start ;", "node    =    node . getTreeNext (  )  ;", "if    ( node    !  =    null )     {", "do    {", "end    =    node ;", "node    =    node . getTreeNext (  )  ;", "}    while    (  ( node    !  =    null )     &  &     ( tokens . contains ( node . getElementType (  )  )  )     )  ;", "}", "if    ( end    !  =    start )     {", "while    (  ( end . getPsi (  )  )    instanceof   PsiWhiteSpace )     {", "end    =    end . getTreePrev (  )  ;", "}", "if    (  . isOnDifferentLine ( start ,    end ,    document )  )     {", "regions . add ( new   FoldingDescriptor ( start ,    new   com . intellij . openapi . util . TextRange ( start . getStartOffset (  )  ,    end . getTextRange (  )  . getEndOffset (  )  )  )  )  ;", "}", "}", "}", "return   node ;", "}", "METHOD_END"], "methodName": ["checkNodeAndSiblings"], "fileName": "org.intellij.plugins.relaxNG.compact.folding.RncFoldingBuilder"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( RncElementTypes . ANNOTATION )     =  =    type )     |  |     (  ( RncElementTypes . ANNOTATION _ ELEMENT )     =  =    type )  )     |  |     (  ( RncElementTypes . FORWARD _ ANNOTATION )     =  =    type )  ;", "}", "METHOD_END"], "methodName": ["isAnnotation"], "fileName": "org.intellij.plugins.relaxNG.compact.folding.RncFoldingBuilder"}, {"methodBody": ["METHOD_START", "{", "return    ( RncTokenTypes . COMMENTS . contains ( type )  )     |  |     ( RncTokenTypes . DOC _ TOKENS . contains ( type )  )  ;", "}", "METHOD_END"], "methodName": ["isCommentLike"], "fileName": "org.intellij.plugins.relaxNG.compact.folding.RncFoldingBuilder"}, {"methodBody": ["METHOD_START", "{", "return    ( document . getLineNumber ( first . getStartOffset (  )  )  )     !  =     ( document . getLineNumber ( second . getStartOffset (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isOnDifferentLine"], "fileName": "org.intellij.plugins.relaxNG.compact.folding.RncFoldingBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( node    =  =    null )     {", "return ;", "}", "final   ASTNode [  ]    braces    =    node . getChildren ( RncTokenTypes . BRACES )  ;", "if    (  ( braces . length )     =  =     2  )     {", "final   ASTNode   lbrace    =    braces [  0  ]  ;", "final   ASTNode   rbrace    =    braces [  1  ]  ;", "if    (  . shouldFold ( lbrace ,    rbrace ,    document )  )     {", "final   TextRange   range    =    new   TextRange ( lbrace . getStartOffset (  )  ,    rbrace . getTextRange (  )  . getEndOffset (  )  )  ;", "regions . add ( new   FoldingDescriptor ( lbrace ,    range )  )  ;", "}", "} else", "if    (  . isAnnotation ( node . getElementType (  )  )  )     {", "if    (  . isOnDifferentLine ( node . getFirstChildNode (  )  ,    node . getLastChildNode (  )  ,    document )  )     {", "regions . add ( new   FoldingDescriptor ( node ,    node . getTextRange (  )  )  )  ;", "}", "}", "node    =    node . getFirstChildNode (  )  ;", "while    ( node    !  =    null )     {", "node    =     . checkNodeAndSiblings ( node ,    RncTokenTypes . DOC _ TOKENS ,    regions ,    document )  ;", "node    =     . checkNodeAndSiblings ( node ,    RncTokenTypes . COMMENTS ,    regions ,    document )  ;", ". process ( node ,    document ,    regions )  ;", "if    ( node    !  =    null )     {", "node    =    node . getTreeNext (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["process"], "fileName": "org.intellij.plugins.relaxNG.compact.folding.RncFoldingBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( first . getElementType (  )  )     !  =     ( RncTokenTypes . LBRACE )  )     {", "return   false ;", "} else", "if    (  ( second . getElementType (  )  )     !  =     ( RncTokenTypes . RBRACE )  )     {", "return   false ;", "} else    {", "return    . isOnDifferentLine ( first ,    second ,    document )  ;", "}", "}", "METHOD_END"], "methodName": ["shouldFold"], "fileName": "org.intellij.plugins.relaxNG.compact.folding.RncFoldingBuilder"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   parent    =    myNode . getTreeParent (  )  . getPsi (  )  ;", "return    (  ( parent   tanceof   RncDocument )     |  |     ( parent   tanceof   RncFile )  )     |  |     (  ( parent   tanceof   RncGrammar )     &  &     (  ( parent . getParent (  )  )    tanceof   RncDocument )  )  ;", "}", "METHOD_END"], "methodName": ["isTopLevel"], "fileName": "org.intellij.plugins.relaxNG.compact.formatting.RncBlock"}, {"methodBody": ["METHOD_START", "{", "return   Spacing . createSpacing (  0  ,    Integer . MAX _ VALUE ,     1  ,    true ,     1  0  0  )  ;", "}", "METHOD_END"], "methodName": ["makeNewline"], "fileName": "org.intellij.plugins.relaxNG.compact.formatting.RncBlock"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   CompactSyntaxTokenManager ( new   SimpleCharStream ( preprocessor ,     1  ,     1  )  ,    initialState )  ;", "}    catch    ( NoSuchMethodError   e )     {", "final   Class < CompactSyntaxTokenManager >    managerClass    =    CompactSyntaxTokenManager . class ;", ". LOG . error (  \" Unsupported   version   of   RNGOM   in   classpath .    Please   check   your   IDEA   and   JDK   installation .  \"  ,    e ,     (  \" Actual   parameter   types :     \"     +     ( Arrays . toString ( managerClass . getConstructors (  )  [  0  ]  . getParameterTypes (  )  )  )  )  ,     (  (  (  \" Location   of    \"     +     ( managerClass . getName (  )  )  )     +     \"  :     \"  )     +     (  . getSourceLocation ( managerClass )  )  )  ,     (  (  (  \" Location   of    \"     +     ( CharStream . class . getName (  )  )  )     +     \"  :     \"  )     +     (  . getSourceLocation ( CharStream . class )  )  )  )  ;", "throw   e ;", "}", "}", "METHOD_END"], "methodName": ["createTokenManager"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.CompactSyntaxLexerAdapter"}, {"methodBody": ["METHOD_START", "{", "return   CharArrayUtil . fromSequence ( myBuffer )  ;", "}", "METHOD_END"], "methodName": ["getBuffer"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.CompactSyntaxLexerAdapter"}, {"methodBody": ["METHOD_START", "{", "final   CodeSource   source    =    clazz . getProtectionDomain (  )  . getCodeSource (  )  ;", "if    ( source    !  =    null )     {", "final   URL   location    =    source . getLocation (  )  ;", "if    ( location    !  =    null )     {", "return   location . toExnalForm (  )  ;", "}", "}", "final   String   name    =     ( clazz . getName (  )  . replace (  '  .  '  ,     '  /  '  )  )     +     \"  . class \"  ;", "final   ClassLoader   loader    =    clazz . getClassLoader (  )  ;", "final   URL   resource    =     ( loader    !  =    null )     ?    loader . getResource ( name )     :    ClassLoader . getSystemResource ( name )  ;", "return   resource    !  =    null    ?    resource . toExnalForm (  )     :     \"  < unknown >  \"  ;", "}", "METHOD_END"], "methodName": ["getSourceLocation"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.CompactSyntaxLexerAdapter"}, {"methodBody": ["METHOD_START", "{", "myEndOffset    =    endOffset ;", "myLengthMap    =    new   TIntIntHashMap (  )  ;", "myLexer    =     . createTokenManager ( initialState ,    new   EscapePreprocessor ( reader ,    startOffset ,    myLengthMap )  )  ;", "myCurrentToken    =     . START ;", "myCurrentOffset    =    startOffset ;", "myCurrentEnd    =    startOffset ;", "myTokenQueue . clear (  )  ;", "advance (  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.CompactSyntaxLexerAdapter"}, {"methodBody": ["METHOD_START", "{", "final   CompactSyntaxLexerAdapter   lexer    =    new   CompactSyntaxLexerAdapter (  )  ;", "lexer . start ( new   com . intellij . util . text . CharArrayCharSequence ( FileUtil . adaptiveLoadText ( new   FileReader ( args [  0  ]  )  )  )  )  ;", "while    (  ( lexer . getTokenType (  )  )     !  =    null )     {", "System . out . println (  (  \" token    =     \"     +     ( lexer . getTokenType (  )  )  )  )  ;", "final   int   start    =    lexer . getTokenStart (  )  ;", "System . out . println (  (  \" start    =     \"     +    start )  )  ;", "final   int   end    =    lexer . getTokenEnd (  )  ;", "System . out . println (  (  \" end    =     \"     +    end )  )  ;", "final   CharSequence   t    =    lexer . getBufferSequence (  )  . subSequence ( start ,    end )  ;", "System . out . println (  (  \" t    =     \"     +    t )  )  ;", "lexer . advance (  )  ;", "}", "}", "METHOD_END"], "methodName": ["main"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.CompactSyntaxLexerAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myTokenQueue . size (  )  )     >     0  )     {", "return   myTokenQueue . removeFirst (  )  ;", "}", "final   Token   t    =    my . getNextToken (  )  ;", "if    (  ( t . specialToken )     !  =    null )     {", "myTokenQueue . addFirst ( t )  ;", "for    ( Token   s    =    t . specialToken ;    s    !  =    null ;    s    =    s . specialToken )     {", "myTokenQueue . addFirst ( s )  ;", "}", "return   myTokenQueue . removeFirst (  )  ;", "} else    {", "return   t ;", "}", "}", "METHOD_END"], "methodName": ["nextToken"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.CompactSyntaxLexerAdapter"}, {"methodBody": ["METHOD_START", "{", "myBuffer    =    new   CharArrayCharSequence ( buffer ,    startOffset ,    endOffset )  ;", "final   CharArrayReader   reader    =    new   CharArrayReader ( buffer ,    startOffset ,     ( endOffset    -    startOffset )  )  ;", "init ( startOffset ,    endOffset ,    reader ,    initialState )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.CompactSyntaxLexerAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myQueuedChars . size (  )  )     >     0  )     {", "( myOffset )  +  +  ;", "return   myQueuedCharmove (  0  )  ;", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["consume"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.EscapePreprocessor"}, {"methodBody": ["METHOD_START", "{", "myQueuedChars . remove (  0  ,    n )  ;", "}", "METHOD_END"], "methodName": ["consume"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.EscapePreprocessor"}, {"methodBody": ["METHOD_START", "{", "if    ( Character . isDigit ( i )  )", "return   true ;", "final   char   c    =    Character . toLowerCase ( i )  ;", "return    ( c    >  =     ' a '  )     &  &     ( c    <  =     ' f '  )  ;", "}", "METHOD_END"], "methodName": ["isHexChar"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.EscapePreprocessor"}, {"methodBody": ["METHOD_START", "{", "final   int   i    =    super . read (  )  ;", "if    ( i    =  =     (  -  1  )  )     {", "return    -  1  ;", "}", "myQueuedChars . add ( i )  ;", "return   i ;", "}", "METHOD_END"], "methodName": ["peek"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.EscapePreprocessor"}, {"methodBody": ["METHOD_START", "{", "tokenBegin    =     -  1  ;", "char   c    =    read (  )  ;", "tokenBegin    =    bufpos ;", "return   c ;", "}", "METHOD_END"], "methodName": ["BeginToken"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.SimpleCharStream"}, {"methodBody": ["METHOD_START", "{", "buffer    =    null ;", "bufline    =    null ;", "bufcolumn    =    null ;", "}", "METHOD_END"], "methodName": ["Done"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.SimpleCharStream"}, {"methodBody": ["METHOD_START", "{", "char [  ]    newbuffer    =    new   char [  ( bufsize )     +     2  0  4  8  ]  ;", "int [  ]    newbufline    =    new   int [  ( bufsize )     +     2  0  4  8  ]  ;", "int [  ]    newbufcolumn    =    new   int [  ( bufsize )     +     2  0  4  8  ]  ;", "try    {", "if    ( wrapAround )     {", "System . arraycopy ( buffer ,    tokenBegin ,    newbuffer ,     0  ,     (  ( bufsize )     -     ( tokenBegin )  )  )  ;", "System . arraycopy ( buffer ,     0  ,    newbuffer ,     (  ( bufsize )     -     ( tokenBegin )  )  ,    bufpos )  ;", "buffer    =    newbuffer ;", "System . arraycopy ( bufline ,    tokenBegin ,    newbufline ,     0  ,     (  ( bufsize )     -     ( tokenBegin )  )  )  ;", "System . arraycopy ( bufline ,     0  ,    newbufline ,     (  ( bufsize )     -     ( tokenBegin )  )  ,    bufpos )  ;", "bufline    =    newbufline ;", "System . arraycopy ( bufcolumn ,    tokenBegin ,    newbufcolumn ,     0  ,     (  ( bufsize )     -     ( tokenBegin )  )  )  ;", "System . arraycopy ( bufcolumn ,     0  ,    newbufcolumn ,     (  ( bufsize )     -     ( tokenBegin )  )  ,    bufpos )  ;", "bufcolumn    =    newbufcolumn ;", "maxNextInd    =    bufpos    +  =     ( bufsize )     -     ( tokenBegin )  ;", "} else    {", "System . arraycopy ( buffer ,    tokenBegin ,    newbuffer ,     0  ,     (  ( bufsize )     -     ( tokenBegin )  )  )  ;", "buffer    =    newbuffer ;", "System . arraycopy ( bufline ,    tokenBegin ,    newbufline ,     0  ,     (  ( bufsize )     -     ( tokenBegin )  )  )  ;", "bufline    =    newbufline ;", "System . arraycopy ( bufcolumn ,    tokenBegin ,    newbufcolumn ,     0  ,     (  ( bufsize )     -     ( tokenBegin )  )  )  ;", "bufcolumn    =    newbufcolumn ;", "maxNextInd    =    bufpos    -  =    tokenBegin ;", "}", "}    catch    ( Throwable   t )     {", "throw   new   Error ( t . getMessage (  )  )  ;", "}", "bufsize    +  =     2  0  4  8  ;", "available    =    bufsize ;", "tokenBegin    =     0  ;", "}", "METHOD_END"], "methodName": ["ExpandBuff"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.SimpleCharStream"}, {"methodBody": ["METHOD_START", "{", "if    (  ( maxNextCharInd )     =  =     ( available )  )     {", "if    (  ( available )     =  =     ( bufsize )  )     {", "if    (  ( tokenBegin )     >     2  0  4  8  )     {", "bufpos    =    maxNextCharInd    =     0  ;", "available    =    tokenBegin ;", "} else", "if    (  ( tokenBegin )     <     0  )", "bufpos    =    maxNextCharInd    =     0  ;", "else", "ExpandBuff ( false )  ;", "} else", "if    (  ( available )     >     ( tokenBegin )  )", "available    =    bufsize ;", "else", "if    (  (  ( tokenBegin )     -     ( available )  )     <     2  0  4  8  )", "ExpandBuff ( true )  ;", "else", "available    =    tokenBegin ;", "}", "int   i ;", "try    {", "if    (  ( i    =    input . read ( buffer ,    maxNextCharInd ,     (  ( available )     -     ( maxNextCharInd )  )  )  )     =  =     (  -  1  )  )     {", "input . close (  )  ;", "throw   new   IOException (  )  ;", "} else", "maxNextCharInd    +  =    i ;", "return ;", "}    catch    ( IOException   e )     {", "-  -  ( bufpos )  ;", "backup (  0  )  ;", "if    (  ( tokenBegin )     =  =     (  -  1  )  )", "tokenBegin    =    bufpos ;", "throw   new   EOFException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["FillBuff"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.SimpleCharStream"}, {"methodBody": ["METHOD_START", "{", "if    (  ( bufpos )     >  =     ( tokenBegin )  )", "return   new   String ( buffer ,    tokenBegin ,     (  (  ( bufpos )     -     ( tokenBegin )  )     +     1  )  )  ;", "else", "return    ( new   String ( buffer ,    tokenBegin ,     (  ( bufsize )     -     ( tokenBegin )  )  )  )     +     ( new   String ( buffer ,     0  ,     (  ( bufpos )     +     1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["GetImage"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.SimpleCharStream"}, {"methodBody": ["METHOD_START", "{", "char [  ]    ret    =    new   char [ len ]  ;", "if    (  (  ( bufpos )     +     1  )     >  =    len )", "System . arraycopy ( buffer ,     (  (  ( bufpos )     -    len )     +     1  )  ,    ret ,     0  ,    len )  ;", "else    {", "System . arraycopy ( buffer ,     (  ( bufsize )     -     (  ( len    -     ( bufpos )  )     -     1  )  )  ,    ret ,     0  ,     (  ( len    -     ( bufpos )  )     -     1  )  )  ;", "System . arraycopy ( buffer ,     0  ,    ret ,     (  ( len    -     ( bufpos )  )     -     1  )  ,     (  ( bufpos )     +     1  )  )  ;", "}", "return   ret ;", "}", "METHOD_END"], "methodName": ["GetSuffix"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.SimpleCharStream"}, {"methodBody": ["METHOD_START", "{", "ReInit ( dstream ,     1  ,     1  ,     4  0  9  6  )  ;", "}", "METHOD_END"], "methodName": ["ReInit"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.SimpleCharStream"}, {"methodBody": ["METHOD_START", "{", "ReInit ( dstream ,    startline ,    startcolumn ,     4  0  9  6  )  ;", "}", "METHOD_END"], "methodName": ["ReInit"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.SimpleCharStream"}, {"methodBody": ["METHOD_START", "{", "ReInit ( new   InputStreamReader ( dstream )  ,    startline ,    startcolumn ,    buffersize )  ;", "}", "METHOD_END"], "methodName": ["ReInit"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.SimpleCharStream"}, {"methodBody": ["METHOD_START", "{", "ReInit ( dstream ,     1  ,     1  ,     4  0  9  6  )  ;", "}", "METHOD_END"], "methodName": ["ReInit"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.SimpleCharStream"}, {"methodBody": ["METHOD_START", "{", "ReInit ( dstream ,    startline ,    startcolumn ,     4  0  9  6  )  ;", "}", "METHOD_END"], "methodName": ["ReInit"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.SimpleCharStream"}, {"methodBody": ["METHOD_START", "{", "inputStream    =    dstream ;", "line    =    startline ;", "column    =    startcolumn    -     1  ;", "if    (  (  ( buffer )     =  =    null )     |  |     ( buffersize    !  =     ( buffer . length )  )  )     {", "available    =    bufsize    =    buffersize ;", "buffer    =    new   char [ buffersize ]  ;", "bufline    =    new   int [ buffersize ]  ;", "bufcolumn    =    new   int [ buffersize ]  ;", "}", "prevCharIsLF    =    prevCharIsCR    =    false ;", "tokenBegin    =    inBuf    =    maxNextCharInd    =     0  ;", "bufpos    =     -  1  ;", "}", "METHOD_END"], "methodName": ["ReInit"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.SimpleCharStream"}, {"methodBody": ["METHOD_START", "{", "( column )  +  +  ;", "if    ( prevIsLF )     {", "prevIsLF    =    false ;", "line    +  =    column    =     1  ;", "} else", "if    ( prevIsCR )     {", "prevIsCR    =    false ;", "if    ( c    =  =     '  \\ n '  )     {", "prevIsLF    =    true ;", "} else", "line    +  =    column    =     1  ;", "}", "switch    ( c )     {", "case    '  \\ r '     :", "prevIsCR    =    true ;", "break ;", "case    '  \\ n '     :", "prevIsLF    =    true ;", "break ;", "case    '  \\ t '     :", "( column )  -  -  ;", "column    +  =     8     -     (  ( column )     &     7  )  ;", "break ;", "default    :", "break ;", "}", "bufline [ bufpos ]     =    line ;", "bufcolumn [ bufpos ]     =    column ;", "}", "METHOD_END"], "methodName": ["UpdateLineColumn"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.SimpleCharStream"}, {"methodBody": ["METHOD_START", "{", "int   start    =    tokenBegin ;", "int   len ;", "if    (  ( bufpos )     >  =     ( tokenBegin )  )     {", "len    =     (  (  ( bufpos )     -     ( tokenBegin )  )     +     ( inBuf )  )     +     1  ;", "} else    {", "len    =     (  (  (  ( bufsize )     -     ( tokenBegin )  )     +     ( bufpos )  )     +     1  )     +     ( inBuf )  ;", "}", "int   i    =     0  ;", "int   j    =     0  ;", "int   k    =     0  ;", "int   nextColDiff    =     0  ;", "int   columnDiff    =     0  ;", "while    (  ( i    <    len )     &  &     (  ( bufline [  ( j    =    start    %     ( bufsize )  )  ]  )     =  =     ( bufline [  ( k    =     (  +  + start )     %     ( bufsize )  )  ]  )  )  )     {", "bufline [ j ]     =    newLine ;", "nextColDiff    =     ( columnDiff    +     ( bufcolumn [ k ]  )  )     -     ( bufcolumn [ j ]  )  ;", "bufcolumn [ j ]     =    newCol    +    columnDiff ;", "columnDiff    =    nextColDiff ;", "i +  +  ;", "}", "if    ( i    <    len )     {", "bufline [ j ]     =    newLine +  +  ;", "bufcolumn [ j ]     =    newCol    +    columnDiff ;", "while    (  ( i +  +  )     <    len )     {", "if    (  ( bufline [  ( j    =    start    %     ( bufsize )  )  ]  )     !  =     ( bufline [  (  (  +  + start )     %     ( bufsize )  )  ]  )  )", "bufline [ j ]     =    newLine +  +  ;", "else", "bufline [ j ]     =    newLine ;", "}", "}", "line    =    bufline [ j ]  ;", "column    =    bufcolumn [ j ]  ;", "}", "METHOD_END"], "methodName": ["adjustBeginLineColumn"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.SimpleCharStream"}, {"methodBody": ["METHOD_START", "{", "inBuf    +  =    amount ;", "if    (  ( bufpos    -  =    amount )     <     0  )", "bufpos    +  =    bufsize ;", "}", "METHOD_END"], "methodName": ["backup"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.SimpleCharStream"}, {"methodBody": ["METHOD_START", "{", "return   bufcolumn [ tokenBegin ]  ;", "}", "METHOD_END"], "methodName": ["getBeginColumn"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.SimpleCharStream"}, {"methodBody": ["METHOD_START", "{", "return   bufline [ tokenBegin ]  ;", "}", "METHOD_END"], "methodName": ["getBeginLine"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.SimpleCharStream"}, {"methodBody": ["METHOD_START", "{", "return   bufcolumn [ bufpos ]  ;", "}", "METHOD_END"], "methodName": ["getColumn"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.SimpleCharStream"}, {"methodBody": ["METHOD_START", "{", "return   bufcolumn [ bufpos ]  ;", "}", "METHOD_END"], "methodName": ["getEndColumn"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.SimpleCharStream"}, {"methodBody": ["METHOD_START", "{", "return   bufline [ bufpos ]  ;", "}", "METHOD_END"], "methodName": ["getEndLine"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.SimpleCharStream"}, {"methodBody": ["METHOD_START", "{", "return   bufline [ bufpos ]  ;", "}", "METHOD_END"], "methodName": ["getLine"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.SimpleCharStream"}, {"methodBody": ["METHOD_START", "{", "if    (  ( inBuf )     >     0  )     {", "-  -  ( inBuf )  ;", "if    (  (  +  +  ( bufpos )  )     =  =     ( bufsize )  )", "bufpos    =     0  ;", "return   buffer [ bufpos ]  ;", "}", "if    (  (  +  +  ( bufpos )  )     >  =     ( maxNextInd )  )", "FillBuff (  )  ;", "char   c    =    buffer [ bufpos ]  ;", "UpdateLineColumn ( c )  ;", "return   c ;", "}", "METHOD_END"], "methodName": ["readChar"], "fileName": "org.intellij.plugins.relaxNG.compact.lexer.SimpleCharStream"}, {"methodBody": ["METHOD_START", "{", "myBuilder . advanceLexer (  )  ;", "}", "METHOD_END"], "methodName": ["advance"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.AbstractParsing"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   marker    =    myBuilder . mark (  )  ;", "advance (  )  ;", "return   marker ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.AbstractParsing"}, {"methodBody": ["METHOD_START", "{", "final   IElementType   token    =    myBuilder . getTokenType (  )  ;", "if    (  . isName ( token )  )     {", "final   PsiBuilder . Marker   marker    =    myBuilder . mark (  )  ;", "makeName (  )  ;", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( RncTokenTypes . LBRACKET )  )     {", "skipAnnotation ( marker ,    RncElementTypes . ANNOTATION _ ELEMENT )  ;", "return   currentToken (  )  ;", "} else    {", "marker . rollbackTo (  )  ;", "}", "} else", "if    ( token    =  =     ( RncTokenTypes . LBRACKET )  )     {", "final   PsiBuilder . Marker   marker    =    myBuilder . mark (  )  ;", "skipAnnotation ( marker ,    RncElementTypes . ANNOTATION )  ;", "return   currentToken (  )  ;", "} else", "if    ( token    =  =     ( RncTokenTypes . GTGT )  )     {", "final   PsiBuilder . Marker   marker    =    myBuilder . mark (  )  ;", "advance (  )  ;", "if    (  . isName ( myBuilder . getTokenType (  )  )  )     {", "makeName (  )  ;", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( RncTokenTypes . LBRACKET )  )     {", "skipAnnotation ( marker ,    RncElementTypes . FORWARD _ ANNOTATION )  ;", "return   currentToken (  )  ;", "}", "}", "marker . done ( RncElementTypes . FORWARD _ ANNOTATION )  ;", "return   currentToken (  )  ;", "}", "return   token ;", "}", "METHOD_END"], "methodName": ["currentToken"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.AbstractParsing"}, {"methodBody": ["METHOD_START", "{", "myBuilder . error ( s )  ;", "}", "METHOD_END"], "methodName": ["error"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.AbstractParsing"}, {"methodBody": ["METHOD_START", "{", "return    ( RncTokenTypes . IDENTIFIER _ OR _ KEYWORD . contains ( token )  )     |  |     ( token    =  =     ( RncTokenTypes . PREFIXED _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["isName"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.AbstractParsing"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   name    =    myBuilder . mark (  )  ;", "advance (  )  ;", "name . done ( RncElementTypes . NAME )  ;", "}", "METHOD_END"], "methodName": ["makeName"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.AbstractParsing"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( matches ( token )  )  )     {", "ror ( msg )  ;", "advance (  )  ;", "}", "}", "METHOD_END"], "methodName": ["match"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.AbstractParsing"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( matches ( set )  )  )     {", "error ( msg )  ;", "advance (  )  ;", "}", "}", "METHOD_END"], "methodName": ["match"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.AbstractParsing"}, {"methodBody": ["METHOD_START", "{", "if    ( t    =  =     ( currentToken (  )  )  )     {", "advance (  )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["matches"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.AbstractParsing"}, {"methodBody": ["METHOD_START", "{", "if    ( set . contains ( currentToken (  )  )  )     {", "advance (  )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["matches"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.AbstractParsing"}, {"methodBody": ["METHOD_START", "{", "final   boolean   b    =     ( myBuilder . getTokenType (  )  )     =  =     ( RncTokenTypes . LBRACKET )  ;", "advance (  )  ;", "assert   b ;", "while    (  (  !  ( myBuilder . eof (  )  )  )     &  &     (  ( currentToken (  )  )     !  =     ( RncTokenTypes . RBRACKET )  )  )     {", "advance (  )  ;", "}", "if    (  ( myBuilder . getTokenType (  )  )     =  =     ( RncTokenTypes . RBRACKET )  )     {", "advance (  )  ;", "}", "marker . done ( annotationType )  ;", "}", "METHOD_END"], "methodName": ["skipAnnotation"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.AbstractParsing"}, {"methodBody": ["METHOD_START", "{", "match ( RncTokenTypes . LITERAL ,     \" URI   literal   expected \"  )  ;", "}", "METHOD_END"], "methodName": ["parseAnyUriLiteral"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.DeclarationParsing"}, {"methodBody": ["METHOD_START", "{", "match ( RncTokenTypes . LBRACE ,     \"  '  {  '    expected \"  )  ;", "GrammarContents (  )  ;", "match ( RncTokenTypes . RBRACE ,     \"  '  }  '    expected \"  )  ;", "}", "METHOD_END"], "methodName": ["parseBracedGrammarContents"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.DeclarationParsing"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   marker    =    begin (  )  ;", "match ( RncTokenTypes . IDENTIFIER _ OR _ KEYWORD ,     \" Identifier   expected \"  )  ;", "match ( RncTokenTypes . EQ ,     \"  '  =  '    expected \"  )  ;", "NsUriLiteral (  )  ;", "marker . done ( RncElementTypes . DATATYPES _ DECL )  ;", "}", "METHOD_END"], "methodName": ["parseDataTypesDecl"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.DeclarationParsing"}, {"methodBody": ["METHOD_START", "{", "final   IElementType   t    =    builder . getTokenType (  )  ;", "if    ( t    =  =     ( RncTokenTypes . KEYWORD _ NAMESPACE )  )     {", "NamespaceDecl ( false )  ;", "} else", "if    ( t    =  =     ( RncTokenTypes . KEYWORD _ DEFAULT )  )     {", "NamespaceDecl ( true )  ;", "} else", "if    ( t    =  =     ( RncTokenTypes . KEYWORD _ DATATYPES )  )     {", "DataTypesDecl (  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseDecl"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.DeclarationParsing"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   marker    =    begin (  )  ;", "match ( Abstract . ASSIGN _ METHOD ,     \"  '  =  '  ,     '  |  =  '    or    '  &  =  '    expected \"  )  ;", "if    (  !  ( parsePattern (  )  )  )     {", "error (  \" Pattern   expected \"  )  ;", "}", "marker . done ( RncElementTypes . DEFINE )  ;", "}", "METHOD_END"], "methodName": ["parseDefine"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.DeclarationParsing"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   marker    =    begin (  )  ;", "BracedGrammarContents (  )  ;", "marker . done ( RncElementTypes . DIV )  ;", "}", "METHOD_END"], "methodName": ["parseDiv"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.DeclarationParsing"}, {"methodBody": ["METHOD_START", "{", "final   IElementType   t    =    currentToken (  )  ;", "if    ( t    =  =     ( RncTokenTypes . KEYWORD _ START )  )     {", "Start (  )  ;", "} else", "if    ( t    =  =     ( RncTokenTypes . KEYWORD _ DIV )  )     {", "Div (  )  ;", "} else", "if    ( allowInclude    &  &     ( t    =  =     ( RncTokenTypes . KEYWORD _ INCLUDE )  )  )     {", "Include (  )  ;", "} else", "if    ( RncTokenTypes . IDENTIFIERS . contains ( t )  )     {", "Define (  )  ;", "} else    {", "error (  \" Unexpected   token \"  )  ;", "advance (  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseGrammarContent"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.DeclarationParsing"}, {"methodBody": ["METHOD_START", "{", "while    ( AbstractParsing . LA _ GRAMMAR _ CONTENT . contains ( currentToken (  )  )  )     {", "parseGrammarContent ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["parseGrammarContents"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.DeclarationParsing"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   marker    =    begin (  )  ;", "AnyUriLiteral (  )  ;", "Inherit (  )  ;", "if    ( matches ( RncTokenTypes . LBRACE )  )     {", "IncludeContents (  )  ;", "match ( RncTokenTypes . RBRACE ,     \"  '  }  '    expected \"  )  ;", "}", "marker . done ( RncElementTypes . INCLUDE )  ;", "}", "METHOD_END"], "methodName": ["parseInclude"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.DeclarationParsing"}, {"methodBody": ["METHOD_START", "{", "while    ( AbstractParsing . LA _ INCLUDE _ CONTENT . contains ( currentToken (  )  )  )     {", "parseGrammarContent ( false )  ;", "}", "}", "METHOD_END"], "methodName": ["parseIncludeContents"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.DeclarationParsing"}, {"methodBody": ["METHOD_START", "{", "if    ( matches ( RncTokenTypes . KEYWORD _ INHERIT )  )     {", "match ( RncTokenTypes . EQ ,     \"  '  =  '    expected \"  )  ;", "match ( RncTokenTypes . IDENTIFIER _ OR _ KEYWORD ,     \" Identifier   expected \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseInherit"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.DeclarationParsing"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   marker    =    begin (  )  ;", "if    ( isDefault )     {", "match ( RncTokenTypes . KEYWORD _ NAMESPACE ,     \"  ' namespace '    expected \"  )  ;", "matches ( RncTokenTypes . IDENTIFIER _ OR _ KEYWORD )  ;", "} else    {", "match ( RncTokenTypes . IDENTIFIER _ OR _ KEYWORD ,     \" Identifier   expected \"  )  ;", "}", "match ( RncTokenTypes . EQ ,     \"  '  =  '    expected \"  )  ;", "NsUriLiteral (  )  ;", "marker . done ( RncElementTypes . NS _ DECL )  ;", "}", "METHOD_END"], "methodName": ["parseNamespaceDecl"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.DeclarationParsing"}, {"methodBody": ["METHOD_START", "{", "match ( AbstractParsing . NS _ URI _ LITERAL ,     \" Namespace   URI   or    ' inherit '    expected \"  )  ;", "}", "METHOD_END"], "methodName": ["parseNsUriLiteral"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.DeclarationParsing"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   marker    =    begin (  )  ;", "match ( Abstract . ASSIGN _ METHOD ,     \"  '  =  '  ,     '  |  =  '    or    '  &  =  '    expected \"  )  ;", "if    (  !  ( parsePattern (  )  )  )     {", "error (  \" Pattern   expected \"  )  ;", "}", "marker . done ( RncElementTypes . START )  ;", "}", "METHOD_END"], "methodName": ["parseStart"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.DeclarationParsing"}, {"methodBody": ["METHOD_START", "{", "while    (  (  !  ( myBuilder . eof (  )  )  )     &  &     ( AbstractParsing . LA _ DECL . contains ( currentToken (  )  )  )  )     {", "parseDecl ( myBuilder )  ;", "}", "if    ( AbstractParsing . LA _ GRAMMAR _ CONTENT . contains ( currentToken (  )  )  )     {", "final   PsiBuilder . Marker   marker    =    myBuilder . mark (  )  ;", "parseGrammarContents (  )  ;", "marker . done ( RncElementTypes . GRAMMAR _ PATTERN )  ;", "} else", "if    (  ( currentToken (  )  )     =  =     ( RncTokenTypes . KEYWORD _ GRAMMAR )  )     {", "parsePattern (  )  ;", "} else    {", "final   PsiBuilder . Marker   marker    =    myBuilder . mark (  )  ;", "while    (  !  ( myBuilder . eof (  )  )  )     {", "if    (  !  ( parsePattern (  )  )  )     {", "break ;", "}", "}", "marker . done ( RncElementTypes . GRAMMAR _ PATTERN )  ;", "}", "}", "METHOD_END"], "methodName": ["parseTopLevel"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.DeclarationParsing"}, {"methodBody": ["METHOD_START", "{", "if    (  ( RncTokenTypes . MINUS )     =  =     ( currentToken (  )  )  )     {", "final   PsiBuilder . Marker   marker    =    begin (  )  ;", "if    (  !  ( parse (  )  )  )     {", "error (  \"    expected \"  )  ;", "}", "marker . done ( RncElementTypes . EXCEPT _ NAME _ CLASS )  ;", "}", "}", "METHOD_END"], "methodName": ["parseExceptNameClass"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.NameClassParsing"}, {"methodBody": ["METHOD_START", "{", "PsiBuilder . Marker   marker    =    myBuilder . mark (  )  ;", "if    (  !  ( parset (  )  )  )     {", "marker . drop (  )  ;", "return   false ;", "}", "if    (  ( currentToken (  )  )     =  =     ( RncTokenTypes . PIPE )  )     {", "do    {", "advance (  )  ;", "if    (  !  ( parset (  )  )  )     {", "error (  \" NameClass   expected \"  )  ;", "}", "}    while    (  ( currentToken (  )  )     =  =     ( RncTokenTypes . PIPE )     )  ;", "marker . done ( RncElementTypes . NAME _ CLASS _ CHOICE )  ;", "} else    {", "marker . drop (  )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["parseNameClass"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.NameClassParsing"}, {"methodBody": ["METHOD_START", "{", "final   IElementType   t    =    currentToken (  )  ;", "PsiBuilder . Marker   marker    =    myBuilder . mark (  )  ;", "if    ( RncTokenTypes . IDENTIFIER _ OR _ KEYWORD . contains ( t )  )     {", "advance (  )  ;", "} else", "if    (  ( RncTokenTypes . PREFIXED _ NAME )     =  =    t )     {", "makeName (  )  ;", "} else", "if    (  ( RncTokenTypes . STAR )     =  =    t )     {", "advance (  )  ;", "parseExcept (  )  ;", "} else", "if    (  ( RncTokenTypes . PREFIXED _ STAR )     =  =    t )     {", "makeName (  )  ;", "parseExcept (  )  ;", "} else", "if    (  ( RncTokenTypes . LPAREN )     =  =    t )     {", "advance (  )  ;", "if    ( parse (  )  )     {", "match ( RncTokenTypes . RPAREN ,     \"  '  )  '    expected \"  )  ;", "}", "} else    {", "marker . drop (  )  ;", "return   false ;", "}", "marker . done ( RncElementTypes . NAME _ CLASS )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["parseNameClassPart"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.NameClassParsing"}, {"methodBody": ["METHOD_START", "{", "parseTopLevel (  )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.PatternParsing"}, {"methodBody": ["METHOD_START", "{", "match ( RncTokenTypes . LBRACE ,     \"  '  {  '    expected \"  )  ;", "if    (  !  ( parse (  )  )  )     {", "error (  \"    expected \"  )  ;", "}", "match ( RncTokenTypes . RBRACE ,     \"  '  }  '    expected \"  )  ;", "}", "METHOD_END"], "methodName": ["parseBracedPattern"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.PatternParsing"}, {"methodBody": ["METHOD_START", "{", "if    (  ( currentToken (  )  )     =  =     ( RncTokenTypes . LITERAL )  )     {", "advance (  )  ;", "} else", "if    ( matches ( RncTokenTypes . LBRACE )  )     {", "parseParams (  )  ;", "if    ( matches ( RncTokenTypes . MINUS )  )     {", "if    (  !  ( parse (  )  )  )     {", "error (  \"    expected \"  )  ;", "}", "}", "match ( RncTokenTypes . RBRACE ,     \"  '  }  '    expected \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseDatatype"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.PatternParsing"}, {"methodBody": ["METHOD_START", "{", "final   IElementType   t    =    currentToken (  )  ;", "if    ( t    !  =     ( RncTokenTypes . RBRACE )  )     {", "do    {", "final   PsiBuildMarkmark =    myBuildmark (  )  ;", "match ( RncTokenTypes . IDENTIFIER _ OR _ KEYWORD ,     \" Identifiexpected \"  )  ;", "match ( RncTokenTypes . EQ ,     \"  '  =  '    expected \"  )  ;", "match ( RncTokenTypes . LITERAL ,     \" Litl   expected \"  )  ;", "markdone ( RncElementTypes . PARAM )  ;", "}    while    ( RncTokenTypes . IDENTIFIER _ OR _ KEYWORD . contains ( currentToken (  )  )     )  ;", "}", "}", "METHOD_END"], "methodName": ["parseParams"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.PatternParsing"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   marker    =    myBuilder . mark (  )  ;", "if    (  !  ( parseSinglePattern (  )  )  )     {", "marker . drop (  )  ;", "return   false ;", "}", "final   IElementType   t    =    currentToken (  )  ;", "if    ( matches ( RncTokenTypes . QUANTIFIER _ OPS )  )     {", "marker . done (  . TOKEN _ MAP . get ( t )  )  ;", "} else    {", "marker . drop (  )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["parseQuantifiedPattern"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.PatternParsing"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   marker    =    myBuilder . mark (  )  ;", "if    ( matches ( AbstractParsing . ATTR _ OR _ ELEMENT )  )     {", "if    (  !  ( myNameClassParsing . parseNameClass (  )  )  )     {", "error (  \" Name   class   expected \"  )  ;", "marker . drop (  )  ;", "return   false ;", "}", "parseBracedPattern (  )  ;", "marker . done ( RncElementTypes . PATTERN )  ;", "} else", "if    ( matches ( RncTokenTypes . KEYWORD _ LIST )  )     {", "parseBracedPattern (  )  ;", "marker . done ( RncElementTypes . LIST _ PATTERN )  ;", "} else", "if    ( matches ( RncTokenTypes . KEYWORD _ MIXED )  )     {", "parseBracedPattern (  )  ;", "marker . done ( RncElementTypes . MIXED _ PATTERN )  ;", "} else", "if    ( matches ( RncTokenTypes . KEYWORD _ EXTERNAL )  )     {", "parseAnyUriLiteral (  )  ;", "parseInherit (  )  ;", "marker . done ( RncElementTypes . EXTERNAL _ REF )  ;", "} else", "if    ( matches ( RncTokenTypes . KEYWORD _ NOT _ ALLOWED )  )     {", "marker . done ( RncElementTypes . NOT _ ALLOWED _ PATTERN )  ;", "} else", "if    ( matches ( RncTokenTypes . KEYWORD _ TEXT )  )     {", "marker . done ( RncElementTypes . TEXT _ PATTERN )  ;", "} else", "if    ( matches ( RncTokenTypes . KEYWORD _ EMPTY )  )     {", "marker . done ( RncElementTypes . EMPTY _ PATTERN )  ;", "} else", "if    ( matches ( RncTokenTypes . KEYWORD _ PARENT )  )     {", "match ( RncTokenTypes . IDENTIFIERS ,     \" Identifier   expected \"  )  ;", "marker . done ( RncElementTypes . PARENT _ REF )  ;", "} else", "if    ( matches ( RncTokenTypes . KEYWORD _ GRAMMAR )  )     {", "parseBracedGrammarContents (  )  ;", "marker . done ( RncElementTypes . GRAMMAR _ PATTERN )  ;", "} else", "if    ( matches ( RncTokenTypes . LPAREN )  )     {", "if    (  !  ( parsePattern (  )  )  )     {", "error (  \" Pattern   expected \"  )  ;", "}", "match ( RncTokenTypes . RPAREN ,     \"  '  )  '    expected \"  )  ;", "marker . done ( RncElementTypes . GROUP _ PATTERN )  ;", "} else", "if    ( matches ( RncTokenTypes . IDENTIFIERS )  )     {", "marker . done ( RncElementTypes . REF _ PATTERN )  ;", "} else", "if    ( matches ( AbstractParsing . LA _ DATATYPE )  )     {", "parseDatatype (  )  ;", "marker . done ( RncElementTypes . DATATYPE _ PATTERN )  ;", "} else", "if    (  ( currentToken (  )  )     =  =     ( RncTokenTypes . PREFIXED _ NAME )  )     {", "makeName (  )  ;", "parseDatatype (  )  ;", "marker . done ( RncElementTypes . DATATYPE _ PATTERN )  ;", "} else", "if    ( matches ( RncTokenTypes . LITERAL )  )     {", "marker . done ( RncElementTypes . DATATYPE _ PATTERN )  ;", "} else    {", "marker . drop (  )  ;", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["parseSinglePattern"], "fileName": "org.intellij.plugins.relaxNG.compact.parser.PatternParsing"}, {"methodBody": ["METHOD_START", "{", "super . visitElement ( element )  ;", "}", "METHOD_END"], "methodName": ["superVisitElement"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.RncElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitElement ( annotation )  ;", "}", "METHOD_END"], "methodName": ["visitAnnotation"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.RncElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitElement ( pattern )  ;", "}", "METHOD_END"], "methodName": ["visitDefine"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.RncElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitElement ( div )  ;", "}", "METHOD_END"], "methodName": ["visitDiv"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.RncElementVisitor"}, {"methodBody": ["METHOD_START", "{", "super . visitElement ( element )  ;", "}", "METHOD_END"], "methodName": ["visitElement"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.RncElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitElement ( ref )  ;", "}", "METHOD_END"], "methodName": ["visitExternalRef"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.RncElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitElement ( pattern )  ;", "}", "METHOD_END"], "methodName": ["visitGrammar"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.RncElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitElement ( include )  ;", "}", "METHOD_END"], "methodName": ["visitInclude"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.RncElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitElement ( name )  ;", "}", "METHOD_END"], "methodName": ["visitName"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.RncElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitElement ( pattern )  ;", "}", "METHOD_END"], "methodName": ["visitParentRef"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.RncElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitElement ( pattern )  ;", "}", "METHOD_END"], "methodName": ["visitRef"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.RncElementVisitor"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   node    =    myElement . getNode (  )  ;", "assert   node    !  =    null ;", "return   node . findChildByType ( RncTokenTypes . IDENTIFIERS )  ;", "}", "METHOD_END"], "methodName": ["findNameNode"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.impl.PatternReference"}, {"methodBody": ["METHOD_START", "{", "return   PsiTreeUtil . getParentOfType ( myElement ,    RncGrammar . class ,    true ,    PsiFile . class )  ;", "}", "METHOD_END"], "methodName": ["getScope"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.impl.PatternReference"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   node    =    getNode (  )  . findChildByType ( RncTokenTypes . IDENTIFIERS )  ;", "if    ( node    =  =    null )     {", "final   ASTNode [  ]    nodes    =    getNode (  )  . getChildren ( RncTokenTypes . KEYWORDS )  ;", "if    (  ( nodes . length )     >     1  )     {", "return   nodes [  1  ]  ;", "}", "}", "return   node ;", "}", "METHOD_END"], "methodName": ["findIdentifierNode"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.impl.RncDeclImpl"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   node    =    getNode (  )  . findChildByType ( RncTokenTypes . IDENTIFIERS )  ;", "assert   node    !  =    null ;", "return   node ;", "}", "METHOD_END"], "methodName": ["getNameNode"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.impl.RncDefineImpl"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isMetaEnough"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.impl.RncDefineImpl"}, {"methodBody": ["METHOD_START", "{", "return   findChildByClass ( RncGrammar . class )  ;", "}", "METHOD_END"], "methodName": ["getGrammar"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.impl.RncDocument"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isMetaEnough"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.impl.RncDocument"}, {"methodBody": ["METHOD_START", "{", "return   getNode (  )  . getElementType (  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.impl.RncElementImpl"}, {"methodBody": ["METHOD_START", "{", "final   IElementType   parent    =    getNode (  )  . getTreeParent (  )  . getElementType (  )  ;", "if    ( parent    =  =     ( RncElementTypes . DATATYPE _ PATTERN )  )     {", "return    . Kind . DATATYPES ;", "} else    {", "return    . Kind . NAMESPACE ;", "}", "}", "METHOD_END"], "methodName": ["getKind"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.impl.RncNameImpl"}, {"methodBody": ["METHOD_START", "{", "return   getNode (  )  . findChildByType ( RncTokenTypes . IDENTIFIERS )  ;", "}", "METHOD_END"], "methodName": ["findNameNode"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.impl.RncRefImpl"}, {"methodBody": ["METHOD_START", "{", "return   EscapeUtil . unquote ( EscapeUtil . unescapeText ( ns )  )  ;", "}", "METHOD_END"], "methodName": ["parseLiteralValue"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.util.EscapeUtil"}, {"methodBody": ["METHOD_START", "{", "final   String   text    =    node . getText (  )  ;", "if    (  ( node . getElementType (  )  )     =  =     ( RncTokenTypes . ESCAPED _ IDENTIFIER )  )     {", "assert    ( text . charAt (  0  )  )     =  =     '  \\  \\  '  ;", "return    ( text . length (  )  )     >     1     ?    text . substring (  1  )     :     \"  \"  ;", "} else    {", "return   text ;", "}", "}", "METHOD_END"], "methodName": ["unescapeText"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.util.EscapeUtil"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   node    =    element . getNode (  )  ;", "if    ( node    !  =    null )     {", "return    . unescapeText ( node )  ;", "} else    {", "return   element . getText (  )  ;", "}", "}", "METHOD_END"], "methodName": ["unescapeText"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.util.EscapeUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( s . length (  )  )     >  =     6  )     &  &     (  ( s . charAt (  0  )  )     =  =     ( s . charAt (  1  )  )  )  )     {", "s    =    place (  '  \\ u 0  0  0  0  '  ,     '  \\ n '  )  ;", "return   s . substring (  3  ,     (  ( s . length (  )  )     -     3  )  )  ;", "} else    {", "return   s . substring (  1  ,     (  ( s . length (  )  )     -     1  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["unquote"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.util.EscapeUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( RenameUtil . isKeyword ( name )  )     {", "name    =     \"  \\  \\  \"     +    name ;", "} else", "if    (  !  ( RenameUtil . isIdentifier ( name )  )  )     {", "throw   new   com . intellij . util . IncorrectOperationException (  (  \" Illegal   identifier :     \"     +    name )  )  ;", "}", "final   PsiFileFactory   f    =    PsiFileFactory . getInstance ( manager . getProject (  )  )  ;", "final   RncFile   file    =     (  ( RncFile )     ( f . createFileFromText (  \" dummy . rnc \"  ,    RncFileType . getInstance (  )  ,     ( name    +     \"     =    bar \"  )  )  )  )  ;", "final   ASTNode   astNode    =    RenameUtil . findFirstGrammarNode ( file )  ;", "final   ASTNode   newNode    =    astNode . findChildByType ( RncTokenTypes . IDENTIFIERS )  ;", "assert   newNode    !  =    null ;", "return   newNode ;", "}", "METHOD_END"], "methodName": ["createIdentifierNode"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.util.RenameUtil"}, {"methodBody": ["METHOD_START", "{", "final   PsiFileFactory   f    =    PsiFileFactory . getInstance ( manager . getProject (  )  )  ;", "final   RncFile   file    =     (  ( RncFile )     ( f . createFileFromText (  \" dummy . rnc \"  ,    RncFileType . getInstance (  )  ,     (  (  \" include    \\  \"  \"     +    content )     +     \"  \\  \"  \"  )  )  )  )  ;", "final   ASTNode   include    =     . findFirstGrammarNode ( file )  ;", "final   ASTNode   literal    =    include . findChildByType ( RncTokenTypes . LITERAL )  ;", "assert   literal    !  =    null ;", "return   literal ;", "}", "METHOD_END"], "methodName": ["createLiteralNode"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.util.RenameUtil"}, {"methodBody": ["METHOD_START", "{", "final   PsiFileFactory   f    =    PsiFileFactory . getInstance ( manager . getProject (  )  )  ;", "final   RncFile   file    =     (  ( RncFile )     ( f . createFileFromText (  \" dummy . rnc \"  ,    RncFileType . getInstance (  )  ,     (  (  (  (  \" element    \"     +    prefix )     +     \"  :  \"  )     +    localPart )     +     \"     {    text    }  \"  )  )  )  )  ;", "final   ASTNode   node    =     . findFirstGrammarNode ( file )  ;", "final   ASTNode   nameClassNode    =    node . findChildByType ( RncElementTypes . NAME _ CLASS )  ;", "assert   nameClassNode    !  =    null ;", "final   ASTNode   astNode    =    nameClassNode . findChildByType ( RncElementTypes . NAME )  ;", "assert   astNode    !  =    null ;", "return   astNode ;", "}", "METHOD_END"], "methodName": ["createPrefixedNode"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.util.RenameUtil"}, {"methodBody": ["METHOD_START", "{", "final   RncGrammar   grammar    =    file . getGrammar (  )  ;", "assert   grammar    !  =    null ;", "final   ASTNode   grammarNode    =    grammar . getNode (  )  ;", "assert   grammarNode    !  =    null ;", "final   ASTNode   astNode    =    grammarNode . getFirstChildNode (  )  ;", "assert   astNode    !  =    null ;", "return   astNode ;", "}", "METHOD_END"], "methodName": ["findFirstGrammarNode"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.util.RenameUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( name    =  =    null )     {", "return   false ;", "}", "return    (  ( Verifier . checkXMLName ( name )  )     =  =    null )     |  |     (  (  (  ( name . length (  )  )     >  =     2  )     &  &     (  ( name . charAt (  0  )  )     =  =     '  \\  \\  '  )  )     &  &     (  ( Verifier . checkXMLName ( name . substring (  1  )  )  )     =  =    null )  )  ;", "}", "METHOD_END"], "methodName": ["isIdentifier"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.util.RenameUtil"}, {"methodBody": ["METHOD_START", "{", "return   RenameUtil . ourRncKeywords . contains ( name )  ;", "}", "METHOD_END"], "methodName": ["isKeyword"], "fileName": "org.intellij.plugins.relaxNG.compact.psi.util.RenameUtil"}, {"methodBody": ["METHOD_START", "{", "return   project . getComponent ( NoNamespaceConfig . class )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.intellij.plugins.relaxNG.config.NoNamespaceConfig"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   virtualFile    =    file . getVirtualFile (  )  ;", "if    ( virtualFile    =  =    null )", "return   null ;", "final   String   url    =    virtualFile . getUrl (  )  ;", "for    ( VirtualFilePor   por    :    myMappings . keySet (  )  )     {", "if    ( url . equals ( por . getUrl (  )  )  )     {", "return   myMappings . get ( por )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getMappedPointer"], "fileName": "org.intellij.plugins.relaxNG.config.NoNamespaceConfigImpl"}, {"methodBody": ["METHOD_START", "{", "myMappings . clear (  )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.intellij.plugins.relaxNG.config.NoNamespaceConfigImpl"}, {"methodBody": ["METHOD_START", "{", "final   String   s    =    mySchemaFile . getText (  )  . trim (  )  ;", "return    ( s . length (  )  )     >     0     ?    VfsUtil . pathToUrl ( place ( File . separatorChar ,     '  /  '  )  )     :    null ;", "}", "METHOD_END"], "methodName": ["getMapping"], "fileName": "org.intellij.plugins.relaxNG.config.NoNamespaceConfigPanel"}, {"methodBody": ["METHOD_START", "{", "final   PsiFile   file    =    PsiManager . getInstance ( project )  . findFile ( firstFile )  ;", "if    ( file    =  =    null )     {", "return   Collections . emptyMap (  )  ;", "}", "final   HashMap < String ,    Object >    map    =    new   LinkedHashMap <  >  (  )  ;", "file . accept ( new   PsiRecursiveElementVisitor (  )     {", "@ Override", "public   void   visitElement ( PsiElement   element )     {", "if    ( element   instanceof   XmlElementDecl )     {", "final   String   s    =     (  ( XmlElementDecl )     ( element )  )  . getName (  )  ;", "if    ( s    !  =    null )     {", "final   String [  ]    parts    =    s . split (  \"  :  \"  )  ;", "if    (  ( parts . length )     >     1  )     {", "map . put (  (  (  (  . XMLNS )     +     \"  :  \"  )     +     ( parts [  0  ]  )  )  ,    null )  ;", "}", "}", "} else", "if    ( element   instanceof   com . intellij . psi . xml . XmlAttributeDecl )     {", "final   String   s    =     (  ( com . intellij . psi . xml . XmlAttributeDecl )     ( element )  )  . getName (  )  ;", "if    ( s    !  =    null )     {", "final   String [  ]    parts    =    s . split (  \"  :  \"  )  ;", "if    (  ( parts . length )     >     1  )     {", "map . put (  (  (  (  . XMLNS )     +     \"  :  \"  )     +     ( parts [  0  ]  )  )  ,    null )  ;", "}", "}", "}", "super . visitElement ( element )  ;", "}", "}  )  ;", "return   map ;", "}", "METHOD_END"], "methodName": ["prepareNamespaceMap"], "fileName": "org.intellij.plugins.relaxNG.convert.AdvancedDtdOptions"}, {"methodBody": ["METHOD_START", "{", "final   String   colonReplacement    =    field . getText (  )  ;", "if    (  ( colonReplacement    !  =    null )     &  &     (  ( colonReplacement . trim (  )  . length (  )  )     >     0  )  )     {", "map . put ( o ,    colonReplacement )  ;", "}", "}", "METHOD_END"], "methodName": ["setText"], "fileName": "org.intellij.plugins.relaxNG.convert.AdvancedDtdOptions"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myInputOptions )     !  =    null )     {", "return   myInputOptions . getOptions (  )  ;", "} else    {", "return   myInputOptions _  ;", "}", "}", "METHOD_END"], "methodName": ["getInputOptions"], "fileName": "org.intellij.plugins.relaxNG.convert.AdvancedOptionsDialog"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myOutputOptions )     !  =    null )     {", "return   myOutputOptions . getOptions (  )  ;", "} else    {", "return   myOutputOptions _  ;", "}", "}", "METHOD_END"], "methodName": ["getOutputOptions"], "fileName": "org.intellij.plugins.relaxNG.convert.AdvancedOptionsDialog"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myInputOptions )     !  =    null )     {", "myInputOptions . setOptions ( inputOptions )  ;", "} else    {", "myInputOptions _     =    inputOptions ;", "}", "if    (  ( myOutputOptions )     !  =    null )     {", "myOutputOptions . setOptions ( outputOptions )  ;", "} else    {", "myOutputOptions _     =    outputOptions ;", "}", "}", "METHOD_END"], "methodName": ["setOptions"], "fileName": "org.intellij.plugins.relaxNG.convert.AdvancedOptionsDialog"}, {"methodBody": ["METHOD_START", "{", "if    (  ( files . length )     =  =     0  )", "return   null ;", "final   VirtualFile   file    =    files [  0  ]  ;", "final   FileType   type    =    file . getFileType (  )  ;", "if    ( type    =  =     ( StdFileTypes . XML )  )     {", "final   PsiFile   psiFile    =    PsiManager . getInstance ( project )  . findFile ( file )  ;", "if    ( psiFile   instanceof   XmlFile )     {", "final   XmlDocument   document    =     (  ( XmlFile )     ( psiFile )  )  . getDocument (  )  ;", "if    (  ( document    !  =    null )     &  &     (  ( document . getRootTag (  )  )     !  =    null )  )     {", "final   XmlTag   rootTag    =    document . getRootTag (  )  ;", "assert   rootTag    !  =    null ;", "final   String   uri    =    rootTag . getNamespace (  )  ;", "if    (  ( ApplicationLoader . RNG _ NAMESPACE . equals ( uri )  )     &  &     (  ( files . length )     =  =     1  )  )     {", "return   SchemaType . RNG ;", "}", "}", "}", "if    (  ( files . length )     >     1  )     {", "for    ( VirtualFile   virtualFile    :    files )     {", "if    (  (  ( virtualFile . getFileType (  )  )     !  =     ( StdFileTypes . XML )  )     |  |     (  ( ConvertSchemaAction . getInputType ( project ,    virtualFile )  )     !  =    null )  )     {", "return   null ;", "}", "}", "}", "return   SchemaType . XML ;", "} else", "if    (  ( type    =  =     ( StdFileTypes . DTD )  )     &  &     (  ( files . length )     =  =     1  )  )     {", "return   SchemaType . DTD ;", "} else", "if    (  ( type    =  =     ( mpact . RncFileType . getInstance (  )  )  )     &  &     (  ( files . length )     =  =     1  )  )     {", "return   SchemaType . RNC ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getInputType"], "fileName": "org.intellij.plugins.relaxNG.convert.ConvertSchemaAction"}, {"methodBody": ["METHOD_START", "{", "return   mySettings ;", "}", "METHOD_END"], "methodName": ["getSettings"], "fileName": "org.intellij.plugins.relaxNG.convert.ConvertSchemaDialog"}, {"methodBody": ["METHOD_START", "{", "myPropertyChangeSupport . addPropertyChangeListener ( name ,    listener )  ;", "}", "METHOD_END"], "methodName": ["addPropertyChangeListener"], "fileName": "org.intellij.plugins.relaxNG.convert.ConvertSchemaSettingsImpl"}, {"methodBody": ["METHOD_START", "{", "return   myOutputDestination ;", "}", "METHOD_END"], "methodName": ["getPreferredFocusedComponent"], "fileName": "org.intellij.plugins.relaxNG.convert.ConvertSchemaSettingsImpl"}, {"methodBody": ["METHOD_START", "{", "return   myRoot ;", "}", "METHOD_END"], "methodName": ["getRoot"], "fileName": "org.intellij.plugins.relaxNG.convert.ConvertSchemaSettingsImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( getOutputType (  )  )     =  =     ( SchemaType . XSD )  )     |  |     (  ( myInputType )     =  =     ( SchemaType . DTD )  )  ;", "}", "METHOD_END"], "methodName": ["hasAdvancedSettings"], "fileName": "org.intellij.plugins.relaxNG.convert.ConvertSchemaSettingsImpl"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    ( s . length (  )  )     >     0     ?    Iger . parseInt ( s )     :     -  1  ;", "}    catch    ( NumberFormatException   e )     {", "return    -  1  ;", "}", "}", "METHOD_END"], "methodName": ["parseInt"], "fileName": "org.intellij.plugins.relaxNG.convert.ConvertSchemaSettingsImpl"}, {"methodBody": ["METHOD_START", "{", "final   Set < String >    set    =    map . keySet (  )  ;", "for    ( String   s    :    set )     {", "final   Object   value    =    map . get ( s )  ;", "if    ( value    =  =     ( Boolean . TRUE )  )     {", "inputParams . add ( s )  ;", "} else", "if    ( value    =  =     ( Boolean . FALSE )  )     {", "inputParams . add (  (  \" no -  \"     +    s )  )  ;", "} else", "if    ( value    !  =    null )     {", "inputParams . add (  (  ( s    +     \"  =  \"  )     +    value )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setParams"], "fileName": "org.intellij.plugins.relaxNG.convert.ConvertSchemaSettingsImpl"}, {"methodBody": ["METHOD_START", "{", "final   AdvancedOptionsDialog   dialog    =    new   AdvancedOptionsDialog ( myProject ,    myInputType ,    getOutputType (  )  )  ;", "dialog . setOptions ( myInputOptions ,    myOutputOptions )  ;", "if    ( dialog . showAndGet (  )  )     {", "myInputOptions    =    dialog . getInputOptions (  )  ;", "myOutputOptions    =    dialog . getOutputOptions (  )  ;", "}", "}", "METHOD_END"], "methodName": ["showAdvancedSettings"], "fileName": "org.intellij.plugins.relaxNG.convert.ConvertSchemaSettingsImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( inputFiles . length )     =  =     0  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "try    {", "final   InputFormat   inFormat    =    getInputFormat ( inputType )  ;", "if    (  ( inputFiles . length )     >     1  )     {", "if    (  !  ( inFormat   instanceof   MultiInputFormat )  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "}", "final   VirtualFile   inputFile    =    inputFiles [  0  ]  ;", "final   SchemaType   type    =    settings . getOutputType (  )  ;", "final   String   outputType    =    type . toString (  )  . toLowerCase (  )  ;", "final   ArrayList < String >    inputParams    =    new   ArrayList <  >  (  )  ;", "if    ( inputType    !  =     ( SchemaType . DTD )  )     {", "final   Charset   charset    =    inputFile . getCharset (  )  ;", "inputParams . add (  (  \" encoding =  \"     +     ( charset . name (  )  )  )  )  ;", "}", "final   ArrayList < String >    outputParams    =    new   ArrayList <  >  (  )  ;", "settings . addAdvancedSettings ( inputParams ,    outputParams )  ;", "final   SchemaCollection   sc ;", "final   String   input    =    inputFile . getPath (  )  ;", "final   String   uri    =    UriOrFile . toUri ( input )  ;", "try    {", "if    ( inFormat   instanceof   MultiInputFormat )     {", "final   MultiInputFormat   format    =     (  ( MultiInputFormat )     ( inFormat )  )  ;", "final   String [  ]    uris    =    new   String [ inputFiles . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( inputFiles . length )  ;    i +  +  )     {", "uris [ i ]     =    UriOrFile . toUri ( inputFiles [ i ]  . getPath (  )  )  ;", "}", "sc    =    format . load ( uris ,    ArrayUtil . toStringArray ( inputParams )  ,    outputType ,    errorHandler )  ;", "} else    {", "sc    =    inFormat . load ( uri ,    ArrayUtil . toStringArray ( inputParams )  ,    outputType ,    errorHandler )  ;", "}", "}    catch    ( IOException   e )     {", "errorHandler . fatalError ( new   SAXParseException ( e . getMessage (  )  ,    null ,    uri ,     (  -  1  )  ,     (  -  1  )  ,    e )  )  ;", "return ;", "}", "final   File   destination    =    new   File ( settings . getOutputDestination (  )  )  ;", "final   File   outputFile ;", "if    ( destination . isDirectory (  )  )     {", "final   String   name    =    new   File ( input )  . getName (  )  ;", "final   int   ext    =    name . lastIndexOf (  '  .  '  )  ;", "outputFile    =    new   File ( destination ,     (  (  ( ext    >     0     ?    name . substring (  0  ,    ext )     :    name )     +     \"  .  \"  )     +    outputType )  )  ;", "} else    {", "outputFile    =    destination ;", "}", "try    {", "final   int   indent    =    settings . getIndent (  )  ;", "final   int   length    =    settings . getLineLength (  )  ;", "final   OutputDirectory   od    =    new   LocalOutputDirectory ( sc . getMainUri (  )  ,    outputFile ,     (  \"  .  \"     +    outputType )  ,    settings . getOutputEncoding (  )  ,     ( length    >     0     ?    length    :     . DEFAULT _ LINE _ LENGTH )  ,     ( indent    >     0     ?    indent    :     . DEFAULT _ INDENT )  )     {", "@ Override", "public   Stream   open ( String   sourceUri ,    String   encoding )    throws   IOException    {", "final   String   s    =    reference ( null ,    sourceUri )  ;", "final   File   file    =    new   File ( outputFile . getParentFile (  )  ,    s )  ;", "if    ( file . exists (  )  )     {", "final   String   msg    =     (  \" The   file    '  \"     +     ( file . getAbsolutePath (  )  )  )     +     \"  '    already   exists .    Overwrite   it ?  \"  ;", "final   int   choice    =    Messages . showYesNoDialog ( myProject ,    msg ,     \" Output   File   Exists \"  ,    Messages . getWarningIcon (  )  )  ;", "if    ( choice    =  =     ( Messages . YES )  )     {", "return   super . open ( sourceUri ,    encoding )  ;", "} else", "if    ( choice    =  =     1  )     {", "throw   new    . CanceledException (  )  ;", "}", "}", "return   super . open ( sourceUri ,    encoding )  ;", "}", "}  ;", "final   OutputFormat   of    =    getOutputFormat ( settings . getOutputType (  )  )  ;", "of . output ( sc ,    od ,    ArrayUtil . toStringArray ( outputParams )  ,    inputType . toString (  )  . toLowerCase (  )  ,    errorHandler )  ;", "}    catch    ( IOException   e )     {", "errorHandler . fatalError ( new   SAXParseException ( e . getMessage (  )  ,    null ,    UriOrFile . fileToUri ( outputFile )  ,     (  -  1  )  ,     (  -  1  )  ,    e )  )  ;", "}", "}    catch    (  . CanceledException   e )     {", "}    catch    ( SAXParseException   e )     {", "errorHandler . error ( e )  ;", "}    catch    ( MalformedURLException   e )     {", "Logger . getInstance ( getClass (  )  . getName (  )  )  . error ( e )  ;", "}    catch    ( InputFailedException   e )     {", "}    catch    ( InvalidParamsException   e )     {", "}    catch    ( OutputFailedException   e )     {", "}    catch    ( SAXException   e )     {", "}", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.intellij.plugins.relaxNG.convert.IdeaDriver"}, {"methodBody": ["METHOD_START", "{", "switch    ( type )     {", "case   DTD    :", "return   new   DtdInputFormat (  )  ;", "case   RNC    :", "return   new   CompactParseInputFormat (  )  ;", "case   RNG    :", "return   new   SAXParseInputFormat (  )  ;", "case   XML    :", "return   new   XmlInputFormat (  )  ;", "default    :", "ass   false    :     \" Unsupported   input   type :     \"     +    type ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getInputFormat"], "fileName": "org.intellij.plugins.relaxNG.convert.IdeaDriver"}, {"methodBody": ["METHOD_START", "{", "switch    ( outputType )     {", "case   DTD    :", "return   new   DtdOutputFormat (  )  ;", "case   RNC    :", "return   new   RncOutputFormat (  )  ;", "case   RNG    :", "return   new   RngOutputFormat (  )  ;", "case   XSD    :", "return   new   XsdOutputFormat (  )  ;", "default    :", "ass   false    :     \" Unsupported   output   type :     \"     +    outputType ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getOutputFormat"], "fileName": "org.intellij.plugins.relaxNG.convert.IdeaDriver"}, {"methodBody": ["METHOD_START", "{", "return    \" RELAX   NG \"  ;", "}", "METHOD_END"], "methodName": ["getRngGroupDisplayName"], "fileName": "org.intellij.plugins.relaxNG.inspections.BaseInspection"}, {"methodBody": ["METHOD_START", "{", "return   ContainerUtil . map ( super . getBatchSuppressActions ( element )  ,     (    action )     -  >    new   SuppressQuickFix (  )     {", "@ NotNull", "@ Override", "public   String   getName (  )     {", "return   action . getName (  )  ;", "}", "@ Override", "public   boolean   isAvailable (  @ NotNull", "Project   project ,     @ NotNull", "PsiElement   context )     {", "return   context . isValid (  )  ;", "}", "@ Override", "public   void   applyFix (  @ NotNull", "Project   project ,     @ NotNull", "ProblemDescriptor   descriptor )     {", "PsiElement   element 1     =    descriptor . getPsiElement (  )  ;", "PsiFile   file    =     ( element 1     =  =    null )     ?    null    :    element 1  . getContainingFile (  )  ;", "if    (  ( file    =  =    null )     |  |     (  ( file . getFileType (  )  )     !  =    StdFileTypes . XML )  )", "return ;", "action . applyFix ( project ,    descriptor )  ;", "}", "@ Override", "@ NotNull", "public   String   getFamilyName (  )     {", "return   action . getFamilyName (  )  ;", "}", "@ Override", "public   boolean   isSuppressAll (  )     {", "return   action . isSuppressAll (  )  ;", "}", "}  ,    EMPTY _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["getXmlOnlySuppressions"], "fileName": "org.intellij.plugins.relaxNG.inspections.BaseInspection"}, {"methodBody": ["METHOD_START", "{", "PsiElement   prev    =    location . getPrevSibling (  )  ;", "while    (  ( prev   instanceof   PsiWhiteSpace )     |  |     ( prev   instanceof   PsiComment )  )     {", "if    ( prev   instanceof   PsiComment )     {", "@ NonNls", "String   text    =    prev . getText (  )  ;", "if    (  ( text . matches (  \"  \\ n *  #  \\  \\ s * suppress \\  \\ s .  +  \"  )  )     &  &     (  ( text . contains ( getID (  )  )  )     |  |     (  \" ALL \"  . equals ( text )  )  )  )", "return   true ;", "}", "prev    =    prev . getPrevSibling (  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isSuppressedAt"], "fileName": "org.intellij.plugins.relaxNG.inspections.BaseInspection"}, {"methodBody": ["METHOD_START", "{", "BaseInspection . suppress ( file ,    location ,     (  \"  # suppress    \"     +     ( getID (  )  )  )  ,     (    text )     -  >     ( text    +     \"  ,     \"  )     +     ( getID (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["suppress"], "fileName": "org.intellij.plugins.relaxNG.inspections.BaseInspection"}, {"methodBody": ["METHOD_START", "{", "final   Project   project    =    file . getProject (  )  ;", "final   VirtualFile   vfile    =    file . getVirtualFile (  )  ;", "if    (  ( vfile    =  =    null )     |  |     ( ReadonlyStatusHandler . getInstance ( project )  . ensureFilesWritable ( vfile )  . hasReadonlyFiles (  )  )  )     {", "return ;", "}", "final   Document   doc    =    PsiDocumentManager . getInstance ( project )  . getDocument ( file )  ;", "assert   doc    !  =    null ;", "PsiElement   leaf    =    loca . getPrevSibling (  )  ;", "while    ( leaf   instanceof   PsiWhiteSpace )", "leaf    =    leaf . getPrevSibling (  )  ;", "while    (  ( leaf   instanceof   PsiComment )     |  |     ( leaf   instanceof   PsiWhiteSpace )  )     {", "@ NonNls", "String   text    =    leaf . getText (  )  ;", "if    ( text . matches (  \"  \\ n *  #  \\  \\ s * suppress \\  \\ s .  +  \"  )  )     {", "final   TextRange   textRange    =    leaf . getTextRange (  )  ;", "doc . replaceString ( textRange . getStartOffset (  )  ,    textRange . getEndOffset (  )  ,    replace . fun ( text )  )  ;", "return ;", "}", "leaf    =    leaf . getPrevSibling (  )  ;", "}", "final   int   offset    =    loca . getTextRange (  )  . getStartOffset (  )  ;", "doc . insertString ( offset ,     ( suppressComment    +     \"  \\ n \"  )  )  ;", "CodeStyleManager . getInstance ( project )  . adjustLineIndent ( doc ,     ( offset    +     ( suppressComment . length (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["suppress"], "fileName": "org.intellij.plugins.relaxNG.inspections.BaseInspection"}, {"methodBody": ["METHOD_START", "{", "return   new   CommonAnnotationHolder . HolderAdapter ( holder )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.intellij.plugins.relaxNG.model.annotation.CommonAnnotationHolder"}, {"methodBody": ["METHOD_START", "{", "return   new   CommonAnnotationHolder . DomHolderAdapter <  >  ( holder )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.intellij.plugins.relaxNG.model.annotation.CommonAnnotationHolder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( set . size (  )  )     =  =     1  )     {", "final   Navigatable   n    =     (  ( Navigatable )     ( set . iterator (  )  . next (  )  . getPsiElement (  )  )  )  ;", "OpenSourceUtil . navigate ( true ,    n )  ;", "} else    {", "final    [  ]    array    =    set . toArray ( new    [  0  ]  )  ;", "NavigationUtil . getPsiElementPopup ( ContainerUtil . map ( array ,     (    define )     -  >    define . getPsiElement (  )  ,    EMPTY _ ARRAY )  ,    title )  . show ( new   RelativePoint (  (  ( MouseEvent )     ( e . getInputEvent (  )  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doClickAction"], "fileName": "org.intellij.plugins.relaxNG.model.annotation.OverridingDefineRenderer"}, {"methodBody": ["METHOD_START", "{", "final   AttributeFinder   finder    =    new   AttributeFinder ( qname )  ;", "finder . doAccept ( patterns )  ;", "return   finder . myAttributes ;", "}", "METHOD_END"], "methodName": ["find"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.AttributeFinder"}, {"methodBody": ["METHOD_START", "{", "final   AttributeFinder   finder    =    new   AttributeFinder (  )  ;", "finder . doAccept ( patterns )  ;", "return   finder . myAttributes ;", "}", "METHOD_END"], "methodName": ["find"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.AttributeFinder"}, {"methodBody": ["METHOD_START", "{", "final   ChildElementFinder   finder    =    new   ChildElementFinder ( targetDepth )  ;", "finder . doAccept ( p )  ;", "return   finder . myRoots ;", "}", "METHOD_END"], "methodName": ["find"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.ChildElementFinder"}, {"methodBody": ["METHOD_START", "{", "return   ChildElementFinder . find (  1  ,    p )  ;", "}", "METHOD_END"], "methodName": ["find"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.ChildElementFinder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    o )", "return   true ;", "if    (  ( o    =  =    null )     |  |     (  ( getClass (  )  )     !  =     ( o . getClass (  )  )  )  )", "return   false ;", "if    (  !  ( super . equals ( o )  )  )", "return   false ;", "final      that    =     (  (  )     ( o )  )  ;", "if    (  !  ( Arrays . equals ( myPatterns ,    that . myPatterns )  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.CompositeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   myPatterns ;", "}", "METHOD_END"], "methodName": ["getElementPatterns"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.CompositeDescriptor"}, {"methodBody": ["METHOD_START", "{", "int   result    =    super . hashCode (  )  ;", "result    =     (  3  1     *    result )     +     ( Arrays . hashCode ( myPatterns )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.CompositeDescriptor"}, {"methodBody": ["METHOD_START", "{", "myVisited    =    RecursionSaveWalker . ourAllocator . alloc (  )  ;", "try    {", "for    ( int   i    =     0  ;    i    <     ( p . length )  ;    i +  +  )     {", "p [ i ]  . accept ( this )  ;", "}", "}    finally    {", "RecursionSaveWalker . ourAllocator . dispose ( myVisited )  ;", "}", "}", "METHOD_END"], "methodName": ["doAccept"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RecursionSaveWalker"}, {"methodBody": ["METHOD_START", "{", "return   computeAttributeDescriptors ( AttributeFinder . find (  (  ( QName )     ( null )  )  ,    myElementPattern )  )  ;", "}", "METHOD_END"], "methodName": ["collectAttributeDescriptors"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngElementDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( attributes . size (  )  )     >     0  )     {", "RngXmlAttribute   d    =    null ;", "final   Set < DAttributePattern >    patterns    =    attributes . keySet (  )  ;", "for    ( DAttributePattern   pattern    :    patterns )     {", "final   com . intellij . openapi . util . Pair <  ?    extends   Map < String ,    String >  ,    Boolean >    pair    =    attributes . get ( pattern )  ;", "final   RngXmlAttribute   a    =    new   RngXmlAttribute ( this ,    pattern ,    pair . first ,    pair . second )  ;", "if    ( d    =  =    null )     {", "d    =    a ;", "} else    {", "d    =    d . mergeWith ( a )  ;", "}", "}", "return   d ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["computeAttributeDescriptor"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngElementDescriptor"}, {"methodBody": ["METHOD_START", "{", "final   Map < QName ,    RngXmlAttributeDescriptor >    name 2 descriptor    =    new   HashMap <  >  (  )  ;", "for    ( DAttributePattern   pattern    :    map . keySet (  )  )     {", "final   com . intellij . openapi . util . Pair <  ?    extends   Map < String ,    String >  ,    Boolean >    value    =    map . get ( pattern )  ;", "for    ( QName   name    :    pattern . getName (  )  . listNames (  )  )     {", "RngXmlAttributeDescriptor   descriptor    =    name 2 descriptor . get ( name )  ;", "final   RngXmlAttributeDescriptor   newDescriptor    =    new   RngXmlAttributeDescriptor ( this ,    pattern ,    value . first ,    value . second )  ;", "if    ( descriptor    =  =    null )     {", "descriptor    =    newDescriptor ;", "} else    {", "descriptor    =    descriptor . mergeWith ( newDescriptor )  ;", "}", "name 2 descriptor . put ( name ,    descriptor )  ;", "}", "}", "final   Collection < RngXmlAttributeDescriptor >    result    =    name 2 descriptor . values (  )  ;", "return   result . toArray ( new   RngXmlAttributeDescriptor [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["computeAttributeDescriptors"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngElementDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    o )", "return   true ;", "if    (  ( o    =  =    null )     |  |     (  ( getClass (  )  )     !  =     ( o . getClass (  )  )  )  )", "return   false ;", "final      that    =     (  (  )     ( o )  )  ;", "if    (  !  ( myElementPattern . equals ( that . myElementPattern )  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngElementDescriptor"}, {"methodBody": ["METHOD_START", "{", "final   List < DElementPattern >    patterns    =    ChildElementFinder . find (  2  ,    myElementPattern )  ;", "final   XmlElementDescriptor   d    =    myNsDescriptor . findDescriptor ( childTag ,    patterns )  ;", "return   d    =  =    null    ?     . NULL    :    d ;", "}", "METHOD_END"], "methodName": ["findElementDescriptor"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngElementDescriptor"}, {"methodBody": ["METHOD_START", "{", "final   String   localPart    =    qName . getLocalPart (  )  ;", "return    ( p . length (  )  )     >     0     ?     ( p    +     \"  :  \"  )     +    localPart    :    localPart ;", "}", "METHOD_END"], "methodName": ["format"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngElementDescriptor"}, {"methodBody": ["METHOD_START", "{", "final   QName   qname    =    new   QName ( namespace ,    localName )  ;", "return   computeAttribute ( AttributeFinder . find ( qname ,    myElementPattern )  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeDescriptor"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngElementDescriptor"}, {"methodBody": ["METHOD_START", "{", "final   CachedValuesManager   mgr    =    CachedValuesManager . getManager ( context . getProject (  )  )  ;", "return   mgr . getParameterizedCachedValue ( context ,    key ,    provider ,    false ,    p )  ;", "}", "METHOD_END"], "methodName": ["getCachedValue"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngElementDescriptor"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   element    =    myNsDescriptor . getDeclaration (  )  ;", "if    ( element    =  =    null )     {", "return   null ;", "}", "return    . getDeclarationImpl ( element ,    location )  ;", "}", "METHOD_END"], "methodName": ["getDeclaration"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngElementDescriptor"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   virtualFile    =    RngSchemaValidator . findVirtualFile ( location . getSystemId (  )  )  ;", "if    ( virtualFile    =  =    null )     {", "return   decl ;", "}", "final   Project   project    =    decl . getProject (  )  ;", "final   PsiFile   file    =    PsiManager . getInstance ( project )  . findFile ( virtualFile )  ;", "if    ( file    =  =    null )     {", "return   decl ;", "}", "final   int   column    =    location . getColumnNumber (  )  ;", "final   int   line    =    location . getLineNumber (  )  ;", "final   Document   document    =    PsiDocumentManager . getInstance ( project )  . getDocument ( file )  ;", "assert   document    !  =    null ;", "if    (  ( line    <  =     0  )     |  |     (  ( document . getLineCount (  )  )     <     ( line    -     1  )  )  )     {", "return   decl ;", "}", "final   int   startOffset    =    document . getLineStartOffset (  ( line    -     1  )  )  ;", "final   Psi   at ;", "if    ( column    >     0  )     {", "if    (  ( decl . getContainingFile (  )  . getFileType (  )  )     =  =     ( RncFileType . getInstance (  )  )  )     {", "final   Psi   rnc    =    file . findAt (  ( startOffset    +    column )  )  ;", "final   ASTNode   pattern    =     ( rnc    !  =    null )     ?    TreeUtil . findParent ( rnc . getNode (  )  ,    RncTypes . PATTERN )     :    null ;", "final   ASTNode   nameClass    =     ( pattern    !  =    null )     ?    pattern . findChildByType ( RncTypes . NAME _ CLASS )     :    null ;", "return   nameClass    !  =    null    ?    nameClass . getPsi (  )     :    rnc ;", "}", "at    =    file . findAt (  (  ( startOffset    +    column )     -     2  )  )  ;", "} else    {", "Psi   element    =    file . findAt ( startOffset )  ;", "at    =     ( element    !  =    null )     ?    PsiTreeUtil . nextLeaf ( element )     :    null ;", "}", "return   PsiTreeUtil . getParentOfType ( at ,    XmlTag . class )  ;", "}", "METHOD_END"], "methodName": ["getDeclarationImpl"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngElementDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   getElementDescriptor ( childTag ,    null )  ;", "}", "METHOD_END"], "methodName": ["getElementDescriptor"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngElementDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   myElementPattern ;", "}", "METHOD_END"], "methodName": ["getElementPattern"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngElementDescriptor"}, {"methodBody": ["METHOD_START", "{", "final   Iterator < QName >    iterator    =    myElementPattern . getName (  )  . listNames (  )  . iterator (  )  ;", "if    (  !  ( iterator . hasNext (  )  )  )     {", "return   null ;", "}", "return   iterator . next (  )  ;", "}", "METHOD_END"], "methodName": ["getQName"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngElementDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   myElementPattern . hashCode (  )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngElementDescriptor"}, {"methodBody": ["METHOD_START", "{", "patterns    =    ContainerUtil . findAll ( patterns ,    NamedPatternFilter . INSTANCE )  ;", "final   Map < QName ,    List < DElementPattern >  >    name 2 patterns    =    new   LinkedHashMap <  >  (  )  ;", "for    ( DElementPattern   pattern    :    patterns )     {", "for    ( QName   qName    :    pattern . getName (  )  . listNames (  )  )     {", "List < DElementPattern >    dPatterns    =    name 2 patterns . get ( qName )  ;", "if    ( dPatterns    =  =    null )     {", "dPatterns    =    new   ArrayList (  )  ;", "name 2 patterns . put ( qName ,    dPatterns )  ;", "}", "if    (  !  ( dPatterns . contains ( pattern )  )  )", "dPatterns . add ( pattern )  ;", "}", "}", "final   List < XmlElement >    result    =    new   ArrayList <  >  (  )  ;", "for    ( QName   qName    :    name 2 patterns . keySet (  )  )     {", "final   List < DElementPattern >    patternList    =    name 2 patterns . get ( qName )  ;", "final   XmlElement   descriptor    =    find ( qName ,    patternList )  ;", "if    ( descriptor    !  =    null )     {", "result . add ( descriptor )  ;", "}", "}", "return   result . toArray ( XmlElement . EMPTY _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["convertElementDescriptors"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngNsDescriptor"}, {"methodBody": ["METHOD_START", "{", "final   QName   qName    =    new   QName ( tag . getNamespace (  )  ,    tag . getLocalName (  )  )  ;", "return   find ( qName ,    list )  ;", "}", "METHOD_END"], "methodName": ["findDescriptor"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngNsDescriptor"}, {"methodBody": ["METHOD_START", "{", "int   max    =     -  1  ;", "DElementPattern   maxPattern    =    null ;", "for    ( DElementPattern   pattern    :    list )     {", "final   NameClass   nameClass    =    pattern . getName (  )  ;", "if    ( nameClass . contains ( qName )  )     {", "final   int   spec    =    nameClass . containsSpecificity ( qName )  ;", "if    ( spec    >    max )     {", "maxPattern    =    pattern ;", "max    =    spec ;", "}", "}", "}", "final   List < DElementPattern >    patterns    =    ContainerUtil . findAll ( list ,     (    pattern )     -  >     {", "final   NameClass   nameClass    =    pattern . getName (  )  ;", "return   nameClass . contains ( qName )  ;", "}  )  ;", "if    ( maxPattern    !  =    null )     {", "if    (  ( patterns . size (  )  )     >     1  )     {", "return   init ( new   Composite ( this ,    maxPattern ,    patterns )  )  ;", "} else    {", "return   init ( new   RngElement ( this ,    maxPattern )  )  ;", "}", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["findDescriptor"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngNsDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   getElementDescriptor ( tag . getLocalName (  )  ,    tag . getNamespace (  )  )  ;", "}", "METHOD_END"], "methodName": ["findRootDescriptor"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngNsDescriptor"}, {"methodBody": ["METHOD_START", "{", "XmlElementDescriptor   descriptor    =    findDescriptor ( qName ,    ContainerUtil . findAll ( ChildElementFinder . find (  (  -  1  )  ,    myPattern )  ,    NamedPatternFilter . INSTANCE )  )  ;", "return   descriptor    !  =    null    ?    descriptor    :    findDescriptor ( qName ,    ChildElementFinder . find ( myPattern )  )  ;", "}", "METHOD_END"], "methodName": ["findRootDescriptorInner"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngNsDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   descriptor ;", "}", "METHOD_END"], "methodName": ["initDescriptor"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngNsDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   ContainerUtil . map 2 List ( myDeclarations ,     (    locator )     -  >    myElementDescriptor . getDeclaration ( locator )  )  ;", "}", "METHOD_END"], "methodName": ["getDeclarations"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngXmlAttributeDescriptor"}, {"methodBody": ["METHOD_START", "{", "final   Iterator < QName >    iterator    =    pattern . getName (  )  . listNames (  )  . iterator (  )  ;", "return   iterator . hasNext (  )     ?    iterator . next (  )     :     . UNKNOWN ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngXmlAttributeDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    ( myValues . containsKey ( value )  )     {", "return    \" token \"  . equals ( myValues . get ( value )  )  ;", "}", "value    =     . normalizeSpace ( value )  ;", "return    ( myValues . containsKey ( value )  )     &  &     (  \" token \"  . equals ( myValues . get ( value )  )  )  ;", "}", "METHOD_END"], "methodName": ["isTokenDatatype"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngXmlAttributeDescriptor"}, {"methodBody": ["METHOD_START", "{", "final   QName   name    =     ( d . myName . equals ( RngXmlAttributeDescriptor . UNKNOWN )  )     ?    myName    :    d . myName ;", "final   HashMap < String ,    String >    values    =    new   LinkedHashMap <  >  ( myValues )  ;", "values . putAll ( d . myValues )  ;", "final   THashSet < Locator >    locations    =    new   THashSet ( myDeclarations ,    RngXmlAttributeDescriptor . HASHING _ STRATEGY )  ;", "locations . addAll ( d . myDeclarations )  ;", "return   new   RngXmlAttributeDescriptor ( myElementDescriptor ,    name ,    values ,     (  ( myOptional )     |  |     ( d . myOptional )  )  ,    locations . toArray ( new   Locator [ locations . size (  )  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeWith"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngXmlAttributeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   value . replaceAll (  \"  \\  \\ s +  \"  ,     \"     \"  )  . trim (  )  ;", "}", "METHOD_END"], "methodName": ["normalizeSpace"], "fileName": "org.intellij.plugins.relaxNG.model.descriptors.RngXmlAttributeDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    ( file   instanceof   RncFile )     {", "final   Grammar   grammar    =     (  ( RncFile )     ( file )  )  . getGrammar (  )  ;", "if    ( grammar    !  =    null )     {", "grammar . acceptChildren ( visitor )  ;", "}", "} else", "if    ( file   instanceof   com . intellij . psi . xml . XmlFile )     {", "final   com . intellij . util . xml . DomManager   mgr    =    com . intellij . util . xml . DomManager . getDomManager ( file . getProject (  )  )  ;", "final   com . intellij . util . xml . DomFileElement < xml . dom . RngGrammar >    element    =    mgr . getFileElement (  (  ( com . intellij . psi . xml . XmlFile )     ( file )  )  ,    xml . dom . RngGrammar . class )  ;", "if    ( element    !  =    null )     {", "element . getRootElement (  )  . acceptChildren ( visitor )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doVisitRncOrRngFile"], "fileName": "org.intellij.plugins.relaxNG.model.resolve.DefinitionResolver"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   psiElement    =    scope . getPsiElement (  )  ;", "if    (  ( psiElement    =  =    null )     |  |     (  !  ( psiElement . isValid (  )  )  )  )", "return   null ;", "final   CachedValuesManager   manager    =    CachedValuesManager . getManager ( psiElement . getProject (  )  )  ;", "CachedValue < Map < String ,    Set < Define >  >  >    data    =    psiElement . getUserData (  . KEY )  ;", "if    (  ( data    =  =    null )     |  |     (  !  (  (  (  )     ( data . getValueProvider (  )  )  )  . isValid (  )  )  )  )     {", "final      resolver    =    new    ( scope )  ;", "data    =    manager . createCachedValue ( resolver ,    false )  ;", "psiElement . putUserData (  . KEY ,    data )  ;", "}", "return   data . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getAllVariants"], "fileName": "org.intellij.plugins.relaxNG.model.resolve.DefinitionResolver"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   element    =    myScope . getPsiElement (  )  ;", "return    ( element    !  =    null )     &  &     ( element . isValid (  )  )  ;", "}", "METHOD_END"], "methodName": ["isValid"], "fileName": "org.intellij.plugins.relaxNG.model.resolve.DefinitionResolver"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    Set < Define >  >    map    =    DefinitionResolver . getAllVariants ( scope )  ;", "if    ( map    =  =    null )     {", "return   null ;", "}", "final   Set < Define >    set    =    map . get ( value )  ;", "if    (  ( set    =  =    null )     |  |     (  ( set . size (  )  )     =  =     0  )  )     {", "final   PsiElement   element    =    scope . getPsiElement (  )  ;", "if    ( element    !  =    null )     {", "final   PsiFile   file    =    element . getContainingFile (  )  ;", "if    ( file   instanceof   XmlFile )     {", "final   DefinitionResolver . BackwardDefinitionResolver   resolver    =    new   DefinitionResolver . BackwardDefinitionResolver ( value )  ;", "RelaxIncludeIndex . processBackwardDependencies (  (  ( XmlFile )     ( file )  )  ,    resolver )  ;", "return   resolver . getResult (  )  ;", "}", "}", "}", "return   set ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.intellij.plugins.relaxNG.model.resolve.DefinitionResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( element   instanceof   RncFile )     {", "return    (  ( RncFile )     ( element )  )  . get (  )  ;", "}", "final   DomFileElement < Rng >    fileElement    =    DomManager . getDomManager ( element . getProject (  )  )  . getFileElement ( element ,    Rng . class )  ;", "return   fileElement    !  =    null    ?    fileElement . getRootElement (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getGrammar"], "fileName": "org.intellij.plugins.relaxNG.model.resolve.GrammarFactory"}, {"methodBody": ["METHOD_START", "{", "return    ( psiFile   instanceof   XmlFile )     &  &     (  ( DomManager . getDomManager ( psiFile . getProject (  )  )  . getFileElement (  (  ( XmlFile )     ( psiFile )  )  ,    RngGrammar . class )  )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["isRngFile"], "fileName": "org.intellij.plugins.relaxNG.model.resolve.RelaxIncludeIndex"}, {"methodBody": ["METHOD_START", "{", "VirtualFile   virtualFile    =    file . getVirtualFile (  )  ;", "if    ( virtualFile    =  =    null )     {", "return   processor . execute ( file )  ;", "}", "final   Project   project    =    file . getProject (  )  ;", "final   VirtualFile [  ]    files    =    FileIncludeManager . getManager ( project )  . getIncludingFiles ( virtualFile ,    true )  ;", "return    . processRelatedFiles ( file ,    files ,    processor )  ;", "}", "METHOD_END"], "methodName": ["processBackwardDependencies"], "fileName": "org.intellij.plugins.relaxNG.model.resolve.RelaxIncludeIndex"}, {"methodBody": ["METHOD_START", "{", "final   FileType   type    =    psiFile . getFileType (  )  ;", "if    (  ( type    =  =     ( XmlFileType . INSTANCE )  )     &  &     ( RelaxIncludeIndex . isRngFile ( psiFile )  )  )     {", "if    (  !  ( processor . execute (  (  ( XmlFile )     ( psiFile )  )  )  )  )     {", "return   false ;", "}", "} else", "if    ( type    =  =     ( compact . RncFileType . getInstance (  )  )  )     {", "if    (  !  ( processor . execute (  (  ( XmlFile )     ( psiFile )  )  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["processFile"], "fileName": "org.intellij.plugins.relaxNG.model.resolve.RelaxIncludeIndex"}, {"methodBody": ["METHOD_START", "{", "VirtualFile   virtualFile    =    file . getVirtualFile (  )  ;", "if    ( virtualFile    =  =    null )     {", "return   processor . execute ( file )  ;", "}", "final   Project   project    =    file . getProject (  )  ;", "final   VirtualFile [  ]    files    =    FileIncludeManager . getManager ( project )  . getIncludedFiles ( virtualFile ,    true )  ;", "return    . processRelatedFiles ( file ,    files ,    processor )  ;", "}", "METHOD_END"], "methodName": ["processForwardDependencies"], "fileName": "org.intellij.plugins.relaxNG.model.resolve.RelaxIncludeIndex"}, {"methodBody": ["METHOD_START", "{", "Project   project    =    file . getProject (  )  ;", "final   PsiManager   psiManager    =    PsiManager . getInstance ( project )  ;", "final   PsiFile [  ]    psiFiles    =    ContainerUtil . map 2 Array ( files ,    PsiFile . class ,     (  ( NullableFunction < VirtualFile ,    PsiFile >  )     (  (    file 1  )     -  >    psiManager . findFile ( file 1  )  )  )  )  ;", "for    ( final   PsiFile   psiFile    :    psiFiles )     {", "if    (  !  (  . processFile ( psiFile ,    processor )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["processRelatedFiles"], "fileName": "org.intellij.plugins.relaxNG.model.resolve.RelaxIncludeIndex"}, {"methodBody": ["METHOD_START", "{", "return   FileBasedIndex . getInstance (  )  . getAllKeys ( RelaxSymbolIndex . NAME ,    project )  ;", "}", "METHOD_END"], "methodName": ["getSymbolNames"], "fileName": "org.intellij.plugins.relaxNG.model.resolve.RelaxSymbolIndex"}, {"methodBody": ["METHOD_START", "{", "final   GlobalSearchScope   scope    =     ( includeNonProjectItems )     ?    GlobalSearchScope . allScope ( project )     :    GlobalSearchScope . projectScope ( project )  ;", "final   Collection < NavigationItem >    result    =    new   ArrayList <  >  (  )  ;", "PsiManager   psiManager    =    PsiManager . getInstance ( project )  ;", "for    ( VirtualFile   file    :    FileBasedIndex . getInstance (  )  . getContainingFiles (  . NAME ,    name ,    scope )  )     {", "final   PsiFile   psiFile    =    psiManager . findFile ( file )  ;", "if    ( psiFile   instanceof   XmlFile )     {", "final   Grammar   grammar    =    GrammarFactory . getGrammar (  (  ( XmlFile )     ( psiFile )  )  )  ;", "if    ( grammar    !  =    null )     {", "grammar . acceptChildren ( new   CommonElement . Visitor (  )     {", "@ Override", "public   void   visitDefine ( Define   define )     {", "if    ( name . equals ( define . getName (  )  )  )     {", "final   PsiElement   psi    =    define . getPsiElement (  )  ;", "if    ( psi    !  =    null )     {", ". MyNavigationItem . add (  (  ( NavigationItem )     ( define . getPsiElement (  )  )  )  ,    result )  ;", "}", "}", "}", "}  )  ;", "}", "}", "}", "return   result . toArray ( EMPTY _ NAVIGATION _ ITEM _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["getSymbolsByName"], "fileName": "org.intellij.plugins.relaxNG.model.resolve.RelaxSymbolIndex"}, {"methodBody": ["METHOD_START", "{", "return   new   AddValueCondition ( key )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.intellij.plugins.relaxNG.references.AddValueCondition"}, {"methodBody": ["METHOD_START", "{", "return   ContainerUtil . map 2 Array ( values ,    String . class ,    new   AttributeValueFunction (  )  )  ;", "}", "METHOD_END"], "methodName": ["toStrings"], "fileName": "org.intellij.plugins.relaxNG.references.AttributeValueFunction"}, {"methodBody": ["METHOD_START", "{", "return   new   FileReferenceUtil . PatternCondition ( XmlPatterns . xmlFile (  )  . withRootTag ( XmlPatterns . xmlTag (  )  . withNamespace ( string (  )  . equalTo ( ns )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["byNamespace"], "fileName": "org.intellij.plugins.relaxNG.references.FileReferenceUtil"}, {"methodBody": ["METHOD_START", "{", "return   new   FileReferenceUtil . TypeCondition ( instance )  ;", "}", "METHOD_END"], "methodName": ["byType"], "fileName": "org.intellij.plugins.relaxNG.references.FileReferenceUtil"}, {"methodBody": ["METHOD_START", "{", "return   FileReferenceUtil . restrict ( set ,    cond ,    null )  ;", "}", "METHOD_END"], "methodName": ["restrict"], "fileName": "org.intellij.plugins.relaxNG.references.FileReferenceUtil"}, {"methodBody": ["METHOD_START", "{", "final   FileReference [  ]    references    =    set . getAllReferences (  )  ;", "return   ContainerUtil . map 2 Array ( references ,    PsiReference . class ,     (  ( NotNullFunction < FileReference ,    PsiReference >  )     (  (    fileReference )     -  >    new   MyFileReference ( fileReference ,    cond ,    soft )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["restrict"], "fileName": "org.intellij.plugins.relaxNG.references.FileReferenceUtil"}, {"methodBody": ["METHOD_START", "{", "final   XmlAttributeDescriptor   descriptor    =     (  ( XmlAttribute )     ( xmlAttributeValue . getParent (  )  )  )  . getDescriptor (  )  ;", "return    ( descriptor    !  =    null )     &  &     ( descriptor . hasType (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasIdRefType"], "fileName": "org.intellij.plugins.relaxNG.references.IdRefProvider"}, {"methodBody": ["METHOD_START", "{", "final   XmlAttributeDescriptor   descriptor    =     (  ( XmlAttribute )     ( xmlAttributeValue . getParent (  )  )  )  . getDescriptor (  )  ;", "return    ( descriptor    !  =    null )     &  &     ( descriptor . hasIdType (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasIdType"], "fileName": "org.intellij.plugins.relaxNG.references.IdRefProvider"}, {"methodBody": ["METHOD_START", "{", "myPattern . accepts ( attribute . getValueElement (  )  ,    myProcessingContext )  ;", "}", "METHOD_END"], "methodName": ["processAttribute"], "fileName": "org.intellij.plugins.relaxNG.references.ResolvingVisitor"}, {"methodBody": ["METHOD_START", "{", "final   Set < XmlFile >    set    =    myProcessingContext . get ( ResolvingVisitor . VISITED _ KEY )  ;", "if    ( set . contains ( xmlFile )  )     {", "return ;", "}", "set . add ( xmlFile )  ;", "final   XmlDocument   document    =    xmlFile . getDocument (  )  ;", "if    ( document    =  =    null )", "return ;", "final   XmlTag   rootTag    =    document . getRootTag (  )  ;", "if    ( rootTag    =  =    null )", "return ;", "rootTag . processElements ( this ,    attribute )  ;", "}", "METHOD_END"], "methodName": ["processInclude"], "fileName": "org.intellij.plugins.relaxNG.references.ResolvingVisitor"}, {"methodBody": ["METHOD_START", "{", "myIncludePattern    =    includePattern ;", "}", "METHOD_END"], "methodName": ["setIncludePattern"], "fileName": "org.intellij.plugins.relaxNG.references.ResolvingVisitor"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["shouldContinue"], "fileName": "org.intellij.plugins.relaxNG.references.ResolvingVisitor"}, {"methodBody": ["METHOD_START", "{", "final   XmlAttribute [  ]    xmlAttributes    =    tag . getAttributes (  )  ;", "for    ( XmlAttribute   attribute    :    xmlAttributes )     {", "attribute . accept ( this )  ;", "}", "}", "METHOD_END"], "methodName": ["visitAttributes"], "fileName": "org.intellij.plugins.relaxNG.references.ResolvingVisitor"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag [  ]    tags    =    tag . getSubTags (  )  ;", "for    ( XmlTag   subTag    :    tags )     {", "if    ( shouldContinue (  )  )     {", "subTag . accept ( this )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["visitSubTags"], "fileName": "org.intellij.plugins.relaxNG.references.ResolvingVisitor"}, {"methodBody": ["METHOD_START", "{", "ContentManagerUtil . cleanupContents ( null ,    myProject ,    myContentName )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.intellij.plugins.relaxNG.validation.MessageViewHelper"}, {"methodBody": ["METHOD_START", "{", "assert    ( myErrorsView )     =  =    null ;", "myErrorsView    =    new   com . intellij . ide . errorTreeView . NewErrorTreeViewPanel ( myProject ,    null ,    true ,    true ,    rerun )  ;", "openImpl (  )  ;", "}", "METHOD_END"], "methodName": ["openMessageView"], "fileName": "org.intellij.plugins.relaxNG.validation.MessageViewHelper"}, {"methodBody": ["METHOD_START", "{", "CommandProcessor   commandProcessor    =    CommandProcessor . getInstance (  )  ;", "commandProcessor . executeCommand ( myProject ,     (  )     -  >     {", "messageView    =     . SERVICE . getInstance ( myProject )  ;", "Content   content    =    ContentFactory . SERVICE . getInstance (  )  . createContent ( myErrorsView . getComponent (  )  ,    myContentName ,    true )  ;", "content . putUserData ( myKey ,    myErrorsView )  ;", "messageView . getContentManager (  )  . addContent ( content )  ;", "messageView . getContentManager (  )  . setSelectedContent ( content )  ;", "messageView . getContentManager (  )  . addContentManagerListener ( new   CloseListener ( content ,    myContentName ,    myErrorsView )  )  ;", "ContentManagerUtil . cleanupContents ( content ,    myProject ,    myContentName )  ;", "messageView . getContentManager (  )  . addContentManagerListener ( new   MyContentDisposer ( content ,    messageView ,    myKey )  )  ;", "}  ,     \" Open   Message   View \"  ,    null )  ;", "ToolWindowManager . getInstance ( myProject )  . getToolWindow ( MESSAGES _ WINDOW )  . activate ( null )  ;", "}", "METHOD_END"], "methodName": ["openMessageViewImpl"], "fileName": "org.intellij.plugins.relaxNG.validation.MessageViewHelper"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( myErrors . size (  )  )     =  =     0  )     &  &     (  ( myErrorsView )     =  =    null )  )     {", "myErrorsView    =    new   com . intellij . ide . errorTreeView . NewErrorTreeViewPanel ( myProject ,    null ,    true ,    true ,    null )  ;", "myErrorsView . setProcessController ( myProcessController )  ;", "openMessageViewImpl (  )  ;", "}", "final   String   error    =     (  (  (  (  (  ( ex . getLineNumber (  )  )     +     \"  |  \"  )     +     ( ex . getColumnNumber (  )  )  )     +     \"  |  \"  )     +     ( ex . getSystemId (  )  )  )     +     \"  |  \"  )     +     ( ex . getLocalizedMessage (  )  )  ;", "if    (  !  ( myErrors . add ( error )  )  )     {", "return ;", "}", "VirtualFile   file    =    null ;", "final   String   systemId    =    ex . getSystemId (  )  ;", "if    ( systemId    !  =    null )     {", "try    {", "file    =    VfsUtil . findFileByURL ( new   URL ( systemId )  )  ;", "}    catch    ( MalformedURLException   e )     {", ". LOG . warn (  (  \" systemId    =     \"     +    systemId )  )  ;", ". LOG . error ( e )  ;", "}", "}", "final   VirtualFile   file 1     =    file ;", "ApplicationManager . getApplication (  )  . invokeLater (  (  )     -  >    myErrorsView . addMessage (  ( warning    ?    MessageCategory . WARNING    :    MessageCategory . ERROR )  ,    new   String [  ]  {    ex . getLocalizedMessage (  )     }  ,    file 1  ,     (  ( ex . getLineNumber (  )  )     -     1  )  ,     (  ( ex . getColumnNumber (  )  )     -     1  )  ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["processError"], "fileName": "org.intellij.plugins.relaxNG.validation.MessageViewHelper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myErrorsView )     =  =    null )     {", "myProcessController    =    processController ;", "} else    {", "myErrorsView . setProcessController ( processController )  ;", "}", "}", "METHOD_END"], "methodName": ["setProcessController"], "fileName": "org.intellij.plugins.relaxNG.validation.MessageViewHelper"}, {"methodBody": ["METHOD_START", "{", "try    {", "setLocation ( element )  ;", "myHandler . characters ( text . toCharArray (  )  ,     0  ,    text . length (  )  )  ;", "}    catch    ( SAXException   e )     {", "throw   new    . ParseError ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["handleText"], "fileName": "org.intellij.plugins.relaxNG.validation.Psi2SaxAdapter"}, {"methodBody": ["METHOD_START", "{", "final   PsiFile   psiFile    =    text . getContainingFile (  )  ;", "final   Document   document    =    PsiDocumentManager . getInstance ( text . getProject (  )  )  . getDocument ( psiFile )  ;", "if    ( document    =  =    null )     {", "return ;", "}", "final   VirtualFile   virtualFile    =    psiFile . getVirtualFile (  )  ;", "if    ( virtualFile    =  =    null )     {", "return ;", "}", "final   Locator 2 Impl   locator    =    new   Locator 2 Impl (  )  ;", "locator . setSystemId ( VfsUtilCore . fixIDEAUrl ( virtualFile . getUrl (  )  )  )  ;", "final   int   offset    =    text . getTextRange (  )  . getEndOffset (  )  ;", "final   int   lineNumber    =    document . getLineNumber ( offset )  ;", "locator . setLineNumber (  ( lineNumber    +     1  )  )  ;", "locator . setColumnNumber (  (  (  1     +    offset )     -     ( document . getLineStartOffset ( lineNumber )  )  )  )  ;", "myHandler . setDocumentLocator ( locator )  ;", "}", "METHOD_END"], "methodName": ["setLocation"], "fileName": "org.intellij.plugins.relaxNG.validation.Psi2SaxAdapter"}, {"methodBody": ["METHOD_START", "{", "final   InputSource   source    =    RngParser . makeInputSource ( file )  ;", "final   VirtualFile   virtualFile    =    file . getVirtualFile (  )  ;", "if    (  ( file . getFileType (  )  )     =  =     ( RncFileType . getInstance (  )  )  )     {", "return   new   CompactParseable ( source ,    eh )     {", "@ Override", "public   ParsedPattern   parseInclude ( String   uri ,    SchemaBuilder   schemaBuilder ,    IncludedGrammar   g ,    String   inheritedNs )    throws   BuildException ,    IllegalSchemaException    {", "ProgressManager . checkCanceled (  )  ;", "return   super . parseInclude ( RngParser . resolveURI ( virtualFile ,    uri )  ,    schemaBuilder ,    g ,    inheritedNs )  ;", "}", "}  ;", "} else    {", "return   new   SAXParseable ( source ,    eh )     {", "@ Override", "public   ParsedPattern   parseInclude ( String   uri ,    SchemaBuilder   schemaBuilder ,    IncludedGrammar   g ,    String   inheritedNs )    throws   BuildException ,    IllegalSchemaException    {", "ProgressManager . checkCanceled (  )  ;", "return   super . parseInclude ( RngParser . resolveURI ( virtualFile ,    uri )  ,    schemaBuilder ,    g ,    inheritedNs )  ;", "}", "}  ;", "}", "}", "METHOD_END"], "methodName": ["createParsable"], "fileName": "org.intellij.plugins.relaxNG.validation.RngParser"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   DatatypeLibraryFactoryImpl (  )  ;", "}    catch    ( Throwable   e )     {", ". LOG . error (  \" Could   not   create   DT   library   implementation    ' com . thaiopensource . datatype . xsd . DatatypeLibraryFactoryImpl '  .    Plugin ' s   classpath   seems   to   be   broken .  \"  ,    e )  ;", "return   new   DoNothingDatatypeLibraryFactoryImpl (  )  ;", "}", "}", "METHOD_END"], "methodName": ["createXsdDatatypeFactory"], "fileName": "org.intellij.plugins.relaxNG.validation.RngParser"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   file    =    descriptorFile . getVirtualFile (  )  ;", "if    ( file    =  =    null )     {", "return    . parsePattern ( descriptorFile ,    eh ,    false )  ;", "}", "String   url    =    file . getUrl (  )  ;", "DPattern   pattern    =     . ourCache . get ( url )  ;", "if    ( pattern    =  =    null )     {", "pattern    =     . parsePattern ( descriptorFile ,    eh ,    false )  ;", "}", "if    ( pattern    !  =    null )     {", ". ourCache . put ( url ,    pattern )  ;", "}", "return   pattern ;", "}", "METHOD_END"], "methodName": ["getCachedPattern"], "fileName": "org.intellij.plugins.relaxNG.validation.RngParser"}, {"methodBody": ["METHOD_START", "{", "CachedValue < Schema >    value    =    descriptorFile . getUserData ( RngParser . SCHEMA _ KEY )  ;", "if    ( value    =  =    null )     {", "final   CachedValueProvider < Schema >    provider    =     (  )     -  >     {", "final   InputSource   inputSource    =    makeInputSource ( descriptorFile )  ;", "try    {", "final   Schema   schema    =    new   MySchemaReader ( descriptorFile )  . createSchema ( inputSource ,    RngParser . EMPTY _ PROPS )  ;", "final   PsiElementProcessor . CollectElements < XmlFile >    processor    =    new   PsiElementProcessor . CollectElements <  >  (  )  ;", "RelaxIncludeIndex . processForwardDependencies ( descriptorFile ,    processor )  ;", "if    (  ( processor . getCollection (  )  . size (  )  )     >     0  )     {", "return   CachedValueProvider . Result . create ( schema ,    processor . toArray (  )  ,    descriptorFile )  ;", "} else    {", "return   CachedValueProvider . Result . createSingleDependency ( schema ,    descriptorFile )  ;", "}", "}    catch    (    e )     {", "RngParser . LOG . info ( e )  ;", "return   CachedValueProvider . Result . createSingleDependency ( null ,    descriptorFile )  ;", "}", "}  ;", "final   CachedValuesManager   mgr    =    CachedValuesManager . getManager ( descriptorFile . getProject (  )  )  ;", "value    =    mgr . createCachedValue ( provider ,    false )  ;", "descriptorFile . putUserData ( RngParser . SCHEMA _ KEY ,    value )  ;", "}", "return   value . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getCachedSchema"], "fileName": "org.intellij.plugins.relaxNG.validation.RngParser"}, {"methodBody": ["METHOD_START", "{", "final   InputSource   inputSource    =    new   InputSource ( new   StringReader ( descriptorFile . getText (  )  )  )  ;", "final   VirtualFile   file    =    descriptorFile . getVirtualFile (  )  ;", "if    ( file    !  =    null )     {", "inputSource . setSystemId ( VfsUtilCore . fixIDEAUrl ( file . getUrl (  )  )  )  ;", "}", "return   inputSource ;", "}", "METHOD_END"], "methodName": ["makeInputSource"], "fileName": "org.intellij.plugins.relaxNG.validation.RngParser"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   Parseable   p    =     . createParsable ( file ,    eh )  ;", "if    ( checking )     {", "p . parse ( new   SchemaBuilderImpl ( eh ,     . DT _ LIBRARY _ FACTORY . getValue (  )  ,    new   SchemaPatternBuilder (  )  )  )  ;", "} else    {", "return   p . parse ( new   DSchemaBuilderImpl (  )  )  ;", "}", "}    catch    ( BuildException   e )     {", ". LOG . info ( e )  ;", "}    catch    ( IllegalSchemaException   e )     {", "final   VirtualFile   virtualFile    =    file . getVirtualFile (  )  ;", "if    ( virtualFile    !  =    null )     {", "if    (  . LOG . isDebugEnabled (  )  )     {", ". LOG . debug (  (  \" invalid   schema :     \"     +     ( virtualFile . getPresentableUrl (  )  )  )  ,    e )  ;", "} else    {", ". LOG . info (  (  (  (  (  \" invalid   schema :     \"     +     ( virtualFile . getPresentableUrl (  )  )  )     +     \"  .     [  \"  )     +     ( e . getMessage (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["parsePattern"], "fileName": "org.intellij.plugins.relaxNG.validation.RngParser"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   file    =    UriUtil . findRelativeFile ( s ,    descriptorFile )  ;", "if    ( file    !  =    null )     {", "s    =    VfsUtilCore . fixIDEAUrl ( file . getUrl (  )  )  ;", "}", "return   s ;", "}", "METHOD_END"], "methodName": ["resolveURI"], "fileName": "org.intellij.plugins.relaxNG.validation.RngParser"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   VfsUtil . findFileByURL ( new   URL ( systemId )  )  ;", "}    catch    ( Exception   e )     {", ". LOG . warn (  (  (  \" Failed   to   build   file   from   uri    <  \"     +    systemId )     +     \"  >  \"  )  ,    e )  ;", "return   VirtualFileManager . getInstance (  )  . findFileByUrl ( VfsUtilCore . fixURLforIDEA ( systemId )  )  ;", "}", "}", "METHOD_END"], "methodName": ["findVirtualFile"], "fileName": "org.intellij.plugins.relaxNG.validation.RngSchemaValidator"}, {"methodBody": ["METHOD_START", "{", "final   String   systemId    =    ex . getSystemId (  )  ;", "if    (  . LOG . isDebugEnabled (  )  )     {", ". LOG . debug (  (  (  (  (  \" RNG   Schema   error :     \"     +     ( ex . getMessage (  )  )  )     +     \"     [  \"  )     +    systemId )     +     \"  ]  \"  )  )  ;", "}", "if    ( systemId    !  =    null )     {", "final   VirtualFile   virtualFile    =     . findVirtualFile ( systemId )  ;", "if    (  !  ( Comparing . equal ( virtualFile ,    file . getVirtualFile (  )  )  )  )     {", "return ;", "}", "}", "final   PsiElement   at ;", "final   int   line    =    ex . getLineNumber (  )  ;", "if    ( line    >     0  )     {", "final   int   column    =    ex . getColumnNumber (  )  ;", "final   int   startOffset    =    document . getLineStartOffset (  ( line    -     1  )  )  ;", "if    ( column    >     0  )     {", "if    (  ( file . getFileType (  )  )     =  =     ( RncFileType . getInstance (  )  )  )     {", "final   PsiElement   e    =    file . findElementAt (  ( startOffset    +    column )  )  ;", "if    ( e    =  =    null )     {", "at    =    e ;", "} else    {", "at    =    file . findElementAt (  (  ( startOffset    +    column )     -     1  )  )  ;", "}", "} else    {", "at    =    file . findElementAt (  (  ( startOffset    +    column )     -     2  )  )  ;", "}", "} else    {", "final   PsiElement   e    =    file . findElementAt ( startOffset )  ;", "at    =     ( e    !  =    null )     ?    PsiTreeUtil . nextLeaf ( e )     :    null ;", "}", "} else    {", "final   XmlDocument   d    =     (  ( XmlFile )     ( file )  )  . getDocument (  )  ;", "assert   d    !  =    null ;", "final   XmlTag   rootTag    =    d . getRootTag (  )  ;", "assert   rootTag    !  =    null ;", "at    =    rootTag . getFirstChild (  )  ;", "}", "final   PsiElement   host ;", "if    ( file   instanceof   RncFile )     {", "host    =    at ;", "} else    {", "host    =    PsiTreeUtil . getParentOfType ( at ,    XmlAttribute . class ,    XmlTag . class )  ;", "}", "if    (  ( at    !  =    null )     &  &     ( host    !  =    null )  )     {", "consumer . onMessage ( host ,    ex . getMessage (  )  )  ;", "} else    {", "consumer . onMessage ( file ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleError"], "fileName": "org.intellij.plugins.relaxNG.validation.RngSchemaValidator"}, {"methodBody": ["METHOD_START", "{", "final   PsiFile   file    =    e . getData ( PSI _ FILE )  ;", "if    ( file    =  =    null )     {", "return   false ;", "}", "final   Project   project    =    e . getData ( PROJECT )  ;", "if    ( project    =  =    null )     {", "return   false ;", "}", "final   RngElementDescriptor   descriptor    =     . getRootDescriptor ( file )  ;", "if    ( descriptor    =  =    null )", "return   false ;", "final   PsiElement   element    =    descriptor . getDeclaration (  )  ;", "final   XmlFile   xmlFile    =    PsiTreeUtil . getParentOfType ( element ,    XmlFile . class )  ;", "if    ( xmlFile    =  =    null )", "return   false ;", "final   VirtualFile   instanceFile    =    file . getVirtualFile (  )  ;", "final   VirtualFile   schemaFile    =    xmlFile . getVirtualFile (  )  ;", "if    (  ( instanceFile    =  =    null )     |  |     ( schemaFile    =  =    null )  )     {", "return   true ;", "}", ". doRun ( project ,    instanceFile ,    schemaFile )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["actionPerformedImpl"], "fileName": "org.intellij.plugins.relaxNG.validation.ValidateAction"}, {"methodBody": ["METHOD_START", "{", "ValidateAction . saveFiles ( instanceFile ,    schemaFile )  ;", "final   MessageViewHelper   helper    =    new   MessageViewHelper ( project ,    ValidateAction . CONTENT _ NAME ,    ValidateAction . KEY )  ;", "helper . openMessageView (  (  )     -  >    ValidateAction . doRun ( project ,    instanceFile ,    schemaFile )  )  ;", "final   Future <  ?  >    future    =    ApplicationManager . getApplication (  )  . executeOnPooledThread (  (  )     -  >    ApplicationManager . getApplication (  )  . runReadAction (  (  )     -  >     {", "final   MessageViewHelper . ErrorHandler   eh    =    helper . new   ErrorHandler (  )  ;", "instanceFile . putUserData ( ValidateAction . IN _ PROGRESS _ KEY ,    Boolean . TRUE )  ;", "try    {", "doValidation ( instanceFile ,    schemaFile ,    eh )  ;", "}    finally    {", "instanceFile . putUserData ( ValidateAction . IN _ PROGRESS _ KEY ,    null )  ;", "}", "SwingUtilities . invokeLater (  (  )     -  >     {", "if    (  !  ( eh . hadErrorOrWarning (  )  )  )     {", "SwingUtilities . invokeLater (  (  )     -  >     {", "helper . close (  )  ;", "WindowManager . getInstance (  )  . getStatusBar ( project )  . setInfo (  \" No   errors   detected \"  )  ;", "}  )  ;", "}", "}  )  ;", "}  )  )  ;", "helper . setProcessController ( new   NewErrorTreeViewPanel . ProcessController (  )     {", "@ Override", "public   void   stopProcess (  )     {", "future . cancel ( true )  ;", "}", "@ Override", "public   boolean   isProcessStopped (  )     {", "return   future . isDone (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["doRun"], "fileName": "org.intellij.plugins.relaxNG.validation.ValidateAction"}, {"methodBody": ["METHOD_START", "{", "final   SchemaReader   sr    =     (  ( schemaFile . getFileType (  )  )     =  =     ( RncFileType . getInstance (  )  )  )     ?    CompactSchemaReader . getInstance (  )     :    new   AutoSchemaReader (  )  ;", "final   PropertyMapBuilder   properties    =    new   PropertyMapBuilder (  )  ;", "ERROR _ HANDLER . put ( properties ,    eh )  ;", "CHECK _ ID _ IDREF . add ( properties )  ;", "try    {", "final   String   schemaPath    =    VfsUtilCore . fixIDEAUrl ( schemaFile . getUrl (  )  )  ;", "try    {", "final   ValidationDriver   driver    =    new   ValidationDriver ( properties . toPropertyMap (  )  ,    sr )  ;", "final   InputSource   in    =    ValidationDriver . uriOrFileInputSource ( schemaPath )  ;", "in . setEncoding ( schemaFile . getCharset (  )  . name (  )  )  ;", "if    ( driver . loadSchema ( in )  )     {", "final   String   path    =    VfsUtilCore . fixIDEAUrl ( instanceFile . getUrl (  )  )  ;", "try    {", "driver . validate ( ValidationDriver . uriOrFileInputSource ( path )  )  ;", "}    catch    ( IOException   e 1  )     {", "eh . fatalError ( new   SAXParseException ( e 1  . getMessage (  )  ,    null ,    UriOrFile . fileToUri ( path )  ,     (  -  1  )  ,     (  -  1  )  ,    e 1  )  )  ;", "}", "}", "}    catch    ( SAXParseException   e 1  )     {", "eh . fatalError ( e 1  )  ;", "}    catch    ( IOException   e 1  )     {", "eh . fatalError ( new   SAXParseException ( e 1  . getMessage (  )  ,    null ,    UriOrFile . fileToUri ( schemaPath )  ,     (  -  1  )  ,     (  -  1  )  ,    e 1  )  )  ;", "}", "}    catch    ( SAXException    |    MalformedURLException   e 1  )     {", "Logger . getInstance (  . class . getName (  )  )  . error ( e 1  )  ;", "}", "}", "METHOD_END"], "methodName": ["doValidation"], "fileName": "org.intellij.plugins.relaxNG.validation.ValidateAction"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( file   instanceof   XmlFile )     {", "final   XmlElementDescriptor   descriptor    =     (  ( XmlFile )     ( file )  )  . getDocument (  )  . getRootTag (  )  . getDescriptor (  )  ;", "if    ( descriptor   instanceof   RngElementDescriptor )     {", "return    (  ( RngElementDescriptor )     ( descriptor )  )  ;", "}", "}", "}    catch    ( NullPorException   e 1  )     {", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getRootDescriptor"], "fileName": "org.intellij.plugins.relaxNG.validation.ValidateAction"}, {"methodBody": ["METHOD_START", "{", "final   FileDocumentManager   mgr    =    FileDocumentManager . getInstance (  )  ;", "for    ( VirtualFile   f    :    files )     {", "final   Document   document    =    mgr . getDocument ( f )  ;", "if    ( document    !  =    null )     {", "mgr . saveDocument ( document )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["saveFiles"], "fileName": "org.intellij.plugins.relaxNG.validation.ValidateAction"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   Schema   schema    =    RngParser . getCachedSchema ( descriptorFile )  ;", "if    ( schema    =  =    null )     {", "return ;", "}", "final   ErrorHandler   eh    =     . MyErrorHandler . create ( doc ,    host )  ;", "if    ( eh    =  =    null )     {", "return ;", "}", "final   PropertyMapBuilder   builder    =    new   PropertyMapBuilder (  )  ;", "builder . put ( ERROR _ HANDLER ,    eh )  ;", "final   ContentHandler   handler    =    schema . createValidator ( builder . toPropertyMap (  )  )  . getContentHandler (  )  ;", "doc . accept ( new   Psi 2 SaxAdapter ( handler )  )  ;", "}    catch    ( ProcessCanceledException   e )     {", "throw   e ;", "}    catch    ( RuntimeException   e )     {", ". LOG . error ( e )  ;", "}    catch    ( Exception   e )     {", ". LOG . info ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["doValidation"], "fileName": "org.intellij.plugins.relaxNG.validation.XmlInstanceValidator"}, {"methodBody": ["METHOD_START", "{", "visitDomElement ( def )  ;", "}", "METHOD_END"], "methodName": ["visit"], "fileName": "org.intellij.plugins.relaxNG.xml.dom.RngDomVisitor"}, {"methodBody": ["METHOD_START", "{", "visitDomElement ( div )  ;", "}", "METHOD_END"], "methodName": ["visit"], "fileName": "org.intellij.plugins.relaxNG.xml.dom.RngDomVisitor"}, {"methodBody": ["METHOD_START", "{", "visitDomElement ( grammar )  ;", "}", "METHOD_END"], "methodName": ["visit"], "fileName": "org.intellij.plugins.relaxNG.xml.dom.RngDomVisitor"}, {"methodBody": ["METHOD_START", "{", "visitDomElement ( include )  ;", "}", "METHOD_END"], "methodName": ["visit"], "fileName": "org.intellij.plugins.relaxNG.xml.dom.RngDomVisitor"}, {"methodBody": ["METHOD_START", "{", "final   XmlTag   tag    =    PsiTreeUtil . getParentOfType ( myReference . getElement (  )  ,    XmlTag . class )  ;", "assert   tag    !  =    null ;", "final   XmlTag   defineTag    =    tag . cChildTag (  \" define \"  ,    ApplicationLoader . RNG _ NAMESPACE ,     \"  \\ n    \\ n \"  ,    false )  ;", "defineTag . setAttribute (  \" name \"  ,    myReference . getCanonicalText (  )  )  ;", "final   RngGrammar   grammar    =     (  ( DefinitionReference )     ( myReference )  )  . getScope (  )  ;", "if    ( grammar    =  =    null )", "return ;", "final   XmlTag   root    =    grammar . getXmlTag (  )  ;", "if    ( root    =  =    null )", "return ;", "final   XmlTag [  ]    tags    =    root . getSubTags (  )  ;", "for    ( XmlTag   xmlTag    :    tags )     {", "if    ( PsiTreeUtil . isAncestor ( xmlTag ,    tag ,    false )  )     {", "final   XmlElementFactory   ef    =    XmlElementFactory . getInstance ( tag . getProject (  )  )  ;", "final   XmlText   text    =    ef . cDisplayText (  \"     \"  )  ;", "final   PsiElement   e    =    root . addAfter ( text ,    xmlTag )  ;", "root . addAfter ( defineTag ,    e )  ;", "return ;", "}", "}", "root . add ( defineTag )  ;", "}", "METHOD_END"], "methodName": ["doFix"], "fileName": "org.intellij.plugins.relaxNG.xml.dom.impl.CreatePatternFix"}, {"methodBody": ["METHOD_START", "{", "if    ( tag    =  =    null )     {", "return   null ;", "}", "if    (  ( tag . getLocalName (  )  . equals ( name )  )     &  &     ( tag . getNamespace (  )  . equals ( namespace )  )  )     {", "return   tag ;", "}", "return    . getAncestorTag ( tag . getParentTag (  )  ,    name ,    namespace )  ;", "}", "METHOD_END"], "methodName": ["getAncestorTag"], "fileName": "org.intellij.plugins.relaxNG.xml.dom.impl.CreatePatternFix"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  (  ( myReference )    instanceof   DefinitionReference )  )     |  |     (  !  ( myReference . getElement (  )  . isValid (  )  )  )  )     {", "return   false ;", "} else    {", "final   RngGrammar   grammar    =     (  ( DefinitionReference )     ( myReference )  )  . getScope (  )  ;", "if    ( grammar    =  =    null )     {", "return   false ;", "} else", "if    (  ( grammar . getXmlTag (  )  )     =  =    null )     {", "return   false ;", "}", "return   true ;", "}", "}", "METHOD_END"], "methodName": ["isAvailable"], "fileName": "org.intellij.plugins.relaxNG.xml.dom.impl.CreatePatternFix"}, {"methodBody": ["METHOD_START", "{", "RngGrammar   scope    =    myValue . getParentOfType ( RngGrammar . class ,    true )  ;", "if    ( scope    =  =    null )     {", "return   null ;", "}", "if    ( myIsParentRef )     {", "scope    =    scope . getParentOfType ( RngGrammar . class ,    true )  ;", "}", "return   scope ;", "}", "METHOD_END"], "methodName": ["getScope"], "fileName": "org.intellij.plugins.relaxNG.xml.dom.impl.DefinitionReference"}, {"methodBody": ["METHOD_START", "{", "if    ( t    =  =    null )", "return   null ;", "final   List < Pattern >    list    =    Util . getChildrenOfType ( t ,    Pattern . class )  ;", "return    ( list . size (  )  )     >     0     ?    list . get (  0  )     :    null ;", "}", "METHOD_END"], "methodName": ["getPatternFrom"], "fileName": "org.intellij.plugins.relaxNG.xml.dom.impl.RngDomElementBase"}, {"methodBody": ["METHOD_START", "{", "return   getParentOfType ( RngGrammar . class ,    true )  ;", "}", "METHOD_END"], "methodName": ["getScope"], "fileName": "org.intellij.plugins.relaxNG.xml.dom.impl.RngRefImpl"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   Method   method    =    test . getClass (  )  . getMethod ( test . getName (  )  )  ;", "CopyFile   annotation    =    method . getAnnotation ( CopyFile . class )  ;", "if    ( annotation    =  =    null )     {", "if    (  ( annotation    =    method . getDeclaringClass (  )  . getAnnotation ( CopyFile . class )  )     =  =    null )     {", "return ;", "}", "}", "final   String [  ]    patterns    =    annotation . value (  )  ;", "for    ( String   pattern    :    patterns )     {", "final   File   root    =    new   File (  (  ( HighlightingTestBase . getTestDataBasePath (  )  )     +     ( test . getTestDataPath (  )  )  )  )  ;", "final   ArrayList < File >    files    =    new   ArrayList <  >  (  )  ;", "FilecollectMatchedFiles ( root ,    Pattern . compile ( FileconvertAntToRegexp ( pattern )  )  ,    files )  ;", "final   File   temp    =    new   File ( test . getFixture (  )  . getTempDirPath (  )  )  ;", "final   String   target    =    annotation . target (  )  ;", "if    (  ( target . length (  )  )     >     0  )     {", "Assert . assertEquals ( files . size (  )  ,     1  )  ;", "final   File   destFile    =    new   File ( temp ,    FilegetRelativePath ( root ,    new   File ( root ,    target )  )  )  ;", "Filecopy ( files . get (  0  )  ,    destFile )  ;", "LocalFileSystem . getInstance (  )  . refreshAndFindFileByIoFile ( destFile )  ;", "} else    {", "for    ( File   file    :    files )     {", "final   File   destFile    =    new   File ( temp ,    FilegetRelativePath ( root ,    file )  )  ;", "Filecopy ( file ,    destFile )  ;", "LocalFileSystem . getInstance (  )  . refreshAndFindFileByIoFile ( destFile )  ;", "}", "}", "}", "}    catch    ( NoSuchMethodException   e )     {", "Assert . fail ( e . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["copyFiles"], "fileName": "org.intellij.plugins.testUtil.ResourceUtil"}]