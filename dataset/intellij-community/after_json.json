[{"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  (  (  \" breadcrumbs /  \"     +     ( getTestName ( false )  )  )     +     \"  . json \"  )  )  ;", "List < Crumb >    caret    =    myFixture . getAtCaret (  )  ;", "assertOrderedEquals ( caret . stream (  )  . map ( Crumb :  : getText )  . toArray ( String [  ]  :  : new )  ,    components )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.json.JsonBreadcrumbsTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" foo \"  ,     \" bar \"  ,     \"  0  \"  ,     \"  0  \"  ,     \" baz \"  )  ;", "}", "METHOD_END"], "methodName": ["testComplexItems"], "fileName": "com.intellij.json.JsonBreadcrumbsTest"}, {"methodBody": ["METHOD_START", "{", "ResourceBundle   bundle    =    SoftReference . dereference ( JsonBundle . ourBundle )  ;", "if    ( bundle    =  =    null )     {", "bundle    =    ResourceBundle . getBundle ( JsonBundle . BUNDLE )  ;", "JsonBundle . ourBundle    =    new   SoftReference ( bundle )  ;", "}", "return   bundle ;", "}", "METHOD_END"], "methodName": ["getBundle"], "fileName": "com.intellij.json.JsonBundle"}, {"methodBody": ["METHOD_START", "{", "return   CommonBundle . message ( JsonBundle . getBundle (  )  ,    key ,    params )  ;", "}", "METHOD_END"], "methodName": ["message"], "fileName": "com.intellij.json.JsonBundle"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  (  (  \" commenter /  \"     +     ( getTestName ( false )  )  )     +     \"  . json \"  )  )  ;", "myFixture . performEditorAction ( actionId )  ;", "myFixture . checkResultByFile (  (  (  \" commenter /  \"     +     ( getTestName ( false )  )  )     +     \"  _ after . json \"  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.json.JsonCommenterTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( ACTION _ COMMENT _ BLOCK )  ;", "}", "METHOD_END"], "methodName": ["testBlockComment"], "fileName": "com.intellij.json.JsonCommenterTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( ACTION _ COMMENT _ LINE )  ;", "}", "METHOD_END"], "methodName": ["testLineComment"], "fileName": "com.intellij.json.JsonCommenterTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( ACTION _ COMMENT _ LINE )  ;", "}", "METHOD_END"], "methodName": ["testLineComment2"], "fileName": "com.intellij.json.JsonCommenterTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( ACTION _ COMMENT _ LINE )  ;", "}", "METHOD_END"], "methodName": ["testLineComment3"], "fileName": "com.intellij.json.JsonCommenterTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . testCompletionVariants (  (  (  \" completion /  \"     +     ( getTestName ( false )  )  )     +     \"  . json \"  )  ,    variants )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.json.JsonCompletionTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  (  (  \" completion /  \"     +     ( getTestName ( false )  )  )     +     \"  . json \"  )  )  ;", "final   LookupElement [  ]    variants    =    myFixture . completeBasic (  )  ;", "assertNull ( variants )  ;", "myFixture . checkResultByFile (  (  (  \" completion /  \"     +     ( getTestName ( false )  )  )     +     \"  _ after . json \"  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestSingleVariant"], "fileName": "com.intellij.json.JsonCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( JsonCompletionTest . ALL _ KEYWORDS )  ;", "}", "METHOD_END"], "methodName": ["testInsideArrayElement1"], "fileName": "com.intellij.json.JsonCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( JsonCompletionTest . ALL _ KEYWORDS )  ;", "}", "METHOD_END"], "methodName": ["testInsideArrayElement2"], "fileName": "com.intellij.json.JsonCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( JsonCompletionTest . NOTHING )  ;", "}", "METHOD_END"], "methodName": ["testInsidePropertyKey1"], "fileName": "com.intellij.json.JsonCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( JsonCompletionTest . NOTHING )  ;", "}", "METHOD_END"], "methodName": ["testInsidePropertyKey2"], "fileName": "com.intellij.json.JsonCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( JsonCompletionTest . ALL _ KEYWORDS )  ;", "}", "METHOD_END"], "methodName": ["testInsidePropertyValue"], "fileName": "com.intellij.json.JsonCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( JsonCompletionTest . NOTHING )  ;", "}", "METHOD_END"], "methodName": ["testInsideStringLiteral1"], "fileName": "com.intellij.json.JsonCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( JsonCompletionTest . NOTHING )  ;", "}", "METHOD_END"], "methodName": ["testInsideStringLiteral2"], "fileName": "com.intellij.json.JsonCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestSingleVariant (  )  ;", "}", "METHOD_END"], "methodName": ["testKeywords"], "fileName": "com.intellij.json.JsonCompletionTest"}, {"methodBody": ["METHOD_START", "{", "doTestSingleVariant (  )  ;", "}", "METHOD_END"], "methodName": ["testKeywords_2"], "fileName": "com.intellij.json.JsonCompletionTest"}, {"methodBody": ["METHOD_START", "{", "PsiFile   file    =    element . getContainingFile (  )  ;", "if    ( file    =  =    null )", "return   Language . INSTANCE ;", "Language   language    =    file . getLanguage (  )  ;", "return   language   instanceof   Language    ?    language    :    Language . INSTANCE ;", "}", "METHOD_END"], "methodName": ["getLanguage"], "fileName": "com.intellij.json.JsonDialectUtil"}, {"methodBody": ["METHOD_START", "{", "return    ( JsonDialectUtil . getLanguage ( element )  )     =  =     ( JsonLanguage . INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["isStandardJson"], "fileName": "com.intellij.json.JsonDialectUtil"}, {"methodBody": ["METHOD_START", "{", "final   JsonCodeStyleSettings   settings    =    getCustomCodeStyleSettings (  )  ;", "final   CommonCodeStyleSettings . IndentOptions   indentOptions    =    getIndentOptions (  )  ;", "final      oldPropertyAlignment    =    settings . PROPERTY _ ALIGNMENT ;", "final      oldIndentSize    =    indentOptions . INDENT _ SIZE ;", "settings . PROPERTY _ ALIGNMENT    =    JsonCodeStyleSettings . ALIGN _ PROPERTY _ ON _ VALUE ;", "indentOptions . INDENT _ SIZE    =     4  ;", "try    {", "doTest (  \"  \\ n \"  )  ;", "}    finally    {", "indentOptions . INDENT _ SIZE    =    oldIndentSize ;", "settings . PROPERTY _ ALIGNMENT    =    oldPropertyAlignment ;", "}", "}", "METHOD_END"], "methodName": ["doEnterTestForWeb11600"], "fileName": "com.intellij.json.JsonEditingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =     \" editing /  \"     +     ( getTestName ( false )  )  ;", "myFixture . configureByFile (  ( testName    +     \"  . json \"  )  )  ;", "myFixture . type ( characters )  ;", "myFixture . checkResultByFile (  ( testName    +     \"  . after . json \"  )  )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.json.JsonEditingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  \\ n \"  )  ;", "}", "METHOD_END"], "methodName": ["testContinuationIndentAfterColon"], "fileName": "com.intellij.json.JsonEditingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  \\ n \"  )  ;", "}", "METHOD_END"], "methodName": ["testContinuationIndentAfterPropertyKey"], "fileName": "com.intellij.json.JsonEditingTest"}, {"methodBody": ["METHOD_START", "{", "doEnterTestForWeb 1  1  6  0  0  (  )  ;", "}", "METHOD_END"], "methodName": ["testEnterWhenPropertiesAlignedOnValue"], "fileName": "com.intellij.json.JsonEditingTest"}, {"methodBody": ["METHOD_START", "{", "doEnterTestForWeb 1  1  6  0  0  (  )  ;", "}", "METHOD_END"], "methodName": ["testEnterWhenPropertiesAlignedOnValue1"], "fileName": "com.intellij.json.JsonEditingTest"}, {"methodBody": ["METHOD_START", "{", "final   CommonCodeStyleSettings . IndentOptions   indentOptions    =    getIndentOptions (  )  ;", "final   CommonCodeStyleSettings . IndentOptions   oldSettings    =     (  ( CommonCodeStyleSettings . IndentOptions )     ( indentOptions . clone (  )  )  )  ;", "indentOptions . TAB _ SIZE    =     4  ;", "indentOptions . INDENT _ SIZE    =     4  ;", "indentOptions . USE _ TAB _ CHARACTER    =    true ;", "indentOptions . SMART _ TABS    =    true ;", "try    {", "doTest (  \"  \\ n \\  \" baz \\  \"  \"  )  ;", "}    finally    {", "indentOptions . copyFrom ( oldSettings )  ;", "}", "}", "METHOD_END"], "methodName": ["testIndentWithTabsWhenSmartTabEnabled"], "fileName": "com.intellij.json.JsonEditingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  \\ n \"  )  ;", "}", "METHOD_END"], "methodName": ["testNormalIndentAfterPropertyWithoutComma"], "fileName": "com.intellij.json.JsonEditingTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . testFolding (  (  (  (  ( getTestDataPath (  )  )     +     \"  / folding /  \"  )     +     ( getTestName ( false )  )  )     +     \"  . json \"  )  )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.json.JsonFoldingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testArrayFolding"], "fileName": "com.intellij.json.JsonFoldingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testCommentaries"], "fileName": "com.intellij.json.JsonFoldingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testObjectFolding"], "fileName": "com.intellij.json.JsonFoldingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testObjectLiteral2"], "fileName": "com.intellij.json.JsonFoldingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testObjectLiteral3"], "fileName": "com.intellij.json.JsonFoldingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testObjectLiteral4"], "fileName": "com.intellij.json.JsonFoldingTest"}, {"methodBody": ["METHOD_START", "{", "getCustomCodeStyleSettings (  )  . PROPERTY _ ALIGNMENT    =    alignmentType . getId (  )  ;", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["checkPropertyAlignment"], "fileName": "com.intellij.json.JsonFormattingTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  (  ( getTestName ( false )  )     +     \"  . json \"  )  )  ;", "WriteCommandAction . runWriteCommandAction ( null ,     (  )     -  >     {", "CodeStyleManager   codeStyleManager    =    CodeStyleManager . getInstance ( myFixture . getProject (  )  )  ;", "codeStyleManager . reformat ( myFixture . getFile (  )  )  ;", "}  )  ;", "myFixture . checkResultByFile (  (  ( getTestName ( false )  )     +     \"  _ after . json \"  )  )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.json.JsonFormattingTest"}, {"methodBody": ["METHOD_START", "{", "checkPropertyAlignment ( JsonCodeStyleSettings . PropertyAlignment . ALIGN _ ON _ COLON )  ;", "}", "METHOD_END"], "methodName": ["testAlignPropertiesOnColon"], "fileName": "com.intellij.json.JsonFormattingTest"}, {"methodBody": ["METHOD_START", "{", "checkPropertyAlignment ( JsonCodeStyleSettings . PropertyAlignment . ALIGN _ ON _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["testAlignPropertiesOnValue"], "fileName": "com.intellij.json.JsonFormattingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testBlankLinesStripping"], "fileName": "com.intellij.json.JsonFormattingTest"}, {"methodBody": ["METHOD_START", "{", "getCustomCodeStyleSettings (  )  . ARRAY _ WRAPPING    =    CommonCodeStyleSettings . WRAP _ ON _ EVERY _ ITEM ;", "getCodeStyleSettings (  )  . setRightMargin ( JsonLanguage . INSTANCE ,     4  0  )  ;", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testChopDownArrays"], "fileName": "com.intellij.json.JsonFormattingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testContainerElementsAlignment"], "fileName": "com.intellij.json.JsonFormattingTest"}, {"methodBody": ["METHOD_START", "{", "getCustomCodeStyleSettings (  )  . PROPERTY _ ALIGNMENT    =    JsonCodeStyleSettings . PropertyAlignment . ALIGN _ ON _ VALUE . getId (  )  ;", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testDoNotThrowFailedToAlignException"], "fileName": "com.intellij.json.JsonFormattingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testObjectsWithSingleProperty"], "fileName": "com.intellij.json.JsonFormattingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testReformatIncompleteJson1"], "fileName": "com.intellij.json.JsonFormattingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testReformatIncompleteJson2"], "fileName": "com.intellij.json.JsonFormattingTest"}, {"methodBody": ["METHOD_START", "{", "getIndentOptions (  )  . INDENT _ SIZE    =     4  ;", "do (  )  ;", "}", "METHOD_END"], "methodName": ["testReformatJSon"], "fileName": "com.intellij.json.JsonFormattingTest"}, {"methodBody": ["METHOD_START", "{", "getIndentOptions (  )  . INDENT _ SIZE    =     4  ;", "do (  )  ;", "}", "METHOD_END"], "methodName": ["testReformatJSon2"], "fileName": "com.intellij.json.JsonFormattingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testRemoveTrailingCommas"], "fileName": "com.intellij.json.JsonFormattingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testSpacesInsertion"], "fileName": "com.intellij.json.JsonFormattingTest"}, {"methodBody": ["METHOD_START", "{", "CommonCodeStyleSettings . IndentOptions   options    =    getIndentOptions (  )  ;", "options . INDENT _ SIZE    =     8  ;", "options . USE _ TAB _ CHARACTER    =    true ;", "options . TAB _ SIZE    =     8  ;", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testWeb3830"], "fileName": "com.intellij.json.JsonFormattingTest"}, {"methodBody": ["METHOD_START", "{", "getCodeStyleSettings (  )  . setRightMargin ( JsonLanguage . INSTANCE ,     2  0  )  ;", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testWrapping"], "fileName": "com.intellij.json.JsonFormattingTest"}, {"methodBody": ["METHOD_START", "{", "final   JsonStandardComplianceInspection   inspection    =    new   JsonStandardComplianceInspection (  )  ;", "inspection . myWarnAboutComments    =    checkComments ;", "inspection . myWarnAboutMultipleTopLevelValues    =    checkTopLevelValues ;", "myFixture . enableInspections ( inspection )  ;", "}", "METHOD_END"], "methodName": ["enableStandardComplianceInspection"], "fileName": "com.intellij.json.JsonHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "enableStandardComplianceInspection ( true ,    true )  ;", "doTest ( false ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["testComplianceProblems"], "fileName": "com.intellij.json.JsonHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "enableStandardComplianceInspection ( true ,    true )  ;", "do (  )  ;", "}", "METHOD_END"], "methodName": ["testComplianceProblemsLiteralTopLevelValueIsAllowed"], "fileName": "com.intellij.json.JsonHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "enableStandardComplianceInspection ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testComplianceProblemsMultipleTopLevelValuesAllowed"], "fileName": "com.intellij.json.JsonHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . enableInspections ( JsonDuplicatePropertyKeysInspection . class )  ;", "doTest ( false ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["testDuplicatePropertyKeys"], "fileName": "com.intellij.json.JsonHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestHighlighting ( false ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testIncompleteFloatingPointLiteralsWithExponent"], "fileName": "com.intellij.json.JsonHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "enableStandardComplianceInspection ( true ,    true )  ;", "doTest ( false ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["testJSON"], "fileName": "com.intellij.json.JsonHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "enableStandardComplianceInspection ( false ,    true )  ;", "doTest ( false ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["testJSON_with_comment"], "fileName": "com.intellij.json.JsonHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testSemanticHighlighting"], "fileName": "com.intellij.json.JsonHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testStringLiterals"], "fileName": "com.intellij.json.JsonHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTestHighlighting ( true ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.json.JsonHighlightingTestBase"}, {"methodBody": ["METHOD_START", "{", "myFixture . testHighlighting ( checkWarning ,    checkInfo ,    checkWeakWarning ,     (  (  (  \"  / highlighting /  \"     +     ( getTestName ( false )  )  )     +     \"  .  \"  )     +     ( getExtension (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestHighlighting"], "fileName": "com.intellij.json.JsonHighlightingTestBase"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  [  \\  \"  \\  \\  /  \\  \"  ,  -  1  ,  \\  \"  \\  \\ n \\  \"  ,     1  ]  \"  ,     (  \"  [     (  \\  '  [  \\  '  )  \\ n \"     +     (  (  (  (  (  (  (  (  \" DOUBLE _ QUOTED _ STRING    (  \\  '  \\  \"  \\  \\  /  \\  \"  \\  '  )  \\ n \"     +     \"  ,     (  \\  '  ,  \\  '  )  \\ n \"  )     +     \" NUMBER    (  \\  '  -  1  \\  '  )  \\ n \"  )     +     \"  ,     (  \\  '  ,  \\  '  )  \\ n \"  )     +     \" DOUBLE _ QUOTED _ STRING    (  \\  '  \\  \"  \\  \\ n \\  \"  \\  '  )  \\ n \"  )     +     \"  ,     (  \\  '  ,  \\  '  )  \\ n \"  )     +     \" WHITE _ SPACE    (  \\  '     \\  '  )  \\ n \"  )     +     \" NUMBER    (  \\  '  1  \\  '  )  \\ n \"  )     +     \"  ]     (  '  ]  '  )  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testEscapeSlash"], "fileName": "com.intellij.json.JsonLexerTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( false )  ;", "FileDocumentManager . getInstance (  )  . reloadFromDisk ( myFixture . getDocument ( myFixture . getFile (  )  )  )  ;", "doTest ( true )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.json.JsonLineMoverTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testName    =    getTestName ( false )  ;", "if    ( down )     {", "myFixture . configureByFile (  (  (  \" mover /  \"     +    testName )     +     \"  \"  )  )  ;", "myFixture . performEditorAction ( ACTION _ MOVE _ STATEMENT _ DOWN _ ACTION )  ;", "myFixture . checkResultByFile (  (  (  \" mover /  \"     +    testName )     +     \"  _ afterDown \"  )  ,    true )  ;", "} else    {", "myFixture . configureByFile (  (  (  \" mover /  \"     +    testName )     +     \"  \"  )  )  ;", "myFixture . performEditorAction ( ACTION _ MOVE _ STATEMENT _ UP _ ACTION )  ;", "myFixture . checkResultByFile (  (  (  \" mover /  \"     +    testName )     +     \"  _ afterUp \"  )  ,    true )  ;", "}", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.json.JsonLineMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( true )  ;", "}", "METHOD_END"], "methodName": ["testArraySelectionMovedDown"], "fileName": "com.intellij.json.JsonLineMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( false )  ;", "}", "METHOD_END"], "methodName": ["testLastArrayElementMovedUp"], "fileName": "com.intellij.json.JsonLineMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( false )  ;", "}", "METHOD_END"], "methodName": ["testLastObjectPropertyMovedUp"], "fileName": "com.intellij.json.JsonLineMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( true )  ;", "}", "METHOD_END"], "methodName": ["testLineCommentariesMovedTogether"], "fileName": "com.intellij.json.JsonLineMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( true )  ;", "}", "METHOD_END"], "methodName": ["testObjectSelectionMovedDown"], "fileName": "com.intellij.json.JsonLineMoverTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testWeb_10585"], "fileName": "com.intellij.json.JsonLineMoverTest"}, {"methodBody": ["METHOD_START", "{", "final   List < Pair < TextRange ,    String >  >    actual    =    createStringLiteralFromText ( rawStringLiteral )  . getTextFragments (  )  ;", "final   List <  ?  >    expected    =    Arrays . asList ( fragments )  ;", "assertEquals ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["checkFragments"], "fileName": "com.intellij.json.JsonLiteralApiTest"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( content ,    createStringLiteralFromContent ( content )  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkStringContent"], "fileName": "com.intellij.json.JsonLiteralApiTest"}, {"methodBody": ["METHOD_START", "{", "return   new   JsonElementGenerator ( getProject (  )  )  . createStringLiteral ( unescapedContent )  ;", "}", "METHOD_END"], "methodName": ["createStringLiteralFromContent"], "fileName": "com.intellij.json.JsonLiteralApiTest"}, {"methodBody": ["METHOD_START", "{", "final   JsonArray   jsonArray    =    new   JsonElementGenerator ( getProject (  )  )  . createValue (  (  (  \"  [  \\ n \"     +    rawText )     +     \"  \\ n ]  \"  )  )  ;", "assertEquals (  1  ,    jsonArray . getValueList (  )  . size (  )  )  ;", "final   JsonValue   firstElement    =    jsonArray . getValueList (  )  . get (  0  )  ;", "assertInstanceOf ( firstElement ,    JsonString . class )  ;", "return    (  ( JsonString )     ( firstElement )  )  ;", "}", "METHOD_END"], "methodName": ["createStringLiteralFromText"], "fileName": "com.intellij.json.JsonLiteralApiTest"}, {"methodBody": ["METHOD_START", "{", "return   Pair . create ( new   TextRange ( start ,    end )  ,    chunk )  ;", "}", "METHOD_END"], "methodName": ["fragment"], "fileName": "com.intellij.json.JsonLiteralApiTest"}, {"methodBody": ["METHOD_START", "{", "final   JsonElementGenerator   generator    =    new   JsonElementGenerator ( getProject (  )  )  ;", "assertTrue ( generator .  < JsonBoolea > createValue (  \" true \"  )  . getValue (  )  )  ;", "assertFalse ( generator .  < JsonBoolea > createValue (  \" false \"  )  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBooleanLiteralValue"], "fileName": "com.intellij.json.JsonLiteralApiTest"}, {"methodBody": ["METHOD_START", "{", "checkFragments (  \"  \\  \"  \\  \\ q \\  \\ zz \\  \\ uBEE \\  \\ u \\  \\     \"  ,    JsonLiteralApiTest . fragment (  1  ,     3  ,     \"  \\  \\ q \"  )  ,    JsonLiteralApiTest . fragment (  3  ,     5  ,     \"  \\  \\ z \"  )  ,    JsonLiteralApiTest . fragment (  5  ,     6  ,     \" z \"  )  ,    JsonLiteralApiTest . fragment (  6  ,     1  1  ,     \"  \\  \\ uBEE \"  )  ,    JsonLiteralApiTest . fragment (  1  1  ,     1  3  ,     \"  \\  \\ u \"  )  ,    JsonLiteralApiTest . fragment (  1  3  ,     1  5  ,     \"  \\  \\     \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testFragmentSplittingIllegalEscapes"], "fileName": "com.intellij.json.JsonLiteralApiTest"}, {"methodBody": ["METHOD_START", "{", "checkFragments (  \"  \\  \"  \\  \\ b \\  \\ f \\  \\ n \\  \\ r \\  \\ t \\  \\  \\  \\  \\  \\  /  \\  \\  \\  \"  \\  \"  \"  ,    JsonLiteralApiTest . fragment (  1  ,     3  ,     \"  \\ b \"  )  ,    JsonLiteralApiTest . fragment (  3  ,     5  ,     \"  \\ f \"  )  ,    JsonLiteralApiTest . fragment (  5  ,     7  ,     \"  \\ n \"  )  ,    JsonLiteralApiTest . fragment (  7  ,     9  ,     \"  \\ r \"  )  ,    JsonLiteralApiTest . fragment (  9  ,     1  1  ,     \"  \\ t \"  )  ,    JsonLiteralApiTest . fragment (  1  1  ,     1  3  ,     \"  \\  \\  \"  )  ,    JsonLiteralApiTest . fragment (  1  3  ,     1  5  ,     \"  /  \"  )  ,    JsonLiteralApiTest . fragment (  1  5  ,     1  7  ,     \"  \\  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testFragmentSplittingSimpleEscapes"], "fileName": "com.intellij.json.JsonLiteralApiTest"}, {"methodBody": ["METHOD_START", "{", "checkFragments (  \"  \\  ' foo \\  \\ uCAFEBABE \\  \\ u 0  0  2  7 baz \\  '  \"  ,    JsonLiteralApiTest . fragment (  1  ,     4  ,     \" foo \"  )  ,    JsonLiteralApiTest . fragment (  4  ,     1  0  ,     \"  \\  \\ uCAFE \"  )  ,    JsonLiteralApiTest . fragment (  1  0  ,     1  4  ,     \" BABE \"  )  ,    JsonLiteralApiTest . fragment (  1  4  ,     2  0  ,     \"  \\  \\ u 0  0  2  7  \"  )  ,    JsonLiteralApiTest . fragment (  2  0  ,     2  4  ,     \" baz \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testFragmentSplittingUnicodeEscapes"], "fileName": "com.intellij.json.JsonLiteralApiTest"}, {"methodBody": ["METHOD_START", "{", "final   JsonElementGenerator   generator    =    new   JsonElementGenerator ( getProject (  )  )  ;", "assertEquals (  1  2  3  .  0  ,    generator .  < JsonNumber > createValue (  \"  1  2  3  .  0  \"  )  . getValue (  )  ,     1  .  0 E -  5  )  ;", "assertEquals (  0  .  1  ,    generator .  < JsonNumber > createValue (  \"  0  .  1  \"  )  . getValue (  )  ,     1  .  0 E -  5  )  ;", "assertEquals (  1  0  0  0  .  0  ,    generator .  < JsonNumber > createValue (  \"  1 e 3  \"  )  . getValue (  )  ,     1  .  0 E -  5  )  ;", "assertEquals (  1  0  0  0  .  0  ,    generator .  < JsonNumber > createValue (  \"  1 e +  3  \"  )  . getValue (  )  ,     1  .  0 E -  5  )  ;", "assertEquals (  0  .  0  0  1  ,    generator .  < JsonNumber > createValue (  \"  1 e -  3  \"  )  . getValue (  )  ,     1  .  0 E -  5  )  ;", "assertEquals (  1  0  0  0  .  0  ,    generator .  < JsonNumber > createValue (  \"  1  .  0  0 e 3  \"  )  . getValue (  )  ,     1  .  0 E -  5  )  ;", "assertEquals (  0  .  0  0  1  2  3  ,    generator .  < JsonNumber > createValue (  \"  1  .  2  3 e -  3  \"  )  . getValue (  )  ,     1  .  0 E -  5  )  ;", "}", "METHOD_END"], "methodName": ["testNumberLiteralValue"], "fileName": "com.intellij.json.JsonLiteralApiTest"}, {"methodBody": ["METHOD_START", "{", "checkStringContent (  \" simple \"  )  ;", "checkStringContent (  . ALL _ CHARACTER _ ESCAPES )  ;", "checkStringContent (  \"  \\ u 0  4  3 c \\ u 0  4  3  5  \\ u 0  4  3  4  \\ u 0  4  3  2  \\ u 0  4  3  5  \\ u 0  4  3  4  \\ u 0  4  4 c \"  )  ;", "}", "METHOD_END"], "methodName": ["testStringLiteralValue"], "fileName": "com.intellij.json.JsonLiteralApiTest"}, {"methodBody": ["METHOD_START", "{", "final   TemplateManager   templateManager    =    TemplateManager . getInstance ( getProject (  )  )  ;", "final   Template   template    =    templateManager . creat ( name ,    group ,    text )  ;", "final   TemplateContextType   context    =    ContainerUtil . findInstance ( EP _ NAME . getExtensions (  )  ,    JsonContextType . class )  ;", "assertNotNull ( context )  ;", "(  ( TemplateImpl )     ( template )  )  . getTemplateContext (  )  . setEnabled ( context ,    true )  ;", "CodeInsightTestUtil . addTemplate ( template ,    myFixture . getTestRootDisposable (  )  )  ;", "return   template ;", "}", "METHOD_END"], "methodName": ["createJsonTemplate"], "fileName": "com.intellij.json.JsonLiveTemplateTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText ( JsonFileType . INSTANCE ,    text )  ;", "final      template    =    createJson (  \" foo \"  ,     \" foo \"  ,     \"  [  4  2  ]  \"  )  ;", "return   ManagerImpl . isApplicable ( myFixture . getFile (  )  ,    myFixture . getCaretOffset (  )  ,     (  ( Impl )     ( template )  )  )  ;", "}", "METHOD_END"], "methodName": ["isApplicableContextUnderCaret"], "fileName": "com.intellij.json.JsonLiveTemplateTest"}, {"methodBody": ["METHOD_START", "{", "final   String   templateContent    =     \"  {  \\ n \"     +     (  \"        \\  \" foo \\  \"  :     \\  \"  $  1  $  \\  \"  \\ n \"     +     \"  }  \"  )  ;", "createJson (  \" foo \"  ,     \" foo \"  ,    templateContent )  ;", "myFixture . configureByText ( JsonFileType . INSTANCE ,     \" foo < caret >  \"  )  ;", "final   Editor   editor    =    myFixture . getEditor (  )  ;", "new   ListsAction (  )  . actionPerformedImpl ( getProject (  )  ,    editor )  ;", "final   LookupImpl   lookup    =     (  ( LookupImpl )     ( LookupManager . getActiveLookup ( editor )  )  )  ;", "assertNotNull ( lookup )  ;", "lookup . finishLookup ( NORMAL _ SELECT _ CHAR )  ;", "myFixture . checkResult ( templateContent . replaceAll (  \"  \\  \\  $  .  *  ?  \\  \\  $  \"  ,     \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomTemplateExpansion"], "fileName": "com.intellij.json.JsonLiveTemplateTest"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( isApplicableContextUnderCaret (  \" fo < caret > o \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testExpandableAtTopLevel"], "fileName": "com.intellij.json.JsonLiveTemplateTest"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( isApplicableContextUnderCaret (  \"  { fo < caret > o }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testExpandableInObjectLiteral"], "fileName": "com.intellij.json.JsonLiveTemplateTest"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( isApplicableContextUnderCaret (  \"  { fo < caret > o :     \\  \" bar \\  \"  }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testNotExpandableInsidePropertyKey"], "fileName": "com.intellij.json.JsonLiveTemplateTest"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( isApplicableContextUnderCaret (  \"  { fo < caret > o    :     \\  \" bar \\  \"  }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testNotExpandableInsidePropertyKeyWithWhitespace"], "fileName": "com.intellij.json.JsonLiveTemplateTest"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( isApplicableContextUnderCaret (  \"  {  \\  \" bar \\  \"  :     \\  \" fo < caret > o \\  \"  }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testNotExpandableInsideStringLiteral"], "fileName": "com.intellij.json.JsonLiveTemplateTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  (  (  \" navigation /  \"     +     ( getTestName ( false )  )  )     +     \"  . json \"  )  )  ;", "final   PsiElement   element    =    myFixture . getElementAtCaret (  )  ;", "assertInstanceOf ( element ,    JsonProperty . class )  ;", "final   String   qualifiedName    =    CopyReferenceAction . elementToFqn ( element )  ;", "assertEquals (  \" foo . bar [  0  ]  [  0  ]  . baz \"  ,    qualifiedName )  ;", "}", "METHOD_END"], "methodName": ["testCopyReference"], "fileName": "com.intellij.json.JsonNavigationTest"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" array \"  )  )  )", "return   false ;", "if    (  !  ( nextTokenIs ( b ,    JsonElementTypes . L _ BRACKET )  )  )", "return   false ;", "boolean   r ;", "boolean   p ;", "Marker   m    =    enter _ section _  ( b ,    l ,     _ NONE _  ,    JsonElementTypes . ARRAY ,    null )  ;", "r    =    consumeToken ( b ,    JsonElementTypes . L _ BRACKET )  ;", "p    =    r ;", "r    =    r    &  &     ( report _ error _  ( b ,     . array _  1  ( b ,     ( l    +     1  )  )  )  )  ;", "r    =     ( p    &  &     ( consumeToken ( b ,    JsonElementTypes . R _ BRACKET )  )  )     &  &    r ;", "exit _ section _  ( b ,    l ,    m ,    r ,    p ,    null )  ;", "return   r    |  |    p ;", "}", "METHOD_END"], "methodName": ["array"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" array _  1  \"  )  )  )", "return   false ;", "c    =    current _ position _  ( b )  ;", "while    ( true )     {", "if    (  !  (  . array _ element ( b ,     ( l    +     1  )  )  )  )", "break ;", "if    (  !  ( empty _ element _ parsed _ guard _  ( b ,     \" array _  1  \"  ,    c )  )  )", "break ;", "c    =    current _ position _  ( b )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["array_1"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" array _ element \"  )  )  )", "return   false ;", "boolean   r ;", "boolean   p ;", "Marker   m    =    enter _ section _  ( b ,    l ,     _ NONE _  )  ;", "r    =     . value ( b ,     ( l    +     1  )  )  ;", "p    =    r ;", "r    =    r    &  &     (  . array _ element _  1  ( b ,     ( l    +     1  )  )  )  ;", "exit _ section _  ( b ,    l ,    m ,    r ,    p ,     . not _ bracket _ or _ next _ value _ parser _  )  ;", "return   r    |  |    p ;", "}", "METHOD_END"], "methodName": ["array_element"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" array _ element _  1  \"  )  )  )", "return   false ;", "boolean   r ;", "Marker   m    =    enter _ section _  ( b )  ;", "r    =    consumeToken ( b ,    JsonElementTypes . COMMA )  ;", "if    (  ! r )", "r    =     . array _ element _  1  _  1  ( b ,     ( l    +     1  )  )  ;", "exit _ section _  ( b ,    m ,    null ,    r )  ;", "return   r ;", "}", "METHOD_END"], "methodName": ["array_element_1"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" array _ element _  1  _  1  \"  )  )  )", "return   false ;", "boolean   r ;", "Marker   m    =    enter _ section _  ( b ,    l ,     _ AND _  )  ;", "r    =    consumeToken ( b ,    ElementTypes . R _ BRACKET )  ;", "exit _ section _  ( b ,    l ,    m ,    r ,    false ,    null )  ;", "return   r ;", "}", "METHOD_END"], "methodName": ["array_element_1_1"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" boolean _ literal \"  )  )  )", "return   false ;", "if    (  !  ( nextTokenIs ( b ,     \"  < boolean   literal >  \"  ,    ElementTypes . FALSE ,    ElementTypes . TRUE )  )  )", "return   false ;", "boolean   r ;", "Marker   m    =    enter _ section _  ( b ,    l ,     _ NONE _  ,    ElementTypes . BOOLEAN _ LITERAL ,     \"  < boolean   literal >  \"  )  ;", "r    =    consumeToken ( b ,    ElementTypes . TRUE )  ;", "if    (  ! r )", "r    =    consumeToken ( b ,    ElementTypes . FALSE )  ;", "exit _ section _  ( b ,    l ,    m ,    r ,    false ,    null )  ;", "return   r ;", "}", "METHOD_END"], "methodName": ["boolean_literal"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" json \"  )  )  )", "return   false ;", "boolean   r ;", "Marker   m    =    enter _ section _  ( b )  ;", "r    =     . value ( b ,     ( l    +     1  )  )  ;", "c    =    current _ position _  ( b )  ;", "while    ( r )     {", "if    (  !  (  . value ( b ,     ( l    +     1  )  )  )  )", "break ;", "if    (  !  ( empty _ element _ parsed _ guard _  ( b ,     \" json \"  ,    c )  )  )", "break ;", "c    =    current _ position _  ( b )  ;", "}", "exit _ section _  ( b ,    m ,    null ,    r )  ;", "return   r ;", "}", "METHOD_END"], "methodName": ["json"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" literal \"  )  )  )", "return   false ;", "boolean   r ;", "Marker   m    =    enter _ section _  ( b ,    l ,     _ COLLAPSE _  ,    JsonElementTypes . LITERAL ,     \"  < literal >  \"  )  ;", "r    =     . string _ literal ( b ,     ( l    +     1  )  )  ;", "if    (  ! r )", "r    =     . number _ literal ( b ,     ( l    +     1  )  )  ;", "if    (  ! r )", "r    =     . boolean _ literal ( b ,     ( l    +     1  )  )  ;", "if    (  ! r )", "r    =     . null _ literal ( b ,     ( l    +     1  )  )  ;", "exit _ section _  ( b ,    l ,    m ,    r ,    false ,    null )  ;", "return   r ;", "}", "METHOD_END"], "methodName": ["literal"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" not _ brace _ or _ next _ value \"  )  )  )", "return   false ;", "boolean   r ;", "Marker   m    =    enter _ section _  ( b ,    l ,     _ NOT _  )  ;", "r    =     !  (  . not _ brace _ or _ next _ value _  0  ( b ,     ( l    +     1  )  )  )  ;", "exit _ section _  ( b ,    l ,    m ,    r ,    false ,    null )  ;", "return   r ;", "}", "METHOD_END"], "methodName": ["not_brace_or_next_value"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" not _ brace _ or _ next _ value _  0  \"  )  )  )", "return   false ;", "boolean   r ;", "Marker   m    =    enter _ section _  ( b )  ;", "r    =    consumeToken ( b ,    JsonElementTypes . R _ CURLY )  ;", "if    (  ! r )", "r    =     . value ( b ,     ( l    +     1  )  )  ;", "exit _ section _  ( b ,    m ,    null ,    r )  ;", "return   r ;", "}", "METHOD_END"], "methodName": ["not_brace_or_next_value_0"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" not _ bracket _ or _ next _ value \"  )  )  )", "return   false ;", "boolean   r ;", "Marker   m    =    enter _ section _  ( b ,    l ,     _ NOT _  )  ;", "r    =     !  (  . not _ bracket _ or _ next _ value _  0  ( b ,     ( l    +     1  )  )  )  ;", "exit _ section _  ( b ,    l ,    m ,    r ,    false ,    null )  ;", "return   r ;", "}", "METHOD_END"], "methodName": ["not_bracket_or_next_value"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" not _ bracket _ or _ next _ value _  0  \"  )  )  )", "return   false ;", "boolean   r ;", "Marker   m    =    enter _ section _  ( b )  ;", "r    =    consumeToken ( b ,    JsonElementTypes . R _ BRACKET )  ;", "if    (  ! r )", "r    =     . value ( b ,     ( l    +     1  )  )  ;", "exit _ section _  ( b ,    m ,    null ,    r )  ;", "return   r ;", "}", "METHOD_END"], "methodName": ["not_bracket_or_next_value_0"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" null _ literal \"  )  )  )", "return   false ;", "if    (  !  ( nextTokenIs ( b ,    ElementTypes . NULL )  )  )", "return   false ;", "boolean   r ;", "Marker   m    =    enter _ section _  ( b )  ;", "r    =    consumeToken ( b ,    ElementTypes . NULL )  ;", "exit _ section _  ( b ,    m ,    ElementTypes . NULL _ LITERAL ,    r )  ;", "return   r ;", "}", "METHOD_END"], "methodName": ["null_literal"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" number _ literal \"  )  )  )", "return   false ;", "if    (  !  ( nextTokenIs ( b ,    ElementTypes . NUMBER )  )  )", "return   false ;", "boolean   r ;", "Marker   m    =    enter _ section _  ( b )  ;", "r    =    consumeToken ( b ,    ElementTypes . NUMBER )  ;", "exit _ section _  ( b ,    m ,    ElementTypes . NUMBER _ LITERAL ,    r )  ;", "return   r ;", "}", "METHOD_END"], "methodName": ["number_literal"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" object \"  )  )  )", "return   false ;", "if    (  !  ( nextTokenIs ( b ,    JsonElementTypes . L _ CURLY )  )  )", "return   false ;", "boolean   r ;", "boolean   p ;", "Marker   m    =    enter _ section _  ( b ,    l ,     _ NONE _  ,    JsonElementTypes . OBJECT ,    null )  ;", "r    =    consumeToken ( b ,    JsonElementTypes . L _ CURLY )  ;", "p    =    r ;", "r    =    r    &  &     ( report _ error _  ( b ,     . object _  1  ( b ,     ( l    +     1  )  )  )  )  ;", "r    =     ( p    &  &     ( consumeToken ( b ,    JsonElementTypes . R _ CURLY )  )  )     &  &    r ;", "exit _ section _  ( b ,    l ,    m ,    r ,    p ,    null )  ;", "return   r    |  |    p ;", "}", "METHOD_END"], "methodName": ["object"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" object _  1  \"  )  )  )", "return   false ;", "c    =    current _ position _  ( b )  ;", "while    ( true )     {", "if    (  !  (  . object _ element ( b ,     ( l    +     1  )  )  )  )", "break ;", "if    (  !  ( empty _ element _ parsed _ guard _  ( b ,     \" object _  1  \"  ,    c )  )  )", "break ;", "c    =    current _ position _  ( b )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["object_1"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" object _ element \"  )  )  )", "return   false ;", "boolean   r ;", "boolean   p ;", "Marker   m    =    enter _ section _  ( b ,    l ,     _ NONE _  )  ;", "r    =     . property ( b ,     ( l    +     1  )  )  ;", "p    =    r ;", "r    =    r    &  &     (  . object _ element _  1  ( b ,     ( l    +     1  )  )  )  ;", "exit _ section _  ( b ,    l ,    m ,    r ,    p ,     . not _ brace _ or _ next _ value _ parser _  )  ;", "return   r    |  |    p ;", "}", "METHOD_END"], "methodName": ["object_element"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" object _ element _  1  \"  )  )  )", "return   false ;", "boolean   r ;", "Marker   m    =    enter _ section _  ( b )  ;", "r    =    consumeToken ( b ,    JsonElementTypes . COMMA )  ;", "if    (  ! r )", "r    =     . object _ element _  1  _  1  ( b ,     ( l    +     1  )  )  ;", "exit _ section _  ( b ,    m ,    null ,    r )  ;", "return   r ;", "}", "METHOD_END"], "methodName": ["object_element_1"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" object _ element _  1  _  1  \"  )  )  )", "return   false ;", "boolean   r ;", "Marker   m    =    enter _ section _  ( b ,    l ,     _ AND _  )  ;", "r    =    consumeToken ( b ,    ElementTypes . R _ CURLY )  ;", "exit _ section _  ( b ,    l ,    m ,    r ,    false ,    null )  ;", "return   r ;", "}", "METHOD_END"], "methodName": ["object_element_1_1"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "parseLight ( t ,    b )  ;", "return   b . getTreeBuilt (  )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "boolean   r ;", "b    =    adapt _ builder _  ( t ,    b ,    this ,     . EXTENDS _ SETS _  )  ;", "Marker   m    =    enter _ section _  ( b ,     0  ,     _ COLLAPSE _  ,    null )  ;", "if    ( t    =  =     ( JsonElementTypes . ARRAY )  )     {", "r    =     . array ( b ,     0  )  ;", "} else", "if    ( t    =  =     ( JsonElementTypes . BOOLEAN _ LITERAL )  )     {", "r    =     . boolean _ literal ( b ,     0  )  ;", "} else", "if    ( t    =  =     ( JsonElementTypes . LITERAL )  )     {", "r    =     . literal ( b ,     0  )  ;", "} else", "if    ( t    =  =     ( JsonElementTypes . NULL _ LITERAL )  )     {", "r    =     . null _ literal ( b ,     0  )  ;", "} else", "if    ( t    =  =     ( JsonElementTypes . NUMBER _ LITERAL )  )     {", "r    =     . number _ literal ( b ,     0  )  ;", "} else", "if    ( t    =  =     ( JsonElementTypes . OBJECT )  )     {", "r    =     . object ( b ,     0  )  ;", "} else", "if    ( t    =  =     ( JsonElementTypes . PROPERTY )  )     {", "r    =     . property ( b ,     0  )  ;", "} else", "if    ( t    =  =     ( JsonElementTypes . REFERENCE _ EXPRESSION )  )     {", "r    =     . reference _ expression ( b ,     0  )  ;", "} else", "if    ( t    =  =     ( JsonElementTypes . STRING _ LITERAL )  )     {", "r    =     . string _ literal ( b ,     0  )  ;", "} else", "if    ( t    =  =     ( JsonElementTypes . VALUE )  )     {", "r    =     . value ( b ,     0  )  ;", "} else    {", "r    =    parse _ root _  ( t ,    b ,     0  )  ;", "}", "exit _ section _  ( b ,     0  ,    m ,    t ,    r ,    true ,    TRUE _ CONDITION )  ;", "}", "METHOD_END"], "methodName": ["parseLight"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "return   JsonParser . json ( b ,     ( l    +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["parse_root_"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" property \"  )  )  )", "return   false ;", "boolean   r ;", "boolean   p ;", "Marker   m    =    enter _ section _  ( b ,    l ,     _ NONE _  ,    JsonElementTypes . PROPERTY ,     \"  < property >  \"  )  ;", "r    =     . property _ name ( b ,     ( l    +     1  )  )  ;", "p    =    r ;", "r    =    r    &  &     (  . property _  1  ( b ,     ( l    +     1  )  )  )  ;", "exit _ section _  ( b ,    l ,    m ,    r ,    p ,    null )  ;", "return   r    |  |    p ;", "}", "METHOD_END"], "methodName": ["property"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" property _  1  \"  )  )  )", "return   false ;", "boolean   r ;", "boolean   p ;", "Marker   m    =    enter _ section _  ( b ,    l ,     _ NONE _  )  ;", "r    =    consumeToken ( b ,    JsonElementTypes . COLON )  ;", "p    =    r ;", "r    =    r    &  &     (  . value ( b ,     ( l    +     1  )  )  )  ;", "exit _ section _  ( b ,    l ,    m ,    r ,    p ,    null )  ;", "return   r    |  |    p ;", "}", "METHOD_END"], "methodName": ["property_1"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" property _ name \"  )  )  )", "return   false ;", "boolean   r ;", "Marker   m    =    enter _ section _  ( b )  ;", "r    =     . literal ( b ,     ( l    +     1  )  )  ;", "if    (  ! r )", "r    =     . reference _ expression ( b ,     ( l    +     1  )  )  ;", "exit _ section _  ( b ,    m ,    null ,    r )  ;", "return   r ;", "}", "METHOD_END"], "methodName": ["property_name"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" reference _ expression \"  )  )  )", "return   false ;", "if    (  !  ( nextTokenIs ( b ,    ElementTypes . IDENTIFIER )  )  )", "return   false ;", "boolean   r ;", "Marker   m    =    enter _ section _  ( b )  ;", "r    =    consumeToken ( b ,    ElementTypes . IDENTIFIER )  ;", "exit _ section _  ( b ,    m ,    ElementTypes . REFERENCE _ EXPRESSION ,    r )  ;", "return   r ;", "}", "METHOD_END"], "methodName": ["reference_expression"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" string _ literal \"  )  )  )", "return   false ;", "if    (  !  ( nextTokenIs ( b ,     \"  < string   literal >  \"  ,    ElementTypes . DOUBLE _ QUOTED _ STRING ,    ElementTypes . SINGLE _ QUOTED _ STRING )  )  )", "return   false ;", "boolean   r ;", "Marker   m    =    enter _ section _  ( b ,    l ,     _ NONE _  ,    ElementTypes . STRING _ LITERAL ,     \"  < string   literal >  \"  )  ;", "r    =    consumeToken ( b ,    ElementTypes . SINGLE _ QUOTED _ STRING )  ;", "if    (  ! r )", "r    =    consumeToken ( b ,    ElementTypes . DOUBLE _ QUOTED _ STRING )  ;", "exit _ section _  ( b ,    l ,    m ,    r ,    false ,    null )  ;", "return   r ;", "}", "METHOD_END"], "methodName": ["string_literal"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( recursion _ guard _  ( b ,    l ,     \" value \"  )  )  )", "return   false ;", "boolean   r ;", "Marker   m    =    enter _ section _  ( b ,    l ,     _ COLLAPSE _  ,    JsonElementTypes . VALUE ,     \"  < value >  \"  )  ;", "r    =     . object ( b ,     ( l    +     1  )  )  ;", "if    (  ! r )", "r    =     . array ( b ,     ( l    +     1  )  )  ;", "if    (  ! r )", "r    =     . literal ( b ,     ( l    +     1  )  )  ;", "if    (  ! r )", "r    =     . reference _ expression ( b ,     ( l    +     1  )  )  ;", "exit _ section _  ( b ,    l ,    m ,    r ,    false ,    null )  ;", "return   r ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.intellij.json.JsonParser"}, {"methodBody": ["METHOD_START", "{", "doTest ( true )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.json.JsonParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testComments"], "fileName": "com.intellij.json.JsonParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testExtendedIdentifierToken"], "fileName": "com.intellij.json.JsonParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testIncompleteObjectProperties"], "fileName": "com.intellij.json.JsonParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testKeywords"], "fileName": "com.intellij.json.JsonParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testMissingCommaBetweenArrayElements"], "fileName": "com.intellij.json.JsonParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testMissingCommaBetweenObjectProperties"], "fileName": "com.intellij.json.JsonParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testNestedArrayLiterals"], "fileName": "com.intellij.json.JsonParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testNestedObjectLiterals"], "fileName": "com.intellij.json.JsonParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testNonStandardPropertyKeys"], "fileName": "com.intellij.json.JsonParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testNumberLiterals"], "fileName": "com.intellij.json.JsonParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testSimple1"], "fileName": "com.intellij.json.JsonParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testSimple2"], "fileName": "com.intellij.json.JsonParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testSimple4"], "fileName": "com.intellij.json.JsonParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testStringLiterals"], "fileName": "com.intellij.json.JsonParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testTopLevelStringLiteral"], "fileName": "com.intellij.json.JsonParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testTrailingCommas"], "fileName": "com.intellij.json.JsonParsingTest"}, {"methodBody": ["METHOD_START", "{", "getCustomCodeStyleSettings (  )  . OBJECT _ WRAPPING    =    CommonCodeStyleSettings . DO _ NOT _ WRAP ;", "myFixture . configureByText ( JsonFileType . INSTANCE ,    before )  ;", "final   PsiElement   atCaret    =    myFixture . getFile (  )  . findElementAt ( myFixture . getCaretOffset (  )  )  ;", "final   JsonObject   jsonObject    =    PsiTreeUtil . getParentOfType ( atCaret ,    JsonObject . class )  ;", "assertNotNull ( jsonObject )  ;", "WriteCommandAction . runWriteCommandAction ( getProject (  )  ,     (  )     -  >     {", ". addProperty ( jsonObject ,    new   JsonElementGenerator ( getProject (  )  )  . createProperty (  \" foo \"  ,     \" null \"  )  ,    first )  ;", "}  )  ;", "myFixture . checkResult ( after )  ;", "}", "METHOD_END"], "methodName": ["checkAddProperty"], "fileName": "com.intellij.json.JsonPsiUtilTest"}, {"methodBody": ["METHOD_START", "{", "checkAddProperty (  \"  {  \\  \" bar \\  \"  :     4  2  }  \"  ,     \"  {  \\  \" foo \\  \"  :    null ,     \\  \" bar \\  \"  :     4  2  }  \"  ,    true )  ;", "}", "METHOD_END"], "methodName": ["testAddPropertyFirst"], "fileName": "com.intellij.json.JsonPsiUtilTest"}, {"methodBody": ["METHOD_START", "{", "checkAddProperty (  \"  {  }  \"  ,     \"  {  \\  \" foo \\  \"  :    null }  \"  ,    true )  ;", "}", "METHOD_END"], "methodName": ["testAddPropertyInEmptyLiteral"], "fileName": "com.intellij.json.JsonPsiUtilTest"}, {"methodBody": ["METHOD_START", "{", "checkAddProperty (  \"  {  \"  ,     \"  {  \\  \" foo \\  \"  :    null \"  ,    true )  ;", "}", "METHOD_END"], "methodName": ["testAddPropertyInEmptyUnclosedLiteral"], "fileName": "com.intellij.json.JsonPsiUtilTest"}, {"methodBody": ["METHOD_START", "{", "checkAddProperty (  \"  {  \\  \" bar \\  \"  :     4  2  }  \"  ,     \"  {  \\  \" bar \\  \"  :     4  2  ,     \\  \" foo \\  \"  :    null }  \"  ,    false )  ;", "}", "METHOD_END"], "methodName": ["testAddPropertyLast"], "fileName": "com.intellij.json.JsonPsiUtilTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText ( JsonFileType . INSTANCE ,     \"  {  \\  \" firs < caret > t \\  \"     :     1  ,     \\  \" second \\  \"     :     2  }  \"  )  ;", "PsiElement   atCaret    =    myFixture . getFile (  )  . findElementAt ( myFixture . getCaretOffset (  )  )  ;", "JsonProperty   property    =    PsiTreeUtil . getParentOfType ( atCaret ,    JsonProperty . class )  ;", "assertNotNull ( property )  ;", "assertEquals ( Collections . singleton (  \" second \"  )  ,     . getOtherSiblingPropertyNames ( property )  )  ;", "}", "METHOD_END"], "methodName": ["testGetOtherSiblingPropertyNames"], "fileName": "com.intellij.json.JsonPsiUtilTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText ( JsonFileType . INSTANCE ,    before )  ;", "myFixture . enableInspections ( JsonStandardComplianceInspection . class )  ;", "final   IntentionAction   intentionAction    =    myFixture . getAvailableIntention ( JsonBundle . message (  \" quickfix . add . double . quotes . desc \"  )  )  ;", "assertNotNull ( intentionAction )  ;", "myFixture . launchAction ( intentionAction )  ;", "myFixture . checkResult ( after )  ;", "}", "METHOD_END"], "methodName": ["checkWrapInDoubleQuotes"], "fileName": "com.intellij.json.JsonQuickFixTest"}, {"methodBody": ["METHOD_START", "{", "final   String   testFileName    =     \" quickfix /  \"     +     ( getTestName ( false )  )  ;", "myFixture . enableInspections ( inspectionClass )  ;", "myFixture . configureByFile (  ( testFileName    +     \"  \"  )  )  ;", "myFixture . checkHighlighting ( true ,    false ,    false )  ;", "final   IntentionAction   intentionAction    =    myFixture . getAvailableIntention ( hint )  ;", "assertNotNull ( intentionAction )  ;", "myFixture . launchAction ( intentionAction )  ;", "myFixture . checkResultByFile (  ( testFileName    +     \"  _ after \"  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.json.JsonQuickFixTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( JsonStandardComplianceInspection . class ,    JsonBundle . message (  \" quickfix . add . double . quotes . desc \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testJSON2"], "fileName": "com.intellij.json.JsonQuickFixTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( JsonStandardComplianceInspection . class ,    JsonBundle . message (  \" quickfix . add . double . quotes . desc \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testJSON3"], "fileName": "com.intellij.json.JsonQuickFixTest"}, {"methodBody": ["METHOD_START", "{", "checkWrapInDoubleQuotes (  \"  { n < caret > ull :    false }  \"  ,     \"  {  \\  \" null \\  \"  :    false }  \"  )  ;", "checkWrapInDoubleQuotes (  \"  { t < caret > rue :    false }  \"  ,     \"  {  \\  \" true \\  \"  :    false }  \"  )  ;", "checkWrapInDoubleQuotes (  \"  {  4  < caret >  2  :    false }  \"  ,     \"  {  \\  \"  4  2  \\  \"  :    false }  \"  )  ;", "checkWrapInDoubleQuotes (  \"  { fo < caret > o :    false }  \"  ,     \"  {  \\  \" foo \\  \"  :    false }  \"  )  ;", "checkWrapInDoubleQuotes (  \"  {  ' fo < caret > o '  :    false }  \"  ,     \"  {  \\  \" foo \\  \"  :    false }  \"  )  ;", "checkWrapInDoubleQuotes (  \"  \\  ' foo \\  \\  \\  \"  \"  ,     \"  \\  \" foo \\  \\  \\  \"  \\  \"  \"  )  ;", "checkWrapInDoubleQuotes (  \"  {  \\  \" foo \\  \"  :    b < caret > ar }  \"  ,     \"  {  \\  \" foo \\  \"  :     \\  \" bar \\  \"  }  \"  )  ;", "checkWrapInDoubleQuotes (  \"  {  \\  \" foo \\  \"  :     \\  ' b < caret > ar \\  '  }  \"  ,     \"  {  \\  \" foo \\  \"  :     \\  \" bar \\  \"  }  \"  )  ;", "checkWrapInDoubleQuotes (  \"  \\  ' foo \\  \\ n \\  \\  \\  '  \\  \"  \\  \\  \\  \\  \\  \\  \\  \" bar \"  ,     \"  \\  \" foo \\  \\ n \\  '  \\  \\  \\  \"  \\  \\  \\  \\  \\  \\  \\  \" bar \\  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testWrapInDoubleQuotes"], "fileName": "com.intellij.json.JsonQuickFixTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  (  (  \" rename /  \"     +     ( getTestName ( false )  )  )     +     \"  . json \"  )  )  ;", "myFixture . renameElementAtCaret ( newName )  ;", "myFixture . checkResultByFile (  (  (  \" rename /  \"     +     ( getTestName ( false )  )  )     +     \"  _ after . json \"  )  )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.json.JsonRenameTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" aaa 2  \"  )  ;", "}", "METHOD_END"], "methodName": ["testDuplicateProperties"], "fileName": "com.intellij.json.JsonRenameTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  \\  \" aaa 2  \\  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testDuplicatePropertiesQuotedName"], "fileName": "com.intellij.json.JsonRenameTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  \\  \"  /  \\  \\  \\ b \\ f \\ n \\ r \\ t \\ u 0  0  0  0  \\ u 0  0  1 b \\  '  \"  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyNameRequiresEscaping"], "fileName": "com.intellij.json.JsonRenameTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  (  (  \" smartEnter /  \"     +     ( getTestName ( false )  )  )     +     \"  . json \"  )  )  ;", "final   List < Processor >    processors    =    INSTANCE . forKey ( JsonLanguage . INSTANCE )  ;", "WriteCommandAction . runWriteCommandAction ( myFixture . getProject (  )  ,     (  )     -  >     {", "final   Editor   editor    =    myFixture . getEditor (  )  ;", "for    ( Processor   processor    :    processors )     {", "processor . process ( myFixture . getProject (  )  ,    editor ,    myFixture . getFile (  )  )  ;", "}", "}  )  ;", "myFixture . checkResultByFile (  (  (  \" smartEnter /  \"     +     ( getTestName ( false )  )  )     +     \"  _ after . json \"  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.json.JsonSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testColonInsertedAfterPropertyKey"], "fileName": "com.intellij.json.JsonSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testCommaInsertedAfterArrayElement"], "fileName": "com.intellij.json.JsonSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testCommaInsertedAfterProperty"], "fileName": "com.intellij.json.JsonSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testCommaInsertedAfterPropertyWithMultilineValue"], "fileName": "com.intellij.json.JsonSmartEnterTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . enableInspections ( SpellCheckingInspection . class )  ;", "myFixture . configureByFile (  (  (  \"  / s /  \"     +     ( getTestName ( false )  )  )     +     \"  . json \"  )  )  ;", "myFixture . checkHighlighting ( true ,    false ,    true )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.json.JsonSpellcheckerTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testEscapeAwareness"], "fileName": "com.intellij.json.JsonSpellcheckerTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testSimple"], "fileName": "com.intellij.json.JsonSpellcheckerTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  (  ( getTestName ( false )  )     +     \"  . json \"  )  )  ;", "myFixture . test (  (    svc )     -  >     {", "TreeUtil . expandAll ( svc . getTree (  )  )  ;", "assertTreeEqual ( svc . getTree (  )  ,    expected )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.json.JsonStructureViewTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  (  ( getTestName ( false )  )     +     \"  . json \"  )  )  ;", "final   Builder   builder    =    INSTANCE . getBuilder ( myFixture . getFile (  )  )  ;", "assertNotNull ( builder )  ;", "Component   component    =    null ;", "try    {", "final   FileEditor   editor    =    FileEditorManager . getInstance ( getProject (  )  )  . getSelectedEditor ( myFixture . getFile (  )  . getVirtualFile (  )  )  ;", "component    =     (  ( Component )     ( builder . create ( editor ,    myFixture . getProject (  )  )  )  )  ;", "final   Model   model    =    component . getTreeModel (  )  ;", "consumer . consume ( model )  ;", "}    finally    {", "if    ( component    !  =    null )     {", "Disposer . dispose ( component )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doTestTreeStructure"], "fileName": "com.intellij.json.JsonStructureViewTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  (  \"  - ArrayNodesAreShownIfNecessary . json \\ n \"     +     (  (  (  (  (  (  (  (  \"     - array \\ n \"     +     \"        - object \\ n \"  )     +     \"          nestedObject \\ n \"  )     +     \"     - array \\ n \"  )     +     \"        - array \\ n \"  )     +     \"           - object \\ n \"  )     +     \"             deepNestedObject \\ n \"  )     +     \"     - object \\ n \"  )     +     \"       siblingObject \\ n \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testArrayNodesAreShownIfNecessary"], "fileName": "com.intellij.json.JsonStructureViewTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  (  \"  - ObjectsInsideArraysAreShown . json \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"    aProp \\ n \"     +     \"     - node 1  \\ n \"  )     +     \"       anotherProp \\ n \"  )     +     \"       subNode 1  \\ n \"  )     +     \"       subNode 2  \\ n \"  )     +     \"     - node 2  \\ n \"  )     +     \"        - object \\ n \"  )     +     \"           - subNode 2  \\ n \"  )     +     \"              - object \\ n \"  )     +     \"                someNode \\ n \"  )     +     \"     - node 3  \\ n \"  )     +     \"        - object \\ n \"  )     +     \"          prop 1  \\ n \"  )     +     \"          prop 2  \\ n \"  )     +     \"          someFlag \\ n \"  )     +     \"           - array \\ n \"  )     +     \"              - object \\ n \"  )     +     \"                arrProp 1  \\ n \"  )     +     \"                 - array 2  \\ n \"  )     +     \"                    - object \\ n \"  )     +     \"                      arr 2 Prop 1  \\ n \"  )     +     \"                      arr 2 Prop 2  \\ n \"  )     +     \"                       - array 3  \\ n \"  )     +     \"                          - object \\ n \"  )     +     \"                            prop 1  \\ n \"  )     +     \"                            prop 2  \\ n \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testObjectsInsideArraysAreShown"], "fileName": "com.intellij.json.JsonStructureViewTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  (  \"  - PropertyOrderPreserved . json \\ n \"     +     (  (  (  (  \"    ccc \\ n \"     +     \"    bbb \\ n \"  )     +     \"     - aaa \\ n \"  )     +     \"       eee \\ n \"  )     +     \"       ddd \\ n \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyOrderPreserved"], "fileName": "com.intellij.json.JsonStructureViewTest"}, {"methodBody": ["METHOD_START", "{", "doTestTreeStructure (  (    model )     -  >     {", "TreeElement [  ]    children    =    model . getRoot (  )  . getChildren (  )  ;", "assertEquals (  2  ,    children . length )  ;", "assertEquals (  \" aaa \"  ,    children [  0  ]  . getPresentation (  )  . getPresentableText (  )  )  ;", "assertEquals ( PlatformIcons . PROPERTY _ ICON ,    children [  0  ]  . getPresentation (  )  . getIcon ( false )  )  ;", "assertEquals (  \" bbb \"  ,    children [  1  ]  . getPresentation (  )  . getPresentableText (  )  )  ;", "assertEquals ( AllIcons . Json . Property _ braces ,    children [  1  ]  . getPresentation (  )  . getIcon ( false )  )  ;", "children    =    children [  1  ]  . getChildren (  )  ;", "assertEquals (  1  ,    children . length )  ;", "assertEquals (  \" ccc \"  ,    children [  0  ]  . getPresentation (  )  . getPresentableText (  )  )  ;", "assertEquals ( PlatformIcons . PROPERTY _ ICON ,    children [  0  ]  . getPresentation (  )  . getIcon ( false )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleStructure"], "fileName": "com.intellij.json.JsonStructureViewTest"}, {"methodBody": ["METHOD_START", "{", "doTestTreeStructure (  (    model )     -  >     {", "final   TreeElement [  ]    children    =    model . getRoot (  )  . getChildren (  )  ;", "assertSize (  6  ,    children )  ;", "final   ItemPresentation   booleanNode    =    children [  0  ]  . getPresentation (  )  ;", "assertEquals (  \" boolean \"  ,    booleanNode . getPresentableText (  )  )  ;", "assertEquals (  \" true \"  ,    booleanNode . getLocationString (  )  )  ;", "final   ItemPresentation   nullNode    =    children [  1  ]  . getPresentation (  )  ;", "assertEquals (  \" nullable \"  ,    nullNode . getPresentableText (  )  )  ;", "assertEquals (  \" null \"  ,    nullNode . getLocationString (  )  )  ;", "final   ItemPresentation   numNode    =    children [  2  ]  . getPresentation (  )  ;", "assertEquals (  \" number \"  ,    numNode . getPresentableText (  )  )  ;", "assertEquals (  \"  4  2  \"  ,    numNode . getLocationString (  )  )  ;", "final   ItemPresentation   stringNode    =    children [  3  ]  . getPresentation (  )  ;", "assertEquals (  \" string \"  ,    stringNode . getPresentableText (  )  )  ;", "assertEquals (  \"  \\  \" foo \\  \"  \"  ,    stringNode . getLocationString (  )  )  ;", "final   ItemPresentation   arrayNode    =    children [  4  ]  . getPresentation (  )  ;", "assertEquals (  \" array \"  ,    arrayNode . getPresentableText (  )  )  ;", "assertNull ( arrayNode . getLocationString (  )  )  ;", "final   ItemPresentation   objectNode    =    children [  5  ]  . getPresentation (  )  ;", "assertEquals (  \" object \"  ,    objectNode . getPresentableText (  )  )  ;", "assertNull ( objectNode . getLocationString (  )  )  ;", "final   TreeElement [  ]    nestedChildren    =    children [  5  ]  . getChildren (  )  ;", "assertSize (  1  ,    nestedChildren )  ;", "final   ItemPresentation   subStringNode    =    nestedChildren [  0  ]  . getPresentation (  )  ;", "assertEquals (  \" foo \"  ,    subStringNode . getPresentableText (  )  )  ;", "assertEquals (  \"  \\  \" bar \\  \"  \"  ,    subStringNode . getLocationString (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testValuesOfScalarPropertiesAreShown"], "fileName": "com.intellij.json.JsonStructureViewTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByFile (  (  (  \"  / surround /  \"     +     ( getTestName ( false )  )  )     +     \"  . json \"  )  )  ;", "Handler . invoke ( myFixture . getProject (  )  ,    myFixture . getEditor (  )  ,    myFixture . getFile (  )  ,    new   JsonWithObjectLiteralSurrounder (  )  )  ;", "myFixture . checkResultByFile (  (  (  \"  / surround /  \"     +     ( getTestName ( false )  )  )     +     \"  _ after . json \"  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.json.JsonSurroundWithTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testCannotSurroundPropertyKey"], "fileName": "com.intellij.json.JsonSurroundWithTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testMultipleProperties"], "fileName": "com.intellij.json.JsonSurroundWithTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testObjectLiteral"], "fileName": "com.intellij.json.JsonSurroundWithTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testSingleProperty"], "fileName": "com.intellij.json.JsonSurroundWithTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testSingleValue"], "fileName": "com.intellij.json.JsonSurroundWithTest"}, {"methodBody": ["METHOD_START", "{", "return    \"  / json / tests / testData \"  ;", "}", "METHOD_END"], "methodName": ["getBasePath"], "fileName": "com.intellij.json.JsonTestCase"}, {"methodBody": ["METHOD_START", "{", "return   CodeStyleSettingsManager . getSettings ( getProject (  )  )  ;", "}", "METHOD_END"], "methodName": ["getCodeStyleSettings"], "fileName": "com.intellij.json.JsonTestCase"}, {"methodBody": ["METHOD_START", "{", "return   getCodeStyleSettings (  )  . getCommonSettings ( JsonLanguage . INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["getCommonCodeStyleSettings"], "fileName": "com.intellij.json.JsonTestCase"}, {"methodBody": ["METHOD_START", "{", "return   getCodeStyleSettings (  )  . getCustomSettings ( JsonCodeStyleSettings . class )  ;", "}", "METHOD_END"], "methodName": ["getCustomCodeStyleSettings"], "fileName": "com.intellij.json.JsonTestCase"}, {"methodBody": ["METHOD_START", "{", "final   CommonCodeStyleSettings . IndentOptions   options    =    getCommonCodeStyleSettings (  )  . getIndentOptions (  )  ;", "assertNotNull ( options )  ;", "return   options ;", "}", "METHOD_END"], "methodName": ["getIndentOptions"], "fileName": "com.intellij.json.JsonTestCase"}, {"methodBody": ["METHOD_START", "{", "if    ( expressi =  =    null )     {", "return   null ;", "}", "if    ( cls . isAssignableFrom ( expressigetClass (  )  )  )     {", "return    (  ( T )     ( expressi )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["as"], "fileName": "com.intellij.json.JsonUtil"}, {"methodBody": ["METHOD_START", "{", "PsiElement   parent    =    e . getParent (  )  ;", "if    (  !  ( parent   instanceof   Array )  )", "return    -  1  ;", "List < Value >    elements    =     (  ( Array )     ( parent )  )  . getValueList (  )  ;", "for    (    i    =     0  ;    i    <     ( elements . size (  )  )  ;    i +  +  )     {", "if    ( e    =  =     ( elements . get ( i )  )  )     {", "return   i ;", "}", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["getArrayIndexOfItem"], "fileName": "com.intellij.json.JsonUtil"}, {"methodBody": ["METHOD_START", "{", "final   List < String >    list    =    JsonUtil . getChildAsStringList ( object ,    name )  ;", "if    ( list    !  =    null )", "return   list ;", "final   JsonStringLiteral   literal    =    JsonUtil . getPropertyValueOfType ( object ,    name ,    JsonStringLiteral . class )  ;", "return   literal    =  =    null    ?    null    :    Collections . singletonList ( StringUtil . unquoteString ( literal . getText (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getChildAsSingleStringOrList"], "fileName": "com.intellij.json.JsonUtil"}, {"methodBody": ["METHOD_START", "{", "final   JsonArray   array    =    JsonUtil . getPropertyValueOfType ( object ,    name ,    JsonArray . class )  ;", "if    ( array    !  =    null )", "return   array . getValueList (  )  . stream (  )  . filter (  (    value )     -  >    value   instanceof   psi . JsonStringLiteral )  . map (  (    value )     -  >    com . intellij . openapi . util . text . StringUtil . unquoteString ( value . getText (  )  )  )  . collect ( toList (  )  )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["getChildAsStringList"], "fileName": "com.intellij.json.JsonUtil"}, {"methodBody": ["METHOD_START", "{", "final   JsonProperty   property    =    object . findProperty ( name )  ;", "if    ( property    =  =    null )", "return   null ;", "return   ObjectUtils . tryCast ( property . getValue (  )  ,    clazz )  ;", "}", "METHOD_END"], "methodName": ["getPropertyValueOfType"], "fileName": "com.intellij.json.JsonUtil"}, {"methodBody": ["METHOD_START", "{", "return    ( element   instanceof   JsonValue )     &  &     (  ( element . getParent (  )  )    instanceof   JsonArray )  ;", "}", "METHOD_END"], "methodName": ["isArrayElement"], "fileName": "com.intellij.json.JsonUtil"}, {"methodBody": ["METHOD_START", "{", "CodeInsightTestUtil . doWordSelectionTestOnDirectory ( myFixture ,     (  \" selectWord /  \"     +     ( getTestName ( false )  )  )  ,     \" json \"  )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.json.JsonWordSelectionTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testEscapeAwareness"], "fileName": "com.intellij.json.JsonWordSelectionTest"}, {"methodBody": ["METHOD_START", "{", "return    _ JsonLexer . ZZ _ CMAP _ A [  (  (  (  _ JsonLexer . ZZ _ CMAP _ Y [  (  (  (  _ JsonLexer . ZZ _ CMAP _ Z [  ( ch    >  >     9  )  ]  )     <  <     6  )     |     (  ( ch    >  >     3  )     &     6  3  )  )  ]  )     <  <     3  )     |     ( ch    &     7  )  )  ]  ;", "}", "METHOD_END"], "methodName": ["ZZ_CMAP"], "fileName": "com.intellij.json._JsonLexer"}, {"methodBody": ["METHOD_START", "{", "zzInput ;", "zzAction ;", "zzCurrentPosL ;", "zzMarkedPosL ;", "zzEndReadL    =    zzEndRead ;", "CharSequence   zzBufferL    =    zzBuffer ;", "[  ]    zzTransL    =     . ZZ _ TRANS ;", "[  ]    zzRowMapL    =     . ZZ _ ROWMAP ;", "[  ]    zzAttrL    =     . ZZ _ ATTRIBUTE ;", "while    ( true )     {", "zzMarkedPosL    =    zzMarkedPos ;", "zzAction    =     -  1  ;", "zzCurrentPosL    =    zzCurrentPos    =    zzStartRead    =    zzMarkedPosL ;", "zzState    =     . ZZ _ LEXSTATE [ zzLexicalState ]  ;", "zzAttributes    =    zzAttrL [ zzState ]  ;", "if    (  ( zzAttributes    &     1  )     =  =     1  )     {", "zzAction    =    zzState ;", "}", "zzForAction    :     {", "while    ( true )     {", "if    ( zzCurrentPosL    <    zzEndReadL )     {", "zzInput    =    Character . codePointAt ( zzBufferL ,    zzCurrentPosL )  ;", "zzCurrentPosL    +  =    Character . charCount ( zzInput )  ;", "} else", "if    ( zzAtEOF )     {", "zzInput    =     . YYEOF ;", "break   zzForAction ;", "} else    {", "zzCurrentPos    =    zzCurrentPosL ;", "zzMarkedPos    =    zzMarkedPosL ;", "boolean   eof    =    zzRefill (  )  ;", "zzCurrentPosL    =    zzCurrentPos ;", "zzMarkedPosL    =    zzMarkedPos ;", "zzBufferL    =    zzBuffer ;", "zzEndReadL    =    zzEndRead ;", "if    ( eof )     {", "zzInput    =     . YYEOF ;", "break   zzForAction ;", "} else    {", "zzInput    =    Character . codePointAt ( zzBufferL ,    zzCurrentPosL )  ;", "zzCurrentPosL    +  =    Character . charCount ( zzInput )  ;", "}", "}", "zzNext    =    zzTransL [  (  ( zzRowMapL [ zzState ]  )     +     (  . ZZ _ CMAP ( zzInput )  )  )  ]  ;", "if    ( zzNext    =  =     (  -  1  )  )", "break   zzForAction ;", "zzState    =    zzNext ;", "zzAttributes    =    zzAttrL [ zzState ]  ;", "if    (  ( zzAttributes    &     1  )     =  =     1  )     {", "zzAction    =    zzState ;", "zzMarkedPosL    =    zzCurrentPosL ;", "if    (  ( zzAttributes    &     8  )     =  =     8  )", "break   zzForAction ;", "}", "}", "}", "zzMarkedPos    =    zzMarkedPosL ;", "if    (  ( zzInput    =  =     (  . YYEOF )  )     &  &     (  ( zzStartRead )     =  =     ( zzCurrentPos )  )  )     {", "zzAtEOF    =    true ;", "return   null ;", "} else    {", "switch    ( zzAction    <     0     ?    zzAction    :     . ZZ _ ACTION [ zzAction ]  )     {", "case    1     :", "{", "return   TokenType . BAD _ CHARACTER ;", "}", "case    1  8     :", "break ;", "case    2     :", "{", "return   TokenType . WHITE _ SPACE ;", "}", "case    1  9     :", "break ;", "case    3     :", "{", "return   JsonElementTypes . IDENTIFIER ;", "}", "case    2  0     :", "break ;", "case    4     :", "{", "return   JsonElementTypes . DOUBLE _ QUOTED _ STRING ;", "}", "case    2  1     :", "break ;", "case    5     :", "{", "return   JsonElementTypes . SINGLE _ QUOTED _ STRING ;", "}", "case    2  2     :", "break ;", "case    6     :", "{", "return   JsonElementTypes . NUMBER ;", "}", "case    2  3     :", "break ;", "case    7     :", "{", "return   JsonElementTypes . L _ CURLY ;", "}", "case    2  4     :", "break ;", "case    8     :", "{", "return   JsonElementTypes . R _ CURLY ;", "}", "case    2  5     :", "break ;", "case    9     :", "{", "return   JsonElementTypes . L _ BRACKET ;", "}", "case    2  6     :", "break ;", "case    1  0     :", "{", "return   JsonElementTypes . R _ BRACKET ;", "}", "case    2  7     :", "break ;", "case    1  1     :", "{", "return   JsonElementTypes . COMMA ;", "}", "case    2  8     :", "break ;", "case    1  2     :", "{", "return   JsonElementTypes . COLON ;", "}", "case    2  9     :", "break ;", "case    1  3     :", "{", "return   JsonElementTypes . LINE _ COMMENT ;", "}", "case    3  0     :", "break ;", "case    1  4     :", "{", "return   JsonElementTypes . BLOCK _ COMMENT ;", "}", "case    3  1     :", "break ;", "case    1  5     :", "{", "return   JsonElementTypes . NULL ;", "}", "case    3  2     :", "break ;", "case    1  6     :", "{", "return   JsonElementTypes . TRUE ;", "}", "case    3  3     :", "break ;", "case    1  7     :", "{", "return   JsonElementTypes . FALSE ;", "}", "case    3  4     :", "break ;", "default    :", "zzScanError (  . ZZ _ NO _ MATCH )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["advance"], "fileName": "com.intellij.json._JsonLexer"}, {"methodBody": ["METHOD_START", "{", "return    ( getTokenStart (  )  )     +     ( yylength (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTokenEnd"], "fileName": "com.intellij.json._JsonLexer"}, {"methodBody": ["METHOD_START", "{", "return   zzStartRead ;", "}", "METHOD_END"], "methodName": ["getTokenStart"], "fileName": "com.intellij.json._JsonLexer"}, {"methodBody": ["METHOD_START", "{", "zzBuffer    =    buffer ;", "zzCurrentPos    =    zzMarkedPos    =    zzStartRead    =    start ;", "zzAtEOF    =    false ;", "zzAtBOL    =    true ;", "zzEndRead    =    end ;", "yybegin ( initialState )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.intellij.json._JsonLexer"}, {"methodBody": ["METHOD_START", "{", "zzLexicalState    =    newState ;", "}", "METHOD_END"], "methodName": ["yybegin"], "fileName": "com.intellij.json._JsonLexer"}, {"methodBody": ["METHOD_START", "{", "return   zzBuffer . charAt (  (  ( zzStartRead )     +    pos )  )  ;", "}", "METHOD_END"], "methodName": ["yycharat"], "fileName": "com.intellij.json._JsonLexer"}, {"methodBody": ["METHOD_START", "{", "return    ( zzMarkedPos )     -     ( zzStartRead )  ;", "}", "METHOD_END"], "methodName": ["yylength"], "fileName": "com.intellij.json._JsonLexer"}, {"methodBody": ["METHOD_START", "{", "if    ( number    >     ( yylength (  )  )  )", "zzScanError (  . ZZ _ PUSHBACK _  2 BIG )  ;", "zzMarkedPos    -  =    number ;", "}", "METHOD_END"], "methodName": ["yypushback"], "fileName": "com.intellij.json._JsonLexer"}, {"methodBody": ["METHOD_START", "{", "return   zzLexicalState ;", "}", "METHOD_END"], "methodName": ["yystate"], "fileName": "com.intellij.json._JsonLexer"}, {"methodBody": ["METHOD_START", "{", "return   zzBuffer . subSequence ( zzStartRead ,    zzMarkedPos )  ;", "}", "METHOD_END"], "methodName": ["yytext"], "fileName": "com.intellij.json._JsonLexer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["zzRefill"], "fileName": "com.intellij.json._JsonLexer"}, {"methodBody": ["METHOD_START", "{", "String   message ;", "try    {", "message    =     . ZZ _ ERROR _ MSG [ errorCode ]  ;", "}    catch    ( ArrayIndexOutOfBoundsException   e )     {", "message    =     . ZZ _ ERROR _ MSG [  . ZZ _ UNKNOWN _ ERROR ]  ;", "}", "throw   new   Error ( message )  ;", "}", "METHOD_END"], "methodName": ["zzScanError"], "fileName": "com.intellij.json._JsonLexer"}, {"methodBody": ["METHOD_START", "{", "[  ]    result    =    new    [  5  7  ]  ;", "offset    =     0  ;", "offset    =     . zzUnpackAction (  . ZZ _ ACTION _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackAction"], "fileName": "com.intellij.json._JsonLexer"}, {"methodBody": ["METHOD_START", "{", "i    =     0  ;", "j    =    offset ;", "l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "unt    =    packed . charAt (  ( i +  +  )  )  ;", "value    =    packed . charAt (  ( i +  +  )  )  ;", "do", "result [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - unt )     >     0     )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackAction"], "fileName": "com.intellij.json._JsonLexer"}, {"methodBody": ["METHOD_START", "{", "[  ]    result    =    new    [  5  7  ]  ;", "offset    =     0  ;", "offset    =     . zzUnpackAttribute (  . ZZ _ ATTRIBUTE _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackAttribute"], "fileName": "com.intellij.json._JsonLexer"}, {"methodBody": ["METHOD_START", "{", "i    =     0  ;", "j    =    offset ;", "l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "unt    =    packed . charAt (  ( i +  +  )  )  ;", "value    =    packed . charAt (  ( i +  +  )  )  ;", "do", "result [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - unt )     >     0     )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackAttribute"], "fileName": "com.intellij.json._JsonLexer"}, {"methodBody": ["METHOD_START", "{", "size    =     0  ;", "for    (    i    =     0  ,    length    =    packed . length (  )  ;    i    <    length ;    i    +  =     2  )     {", "size    +  =    packed . charAt ( i )  ;", "}", "char [  ]    map    =    new   char [ size ]  ;", "i    =     0  ;", "j    =     0  ;", "while    ( i    <     ( packed . length (  )  )  )     {", "unt    =    packed . charAt (  ( i +  +  )  )  ;", "char   value    =    packed . charAt (  ( i +  +  )  )  ;", "do", "map [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - unt )     >     0     )  ;", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["zzUnpackCMap"], "fileName": "com.intellij.json._JsonLexer"}, {"methodBody": ["METHOD_START", "{", "[  ]    result    =    new    [  5  7  ]  ;", "offset    =     0  ;", "offset    =     . zzUnpackRowMap (  . ZZ _ ROWMAP _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackRowMap"], "fileName": "com.intellij.json._JsonLexer"}, {"methodBody": ["METHOD_START", "{", "i    =     0  ;", "j    =    offset ;", "l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "high    =     ( packed . charAt (  ( i +  +  )  )  )     <  <     1  6  ;", "result [  ( j +  +  )  ]     =    high    |     ( packed . charAt (  ( i +  +  )  )  )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackRowMap"], "fileName": "com.intellij.json._JsonLexer"}, {"methodBody": ["METHOD_START", "{", "[  ]    result    =    new    [  1  5  4  8  ]  ;", "offset    =     0  ;", "offset    =     . zzUnpackTrans (  . ZZ _ TRANS _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackTrans"], "fileName": "com.intellij.json._JsonLexer"}, {"methodBody": ["METHOD_START", "{", "i    =     0  ;", "j    =    offset ;", "l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "unt    =    packed . charAt (  ( i +  +  )  )  ;", "value    =    packed . charAt (  ( i +  +  )  )  ;", "value -  -  ;", "do", "result [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - unt )     >     0     )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackTrans"], "fileName": "com.intellij.json._JsonLexer"}, {"methodBody": ["METHOD_START", "{", "if    ( JsonPsiUtil . isPropertyKey ( element )  )     {", "holder . createInfoAnnotation ( element ,     (  . Holder . DEBUG    ?     \" property   key \"     :    null )  )  . setTextAttributes ( JsonSyntaxHighlighterFactory . JSON _ PROPERTY _ KEY )  ;", "}", "}", "METHOD_END"], "methodName": ["highlightPropertyKey"], "fileName": "com.intellij.json.codeinsight.JsonLiteralAnnotator"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   lastChild    =    container . getLastChild (  )  ;", "if    (  ( lastChild . getNode (  )  . getElementType (  )  )     !  =    ending )     {", "return   null ;", "}", "final   PsiElement   beforeEnding    =    PsiTreeUtil . skipWhitespacesAnmentsBackward ( lastChild )  ;", "if    (  ( beforeEnding    !  =    null )     &  &     (  ( beforeEnding . getNode (  )  . getElementType (  )  )     =  =     ( JsonElementTypes . COMMA )  )  )     {", "return   beforeEnding ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findTrailingComma"], "fileName": "com.intellij.json.codeinsight.JsonStandardComplianceInspection"}, {"methodBody": ["METHOD_START", "{", "return   JsonBundle . message (  \" inspection . compliance . name \"  )  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "com.intellij.json.codeinsight.JsonStandardComplianceInspection"}, {"methodBody": ["METHOD_START", "{", "JsonStandardComplianceProvider [  ]    providers    =    JsonStandardComplianceProvider . EP _ NAME . getExtensions (  )  ;", "if    (  ( providers . length )     =  =     0  )     {", "return   true ;", "}", "for    ( JsonStandardComplianceProvider   provider    :    providers )     {", "if    ( provider . isCommentAllowed ( comment )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["shouldWarnAboutComment"], "fileName": "com.intellij.json.codeinsight.JsonStandardComplianceProvider"}, {"methodBody": ["METHOD_START", "{", "PsiElement   element    =    property . getNextSibling (  )  ;", "while    ( element    !  =    null )     {", "if    ( element   instanceof   Json )     {", "return   true ;", "}", "if    (  ( element . getNode (  )  . getElementType (  )  )     =  =     ( JsonElementTypes . COMMA )  )     {", "return   false ;", "}", "element    =    element . getNextSibling (  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["needCommaAfter"], "fileName": "com.intellij.json.codeinsight.JsonStringPropertyInsertHandler"}, {"methodBody": ["METHOD_START", "{", "PsiDocumentManager . getInstance ( context . getProject (  )  )  . commitDocument ( context . getDocument (  )  )  ;", "CodeStyleManager   StyleManager    =    CodeStyleManager . getInstance ( context . getProject (  )  )  ;", "StyleManager . reformatText ( context . getFile (  )  ,    startOffset ,    endOffset )  ;", "}", "METHOD_END"], "methodName": ["reformat"], "fileName": "com.intellij.json.codeinsight.JsonStringPropertyInsertHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( fragmentText . startsWith (  \"  \\  \\  \"  )  )     &  &     (  ( fragmentText . length (  )  )     >     1  )  )     &  &     (  !  ( StandardJsonLiteralChecker . VALID _ ESCAPE . matcher ( fragmentText )  . matches (  )  )  )  )     {", "if    ( fragmentText . startsWith (  \"  \\  \\ u \"  )  )     {", "return   JsonBundle . message (  \" syntax . error . illegal . unicode . escape . sequence \"  )  ;", "} else    {", "return   JsonBundle . message (  \" syntax . error . illegal . escape . sequence \"  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getStringError"], "fileName": "com.intellij.json.codeinsight.StandardJsonLiteralChecker"}, {"methodBody": ["METHOD_START", "{", "final   IElementType   type    =    node . getElementType (  )  ;", "if    (  (  ( type    =  =     ( JsonElementTypes . OBJECT )  )     |  |     ( type    =  =     ( JsonElementTypes . ARRAY )  )  )     &  &     (  . spanMultipleLines ( node ,    document )  )  )     {", "descriptors . add ( new   FoldingDescriptor ( node ,    node . getTextRange (  )  )  )  ;", "} else", "if    ( type    =  =     ( JsonElementTypes . BLOCK _ COMMENT )  )     {", "descriptors . add ( new   FoldingDescriptor ( node ,    node . getTextRange (  )  )  )  ;", "} else", "if    ( type    =  =     ( JsonElementTypes . LINE _ COMMENT )  )     {", "final   com . intellij . openapi . util . Couple < com . intellij . psi . PsiElement >    commentRange    =     . expandLineCommentsRange ( node . getPsi (  )  )  ;", "final      startOffset    =    commentRange . getFirst (  )  . getTextRange (  )  . getStartOffset (  )  ;", "final      endOffset    =    commentRange . getSecond (  )  . getTextRange (  )  . getEndOffset (  )  ;", "if    (  ( document . getLineNumber ( startOffset )  )     !  =     ( document . getLineNumber ( endOffset )  )  )     {", "descriptors . add ( new   FoldingDescriptor ( node ,    new   com . intellij . openapi . util . TextRange ( startOffset ,    endOffset )  )  )  ;", "}", "}", "for    ( ASTNode   child    :    node . getChildren ( null )  )     {", ". collectDescriptorsRecursively ( child ,    document ,    descriptors )  ;", "}", "}", "METHOD_END"], "methodName": ["collectDescriptorsRecursively"], "fileName": "com.intellij.json.editor.folding.JsonFoldingBuilder"}, {"methodBody": ["METHOD_START", "{", "return   Couple . of ( JsonPsiUtil . findFurthestSiblingOfSameType ( anchor ,    false )  ,    JsonPsiUtil . findFurthestSiblingOfSameType ( anchor ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["expandLineCommentsRange"], "fileName": "com.intellij.json.editor.folding.JsonFoldingBuilder"}, {"methodBody": ["METHOD_START", "{", "final   TextRange   range    =    node . getTextRange (  )  ;", "return    ( document . getLineNumber ( range . getStartOffset (  )  )  )     <     ( document . getLineNumber ( range . getEndOffset (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["spanMultipleLines"], "fileName": "com.intellij.json.editor.folding.JsonFoldingBuilder"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   upper    =    JsonPsiUtil . findFurthestSiblingOfSameType ( range . getFirst (  )  ,    false )  ;", "final   PsiElement   lower    =    JsonPsiUtil . findFurthestSiblingOfSameType ( range . getSecond (  )  ,    true )  ;", "return   Pair . create ( upper ,    lower )  ;", "}", "METHOD_END"], "methodName": ["expandCommentsInRange"], "fileName": "com.intellij.json.editor.lineMover.JsonLineMover"}, {"methodBody": ["METHOD_START", "{", "if    ( elementRange    =  =    null )     {", "return   false ;", "}", "return    ( elementRange . getFirst (  )  . getParent (  )  )     =  =     ( elementRange . getSecond (  )  . getParent (  )  )  ;", "}", "METHOD_END"], "methodName": ["isValidElementRange"], "fileName": "com.intellij.json.editor.lineMover.JsonLineMover"}, {"methodBody": ["METHOD_START", "{", "return    (  ( PsiTreeUtil . getNextSiblingOfType ( anchor ,    nextElementType )  )     =  =    null )     &  &     (  ( TreeUtil . findSibling ( anchor . getNode (  )  ,    JsonElementTypes . COMMA )  )     =  =    null )  ;", "}", "METHOD_END"], "methodName": ["notFollowedByNextElementOrComma"], "fileName": "com.intellij.json.editor.lineMover.JsonLineMover"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   nextLeaf    =    PsiTreeUtil . nextVisibleLeaf ( element )  ;", "return    ( nextLeaf    !  =    null )     &  &     (  ( nextLeaf . getNode (  )  . getElementType (  )  )     =  =    type )  ;", "}", "METHOD_END"], "methodName": ["isFollowedByTerminal"], "fileName": "com.intellij.json.editor.smartEnter.JsonSmartEnterProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Document   document    =    editor . getDocument (  )  ;", "final      caretOffset    =    editor . getCaretModel (  )  . getCurrentCaret (  )  . getOffset (  )  ;", "final      elementEndOffset    =    element . getTextRange (  )  . getEndOffset (  )  ;", "if    (  ( document . getLineNumber ( elementEndOffset )  )     !  =     ( document . getLineNumber ( caretOffset )  )  )     {", "return   false ;", "}", "PsiElement   nextLeaf    =    PsiTreeUtil . nextLeaf ( element ,    true )  ;", "return    ( nextLeaf    =  =    null )     |  |     (  ( nextLeaf   instanceof   PsiWhiteSpace )     &  &     ( nextLeaf . getText (  )  . contains (  \"  \\ n \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["terminatedOnCurrentLine"], "fileName": "com.intellij.json.editor.smartEnter.JsonSmartEnterProcessor"}, {"methodBody": ["METHOD_START", "{", "return   mySettings . getCustomSettings ( JsonCodeStyleSettings . class )  ;", "}", "METHOD_END"], "methodName": ["getCustomSettings"], "fileName": "com.intellij.json.formatter.JsonBlock"}, {"methodBody": ["METHOD_START", "{", "return    (  ( node . getElementType (  )  )     =  =     ( TokenType . WHITE _ SPACE )  )     |  |     (  ( node . getTextLength (  )  )     =  =     0  )  ;", "}", "METHOD_END"], "methodName": ["isWhitespaceOrEmpty"], "fileName": "com.intellij.json.formatter.JsonBlock"}, {"methodBody": ["METHOD_START", "{", "Indent   indent    =    Indent . getNoneIndent (  )  ;", "Alignment   alignment    =    null ;", "Wrap   wrap    =    null ;", "if    ( JsonPsiUtil . hasElementType ( myNode ,    JsonParserDefinition . JSON _ CONTAINERS )  )     {", "if    ( JsonPsiUtil . hasElementType ( childNode ,    JsonElementTypes . COMMA )  )     {", "wrap    =    Wrap . createWrap ( NONE ,    true )  ;", "} else", "if    (  !  ( JsonPsiUtil . hasElementType ( childNode ,     . JSON _ ALL _ BRACES )  )  )     {", "assert    ( myChildWrap )     !  =    null ;", "wrap    =    myChildWrap ;", "indent    =    Indent . getNormalIndent (  )  ;", "} else", "if    ( JsonPsiUtil . hasElementType ( childNode ,     . JSON _ OPEN _ BRACES )  )     {", "if    (  ( JsonPsiUtil . isPropertyValue ( myPsiElement )  )     &  &     ( propertyAlignment    =  =     ( JsonCodeStyleSettings . ALIGN _ PROPERTY _ ON _ VALUE )  )  )     {", "assert    (  (  ( myParent )     !  =    null )     &  &     (  ( myParent . myParent )     !  =    null )  )     &  &     (  ( myParent . myParent . myPropertyValueAlignment )     !  =    null )  ;", "alignment    =    myParent . myParent . myPropertyValueAlignment ;", "}", "}", "} else", "if    ( JsonPsiUtil . hasElementType ( myNode ,    JsonElementTypes . PROPERTY )  )     {", "assert    (  ( myParent )     !  =    null )     &  &     (  ( myParent . myPropertyValueAlignment )     !  =    null )  ;", "if    (  ( JsonPsiUtil . hasElementType ( childNode ,    JsonElementTypes . COLON )  )     &  &     ( propertyAlignment    =  =     ( JsonCodeStyleSettings . ALIGN _ PROPERTY _ ON _ COLON )  )  )     {", "alignment    =    myParent . myPropertyValueAlignment ;", "} else", "if    (  ( JsonPsiUtil . isPropertyValue ( childNode . getPsi (  )  )  )     &  &     ( propertyAlignment    =  =     ( JsonCodeStyleSettings . ALIGN _ PROPERTY _ ON _ VALUE )  )  )     {", "if    (  !  ( JsonPsiUtil . hasElementType ( childNode ,    JsonParserDefinition . JSON _ CONTAINERS )  )  )     {", "alignment    =    myParent . myPropertyValueAlignment ;", "}", "}", "}", "return   new    ( this ,    childNode ,    mySettings ,    alignment ,    indent ,    wrap )  ;", "}", "METHOD_END"], "methodName": ["makeSubBlock"], "fileName": "com.intellij.json.formatter.JsonBlock"}, {"methodBody": ["METHOD_START", "{", "final   JsonCodeStyleSettings   jsonSettings    =    settings . getCustomSettings ( JsonCodeStyleSettings . class )  ;", "final   CommonCodeStyleSettings   commonSettings    =    settings . getCommonSettings ( JsonLanguage . INSTANCE )  ;", "final      spacesBeforeComma    =     ( commonSettings . SPACE _ BEFORE _ COMMA )     ?     1     :     0  ;", "final      spacesBeforeColon    =     ( jsonSettings . SPACE _ BEFORE _ COLON )     ?     1     :     0  ;", "final      spacesAfterColon    =     ( jsonSettings . SPACE _ AFTER _ COLON )     ?     1     :     0  ;", "return   new   Spac ( settings ,    JsonLanguage . INSTANCE )  . before ( JsonElementTypes . COLON )  . spacing ( spacesBeforeColon ,    spacesBeforeColon ,     0  ,    false ,     0  )  . after ( JsonElementTypes . COLON )  . spacing ( spacesAfterColon ,    spacesAfterColon ,     0  ,    false ,     0  )  . withinPair ( JsonElementTypes . L _ BRACKET ,    JsonElementTypes . R _ BRACKET )  . spaceIf ( commonSettings . SPACE _ WITHIN _ BRACKETS ,    true )  . withinPair ( JsonElementTypes . L _ CURLY ,    JsonElementTypes . R _ CURLY )  . spaceIf ( commonSettings . SPACE _ WITHIN _ BRACES ,    true )  . before ( JsonElementTypes . COMMA )  . spacing ( spacesBeforeComma ,    spacesBeforeComma ,     0  ,    false ,     0  )  . after ( JsonElementTypes . COMMA )  . spaceIf ( commonSettings . SPACE _ AFTER _ COMMA )  ;", "}", "METHOD_END"], "methodName": ["createSpacingBuilder"], "fileName": "com.intellij.json.formatter.JsonFormattingBuilderModel"}, {"methodBody": ["METHOD_START", "{", "return   new   JsonLexer (  )  ;", "}", "METHOD_END"], "methodName": ["getLexer"], "fileName": "com.intellij.json.highlighting.JsonSyntaxHighlighterFactory"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isCanEscapeEol"], "fileName": "com.intellij.json.highlighting.JsonSyntaxHighlighterFactory"}, {"methodBody": ["METHOD_START", "{", "myFixture . enableInspections ( new   Json 5 StandardComplianceInspection (  )  )  ;", "doTest ( false ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["testJSON5"], "fileName": "com.intellij.json.json5.Json5HighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( true )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.intellij.json.json5.Json5ParsingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  )  ;", "}", "METHOD_END"], "methodName": ["testJson5Syntax"], "fileName": "com.intellij.json.json5.Json5ParsingTest"}, {"methodBody": ["METHOD_START", "{", "return    _ Json 5 Lexer . ZZ _ CMAP _ A [  (  (  (  _ Json 5 Lexer . ZZ _ CMAP _ Y [  (  (  (  _ Json 5 Lexer . ZZ _ CMAP _ Z [  ( ch    >  >     9  )  ]  )     <  <     6  )     |     (  ( ch    >  >     3  )     &     6  3  )  )  ]  )     <  <     3  )     |     ( ch    &     7  )  )  ]  ;", "}", "METHOD_END"], "methodName": ["ZZ_CMAP"], "fileName": "com.intellij.json.json5._Json5Lexer"}, {"methodBody": ["METHOD_START", "{", "zzInput ;", "zzAction ;", "zzCurrentPosL ;", "zzMarkedPosL ;", "zzEndReadL    =    zzEndRead ;", "CharSequence   zzBufferL    =    zzBuffer ;", "[  ]    zzTransL    =     . ZZ _ TRANS ;", "[  ]    zzRowMapL    =     . ZZ _ ROWMAP ;", "[  ]    zzAttrL    =     . ZZ _ ATTRIBUTE ;", "while    ( true )     {", "zzMarkedPosL    =    zzMarkedPos ;", "zzAction    =     -  1  ;", "zzCurrentPosL    =    zzCurrentPos    =    zzStartRead    =    zzMarkedPosL ;", "zzState    =     . ZZ _ LEXSTATE [ zzLexicalState ]  ;", "zzAttributes    =    zzAttrL [ zzState ]  ;", "if    (  ( zzAttributes    &     1  )     =  =     1  )     {", "zzAction    =    zzState ;", "}", "zzForAction    :     {", "while    ( true )     {", "if    ( zzCurrentPosL    <    zzEndReadL )     {", "zzInput    =    Character . codePointAt ( zzBufferL ,    zzCurrentPosL )  ;", "zzCurrentPosL    +  =    Character . charCount ( zzInput )  ;", "} else", "if    ( zzAtEOF )     {", "zzInput    =     . YYEOF ;", "break   zzForAction ;", "} else    {", "zzCurrentPos    =    zzCurrentPosL ;", "zzMarkedPos    =    zzMarkedPosL ;", "boolean   eof    =    zzRefill (  )  ;", "zzCurrentPosL    =    zzCurrentPos ;", "zzMarkedPosL    =    zzMarkedPos ;", "zzBufferL    =    zzBuffer ;", "zzEndReadL    =    zzEndRead ;", "if    ( eof )     {", "zzInput    =     . YYEOF ;", "break   zzForAction ;", "} else    {", "zzInput    =    Character . codePointAt ( zzBufferL ,    zzCurrentPosL )  ;", "zzCurrentPosL    +  =    Character . charCount ( zzInput )  ;", "}", "}", "zzNext    =    zzTransL [  (  ( zzRowMapL [ zzState ]  )     +     (  . ZZ _ CMAP ( zzInput )  )  )  ]  ;", "if    ( zzNext    =  =     (  -  1  )  )", "break   zzForAction ;", "zzState    =    zzNext ;", "zzAttributes    =    zzAttrL [ zzState ]  ;", "if    (  ( zzAttributes    &     1  )     =  =     1  )     {", "zzAction    =    zzState ;", "zzMarkedPosL    =    zzCurrentPosL ;", "if    (  ( zzAttributes    &     8  )     =  =     8  )", "break   zzForAction ;", "}", "}", "}", "zzMarkedPos    =    zzMarkedPosL ;", "if    (  ( zzInput    =  =     (  . YYEOF )  )     &  &     (  ( zzStartRead )     =  =     ( zzCurrentPos )  )  )     {", "zzAtEOF    =    true ;", "return   null ;", "} else    {", "switch    ( zzAction    <     0     ?    zzAction    :     . ZZ _ ACTION [ zzAction ]  )     {", "case    1     :", "{", "return   JsonElementTypes . NUMBER ;", "}", "case    1  8     :", "break ;", "case    2     :", "{", "return   TokenType . BAD _ CHARACTER ;", "}", "case    1  9     :", "break ;", "case    3     :", "{", "return   TokenType . WHITE _ SPACE ;", "}", "case    2  0     :", "break ;", "case    4     :", "{", "return   JsonElementTypes . IDENTIFIER ;", "}", "case    2  1     :", "break ;", "case    5     :", "{", "return   JsonElementTypes . DOUBLE _ QUOTED _ STRING ;", "}", "case    2  2     :", "break ;", "case    6     :", "{", "return   JsonElementTypes . SINGLE _ QUOTED _ STRING ;", "}", "case    2  3     :", "break ;", "case    7     :", "{", "return   JsonElementTypes . L _ CURLY ;", "}", "case    2  4     :", "break ;", "case    8     :", "{", "return   JsonElementTypes . R _ CURLY ;", "}", "case    2  5     :", "break ;", "case    9     :", "{", "return   JsonElementTypes . L _ BRACKET ;", "}", "case    2  6     :", "break ;", "case    1  0     :", "{", "return   JsonElementTypes . R _ BRACKET ;", "}", "case    2  7     :", "break ;", "case    1  1     :", "{", "return   JsonElementTypes . COMMA ;", "}", "case    2  8     :", "break ;", "case    1  2     :", "{", "return   JsonElementTypes . COLON ;", "}", "case    2  9     :", "break ;", "case    1  3     :", "{", "return   JsonElementTypes . LINE _ COMMENT ;", "}", "case    3  0     :", "break ;", "case    1  4     :", "{", "return   JsonElementTypes . BLOCK _ COMMENT ;", "}", "case    3  1     :", "break ;", "case    1  5     :", "{", "return   JsonElementTypes . NULL ;", "}", "case    3  2     :", "break ;", "case    1  6     :", "{", "return   JsonElementTypes . TRUE ;", "}", "case    3  3     :", "break ;", "case    1  7     :", "{", "return   JsonElementTypes . FALSE ;", "}", "case    3  4     :", "break ;", "default    :", "zzScanError (  . ZZ _ NO _ MATCH )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["advance"], "fileName": "com.intellij.json.json5._Json5Lexer"}, {"methodBody": ["METHOD_START", "{", "return    ( getTokenStart (  )  )     +     ( yylength (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTokenEnd"], "fileName": "com.intellij.json.json5._Json5Lexer"}, {"methodBody": ["METHOD_START", "{", "return   zzStartRead ;", "}", "METHOD_END"], "methodName": ["getTokenStart"], "fileName": "com.intellij.json.json5._Json5Lexer"}, {"methodBody": ["METHOD_START", "{", "zzBuffer    =    buffer ;", "zzCurrentPos    =    zzMarkedPos    =    zzStartRead    =    start ;", "zzAtEOF    =    false ;", "zzAtBOL    =    true ;", "zzEndRead    =    end ;", "yybegin ( initialState )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.intellij.json.json5._Json5Lexer"}, {"methodBody": ["METHOD_START", "{", "zzLexicalState    =    newState ;", "}", "METHOD_END"], "methodName": ["yybegin"], "fileName": "com.intellij.json.json5._Json5Lexer"}, {"methodBody": ["METHOD_START", "{", "return   zzBuffer . charAt (  (  ( zzStartRead )     +    pos )  )  ;", "}", "METHOD_END"], "methodName": ["yycharat"], "fileName": "com.intellij.json.json5._Json5Lexer"}, {"methodBody": ["METHOD_START", "{", "return    ( zzMarkedPos )     -     ( zzStartRead )  ;", "}", "METHOD_END"], "methodName": ["yylength"], "fileName": "com.intellij.json.json5._Json5Lexer"}, {"methodBody": ["METHOD_START", "{", "if    ( number    >     ( yylength (  )  )  )", "zzScanError (  . ZZ _ PUSHBACK _  2 BIG )  ;", "zzMarkedPos    -  =    number ;", "}", "METHOD_END"], "methodName": ["yypushback"], "fileName": "com.intellij.json.json5._Json5Lexer"}, {"methodBody": ["METHOD_START", "{", "return   zzLexicalState ;", "}", "METHOD_END"], "methodName": ["yystate"], "fileName": "com.intellij.json.json5._Json5Lexer"}, {"methodBody": ["METHOD_START", "{", "return   zzBuffer . subSequence ( zzStartRead ,    zzMarkedPos )  ;", "}", "METHOD_END"], "methodName": ["yytext"], "fileName": "com.intellij.json.json5._Json5Lexer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["zzRefill"], "fileName": "com.intellij.json.json5._Json5Lexer"}, {"methodBody": ["METHOD_START", "{", "String   message ;", "try    {", "message    =     . ZZ _ ERROR _ MSG [ errorCode ]  ;", "}    catch    ( ArrayIndexOutOfBoundsException   e )     {", "message    =     . ZZ _ ERROR _ MSG [  . ZZ _ UNKNOWN _ ERROR ]  ;", "}", "throw   new   Error ( message )  ;", "}", "METHOD_END"], "methodName": ["zzScanError"], "fileName": "com.intellij.json.json5._Json5Lexer"}, {"methodBody": ["METHOD_START", "{", "[  ]    result    =    new    [  7  8  ]  ;", "offset    =     0  ;", "offset    =     . zzUnpackAction (  . ZZ _ ACTION _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackAction"], "fileName": "com.intellij.json.json5._Json5Lexer"}, {"methodBody": ["METHOD_START", "{", "i    =     0  ;", "j    =    offset ;", "l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "unt    =    packed . charAt (  ( i +  +  )  )  ;", "value    =    packed . charAt (  ( i +  +  )  )  ;", "do", "result [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - unt )     >     0     )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackAction"], "fileName": "com.intellij.json.json5._Json5Lexer"}, {"methodBody": ["METHOD_START", "{", "[  ]    result    =    new    [  7  8  ]  ;", "offset    =     0  ;", "offset    =     . zzUnpackAttribute (  . ZZ _ ATTRIBUTE _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackAttribute"], "fileName": "com.intellij.json.json5._Json5Lexer"}, {"methodBody": ["METHOD_START", "{", "i    =     0  ;", "j    =    offset ;", "l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "unt    =    packed . charAt (  ( i +  +  )  )  ;", "value    =    packed . charAt (  ( i +  +  )  )  ;", "do", "result [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - unt )     >     0     )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackAttribute"], "fileName": "com.intellij.json.json5._Json5Lexer"}, {"methodBody": ["METHOD_START", "{", "size    =     0  ;", "for    (    i    =     0  ,    length    =    packed . length (  )  ;    i    <    length ;    i    +  =     2  )     {", "size    +  =    packed . charAt ( i )  ;", "}", "char [  ]    map    =    new   char [ size ]  ;", "i    =     0  ;", "j    =     0  ;", "while    ( i    <     ( packed . length (  )  )  )     {", "unt    =    packed . charAt (  ( i +  +  )  )  ;", "char   value    =    packed . charAt (  ( i +  +  )  )  ;", "do", "map [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - unt )     >     0     )  ;", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["zzUnpackCMap"], "fileName": "com.intellij.json.json5._Json5Lexer"}, {"methodBody": ["METHOD_START", "{", "[  ]    result    =    new    [  7  8  ]  ;", "offset    =     0  ;", "offset    =     . zzUnpackRowMap (  . ZZ _ ROWMAP _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackRowMap"], "fileName": "com.intellij.json.json5._Json5Lexer"}, {"methodBody": ["METHOD_START", "{", "i    =     0  ;", "j    =    offset ;", "l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "high    =     ( packed . charAt (  ( i +  +  )  )  )     <  <     1  6  ;", "result [  ( j +  +  )  ]     =    high    |     ( packed . charAt (  ( i +  +  )  )  )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackRowMap"], "fileName": "com.intellij.json.json5._Json5Lexer"}, {"methodBody": ["METHOD_START", "{", "[  ]    result    =    new    [  2  5  4  2  ]  ;", "offset    =     0  ;", "offset    =     . zzUnpackTrans (  . ZZ _ TRANS _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackTrans"], "fileName": "com.intellij.json.json5._Json5Lexer"}, {"methodBody": ["METHOD_START", "{", "i    =     0  ;", "j    =    offset ;", "l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "unt    =    packed . charAt (  ( i +  +  )  )  ;", "value    =    packed . charAt (  ( i +  +  )  )  ;", "value -  -  ;", "do", "result [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - unt )     >     0     )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackTrans"], "fileName": "com.intellij.json.json5._Json5Lexer"}, {"methodBody": ["METHOD_START", "{", "return   JsonBundle . message (  \" inspection . compliance 5  . name \"  )  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "com.intellij.json.json5.codeinsight.Json5StandardComplianceInspection"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( element   instanceof   JsonElement )  )     {", "return   null ;", "}", "JsonElement   parentProperty    =    PsiTreeUtil . getNonStrictParentOfType ( element ,    JsonProperty . class ,    JsonArray . class )  ;", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "while    ( parentProperty    !  =    null )     {", "if    ( parentProperty   instanceof   JsonProperty )     {", "builder . insert (  0  ,    parentProperty . getName (  )  )  ;", "builder . insert (  0  ,     ( qualifiedNameKind    =  =     ( Kind . JsonPointer )     ?     \"  /  \"     :     \"  .  \"  )  )  ;", "} else    {", "index    =    JsonUtil . getArrayIndexOfItem (  ( element   instanceof   JsonProperty    ?    element . getParent (  )     :    element )  )  ;", "if    ( index    =  =     (  -  1  )  )", "return   null ;", "builder . insert (  0  ,     ( qualifiedNameKind    =  =     ( Kind . JsonPointer )     ?     \"  /  \"     +    index    :     (  \"  [  \"     +    index )     +     \"  ]  \"  )  )  ;", "}", "element    =    parentProperty ;", "parentProperty    =    PsiTreeUtil . getParentOfType ( parentProperty ,    JsonProperty . class ,    JsonArray . class )  ;", "}", "if    (  ( builder . length (  )  )     =  =     0  )", "return   null ;", "if    (  ( builder . charAt (  0  )  )     =  =     '  [  '  )     {", "builder . insert (  0  ,     \"  $  \"  )  ;", "}", "return   StringUtil . trimStart ( builder . toString (  )  ,     \"  .  \"  )  ;", "}", "METHOD_END"], "methodName": ["generateQualifiedName"], "fileName": "com.intellij.json.navigation.JsonQualifiedNameProvider"}, {"methodBody": ["METHOD_START", "{", "final   JsonArray   jsonArray 1     =    createValue (  \"  [  1  ,     2  ]  \"  )  ;", "return   jsonArray 1  . getValueList (  )  . get (  0  )  . getNextSibling (  )  ;", "}", "METHOD_END"], "methodName": ["createComma"], "fileName": "com.intellij.json.psi.JsonElementGenerator"}, {"methodBody": ["METHOD_START", "{", "final   PsiFileFactory   psiFileFactory    =    PsiFileFactory . getInstance ( myProject )  ;", "return   psiFileFactory . createFileFromText (  (  \" dummy .  \"     +     ( FileType . INSTANCE . getDefaultExtension (  )  )  )  ,    FileType . INSTANCE ,    content )  ;", "}", "METHOD_END"], "methodName": ["createDummyFile"], "fileName": "com.intellij.json.psi.JsonElementGenerator"}, {"methodBody": ["METHOD_START", "{", "final   PsiFile   file    =    createDummyFile (  (  (  \"  {  \"     +    content )     +     \"  }  \"  )  )  ;", "return    (  ( Object )     ( file . getFirstChild (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createObject"], "fileName": "com.intellij.json.psi.JsonElementGenerator"}, {"methodBody": ["METHOD_START", "{", "final   PsiFile   file    =    createDummyFile (  (  (  (  (  \"  {  \\  \"  \"     +    name )     +     \"  \\  \"  :     \"  )     +    value )     +     \"  }  \"  )  )  ;", "return    (  ( Object )     ( file . getFirstChild (  )  )  )  . getPropertyList (  )  . get (  0  )  ;", "}", "METHOD_END"], "methodName": ["createProperty"], "fileName": "com.intellij.json.psi.JsonElementGenerator"}, {"methodBody": ["METHOD_START", "{", "return   createValue (  (  (  '  \"  '     +     ( StringUtil . escapeStringCharacters ( unescapedContent )  )  )     +     '  \"  '  )  )  ;", "}", "METHOD_END"], "methodName": ["createStringLiteral"], "fileName": "com.intellij.json.psi.JsonElementGenerator"}, {"methodBody": ["METHOD_START", "{", "final   PsiFile   file    =    createDummyFile (  (  (  \"  {  \\  \" foo \\  \"  :     \"     +    content )     +     \"  }  \"  )  )  ;", "return    (  ( T )     (  (  ( Object )     ( file . getFirstChild (  )  )  )  . getPropertyList (  )  . get (  0  )  . getValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createValue"], "fileName": "com.intellij.json.psi.JsonElementGenerator"}, {"methodBody": ["METHOD_START", "{", "visitContainer ( o )  ;", "}", "METHOD_END"], "methodName": ["visitArray"], "fileName": "com.intellij.json.psi.JsonElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitLiteral ( o )  ;", "}", "METHOD_END"], "methodName": ["visitBooleanLiteral"], "fileName": "com.intellij.json.psi.JsonElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitValue ( o )  ;", "}", "METHOD_END"], "methodName": ["visitContainer"], "fileName": "com.intellij.json.psi.JsonElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitPsiElement ( o )  ;", "}", "METHOD_END"], "methodName": ["visitElement"], "fileName": "com.intellij.json.psi.JsonElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitValue ( o )  ;", "}", "METHOD_END"], "methodName": ["visitLiteral"], "fileName": "com.intellij.json.psi.JsonElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitLiteral ( o )  ;", "}", "METHOD_END"], "methodName": ["visitNullLiteral"], "fileName": "com.intellij.json.psi.JsonElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitLiteral ( o )  ;", "}", "METHOD_END"], "methodName": ["visitNumberLiteral"], "fileName": "com.intellij.json.psi.JsonElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitContainer ( o )  ;", "}", "METHOD_END"], "methodName": ["visitObject"], "fileName": "com.intellij.json.psi.JsonElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitElement ( o )  ;", "}", "METHOD_END"], "methodName": ["visitProperty"], "fileName": "com.intellij.json.psi.JsonElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitElement ( o )  ;", "}", "METHOD_END"], "methodName": ["visitPsiElement"], "fileName": "com.intellij.json.psi.JsonElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitValue ( o )  ;", "}", "METHOD_END"], "methodName": ["visitReferenceExpression"], "fileName": "com.intellij.json.psi.JsonElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitLiteral ( o )  ;", "}", "METHOD_END"], "methodName": ["visitStringLiteral"], "fileName": "com.intellij.json.psi.JsonElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitElement ( o )  ;", "}", "METHOD_END"], "methodName": ["visitValue"], "fileName": "com.intellij.json.psi.JsonElementVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( builder . getTokenType (  )  )     !  =     ( JsonElementTypes . COMMA )  )     {", "return   false ;", "}", "final   IElementType   afterComma    =    builder . lookAhead (  1  )  ;", "if    (  ( afterComma    =  =     ( JsonElementTypes . R _ BRACKET )  )     |  |     ( afterComma    =  =     ( JsonElementTypes . R _ CURLY )  )  )     {", "builder . error (  \" trailing   comma \"  )  ;", "}", "builder . advanceLexer (  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["notTrailingComma"], "fileName": "com.intellij.json.psi.JsonParserUtil"}, {"methodBody": ["METHOD_START", "{", "ASTNode   from    =    myNode ;", "ASTNode   to    =    myNode . getTreeNext (  )  ;", "boolean   seenComma    =    false ;", "ASTNode   toCandidate    =    to ;", "while    (  ( toCandidate    !  =    null )     &  &     (  ( toCandidate . getElementType (  )  )     =  =     ( TokenType . WHITE _ SPACE )  )  )     {", "toCandidate    =    toCandidate . getTreeNext (  )  ;", "}", "if    (  ( toCandidate    !  =    null )     &  &     (  ( toCandidate . getElementType (  )  )     =  =     ( ElementTypes . COMMA )  )  )     {", "toCandidate    =    toCandidate . getTreeNext (  )  ;", "to    =    toCandidate ;", "seenComma    =    true ;", "if    (  ( to    !  =    null )     &  &     (  ( to . getElementType (  )  )     =  =     ( TokenType . WHITE _ SPACE )  )  )     {", "to    =    to . getTreeNext (  )  ;", "}", "}", "if    (  ! seenComma )     {", "ASTNode   treePrev    =    from . getTreePrev (  )  ;", "while    (  ( treePrev    !  =    null )     &  &     (  ( treePrev . getElementType (  )  )     =  =     ( TokenType . WHITE _ SPACE )  )  )     {", "from    =    treePrev ;", "treePrev    =    treePrev . getTreePrev (  )  ;", "}", "if    (  ( treePrev    !  =    null )     &  &     (  ( treePrev . getElementType (  )  )     =  =     ( ElementTypes . COMMA )  )  )     {", "from    =    treePrev ;", "}", "}", "parent . removeRange ( from ,    to )  ;", "}", "METHOD_END"], "methodName": ["removeCommaSeparatedFromList"], "fileName": "com.intellij.json.psi.JsonPsiChangeUtils"}, {"methodBody": ["METHOD_START", "{", "final   List < JsonProperty >    propertyList    =    object . getPropertyList (  )  ;", "if    (  ! first )     {", "final   JsonProperty   lastProperty    =    ContainerUtil . getLastItem ( propertyList )  ;", "if    ( lastProperty    !  =    null )     {", "final   PsiElement   addedProperty    =    object . addAfter ( property ,    lastProperty )  ;", "object . addBefore ( new   JsonElementGenerator ( object . getProject (  )  )  . createComma (  )  ,    addedProperty )  ;", "return   addedProperty ;", "}", "}", "final   PsiElement   leftBrace    =    object . getFirstChild (  )  ;", "assert    . hasElementType ( leftBrace ,    JsonElementTypes . L _ CURLY )  ;", "final   PsiElement   addedProperty    =    object . addAfter ( property ,    leftBrace )  ;", "if    (  !  ( propertyList . isEmpty (  )  )  )     {", "object . addAfter ( new   JsonElementGenerator ( object . getProject (  )  )  . createComma (  )  ,    addedProperty )  ;", "}", "return   addedProperty ;", "}", "METHOD_END"], "methodName": ["addProperty"], "fileName": "com.intellij.json.psi.JsonPsiUtil"}, {"methodBody": ["METHOD_START", "{", "ASTNode   node    =    anchor . getNode (  )  ;", "final   IElementType   expectedType    =    node . getElementType (  )  ;", "ASTNode   lastSeen    =    node ;", "while    ( node    !  =    null )     {", "final   IElementType   elementType    =    node . getElementType (  )  ;", "if    ( elementType    =  =    expectedType )     {", "lastSeen    =    node ;", "} else", "if    ( elementType    =  =     ( com . intellij . psi . TokenType . WHITE _ SPACE )  )     {", "if    (  ( expectedType    =  =     ( JsonElementTypes . LINE _ COMMENT )  )     &  &     (  ( node . getText (  )  . indexOf (  '  \\ n '  ,     1  )  )     !  =     (  -  1  )  )  )     {", "break ;", "}", "} else", "if    (  (  !  ( JsonParserDefinition . JSON _ COMMENTARIES . contains ( elementType )  )  )     |  |     ( JsonParserDefinition . JSON _ COMMENTARIES . contains ( expectedType )  )  )     {", "break ;", "}", "node    =     ( after )     ?    node . getTreeNext (  )     :    node . getTreePrev (  )  ;", "}", "return   lastSeen . getPsi (  )  ;", "}", "METHOD_END"], "methodName": ["findFurthestSiblingOfSameType"], "fileName": "com.intellij.json.psi.JsonPsiUtil"}, {"methodBody": ["METHOD_START", "{", "final   InjectedLanguageManager   manager    =    InjectedLanguageManager . getInstance ( element . getProject (  )  )  ;", "if    ( manager . isInjectedFragment ( element . getContainingFile (  )  )  )     {", "return   manager . getUnescapedText ( element )  ;", "} else    {", "return   element . getText (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getElementTextWithoutHostEscaping"], "fileName": "com.intellij.json.psi.JsonPsiUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( property    =  =    null )", "return   emptySet (  )  ;", "JsonObject   object    =    ObjectUtils . tryCast ( property . getParent (  )  ,    JsonObject . class )  ;", "if    ( object    =  =    null )", "return   emptySet (  )  ;", "Set < String >    result    =    ContainerUtil . newHashSet (  )  ;", "for    ( roperty   jsonProperty    :    object . getPropertyList (  )  )     {", "if    ( jsonProperty    !  =    property )     {", "result . add ( jsonProperty . getName (  )  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getOtherSiblingPropertyNames"], "fileName": "com.intellij.json.psi.JsonPsiUtil"}, {"methodBody": ["METHOD_START", "{", "return   JsonPsiUtil . hasElementType ( node ,    TokenSet . create ( types )  )  ;", "}", "METHOD_END"], "methodName": ["hasElementType"], "fileName": "com.intellij.json.psi.JsonPsiUtil"}, {"methodBody": ["METHOD_START", "{", "return   set . contains ( node . getElementType (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasElementType"], "fileName": "com.intellij.json.psi.JsonPsiUtil"}, {"methodBody": ["METHOD_START", "{", "return    (  ( element . getNode (  )  )     !  =    null )     &  &     ( JsonPsiUtil . hasElementType ( element . getNode (  )  ,    types )  )  ;", "}", "METHOD_END"], "methodName": ["hasElementType"], "fileName": "com.intellij.json.psi.JsonPsiUtil"}, {"methodBody": ["METHOD_START", "{", "return    (  ( element . getNode (  )  )     !  =    null )     &  &     ( JsonPsiUtil . hasElementType ( element . getNode (  )  ,    set )  )  ;", "}", "METHOD_END"], "methodName": ["hasElementType"], "fileName": "com.intellij.json.psi.JsonPsiUtil"}, {"methodBody": ["METHOD_START", "{", "return    ( element   instanceof   JsonValue )     &  &     (  ( element . getParent (  )  )    instanceof   JsonArray )  ;", "}", "METHOD_END"], "methodName": ["isArrayElement"], "fileName": "com.intellij.json.psi.JsonPsiUtil"}, {"methodBody": ["METHOD_START", "{", "count    =     0  ;", "for    (    i    =    position    -     1  ;     ( i    >  =     0  )     &  &     (  ( text . charAt ( i )  )     =  =     '  \\  \\  '  )  ;    i -  -  )     {", "count +  +  ;", "}", "return    ( count    %     2  )     !  =     0  ;", "}", "METHOD_END"], "methodName": ["isEscapedChar"], "fileName": "com.intellij.json.psi.JsonPsiUtil"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   parent    =    element . getParent (  )  ;", "return    ( parent   instanceof   roperty )     &  &     ( element    =  =     (  (  ( roperty )     ( parent )  )  . getNameElement (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isPropertyKey"], "fileName": "com.intellij.json.psi.JsonPsiUtil"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   parent    =    element . getParent (  )  ;", "return    ( parent   instanceof   roperty )     &  &     ( element    =  =     (  (  ( roperty )     ( parent )  )  . getValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isPropertyValue"], "fileName": "com.intellij.json.psi.JsonPsiUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  ( text . length (  )  )     >     0  )     {", "final   char   firstChar    =    text . charAt (  0  )  ;", "final   char   lastChar    =    text . charAt (  (  ( text . length (  )  )     -     1  )  )  ;", "if    (  ( firstChar    =  =     '  \\  '  '  )     |  |     ( firstChar    =  =     '  \"  '  )  )     {", "if    (  (  (  ( text . length (  )  )     >     1  )     &  &     ( firstChar    =  =    lastChar )  )     &  &     (  !  (  . isEscapedChar ( text ,     (  ( text . length (  )  )     -     1  )  )  )  )  )     {", "return   text . substring (  1  ,     (  ( text . length (  )  )     -     1  )  )  ;", "}", "return   text . substring (  1  )  ;", "}", "}", "return   text ;", "}", "METHOD_END"], "methodName": ["stripQuotes"], "fileName": "com.intellij.json.psi.JsonPsiUtil"}, {"methodBody": ["METHOD_START", "{", "[  ]    sourceOffsets    =    new    [  ( chars . length (  )  )     +     1  ]  ;", "sourceOffsetsRef . set ( sourceOffsets )  ;", "if    (  ( chars . indexOf (  '  \\  \\  '  )  )     <     0  )     {", "outChars . append ( chars )  ;", "for    (    i    =     0  ;    i    <     ( sourceOffsets . length )  ;    i +  +  )     {", "sourceOffsets [ i ]     =    i ;", "}", "return   true ;", "}", "index    =     0  ;", "final      outOffset    =    outChars . length (  )  ;", "while    ( index    <     ( chars . length (  )  )  )     {", "char   c    =    chars . charAt (  ( index +  +  )  )  ;", "sourceOffsets [  (  ( outChars . length (  )  )     -    outOffset )  ]     =    index    -     1  ;", "sourceOffsets [  (  (  ( outChars . length (  )  )     +     1  )     -    outOffset )  ]     =    index ;", "if    ( c    !  =     '  \\  \\  '  )     {", "outChars . append ( c )  ;", "continue ;", "}", "if    ( index    =  =     ( chars . length (  )  )  )", "return   false ;", "c    =    chars . charAt (  ( index +  +  )  )  ;", "if    ( eBacktick    &  &     ( c    =  =     '  `  '  )  )     {", "outChars . append ( c )  ;", "} else", "if    ( regExp )     {", "if    ( c    !  =     '  /  '  )     {", "outChars . append (  '  \\  \\  '  )  ;", "}", "outChars . append ( c )  ;", "} else    {", "switch    ( c )     {", "case    ' b '     :", "outChars . append (  '  \\ b '  )  ;", "break ;", "case    ' t '     :", "outChars . append (  '  \\ t '  )  ;", "break ;", "case    ' n '     :", "outChars . append (  '  \\ n '  )  ;", "break ;", "case    ' f '     :", "outChars . append (  '  \\ f '  )  ;", "break ;", "case    ' r '     :", "outChars . append (  '  \\ r '  )  ;", "break ;", "case    '  \"  '     :", "outChars . append (  '  \"  '  )  ;", "break ;", "case    '  /  '     :", "outChars . append (  '  /  '  )  ;", "break ;", "case    '  \\ n '     :", "outChars . append (  '  \\ n '  )  ;", "break ;", "case    '  \\  '  '     :", "outChars . append (  '  \\  '  '  )  ;", "break ;", "case    '  \\  \\  '     :", "outChars . append (  '  \\  \\  '  )  ;", "break ;", "case    '  0  '     :", "case    '  1  '     :", "case    '  2  '     :", "case    '  3  '     :", "case    '  4  '     :", "case    '  5  '     :", "case    '  6  '     :", "case    '  7  '     :", "{", "char   startC    =    c ;", "v    =     (  (  )     ( c )  )     -     '  0  '  ;", "if    ( index    <     ( chars . length (  )  )  )     {", "c    =    chars . charAt (  ( index +  +  )  )  ;", "if    (  (  '  0  '     <  =    c )     &  &     ( c    <  =     '  7  '  )  )     {", "v    <  <  =     3  ;", "v    +  =    c    -     '  0  '  ;", "if    (  ( startC    <  =     '  3  '  )     &  &     ( index    <     ( chars . length (  )  )  )  )     {", "c    =    chars . charAt (  ( index +  +  )  )  ;", "if    (  (  '  0  '     <  =    c )     &  &     ( c    <  =     '  7  '  )  )     {", "v    <  <  =     3  ;", "v    +  =    c    -     '  0  '  ;", "} else    {", "index -  -  ;", "}", "}", "} else    {", "index -  -  ;", "}", "}", "outChars . append (  (  ( char )     ( v )  )  )  ;", "}", "break ;", "case    ' x '     :", "if    (  ( index    +     2  )     <  =     ( chars . length (  )  )  )     {", "try    {", "v    =    Integer . parseInt ( chars . substring ( index ,     ( index    +     2  )  )  ,     1  6  )  ;", "outChars . append (  (  ( char )     ( v )  )  )  ;", "index    +  =     2  ;", "}    catch    ( Exception   e )     {", "return   false ;", "}", "} else    {", "return   false ;", "}", "break ;", "case    ' u '     :", "if    (  ( index    +     4  )     <  =     ( chars . length (  )  )  )     {", "try    {", "v    =    Integer . parseInt ( chars . substring ( index ,     ( index    +     4  )  )  ,     1  6  )  ;", "if    (  ( v    =  =     1  0  )     |  |     ( v    =  =     1  3  )  )", "return   false ;", "c    =    chars . charAt ( index )  ;", "if    (  ( c    =  =     '  +  '  )     |  |     ( c    =  =     '  -  '  )  )", "return   false ;", "outChars . append (  (  ( char )     ( v )  )  )  ;", "index    +  =     4  ;", "}    catch    ( Exception   e )     {", "return   false ;", "}", "} else    {", "return   false ;", "}", "break ;", "default    :", "outChars . append ( c )  ;", "break ;", "}", "}", "sourceOffsets [  (  ( outChars . length (  )  )     -    outOffset )  ]     =    index ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["parseStringCharacters"], "fileName": "com.intellij.json.psi.impl.JSStringLiteralEscaper"}, {"methodBody": ["METHOD_START", "{", "visitor . visitArray ( this )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "com.intellij.json.psi.impl.JsonArrayImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( visitor   instanceof   JsonElementVisitor )", "accept (  (  ( JsonElementVisitor )     ( visitor )  )  )  ;", "else", "super . accept ( visitor )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "com.intellij.json.psi.impl.JsonArrayImpl"}, {"methodBody": ["METHOD_START", "{", "return   JsonPsiImplUtils . getPresentation ( this )  ;", "}", "METHOD_END"], "methodName": ["getPresentation"], "fileName": "com.intellij.json.psi.impl.JsonArrayImpl"}, {"methodBody": ["METHOD_START", "{", "visitor . visitBooleanLiteral ( this )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "com.intellij.json.psi.impl.JsonBooleanLiteralImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( visitor   instanceof   JsonElementVisitor )", "accept (  (  ( JsonElementVisitor )     ( visitor )  )  )  ;", "else", "super . accept ( visitor )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "com.intellij.json.psi.impl.JsonBooleanLiteralImpl"}, {"methodBody": ["METHOD_START", "{", "return   JsonPsiImplUtils . getValue ( this )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.intellij.json.psi.impl.JsonBooleanLiteralImpl"}, {"methodBody": ["METHOD_START", "{", "visitor . visitContainer ( this )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "com.intellij.json.psi.impl.JsonContainerImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( visitor   instanceof   JsonElementVisitor )", "accept (  (  ( JsonElementVisitor )     ( visitor )  )  )  ;", "else", "super . accept ( visitor )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "com.intellij.json.psi.impl.JsonContainerImpl"}, {"methodBody": ["METHOD_START", "{", "visitor . visitLiteral ( this )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "com.intellij.json.psi.impl.JsonLiteralImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( visitor   instanceof   JsonElementVisitor )", "accept (  (  ( JsonElementVisitor )     ( visitor )  )  )  ;", "else", "super . accept ( visitor )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "com.intellij.json.psi.impl.JsonLiteralImpl"}, {"methodBody": ["METHOD_START", "{", "return   JsonPsiImplUtils . isQuotedString ( this )  ;", "}", "METHOD_END"], "methodName": ["isQuotedString"], "fileName": "com.intellij.json.psi.impl.JsonLiteralImpl"}, {"methodBody": ["METHOD_START", "{", "visitor . visitNullLiteral ( this )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "com.intellij.json.psi.impl.JsonNullLiteralImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( visitor   instanceof   JsonElementVisitor )", "accept (  (  ( JsonElementVisitor )     ( visitor )  )  )  ;", "else", "super . accept ( visitor )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "com.intellij.json.psi.impl.JsonNullLiteralImpl"}, {"methodBody": ["METHOD_START", "{", "visitor . visitNumberLiteral ( this )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "com.intellij.json.psi.impl.JsonNumberLiteralImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( visitor   instanceof   JsonElementVisitor )", "accept (  (  ( JsonElementVisitor )     ( visitor )  )  )  ;", "else", "super . accept ( visitor )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "com.intellij.json.psi.impl.JsonNumberLiteralImpl"}, {"methodBody": ["METHOD_START", "{", "return   JsonPsiImplUtils . getValue ( this )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.intellij.json.psi.impl.JsonNumberLiteralImpl"}, {"methodBody": ["METHOD_START", "{", "visitor . visitObject ( this )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "com.intellij.json.psi.impl.JsonObjectImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( visitor   instanceof   JsonElementVisitor )", "accept (  (  ( JsonElementVisitor )     ( visitor )  )  )  ;", "else", "super . accept ( visitor )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "com.intellij.json.psi.impl.JsonObjectImpl"}, {"methodBody": ["METHOD_START", "{", "return   JsonPsiImplUtils . getPresentation ( this )  ;", "}", "METHOD_END"], "methodName": ["getPresentation"], "fileName": "com.intellij.json.psi.impl.JsonObjectImpl"}, {"methodBody": ["METHOD_START", "{", "visitor . visitProperty ( this )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "com.intellij.json.psi.impl.JsonPropertyImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( visitor   instanceof   JsonElementVisitor )", "accept (  (  ( JsonElementVisitor )     ( visitor )  )  )  ;", "else", "super . accept ( visitor )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "com.intellij.json.psi.impl.JsonPropertyImpl"}, {"methodBody": ["METHOD_START", "{", "return   JsonPsiImplUtils . getName ( this )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.intellij.json.psi.impl.JsonPropertyImpl"}, {"methodBody": ["METHOD_START", "{", "return   JsonPsiImplUtils . getNameElement ( this )  ;", "}", "METHOD_END"], "methodName": ["getNameElement"], "fileName": "com.intellij.json.psi.impl.JsonPropertyImpl"}, {"methodBody": ["METHOD_START", "{", "return   JsonPsiImplUtils . getPresentation ( this )  ;", "}", "METHOD_END"], "methodName": ["getPresentation"], "fileName": "com.intellij.json.psi.impl.JsonPropertyImpl"}, {"methodBody": ["METHOD_START", "{", "return   JsonPsiImplUtils . getValue ( this )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.intellij.json.psi.impl.JsonPropertyImpl"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   myNode    =    property . getNode (  )  ;", "ChangeUtils . removeCommaSeparatedFromList ( myNode ,    myNode . getTreeParent (  )  )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "com.intellij.json.psi.impl.JsonPsiImplUtils"}, {"methodBody": ["METHOD_START", "{", "return   StringUtil . unescapeStringCharacters ( JsonPsiUtil . stripQuotes ( property . getNameElement (  )  . getText (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.intellij.json.psi.impl.JsonPsiImplUtils"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   firstChild    =    property . getFirstChild (  )  ;", "assert    ( firstChild   instanceof   Literal )     |  |     ( firstChild   instanceof   ReferenceExpression )  ;", "return    (  ( Value )     ( firstChild )  )  ;", "}", "METHOD_END"], "methodName": ["getNameElement"], "fileName": "com.intellij.json.psi.impl.JsonPsiImplUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   ItemPresentation (  )     {", "@ Nullable", "@ Override", "public   String   getPresentableText (  )     {", "return   JsonBundle . message (  \" array \"  )  ;", "}", "@ Nullable", "@ Override", "public   String   getLocationString (  )     {", "return   null ;", "}", "@ Nullable", "@ Override", "public   Icon   getIcon ( boolean   unused )     {", "return   Json . Array ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getPresentation"], "fileName": "com.intellij.json.psi.impl.JsonPsiImplUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   ItemPresentation (  )     {", "@ Nullable", "@ Override", "public   String   getPresentableText (  )     {", "return   JsonBundle . message (  \" object \"  )  ;", "}", "@ Nullable", "@ Override", "public   String   getLocationString (  )     {", "return   null ;", "}", "@ Nullable", "@ Override", "public   Icon   getIcon ( boolean   unused )     {", "return   Json . Object ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getPresentation"], "fileName": "com.intellij.json.psi.impl.JsonPsiImplUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   ItemPresentation (  )     {", "@ Nullable", "@ Override", "public   String   getPresentableText (  )     {", "return   property . getName (  )  ;", "}", "@ Nullable", "@ Override", "public   String   getLocationString (  )     {", "final   Value   value    =    property . getValue (  )  ;", "return   value   instanceof   Literal    ?    value . getText (  )     :    null ;", "}", "@ Nullable", "@ Override", "public   Icon   getIcon ( boolean   unused )     {", "if    (  ( property . getValue (  )  )    instanceof   Array )     {", "return    . Property _ brackets ;", "}", "if    (  ( property . getValue (  )  )    instanceof   Object )     {", "return    . Property _ braces ;", "}", "return   PlatformIcons . PROPERTY _ ICON ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getPresentation"], "fileName": "com.intellij.json.psi.impl.JsonPsiImplUtils"}, {"methodBody": ["METHOD_START", "{", "List < Pair < TextRange ,    String >  >    result    =    literal . getUserData ( JsonPsiImplUtils . STRING _ FRAGMENTS )  ;", "if    ( result    =  =    null )     {", "result    =    new   ArrayList (  )  ;", "final   String   text    =    literal . getText (  )  ;", "final      length    =    text . length (  )  ;", "pos    =     1  ;", "unescapedSequenceStart    =     1  ;", "while    ( pos    <    length )     {", "if    (  ( text . charAt ( pos )  )     =  =     '  \\  \\  '  )     {", "if    ( unescapedSequenceStart    !  =    pos )     {", "result . add ( Pair . create ( new   TextRange ( unescapedSequenceStart ,    pos )  ,    text . substring ( unescapedSequenceStart ,    pos )  )  )  ;", "}", "if    ( pos    =  =     ( length    -     1  )  )     {", "result . add ( Pair . create ( new   TextRange ( pos ,     ( pos    +     1  )  )  ,     \"  \\  \\  \"  )  )  ;", "break ;", "}", "final   char   next    =    text . charAt (  ( pos    +     1  )  )  ;", "switch    ( next )     {", "case    '  \"  '     :", "case    '  \\  \\  '     :", "case    '  /  '     :", "case    ' b '     :", "case    ' f '     :", "case    ' n '     :", "case    ' r '     :", "case    ' t '     :", "final      idx    =    JsonPsiImplUtils . ourEscapesTable . indexOf ( next )  ;", "result . add ( Pair . create ( new   TextRange ( pos ,     ( pos    +     2  )  )  ,    JsonPsiImplUtils . ourEscapesTable . substring (  ( idx    +     1  )  ,     ( idx    +     2  )  )  )  )  ;", "pos    +  =     2  ;", "break ;", "case    ' u '     :", "i    =    pos    +     2  ;", "for    (  ;    i    <     ( pos    +     6  )  ;    i +  +  )     {", "if    (  ( i    =  =    length )     |  |     (  !  ( StringUtil . isHexDigit ( text . charAt ( i )  )  )  )  )     {", "break ;", "}", "}", "result . add ( Pair . create ( new   TextRange ( pos ,    i )  ,    text . substring ( pos ,    i )  )  )  ;", "pos    =    i ;", "break ;", "default    :", "result . add ( Pair . create ( new   TextRange ( pos ,     ( pos    +     2  )  )  ,    text . substring ( pos ,     ( pos    +     2  )  )  )  )  ;", "pos    +  =     2  ;", "}", "unescapedSequenceStart    =    pos ;", "} else    {", "pos +  +  ;", "}", "}", "final      contentEnd    =     (  ( text . charAt (  0  )  )     =  =     ( text . charAt (  ( length    -     1  )  )  )  )     ?    length    -     1     :    length ;", "if    ( unescapedSequenceStart    <    contentEnd )     {", "result . add ( Pair . create ( new   TextRange ( unescapedSequenceStart ,    length )  ,    text . substring ( unescapedSequenceStart ,    contentEnd )  )  )  ;", "}", "result    =    Collections . unmodifiableList ( result )  ;", "literal . putUserData ( JsonPsiImplUtils . STRING _ FRAGMENTS ,    result )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getTextFragments"], "fileName": "com.intellij.json.psi.impl.JsonPsiImplUtils"}, {"methodBody": ["METHOD_START", "{", "return   literal . textMatches (  \" true \"  )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.intellij.json.psi.impl.JsonPsiImplUtils"}, {"methodBody": ["METHOD_START", "{", "return   Double . parseDouble ( literal . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.intellij.json.psi.impl.JsonPsiImplUtils"}, {"methodBody": ["METHOD_START", "{", "return   PsiTreeUtil . getNextSiblingOfType ( JsonPsiImplUtils . getNameElement ( property )  ,    JsonValue . class )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.intellij.json.psi.impl.JsonPsiImplUtils"}, {"methodBody": ["METHOD_START", "{", "return   StringUtil . unescapeStringCharacters ( JsonPsiUtil . stripQuotes ( literal . getText (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.intellij.json.psi.impl.JsonPsiImplUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( literal . getNode (  )  . findChildByType ( JsonParserDefinition . STRING _ LITERALS )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isQuotedString"], "fileName": "com.intellij.json.psi.impl.JsonPsiImplUtils"}, {"methodBody": ["METHOD_START", "{", "element . acceptChildren ( this )  ;", "}", "METHOD_END"], "methodName": ["visitElement"], "fileName": "com.intellij.json.psi.impl.JsonRecursiveElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitor . visitReferenceExpression ( this )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "com.intellij.json.psi.impl.JsonReferenceExpressionImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( visitor   instanceof   JsonElementVisitor )", "accept (  (  ( JsonElementVisitor )     ( visitor )  )  )  ;", "else", "super . accept ( visitor )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "com.intellij.json.psi.impl.JsonReferenceExpressionImpl"}, {"methodBody": ["METHOD_START", "{", "visitor . visitStringLiteral ( this )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "com.intellij.json.psi.impl.JsonStringLiteralImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( visitor   instanceof   JsonElementVisitor )", "accept (  (  ( JsonElementVisitor )     ( visitor )  )  )  ;", "else", "super . accept ( visitor )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "com.intellij.json.psi.impl.JsonStringLiteralImpl"}, {"methodBody": ["METHOD_START", "{", "return   JsonPsiImplUtils . getTextFragments ( this )  ;", "}", "METHOD_END"], "methodName": ["getTextFragments"], "fileName": "com.intellij.json.psi.impl.JsonStringLiteralImpl"}, {"methodBody": ["METHOD_START", "{", "return   JsonPsiImplUtils . getValue ( this )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.intellij.json.psi.impl.JsonStringLiteralImpl"}, {"methodBody": ["METHOD_START", "{", "visitor . visitValue ( this )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "com.intellij.json.psi.impl.JsonValueImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( visitor   instanceof   JsonElementVisitor )", "accept (  (  ( JsonElementVisitor )     ( visitor )  )  )  ;", "else", "super . accept ( visitor )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "com.intellij.json.psi.impl.JsonValueImpl"}, {"methodBody": ["METHOD_START", "{", "DocumentationProvider   documentationProvider    =    DocumentationManager . getProviderFromElement ( context )  ;", "String   inlineDoc    =    documentationProvider . generateDoc ( docElement ,    context )  ;", "String   quickNavigate    =    documentationProvider . getQuickNavigateInfo ( docElement ,    context )  ;", "checkExpectedDoc ( shouldHaveDoc ,    inlineDoc ,    false )  ;", "checkExpectedDoc ( shouldHaveDoc ,    quickNavigate ,    true )  ;", "}", "METHOD_END"], "methodName": ["assertDocumentation"], "fileName": "com.jetbrains.jsonSchema.JsonBySchemaDocumentationBaseTest"}, {"methodBody": ["METHOD_START", "{", "if    ( shouldHaveDoc )     {", "assertNotNull (  \" inline   help   is   null \"  ,    inlineDoc )  ;", "} else    {", "assertNull (  \" inline   help   is   not   null \"  ,    inlineDoc )  ;", "}", "if    ( shouldHaveDoc )     {", "assertSameLinesWithFile (  (  (  (  ( getDataPath (  )  )     +     \"  /  \"  )     +     ( getName ( true )  )  )     +     ( preferShort    ?     \"  _ short . html \"     :     \"  . html \"  )  )  ,    inlineDoc )  ;", "}", "}", "METHOD_END"], "methodName": ["checkExpectedDoc"], "fileName": "com.jetbrains.jsonSchema.JsonBySchemaDocumentationBaseTest"}, {"methodBody": ["METHOD_START", "{", "final   JsonSchemaDocumentationProvider   provider    =    new   JsonSchemaDocumentationProvider (  )  ;", "INSTANCE . addExplicitExtension ( JsonLanguage . INSTANCE ,    provider )  ;", "try    {", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "final   ArrayList < UserDefinedJsonSchemaConfiguration . Item >    patterns    =    new   ArrayList <  >  (  )  ;", "patterns . add ( new   UserDefinedJsonSchemaConfiguration . Item (  (  ( getTestName ( true )  )     +     \"  *  \"  )  ,    true ,    false )  )  ;", "addSchema ( new   UserDefinedJsonSchemaConfiguration (  \" testDoc \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     (  (  ( moduleDir    +     \"  /  \"  )     +     ( getTestName ( true )  )  )     +     \" Schema . json \"  )  ,    false ,    patterns )  )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     (  (  (  \"  /  \"     +     ( getTestName ( true )  )  )     +     \"  .  \"  )     +    extension )  ,     (  (  \"  /  \"     +     ( getTestName ( true )  )  )     +     \" Schema . json \"  )  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "final   PsiElement   psiElement    =    PsiUtilBase . getElementAtCaret ( myEditor )  ;", "Assert . assertNotNull ( psiElement )  ;", "assertDocumentation ( psiElement ,    psiElement ,    hasDoc )  ;", "}", "}  )  ;", "}    finally    {", "INSTANCE . removeExplicitExtension ( JsonLanguage . INSTANCE ,    provider )  ;", "JsonSchemaTestServiceImpl . setProvider ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.jetbrains.jsonSchema.JsonBySchemaDocumentationBaseTest"}, {"methodBody": ["METHOD_START", "{", "JPanel   wrapper    =    new   JBPanel ( new   BorderLayout (  )  )  ;", "wrapper . add ( panel ,    BorderLayout . NORTH )  ;", "return   wrapper ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCatalogConfigurable"}, {"methodBody": ["METHOD_START", "{", "return   ServiceManager . getService ( project ,    JsonSchemaCatalogProjectConfiguration . class )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCatalogProjectConfiguration"}, {"methodBody": ["METHOD_START", "{", "myState    =    new   JsonSchemaCatalogProjectConfiguration . MyState ( isEnabled )  ;", "updateComponent ( isEnabled )  ;", "}", "METHOD_END"], "methodName": ["setState"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCatalogProjectConfiguration"}, {"methodBody": ["METHOD_START", "{", "(  ( JsonSchemaServiceImpl )     ( JsonSchemaService . Impl . get ( myProject )  )  )  . getCatalogManager (  )  . setEnabled ( isEnabled )  ;", "}", "METHOD_END"], "methodName": ["updateComponent"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCatalogProjectConfiguration"}, {"methodBody": ["METHOD_START", "{", "String   schemaSubPath    =    myView . getSchemaSubPath (  )  ;", "if    ( StringUtil . isEmptyOrSpaces ( schemaSubPath )  )     {", "throw   new   com . intellij . openapi . options . ConfigurationException (  (  (  !  ( StringUtil . isEmptyOrSpaces ( myDisplayName )  )     ?     ( myDisplayName )     +     \"  :     \"     :     \"  \"  )     +     \" Schema   path   is   empty \"  )  )  ;", "}", "VirtualFile   vFile ;", "String   filename ;", "if    (  . isHttpPath ( schemaSubPath )  )     {", "filename    =    schemaSubPath ;", "if    (  !  (  . isValidURL ( schemaSubPath )  )  )     {", "throw   new   com . intellij . openapi . options . ConfigurationException (  (  (  !  ( StringUtil . isEmptyOrSpaces ( myDisplayName )  )     ?     ( myDisplayName )     +     \"  :     \"     :     \"  \"  )     +     \" Invalid   schema   URL \"  )  )  ;", "}", "vFile    =    JsonFileResolver . urlToFile ( schemaSubPath )  ;", "if    ( vFile    =  =    null )     {", "throw   new   com . intellij . openapi . options . ConfigurationException (  (  (  !  ( StringUtil . isEmptyOrSpaces ( myDisplayName )  )     ?     ( myDisplayName )     +     \"  :     \"     :     \"  \"  )     +     \" Invalid   URL   resource \"  )  )  ;", "}", "} else    {", "final   File   file    =    new   File ( myProject . getBasePath (  )  ,    schemaSubPath )  ;", "if    (  (  !  ( file . exists (  )  )  )     |  |     (  ( vFile    =    LocalFileSystem . getInstance (  )  . refreshAndFindFileByIoFile ( file )  )     =  =    null )  )     {", "throw   new   com . intellij . openapi . options . ConfigurationException (  (  (  !  ( StringUtil . isEmptyOrSpaces ( myDisplayName )  )     ?     ( myDisplayName )     +     \"  :     \"     :     \"  \"  )     +     \" Schema   file   does   not   exist \"  )  )  ;", "}", "filename    =    file . getName (  )  ;", "}", "if    ( StringUtil . isEmptyOrSpaces ( myDisplayName )  )", "throw   new   com . intellij . openapi . options . ConfigurationException (  ( filename    +     \"  :    Schema   name   is   empty \"  )  )  ;", "if    ( vFile   instanceof   HttpVirtualFile )", "return ;", "final   String   error    =    JsonSchemaReader . checkIfValidJsonSchema ( myProject ,    vFile )  ;", "if    ( error    !  =    null )     {", "logErrorForUser ( error )  ;", "throw   new   RuntimeConfigurationWarning ( error )  ;", "}", "}", "METHOD_END"], "methodName": ["doValidation"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaConfigurable"}, {"methodBody": ["METHOD_START", "{", "return   mySchema ;", "}", "METHOD_END"], "methodName": ["getSchema"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaConfigurable"}, {"methodBody": ["METHOD_START", "{", "final   UserDefinedJsonSchemaConfiguration   info    =    new   UserDefinedJsonSchemaConfiguration (  )  ;", "info . setApplicationLevel ( mySchema . isApplicationLevel (  )  )  ;", "if    (  (  ( myView )     !  =    null )     &  &     ( myView . isInitialized (  )  )  )     {", "info . setName ( getDisplayName (  )  )  ;", "info . setSchemaVersion ( myView . getSchemaVersion (  )  )  ;", "info . setPatterns ( myView . getData (  )  )  ;", "info . setRelativePathToSchema ( myView . getSchemaSubPath (  )  )  ;", "} else    {", "info . setName ( mySchema . getName (  )  )  ;", "info . setSchemaVersion ( mySchema . getSchemaVersion (  )  )  ;", "info . setPatterns ( mySchema . getPatterns (  )  )  ;", "info . setRelativePathToSchema ( mySchema . getRelativePathToSchema (  )  )  ;", "}", "return   info ;", "}", "METHOD_END"], "methodName": ["getUiSchema"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaConfigurable"}, {"methodBody": ["METHOD_START", "{", "Couple < String >    couple    =    UriUtil . splitScheme ( schemaFieldText )  ;", "return   couple . first . startsWith (  \" http \"  )  ;", "}", "METHOD_END"], "methodName": ["isHttpPath"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaConfigurable"}, {"methodBody": ["METHOD_START", "{", "return    ( JsonSchemaConfigurable . isHttpPath ( url )  )     &  &     (  ( Urls . parse ( url ,    false )  )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["isValidURL"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaConfigurable"}, {"methodBody": ["METHOD_START", "{", "JsonSchemaReader . ERRORS _ NOTIFICATION . createNotification ( error ,    ERROR )  . notify ( myProject )  ;", "}", "METHOD_END"], "methodName": ["logErrorForUser"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaConfigurable"}, {"methodBody": ["METHOD_START", "{", "myError    =    error ;", "if    (  ( myView )     !  =    null )     {", "myView . sError ( error )  ;", "}", "}", "METHOD_END"], "methodName": ["setError"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaConfigurable"}, {"methodBody": ["METHOD_START", "{", "assertStringItems ( strings )  ;", "LookupImpl   lookup    =    getActiveLookup (  )  ;", "if    ( lookup    !  =    null )", "lookup . hide (  )  ;", "Service . Impl . get ( getProject (  )  )  . reset (  )  ;", "doHighlighting (  )  ;", "complete (  )  ;", "assertStringItems ( strings )  ;", "}", "METHOD_END"], "methodName": ["checkCompletion"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "final   PsiReference   referenceAt    =    myFile . findReferenceAt ( offset )  ;", "Assert . assertNotNull ( referenceAt )  ;", "final   PsiElement   resolve    =    referenceAt . resolve (  )  ;", "Assert . assertNotNull ( resolve )  ;", "Assert . assertEquals (  (  (  \"  \\  \"  \"     +    name )     +     \"  \\  \"  \"  )  ,    resolve . getText (  )  )  ;", "final   PsiElement   parent    =    resolve . getParent (  )  ;", "Assert . assertTrue (  ( parent   instanceof   JsonProperty )  )  ;", "Assert . assertEquals ( name ,     (  ( JsonProperty )     ( parent )  )  . getName (  )  )  ;", "Assert . assertTrue (  (  ( parent . getParent (  )  . getParent (  )  )    instanceof   JsonProperty )  )  ;", "Assert . assertEquals ( base ,     (  ( JsonProperty )     ( parent . getParent (  )  . getParent (  )  )  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNavigationTo"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "offset    =    myEditor . getCaretModel (  )  . getPrimaryCaret (  )  . getOffset (  )  ;", "final   PsiElement   element    =    myFile . findElementAt ( offset )  ;", "Assert . assertNotNull ( element )  ;", "ckNavigationTo ( name ,    offset ,    base )  ;", "}", "METHOD_END"], "methodName": ["checkNavigationTo"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "final   PsiReference   referenceAt    =    myFile . findReferenceAt ( offset )  ;", "Assert . assertNotNull ( referenceAt )  ;", "final   PsiElement   resolve    =    referenceAt . resolve (  )  ;", "Assert . assertNotNull ( resolve )  ;", "Assert . assertEquals (  (  (  \"  \\  \"  \"     +    name )     +     \"  \\  \"  \"  )  ,    resolve . getText (  )  )  ;", "final   PsiElement   parent    =    resolve . getParent (  )  ;", "Assert . assertTrue (  ( parent   instanceof   JsonProperty )  )  ;", "Assert . assertEquals ( name ,     (  ( JsonProperty )     ( parent )  )  . getName (  )  )  ;", "Assert . assertTrue (  (  ( parent . getParent (  )  . getParent (  )  )    instanceof   JsonProperty )  )  ;", "final   JsonProperty   props    =     (  ( JsonProperty )     ( parent . getParent (  )  . getParent (  )  )  )  ;", "Assert . assertEquals (  \" properties \"  ,    props . getName (  )  )  ;", "final   JsonProperty   parentProperty    =    ObjectUtils . tryCast ( props . getParent (  )  . getParent (  )  ,    JsonProperty . class )  ;", "Assert . assertNotNull ( parentProperty )  ;", "Assert . assertEquals ( parentPropertyName ,    parentProperty . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNavigationToSchemaVariant"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "doHighlighting (  )  ;", "complete (  )  ;", "assertStringItems (  \"  \\  \" one \\  \"  \"  ,     \"  \\  \" two \\  \"  \"  )  ;", "final   VirtualFile   baseFile    =    moduleFile . findChild ( fileName )  ;", "Assert . assertNotNull ( baseFile )  ;", "FileDocumentManager   fileDocumentManager    =    FileDocumentManager . getInstance (  )  ;", "Document   document    =    fileDocumentManager . getDocument ( baseFile )  ;", "Assert . assertNotNull ( document )  ;", "String   str    =     \"  \\  \" enum \\  \"  :     [  \\  \" one \\  \"  ,     \\  \" two \\  \"  ]  \"  ;", "start    =    document . getText (  )  . indexOf ( str )  ;", "Assert . assertTrue (  ( start    >     0  )  )  ;", "ApplicationManager . getApplication (  )  . runWriteAction (  (  )     -  >     {", "document . replaceString ( start ,     ( start    +     ( str . length (  )  )  )  ,     \"  \\  \" enum \\  \"  :     [  \\  \" one 1  \\  \"  ,     \\  \" two 1  \\  \"  ]  \"  )  ;", "fileDocumentManager . saveAllDocuments (  )  ;", "}  )  ;", "LookupImpl   lookup    =    getActiveLookup (  )  ;", "if    ( lookup    !  =    null )", "lookup . hide (  )  ;", "Service . Impl . get ( getProject (  )  )  . reset (  )  ;", "doHighlighting (  )  ;", "complete (  )  ;", "assertStringItems (  \"  \\  \" one 1  \\  \"  \"  ,     \"  \\  \" two 1  \\  \"  \"  )  ;", "lookup    =    getActiveLookup (  )  ;", "if    ( lookup    !  =    null )", "lookup . hide (  )  ;", "Service . Impl . get ( getProject (  )  )  . reset (  )  ;", "doHighlighting (  )  ;", "complete (  )  ;", "assertStringItems (  \"  \\  \" one 1  \\  \"  \"  ,     \"  \\  \" two 1  \\  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["checkSchemaCompletion"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "addSchema ( new   UserDefinedonfiguration (  \" one \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / completionInsideSchemaDefinition . json \"  )  ,    false ,    Collections . emptyList (  )  )  )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     \" completionInsideSchemaDefinition . json \"  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "final   Set < String >    strings    =    Arrays . stream ( myItems )  . map ( LookupElement :  : getLookupString )  . collect ( Collectors . toSet (  )  )  ;", "Assert . assertTrue ( strings . contains (  \"  \\  \" enum \\  \"  \"  )  )  ;", "Assert . assertTrue ( strings . contains (  \"  \\  \" exclusiveMinimum \\  \"  \"  )  )  ;", "Assert . assertTrue ( strings . contains (  \"  \\  \" description \\  \"  \"  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testCompletionInsideSchemaDefinition"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "final   List < UserDefinedonfiguration . Item >    patterns    =    Collections . singletonList ( new   UserDefinedonfiguration . Item (  \"  *  . json \"  ,    true ,    false )  )  ;", "addSchema ( new   UserDefinedonfiguration (  \" one \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / cycledWithRootRefSchema . json \"  )  ,    false ,    patterns )  )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     \" completionWithRootRef . json \"  ,     \" cycledWithRootRefSchema . json \"  )  ;", "complete (  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "checkCompletion (  \"  \\  \" id \\  \"  \"  ,     \"  \\  \" testProp \\  \"  \"  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testCompletionWithRootRef"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "addSchema ( new   UserDefinedonfiguration (  \" one \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / refToDefinitionInFileSchema . json \"  )  ,    false ,    Collections . emptyList (  )  )  )  ;", "addSchema ( new   UserDefinedonfiguration (  \" two \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / definitionsSchema . json \"  )  ,    false ,    Collections . emptyList (  )  )  )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     \"  / refToDefinitionInFileSchema . json \"  ,     \"  / definitionsSchema . json \"  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "offset    =    myEditor . getCaretModel (  )  . getPrimaryCaret (  )  . getOffset (  )  ;", "final   PsiReference   referenceAt    =    myFile . findReferenceAt ( offset )  ;", "Assert . assertNotNull ( referenceAt )  ;", "final   PsiElement   resolve    =    referenceAt . resolve (  )  ;", "Assert . assertNotNull ( resolve )  ;", "Assert . assertEquals (  \" definitionsSchema . json \"  ,    resolve . getContainingFile (  )  . getName (  )  )  ;", "Assert . assertEquals (  \"  \\  \" findMe \\  \"  \"  ,    resolve . getText (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testFindRefInOtherFile"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "addSchema ( new   UserDefinedonfiguration (  \" one \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / refToOtherFileSchema . json \"  )  ,    false ,    Collections . emptyList (  )  )  )  ;", "addSchema ( new   UserDefinedonfiguration (  \" two \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / definitionsSchema . json \"  )  ,    false ,    Collections . emptyList (  )  )  )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     \"  / refToOtherFileSchema . json \"  ,     \"  / definitionsSchema . json \"  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "offset    =    myEditor . getCaretModel (  )  . getPrimaryCaret (  )  . getOffset (  )  ;", "final   PsiReference   referenceAt    =    myFile . findReferenceAt ( offset )  ;", "Assert . assertNotNull ( referenceAt )  ;", "final   PsiElement   resolve    =    referenceAt . resolve (  )  ;", "Assert . assertNotNull ( resolve )  ;", "Assert . assertEquals (  \" definitionsSchema . json \"  ,    resolve . getContainingFile (  )  . getName (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testFindRefToOtherFile"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "addSchema ( new   UserDefinedonfiguration (  \" one \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / insideCycledSchemaNavigationSchema . json \"  )  ,    false ,    Collections . emptyList (  )  )  )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     \" insideCycledSchemaNavigationSchema . json \"  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "checkNavigationTo (  \" all \"  ,    JsonSchemaObject . DEFINITIONS )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testInsideCycledSchemaNavigation"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "final   UserDefinedonfiguration   inherited    =    new   UserDefinedonfiguration (  \" inherited \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / basePropertiesSchema . json \"  )  ,    false ,    Collections . singletonList ( new   UserDefinedonfiguration . Item (  \"  *  . json \"  ,    true ,    false )  )  )  ;", "addSchema ( inherited )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     \"  / testFileForBaseProperties . json \"  ,     \"  / basePropertiesSchema . json \"  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "offset    =    myEditor . getCaretModel (  )  . getPrimaryCaret (  )  . getOffset (  )  ;", "PsiElement   element    =    myFile . findElementAt ( offset )  ;", "boolean   found    =    false ;", "while    ( element . getTextRange (  )  . contains ( offset )  )     {", "if    ( JsonSchemaReferenceContributor . this . PROPERTY _ NAME _ PATTERN . accepts ( element )  )     {", "found    =    true ;", "break ;", "}", "element    =    element . getParent (  )  ;", "}", "Assert . assertTrue ( found )  ;", "final   PsiReference   referenceAt    =    myFile . findReferenceAt ( offset )  ;", "Assert . assertNotNull ( referenceAt )  ;", "final   PsiElement   resolve    =    referenceAt . resolve (  )  ;", "Assert . assertNotNull ( resolve )  ;", "Assert . assertEquals (  \" basePropertiesSchema . json \"  ,    resolve . getContainingFile (  )  . getName (  )  )  ;", "Assert . assertEquals (  \"  \\  \" baseEnum \\  \"  \"  ,    resolve . getText (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testJson2SchemaPropertyResolve"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   doCheck (  )     {", "checkCompletion (  \"  \\  \" one \\  \"  \"  ,     \"  \\  \" two \\  \"  \"  )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     \"  / completion . json \"  ,     \"  / baseSchema . json \"  ,     \"  / inheritedSchema . json \"  )  ;", "}", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "final   UserDefinedonfiguration   base    =    new   UserDefinedonfiguration (  \" base \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / baseSchema . json \"  )  ,    false ,    Collections . emptyList (  )  )  ;", "addSchema ( base )  ;", "final   UserDefinedonfiguration   inherited    =    new   UserDefinedonfiguration (  \" inherited \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / inheritedSchema . json \"  )  ,    false ,    Collections . singletonList ( new   UserDefinedonfiguration . Item (  \"  *  . json \"  ,    true ,    false )  )  )  ;", "addSchema ( inherited )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testJsonSchemaCrossReferenceCompletion"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "private   String   myModuleDir ;", "@ Override", "public   void   registerSchemes (  )     {", "myModuleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "final   UserDefinedonfiguration   base    =    new   UserDefinedonfiguration (  \" base \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     (  ( myModuleDir )     +     \"  / baseSchema . json \"  )  ,    false ,    Collections . emptyList (  )  )  ;", "addSchema ( base )  ;", "final   UserDefinedonfiguration   inherited    =    new   UserDefinedonfiguration (  \" inherited \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     (  ( myModuleDir )     +     \"  / inheritedSchema . json \"  )  ,    false ,    Collections . singletonList ( new   UserDefinedonfiguration . Item (  \"  *  . json \"  ,    true ,    false )  )  )  ;", "addSchema ( inherited )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     \"  / completion . json \"  ,     \"  / baseSchema . json \"  ,     \"  / inheritedSchema . json \"  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "final   VirtualFile   moduleFile    =    getProject (  )  . getBaseDir (  )  . findChild ( myModuleDir )  ;", "assertNotNull ( moduleFile )  ;", "checkSchemaCompletion ( moduleFile ,     \" baseSchema . json \"  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testJsonSchemaCrossReferenceCompletionWithSchemaEditing"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "AreaPicoContainer   container    =    Extensions . getArea ( getProject (  )  )  . getPicoContainer (  )  ;", "final   String   key    =    JsonSchemaMappingsProjectConfiguration . class . getName (  )  ;", "container . unregisterComponent ( key )  ;", "container . registerComponentImplementation ( key ,    TestJsonSchemaMappingsProjectConfiguration . class )  ;", "final   UserDefinedonfiguration   inherited    =    new   UserDefinedonfiguration (  \" inherited \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / referencingGlobalSchema . json \"  )  ,    false ,    Collections . emptyList (  )  )  ;", "addSchema ( inherited )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     \"  / referencingGlobalSchema . json \"  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "offset    =    myEditor . getCaretModel (  )  . getPrimaryCaret (  )  . getOffset (  )  ;", "final   PsiReference   referenceAt    =    myFile . findReferenceAt ( offset )  ;", "Assert . assertNotNull ( referenceAt )  ;", "final   PsiElement   resolve    =    referenceAt . resolve (  )  ;", "Assert . assertNotNull ( resolve )  ;", "Assert . assertEquals (  \"  \\  \" enum \\  \"  \"  ,    resolve . getText (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testJsonSchemaGlobalRefsCrossResolve"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   doCheck (  )     {", "offset    =    myEditor . getCaretModel (  )  . getPrimaryCaret (  )  . getOffset (  )  ;", "final   PsiReference   referenceAt    =    myFile . findReferenceAt ( offset )  ;", "Assert . assertNotNull ( referenceAt )  ;", "final   PsiElement   resolve    =    referenceAt . resolve (  )  ;", "Assert . assertNotNull ( resolve )  ;", "Assert . assertEquals (  \"  \\  \" baseEnum \\  \"  \"  ,    resolve . getText (  )  )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     \"  / referencingSchema . json \"  ,     \"  / localRefSchema . json \"  )  ;", "}", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "final   UserDefinedonfiguration   base    =    new   UserDefinedonfiguration (  \" base \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / localRefSchema . json \"  )  ,    false ,    Collections . emptyList (  )  )  ;", "addSchema ( base )  ;", "final   UserDefinedonfiguration   inherited    =    new   UserDefinedonfiguration (  \" inherited \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / referencingSchema . json \"  )  ,    false ,    Collections . emptyList (  )  )  ;", "addSchema ( inherited )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testJsonSchemaRefsCrossResolve"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "addSchema ( new   UserDefinedonfiguration (  \" one \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / navigateFromSchemaDefinitionToMainSchema . json \"  )  ,    false ,    Collections . emptyList (  )  )  )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     \" navigateFromSchemaDefinitionToMainSchema . json \"  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "offset    =    myEditor . getCaretModel (  )  . getPrimaryCaret (  )  . getOffset (  )  ;", "final   PsiReference   referenceAt    =    myFile . findReferenceAt ( offset )  ;", "Assert . assertNotNull ( referenceAt )  ;", "final   PsiElement   resolve    =    referenceAt . resolve (  )  ;", "Assert . assertNotNull ( resolve )  ;", "Assert . assertEquals (  \"  \\  \" properties \\  \"  \"  ,    resolve . getText (  )  )  ;", "final   PsiElement   parent    =    resolve . getParent (  )  ;", "Assert . assertTrue (  ( parent   instanceof   JsonProperty )  )  ;", "Assert . assertEquals (  \" schema . json \"  ,    resolve . getContainingFile (  )  . getName (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testNavigateFromSchemaDefinitionToMainSchema"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "final   List < UserDefinedonfiguration . Item >    patterns    =    Collections . singletonList ( new   UserDefinedonfiguration . Item (  \" testNestedAllOfOneOfDefinitions . json \"  ,    true ,    false )  )  ;", "addSchema ( new   UserDefinedonfiguration (  \" one \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / nestedAllOfOneOfDefinitionsSchema . json \"  )  ,    false ,    patterns )  )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     \"  / testNestedAllOfOneOfDefinitions . json \"  ,     \"  / nestedAllOfOneOfDefinitionsSchema . json \"  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "offset    =    myEditor . getCaretModel (  )  . getPrimaryCaret (  )  . getOffset (  )  ;", "final   PsiReference   referenceAt    =    myFile . findReferenceAt ( offset )  ;", "Assert . assertNotNull ( referenceAt )  ;", "final   PsiElement   resolve    =    referenceAt . resolve (  )  ;", "Assert . assertNotNull ( resolve )  ;", "Assert . assertEquals (  \" nestedAllOfOneOfDefinitionsSchema . json \"  ,    resolve . getContainingFile (  )  . getName (  )  )  ;", "Assert . assertEquals (  \"  \\  \" begriff \\  \"  \"  ,    resolve . getText (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testNavigateToAllOfOneOfDefinitions"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "addSchema ( new   UserDefinedonfiguration (  \" one \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / withReferenceToDefinitionSchema . json \"  )  ,    false ,    Collections . emptyList (  )  )  )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     \" withReferenceToDefinitionSchema . json \"  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "offset    =    myEditor . getCaretModel (  )  . getPrimaryCaret (  )  . getOffset (  )  ;", "final   PsiReference   referenceAt    =    myFile . findReferenceAt ( offset )  ;", "Assert . assertNotNull ( referenceAt )  ;", "final   PsiElement   resolve    =    referenceAt . resolve (  )  ;", "Assert . assertNotNull ( resolve )  ;", "Assert . assertEquals (  \"  \\  \" findDefinition \\  \"  \"  ,    resolve . getText (  )  )  ;", "final   PsiElement   parent    =    resolve . getParent (  )  ;", "Assert . assertTrue (  ( parent   instanceof   JsonProperty )  )  ;", "final   JsonValue   value    =     (  ( JsonProperty )     ( parent )  )  . getValue (  )  ;", "Assert . assertTrue (  ( value   instanceof   JsonObject )  )  ;", "final   JsonProperty   anEnum    =     (  ( JsonObject )     ( value )  )  . findProperty (  \" enum \"  )  ;", "Assert . assertNotNull ( anEnum )  ;", "Assert . assertEquals (  \"  [  1  ,  4  ,  8  ]  \"  ,    anEnum . getValue (  )  . getText (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testNavigateToDefinitionByRef"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "addSchema ( new   UserDefinedonfiguration (  \" one \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / withIncorrectReferenceSchema . json \"  )  ,    false ,    Collections . emptyList (  )  )  )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     \" withIncorrectReferenceSchema . json \"  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "final   String   midia    =     \" midia \"  ;", "checkNavigationTo ( midia ,    JsonSchemaObject . DEFINITIONS )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testNavigateToDefinitionByRefInFileWithIncorrectReference"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "final   List < UserDefinedonfiguration . Item >    patterns    =    Collections . singletonList ( new   UserDefinedonfiguration . Item (  \" package . json \"  ,    true ,    false )  )  ;", "addSchema ( new   UserDefinedonfiguration (  \" one \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / packageJsonSchema . json \"  )  ,    false ,    patterns )  )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     \"  / package . json \"  ,     \"  / packageJsonSchema . json \"  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "final   String   text    =    myFile . getText (  )  ;", "final      indexOf    =    text . indexOf (  \" dependencies \"  )  ;", "assertTrue (  ( indexOf    >     0  )  )  ;", "final   PsiReference   referenceAt    =    myFile . findReferenceAt ( indexOf )  ;", "Assert . assertNotNull ( referenceAt )  ;", "final   PsiElement   resolve    =    referenceAt . resolve (  )  ;", "Assert . assertNotNull ( resolve )  ;", "Assert . assertEquals (  \" packageJsonSchema . json \"  ,    resolve . getContainingFile (  )  . getName (  )  )  ;", "Assert . assertEquals (  \"  \\  \" dependencies \\  \"  \"  ,    resolve . getText (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testNavigateToPropertyDefinitionInPackageJsonSchema"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "final   List < UserDefinedonfiguration . Item >    patterns    =    Collections . singletonList ( new   UserDefinedonfiguration . Item (  \" testNestedDefinitionsNavigation . json \"  ,    true ,    false )  )  ;", "addSchema ( new   UserDefinedonfiguration (  \" one \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / nestedDefinitionsSchema . json \"  )  ,    false ,    patterns )  )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     \"  / testNestedDefinitionsNavigation . json \"  ,     \"  / nestedDefinitionsSchema . json \"  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "offset    =    myEditor . getCaretModel (  )  . getPrimaryCaret (  )  . getOffset (  )  ;", "final   PsiReference   referenceAt    =    myFile . findReferenceAt ( offset )  ;", "Assert . assertNotNull ( referenceAt )  ;", "final   PsiElement   resolve    =    referenceAt . resolve (  )  ;", "Assert . assertNotNull ( resolve )  ;", "Assert . assertEquals (  \" nestedDefinitionsSchema . json \"  ,    resolve . getContainingFile (  )  . getName (  )  )  ;", "Assert . assertEquals (  \"  \\  \" definitions \\  \"  \"  ,    resolve . getText (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testNavigateToPropertyDefinitionNestedDefinitions"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "final   JsonSchemaService   service    =    JsonSchemaService . Impl . get ( myProject )  ;", "final   List < JsonSchemaFileProvider >    providers    =    new   JsonSchemaProjectSelfProviderFactory (  )  . getProviders ( myProject )  ;", "Assert . assertEquals ( JsonSchemaProjectSelfProviderFactory . TOTAL _ PROVIDERS ,    providers . size (  )  )  ;", "for    ( JsonSchemaFileProvider   provider    :    providers )     {", "final   VirtualFile   mainSchema    =    provider . getSchemaFile (  )  ;", "assertNotNull ( mainSchema )  ;", "assertTrue ( service . isSchemaFile ( mainSchema )  )  ;", "final   PsiFile   psi    =    PsiManager . getInstance ( myProject )  . findFile ( mainSchema )  ;", "Assert . assertNotNull ( psi )  ;", "Assert . assertTrue (  ( psi   instanceof   JsonFile )  )  ;", "final   JsonValue   top    =     (  ( JsonFile )     ( psi )  )  . getTopLevelValue (  )  ;", "final   JsonObject   obj    =    ObjectUtils . tryCast ( top ,    JsonObject . class )  ;", "Assert . assertNotNull ( obj )  ;", "final   JsonProperty   properties    =    obj . findProperty (  \" properties \"  )  ;", "final   JsonObject   propObj    =    ObjectUtils . tryCast ( properties . getValue (  )  ,    JsonObject . class )  ;", "final   JsonProperty   maxLength    =    propObj . findProperty (  \" maxLength \"  )  ;", "final   JsonObject   value    =    ObjectUtils . tryCast ( maxLength . getValue (  )  ,    JsonObject . class )  ;", "Assert . assertNotNull ( value )  ;", "final   JsonProperty   ref    =    value . findProperty (  \"  $ ref \"  )  ;", "Assert . assertNotNull ( ref )  ;", "final   JsonStringLiteral   literal    =    ObjectUtils . tryCast ( ref . getValue (  )  ,    JsonStringLiteral . class )  ;", "Assert . assertNotNull ( literal )  ;", "final   PsiReference   reference    =    psi . findReferenceAt (  (  ( literal . getTextRange (  )  . getStartOffset (  )  )     +     1  )  )  ;", "Assert . assertNotNull ( reference )  ;", "String   positiveOrNonNegative    =     (  (  ( JsonSchemaProjectSelfProviderFactory . MyJsonSchemaFileProvider )     ( provider )  )  . isSchemaV 4  (  )  )     ?     \" positiveInteger \"     :     \" nonNegativeInteger \"  ;", "Assert . assertEquals (  (  \"  #  / definitions /  \"     +    positiveOrNonNegative )  ,    reference . getCanonicalText (  )  )  ;", "final   PsiElement   resolve    =    reference . resolve (  )  ;", "Assert . assertNotNull ( resolve )  ;", "Assert . assertEquals (  (  (  \"  \\  \"  \"     +    positiveOrNonNegative )     +     \"  \\  \"  \"  )  ,    resolve . getText (  )  )  ;", "Assert . assertTrue (  (  ( resolve . getParent (  )  )    instanceof   JsonProperty )  )  ;", "Assert . assertEquals ( positiveOrNonNegative ,     (  ( JsonProperty )     ( resolve . getParent (  )  )  )  . getName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testNavigateToRefInsideMainSchema"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "final   List < UserDefinedonfiguration . Item >    patterns    =    Collections . singletonList ( new   UserDefinedonfiguration . Item (  \"  *  . json \"  ,    true ,    false )  )  ;", "addSchema ( new   UserDefinedonfiguration (  \" one \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / cycledSchema . json \"  )  ,    false ,    patterns )  )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     \" testNavigationIntoCycled . json \"  ,     \" cycledSchema . json \"  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "checkNavigationTo (  \" bbb \"  ,    JsonSchemaObject . PROPERTIES )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testNavigationIntoCycledSchema"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "final   List < UserDefinedonfiguration . Item >    patterns    =    Collections . singletonList ( new   UserDefinedonfiguration . Item (  \"  *  . json \"  ,    true ,    false )  )  ;", "addSchema ( new   UserDefinedonfiguration (  \" one \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / navigationWithCompositeDefinitionsObjectSchema . json \"  )  ,    false ,    patterns )  )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     \" navigationIntoWithCompositeDefinitionsObjectSchema . json \"  ,     \" navigationWithCompositeDefinitionsObjectSchema . json \"  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "checkNavigationTo (  \" id \"  ,    JsonSchemaObject . PROPERTIES )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testNavigationIntoWithCompositeDefinitionsObject"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "final   List < UserDefinedonfiguration . Item >    patterns    =    Collections . singletonList ( new   UserDefinedonfiguration . Item (  \"  *  . json \"  ,    true ,    false )  )  ;", "addSchema ( new   UserDefinedonfiguration (  \" one \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / navigationWithCompositeDefinitionsObjectSchema . json \"  )  ,    false ,    patterns )  )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     \" navigationWithCompositeDefinitionsObjectSchema . json \"  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "final   Collection < JsonStringLiteral >    strings    =    PsiTreeUtil . findChildrenOfType ( myFile ,    JsonStringLiteral . class )  ;", "final   List < JsonStringLiteral >    list    =    strings . stream (  )  . filter (  (    expression )     -  >    expression . getText (  )  . contains (  \"  #  / definitions \"  )  )  . collect ( Collectors . toList (  )  )  ;", "Assert . assertEquals (  3  ,    list . size (  )  )  ;", "list . forEach (  (    literal )     -  >    checkNavigationTo (  \" cycle . schema \"  ,     (  ( literal . getTextRange (  )  . getStartOffset (  )  )     +     1  )  ,    JsonSchemaObject . DEFINITIONS )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testNavigationWithCompositeDefinitionsObject"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "final   String   prefix    =     \" nestedAllOneAnyWithInheritance /  \"  ;", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "addSchema ( new   UserDefinedonfiguration (  \" one \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / baseSchema . json \"  )  ,    false ,    Collections . emptyList (  )  )  )  ;", "final   List < UserDefinedonfiguration . Item >    patterns    =    Collections . singletonList ( new   UserDefinedonfiguration . Item (  \" testCompletion . json \"  ,    true ,    false )  )  ;", "addSchema ( new   UserDefinedonfiguration (  \" two \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / referentSchema . json \"  )  ,    false ,    patterns )  )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     ( prefix    +     \" testCompletion . json \"  )  ,     ( prefix    +     \" baseSchema . json \"  )  ,     ( prefix    +     \" referentSchema . json \"  )  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "checkCompletion (  \"  1  \"  ,     \"  2  \"  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testNestedAllOneAnyWithInheritanceCompletion"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "final   String   prefix    =     \" nestedAllOneAnyWithInheritance /  \"  ;", "enableInspectionTool ( new   omplianceInspection (  )  )  ;", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "addSchema ( new   UserDefinedonfiguration (  \" one \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / baseSchema . json \"  )  ,    false ,    Collections . emptyList (  )  )  )  ;", "final   List < UserDefinedonfiguration . Item >    patterns    =    Collections . singletonList ( new   UserDefinedonfiguration . Item (  \" testHighlighting . json \"  ,    true ,    false )  )  ;", "addSchema ( new   UserDefinedonfiguration (  \" two \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / referentSchema . json \"  )  ,    false ,    patterns )  )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     ( prefix    +     \" testHighlighting . json \"  )  ,     ( prefix    +     \" baseSchema . json \"  )  ,     ( prefix    +     \" referentSchema . json \"  )  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "doDoTest ( true ,    false )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testNestedAllOneAnyWithInheritanceHighlighting"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "final   String   prefix    =     \" nestedAllOneAnyWithInheritance /  \"  ;", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "addSchema ( new   UserDefinedonfiguration (  \" one \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / baseSchema . json \"  )  ,    false ,    Collections . emptyList (  )  )  )  ;", "final   List < UserDefinedonfiguration . Item >    patterns    =    Collections . singletonList ( new   UserDefinedonfiguration . Item (  \" testNavigation . json \"  ,    true ,    false )  )  ;", "addSchema ( new   UserDefinedonfiguration (  \" two \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / referentSchema . json \"  )  ,    false ,    patterns )  )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     ( prefix    +     \" testNavigation . json \"  )  ,     ( prefix    +     \" baseSchema . json \"  )  ,     ( prefix    +     \" referentSchema . json \"  )  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "offset    =    myEditor . getCaretModel (  )  . getPrimaryCaret (  )  . getOffset (  )  ;", "final   PsiReference   referenceAt    =    myFile . findReferenceAt ( offset )  ;", "Assert . assertNotNull ( referenceAt )  ;", "final   PsiElement   resolve    =    referenceAt . resolve (  )  ;", "Assert . assertNotNull ( resolve )  ;", "Assert . assertEquals (  \" baseSchema . json \"  ,    resolve . getContainingFile (  )  . getName (  )  )  ;", "Assert . assertEquals (  \"  \\  \" findMe \\  \"  \"  ,    resolve . getText (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testNestedAllOneAnyWithInheritanceNavigation"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "private   String   myModuleDir ;", "@ Override", "public   void   registerSchemes (  )     {", "myModuleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "final   UserDefinedonfiguration   base    =    new   UserDefinedonfiguration (  \" base \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     (  ( myModuleDir )     +     \"  / basePropertiesSchema . json \"  )  ,    false ,    Collections . singletonList ( new   UserDefinedonfiguration . Item (  \"  *  . json \"  ,    true ,    false )  )  )  ;", "addSchema ( base )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     \"  / baseCompletion . json \"  ,     \"  / basePropertiesSchema . json \"  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "final   VirtualFile   moduleFile    =    getProject (  )  . getBaseDir (  )  . findChild ( myModuleDir )  ;", "assertNotNull ( moduleFile )  ;", "checkSchemaCompletion ( moduleFile ,     \" basePropertiesSchema . json \"  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testRefreshSchemaCompletionSimpleVariant"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "final   List < UserDefinedonfiguration . Item >    patterns    =    Collections . singletonList ( new   UserDefinedonfiguration . Item (  \"  *  . json \"  ,    true ,    false )  )  ;", "addSchema ( new   UserDefinedonfiguration (  \" one \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / ResolveByValuesCombinationsSchema . json \"  )  ,    false ,    patterns )  )  ;", "}", "@ Override", "public   void   configureFiles (  )    throws   Exception    {", "configureByFile (  \" ResolveByValuesCombinationsSchema . json \"  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "final   List < Trinity < String ,    String ,    String >  >    variants    =    ContainerUtil . list ( Trinity . create (  \" yes \"  ,     \" barkling \"  ,     \" dog \"  )  ,    Trinity . create (  \" yes \"  ,     \" meowing \"  ,     \" cat \"  )  ,    Trinity . create (  \" yes \"  ,     \" crowling \"  ,     \" mouse \"  )  ,    Trinity . create (  \" not \"  ,     \" apparel \"  ,     \" schrank \"  )  ,    Trinity . create (  \" not \"  ,     \" dinner \"  ,     \" tisch \"  )  ,    Trinity . create (  \" not \"  ,     \" rest \"  ,     \" sessel \"  )  )  ;", "variants . forEach (  (    t )     -  >     {", "final   PsiFile   file    =    configureByText ( JsonFileType . INSTANCE ,    String . format (  (  \"  {  \\  \" alive \\  \"  :  \\  \"  % s \\  \"  ,  \\ n \"     +     \"  \\  \" feature \\  \"  :  \\  \"  % s \\  \"  }  \"  )  ,    t . getFirst (  )  ,    t . getSecond (  )  )  ,     \" json \"  )  ;", "final   JsonFile   jsonFile    =    ObjectUtils . tryCast ( file ,     . class )  ;", "Assert . assertNotNull ( jsonFile )  ;", "final   JsonObject   top    =    ObjectUtils . tryCast ( jsonFile . getTopLevelValue (  )  ,     . class )  ;", "Assert . assertNotNull ( top )  ;", "TextRange   range    =    top . findProperty (  \" alive \"  )  . getNameElement (  )  . getTextRange (  )  ;", "checkNavigationToSchemaVariant (  \" alive \"  ,     (  ( range . getStartOffset (  )  )     +     1  )  ,    t . getThird (  )  )  ;", "range    =    top . findProperty (  \" feature \"  )  . getNameElement (  )  . getTextRange (  )  ;", "checkNavigationToSchemaVariant (  \" feature \"  ,     (  ( range . getStartOffset (  )  )     +     1  )  ,    t . getThird (  )  )  ;", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testResolveByValuesCombinations"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaCrossReferencesTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( true ,     \" json \"  )  ;", "}", "METHOD_END"], "methodName": ["testCheckEscaping"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( true ,     \" json \"  )  ;", "}", "METHOD_END"], "methodName": ["testHtmlDescription"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( true ,     \" json \"  )  ;", "}", "METHOD_END"], "methodName": ["testSecondLevel"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( true ,     \" json \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( true ,     \" json \"  )  ;", "}", "METHOD_END"], "methodName": ["testWithDefinition"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( true ,     \" json \"  )  ;", "}", "METHOD_END"], "methodName": ["testWithTitleInDefinition"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaDocumentationTest"}, {"methodBody": ["METHOD_START", "{", "mySchemas . put ( schema . getName (  )  ,    schema )  ;", "}", "METHOD_END"], "methodName": ["addSchema"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHeavyAbstractTest"}, {"methodBody": ["METHOD_START", "{", "String   moduleDir    =    null ;", "VirtualFile [  ]    children    =    project . getBaseDir (  )  . getChildren (  )  ;", "for    ( VirtualFile   child    :    children )     {", "if    ( child . isDirectory (  )  )     {", "moduleDir    =    child . getName (  )  ;", "break ;", "}", "}", "Assert . assertNotNull ( moduleDir )  ;", "return   moduleDir ;", "}", "METHOD_END"], "methodName": ["getModuleDir"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHeavyAbstractTest"}, {"methodBody": ["METHOD_START", "{", "PathManagerEx . TestDataLookupStrategy   strategy    =    PathManagerEx . guessTestDataLookupStrategy (  )  ;", "if    ( strategy . equals ( COMMUNITY )  )     {", "return    (  (  ( PathManager . getHomePath (  )  )     +     \"  / json \"  )     +     ( getBasePath (  )  )  )     +     \"  /  \"  ;", "}", "return    (  (  ( PathManager . getHomePath (  )  )     +     \"  / community / json \"  )     +     ( getBasePath (  )  )  )     +     \"  /  \"  ;", "}", "METHOD_END"], "methodName": ["getTestDataPath"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHeavyAbstractTest"}, {"methodBody": ["METHOD_START", "{", "callback . configureFiles (  )  ;", "callback . registerSchemes (  )  ;", "MappingsProjectConfiguration . getInstance ( getProject (  )  )  . setState ( mySchemas )  ;", "Service . Impl . get ( getProject (  )  )  . reset (  )  ;", "doHighlighting (  )  ;", "if    ( myDoCompletion )", "complete (  )  ;", "callback . doCheck (  )  ;", "}", "METHOD_END"], "methodName": ["skeleton"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHeavyAbstractTest"}, {"methodBody": ["METHOD_START", "{", "enableInspectionTool ( new   JsonSchemaComplianceInspection (  )  )  ;", "final   PsiFile   file    =    createFile ( myModule ,     \" config . json \"  ,    text )  ;", "registerProvider ( getProject (  )  ,    schema )  ;", "Disposer . register ( getTestRootDisposable (  )  ,    new   Disposable (  )     {", "@ Override", "public   void   dispose (  )     {", "JsonSchemaTestServiceImpl . setProvider ( null )  ;", "}", "}  )  ;", "configureByFile ( file . getVirtualFile (  )  )  ;", "doTest ( file . getVirtualFile (  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "File   dir    =    createTempDir (  \" json _ schema _ test \"  ,    true )  ;", "File   child    =    new   File ( dir ,     \" schema . json \"  )  ;", "child . createNewFile (  )  ;", "FileUtil . writeToFile ( child ,    schema )  ;", "VirtualFile   schemaFile    =    getVirtualFile ( child )  ;", "TestServiceImpl . setProvider ( new   TestProvider ( schemaFile )  )  ;", "AreaPicoContainer   container    =    Extensions . getArea ( project )  . getPicoContainer (  )  ;", "String   key    =    Service . class . getName (  )  ;", "container . unregisterComponent ( key )  ;", "container . registerComponentImplementation ( key ,    TestServiceImpl . class )  ;", "}", "METHOD_END"], "methodName": ["registerProvider"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "return    \"  {  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"        \\  \"  $ schema \\  \"  :     \\  \" http :  /  / json - schema . org / draft -  0  4  / schema #  \\  \"  ,  \\ n \"     +     \"        \\  \" type \\  \"  :     \\  \" object \\  \"  ,  \\ n \"  )     +     \"        \\  \"  $ ref \\  \"     :     \\  \"  #  / definitions / root \\  \"  ,  \\ n \"  )     +     \"        \\  \" definitions \\  \"  :     {  \\ n \"  )     +     \"              \\  \" root \\  \"     :     {  \\ n \"  )     +     \"                    \\  \" type \\  \"  :     \\  \" object \\  \"  ,  \\ n \"  )     +     \"                    \\  \" additionalProperties \\  \"  :    false ,  \\ n \"  )     +     \"                    \\  \" properties \\  \"  :     {  \\ n \"  )     +     \"                          \\  \" r 1  \\  \"  :     {  \\ n \"  )     +     \"                                \\  \" type \\  \"  :     \\  \" string \\  \"  \\ n \"  )     +     \"                          }  ,  \\ n \"  )     +     \"                          \\  \" r 2  \\  \"  :     {  \\ n \"  )     +     \"                                \\  \" type \\  \"  :     \\  \" string \\  \"  \\ n \"  )     +     \"                          }  \\ n \"  )     +     \"                    }  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"        }  \\ n \"  )     +     \"  }  \\ n \"  )  ;", "}", "METHOD_END"], "methodName": ["rootObjectRedefinedSchema"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "return    (  \"  {  \\  \" type \\  \"  :     \\  \" object \\  \"  ,     \\  \" properties \\  \"  :     {  \\  \" prop \\  \"  :     \"     +    s )     +     \"  }  }  \"  ;", "}", "METHOD_END"], "methodName": ["schema"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  \"  \\ n \"     +     \"        \\  \" properties \\  \"  :     {  \\ n \"  )     +     \"              \\  \" withFormat \\  \"  :     {  \\ n \"  )     +     \"                    \\  \" oneOf \\  \"  :     [  \\ n \"  )     +     \"                          {  \\ n \"  )     +     \"                                \\  \" format \\  \"  :  \\  \" hostname \\  \"  \\ n \"  )     +     \"                          }  ,  \\ n \"  )     +     \"                          {  \\ n \"  )     +     \"                                \\  \" format \\  \"  :     \\  \" ip 4  \\  \"  \\ n \"  )     +     \"                          }  \\ n \"  )     +     \"                    ]  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"        }  \\ n \"  )     +     \"  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" withFormat \\  \"  :     \\  \" localhost \\  \"  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAcceptSchemaWithoutType"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   schema    =     . schema (  \"  {  }  \"  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     {  }  ,     \\  \" someStuff \\  \"  :     2  0  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAdditionalPropertiesAllowed"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\  \" type \\  \"  :     \\  \" object \\  \"  ,     \\  \" properties \\  \"  :     {  \\  \" prop \\  \"  :     {  }  }  ,     \\  \" additionalProperties \\  \"  :    false }  \"  ;", "doTest ( s ,     \"  {  \\  \" prop \\  \"  :     {  }  ,     < warning   descr =  \\  \" Property    \\  ' someStuff \\  '    is   not   allowed \\  \"  >  \\  \" someStuff \\  \"  :     2  0  <  / warning >  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAdditionalPropertiesDisabled"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\  \" type \\  \"  :     \\  \" object \\  \"  ,     \\  \" properties \\  \"  :     {  \\  \" a \\  \"  :     {  }  }  ,  \"     +     \"  \\  \" additionalProperties \\  \"  :     {  \\  \" type \\  \"  :     \\  \" string \\  \"  }  }  \"  ;", "doTest ( s ,     \"  {  \\  \" a \\  \"     :     1  8  ,     \\  \" b \\  \"  :     \\  \" wall \\  \"  ,     \\  \" c \\  \"  :     < warning   descr =  \\  \" Type   is   not   allowed .    Expected :    string .  \\  \"  >  1  1  <  / warning >  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAdditionalPropertiesSchema"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   List < String >    subSchemas    =    new   ArrayList <  >  (  )  ;", "subSchemas . add (  \"  {  \\  \" type \\  \"  :     \\  \" integer \\  \"  ,     \\  \" multipleOf \\  \"  :     2  }  \"  )  ;", "subSchemas . add (  \"  {  \\  \" enum \\  \"  :     [  1  ,  2  ,  3  ]  }  \"  )  ;", "@ Language (  \" JSON \"  )", "final   String   schema    =     . schema (  (  (  \"  {  \\  \" allOf \\  \"  :     [  \"     +     ( StringUtil . join ( subSchemas ,     \"  ,     \"  )  )  )     +     \"  ]  }  \"  )  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     < warning   descr =  \\  \" Is   not   multiple   of    2  \\  \"  >  1  <  / warning >  }  \"  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     < warning   descr =  \\  \" Value   should   be   one   of :     [  1  ,     2  ,     3  ]  \\  \"  >  4  <  / warning >  }  \"  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     2  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAllOf"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\  \" allOf \\  \"  :     [  {  \\  \" type \\  \"  :     \\  \" object \\  \"  ,     \\  \" properties \\  \"  :     {  \\  \" first \\  \"  :     {  }  }  }  ,  \"     +     \"     {  \\  \" properties \\  \"  :     {  \\  \" second \\  \"  :     {  \\  \" enum \\  \"  :     [  3  3  ,  4  4  ]  }  }  }  ]  ,     \\  \" additionalProperties \\  \"  :    false }  \"  ;", "doTest ( s ,     \"  {  \\  \" first \\  \"  :     {  }  ,     \\  \" second \\  \"  :     < warning   descr =  \\  \" Value   should   be   one   of :     [  3  3  ,     4  4  ]  \\  \"  > null <  / warning >  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" first \\  \"  :     {  }  ,     \\  \" second \\  \"  :     4  4  ,     < warning   descr =  \\  \" Property    \\  ' other \\  '    is   not   allowed \\  \"  >  \\  \" other \\  \"  :     1  5  <  / warning >  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" first \\  \"  :     {  }  ,     \\  \" second \\  \"  :     < warning   descr =  \\  \" Value   should   be   one   of :     [  3  3  ,     4  4  ]  \\  \"  >  1  2  <  / warning >  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAllOfProperties"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   List < String >    subSchemas    =    new   ArrayList <  >  (  )  ;", "subSchemas . add (  \"  {  \\  \" type \\  \"  :     \\  \" string \\  \"  ,     \\  \" enum \\  \"  :     [  \\  \" a \\  \"  ,     \\  \" b \\  \"  ]  }  \"  )  ;", "subSchemas . add (  \"  {  \\  \" type \\  \"  :     \\  \" string \\  \"  ,     \\  \" enum \\  \"  :     [  \\  \" a \\  \"  ,     \\  \" c \\  \"  ]  }  \"  )  ;", "@ Language (  \" JSON \"  )", "final   String   schema    =     . schema (  (  (  \"  {  \\  \" anyOf \\  \"  :     [  \"     +     ( StringUtil . join ( subSchemas ,     \"  ,     \"  )  )  )     +     \"  ]  }  \"  )  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     \\  \" b \\  \"  }  \"  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     \\  \" c \\  \"  }  \"  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     \\  \" a \\  \"  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAnyOf"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "String   schemaText    =    FileUtil . loadFile ( new   File (  (  ( getTestDataPath (  )  )     +     \"  / anyOnePropertySelectijson \"  )  )  )  ;", "String   inputText    =    FileUtil . loadFile ( new   File (  (  ( getTestDataPath (  )  )     +     \"  / anyOnePropertySelection . json \"  )  )  )  ;", "doTest ( schemaText ,    inputText )  ;", "}", "METHOD_END"], "methodName": ["testAnyOnePropertySelection"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "String   schemaText    =    FileUtil . loadFile ( new   File (  (  ( getTestDataPath (  )  )     +     \"  / anyOneTypeSelectijson \"  )  )  )  ;", "String   inputText    =    FileUtil . loadFile ( new   File (  (  ( getTestDataPath (  )  )     +     \"  / anyOneTypeSelection . json \"  )  )  )  ;", "doTest ( schemaText ,    inputText )  ;", "}", "METHOD_END"], "methodName": ["testAnyOneTypeSelection"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   schema    =     . schema (  (  \"  {  \\ n \"     +     (  (  (  (  \"        \\  \" type \\  \"  :     \\  \" array \\  \"  ,  \\ n \"     +     \"        \\  \" items \\  \"  :     {  \\ n \"  )     +     \"              \\  \" type \\  \"  :     \\  \" number \\  \"  ,     \\  \" minimum \\  \"  :     1  8  \"  )     +     \"        }  \\ n \"  )     +     \"  }  \"  )  )  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     [  1  0  1  ,     1  0  2  ]  }  \"  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     [  < warning   descr =  \\  \" Less   than   a   minimum    1  8  \\  \"  >  1  6  <  / warning >  ]  }  \"  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     [  < warning   descr =  \\  \" Type   is   not   allowed .    Expected :    number .  \\  \"  >  \\  \" test \\  \"  <  / warning >  ]  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testArray"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\ n \"     +     (  (  (  (  (  (  (  (  \"        \\  \" items \\  \"  :     [  \\ n \"     +     \"              {  \\ n \"  )     +     \"                    \\  \" type \\  \"  :     \\  \" integer \\  \"  \\ n \"  )     +     \"              }  ,  \\ n \"  )     +     \"              {  \\ n \"  )     +     \"                    \\  \"  $ ref \\  \"  :     \\  \"  #  / items /  0  \\  \"  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"        ]  \\ n \"  )     +     \"  }  \"  )  ;", "doTest ( s ,     \"  [  1  ,     2  ]  \"  )  ;", "doTest ( s ,     \"  [  1  ,     < warning >  \\  \" foo \\  \"  <  / warning >  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testArrayItemReference"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   schema    =     . schema (  \"  {  \\  \" type \\  \"  :     \\  \" array \\  \"  ,     \\  \" minItems \\  \"  :     2  ,     \\  \" maxItems \\  \"  :     3  }  \"  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     < warning   descr =  \\  \" Array   is   shorter   than    2  \\  \"  >  [  ]  <  / warning >  }  \"  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     [  1  ,  2  ]  }  \"  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     < warning   descr =  \\  \" Array   is   longer   than    3  \\  \"  >  [  1  ,  2  ,  3  ,  4  ]  <  / warning >  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testArrayLength"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  \"        \\  \" definitions \\  \"  :     {  \\ n \"     +     \"              \\  \" options \\  \"  :     {  \\ n \"  )     +     \"                    \\  \" type \\  \"  :     \\  \" array \\  \"  ,  \\ n \"  )     +     \"                    \\  \" items \\  \"  :     {  \\ n \"  )     +     \"                          \\  \" type \\  \"  :     \\  \" number \\  \"  \\ n \"  )     +     \"                    }  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"        }  ,  \\ n \"  )     +     \"        \\  \" items \\  \"  :  {  \\ n \"  )     +     \"                    \\  \"  $ ref \\  \"  :     \\  \"  #  / definitions / options / items \\  \"  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"        \\ n \"  )     +     \"  }  \"  )  ;", "doTest ( s ,     \"  [  2  ,     3     ,  4  ]  \"  )  ;", "doTest ( s ,     \"  [  2  ,     < warning >  \\  \"  3  \\  \"  <  / warning >  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testArrayReference"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "String   s    =     \"  {  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"        \\  \" myDefs \\  \"  :     {  \\ n \"     +     \"              \\  \" myArray \\  \"  :     [  \\ n \"  )     +     \"                    {  \\ n \"  )     +     \"                          \\  \" type \\  \"  :     \\  \" number \\  \"  \\ n \"  )     +     \"                    }  ,  \\ n \"  )     +     \"                    {  \\ n \"  )     +     \"                          \\  \" type \\  \"  :     \\  \" string \\  \"  \\ n \"  )     +     \"                    }  \\ n \"  )     +     \"              ]  \\ n \"  )     +     \"        }  ,  \\ n \"  )     +     \"        \\  \" type \\  \"  :     \\  \" array \\  \"  ,  \\ n \"  )     +     \"        \\  \" items \\  \"  :     [  \\ n \"  )     +     \"              {  \\ n \"  )     +     \"                    \\  \"  $ ref \\  \"  :     \\  \"  #  / myDefs / myArray /  0  \\  \"  \\ n \"  )     +     \"              }  ,  \\ n \"  )     +     \"              {  \\ n \"  )     +     \"                    \\  \"  $ ref \\  \"  :     \\  \"  #  / myDefs / myArray /  1  \\  \"  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"        ]  \\ n \"  )     +     \"  }  \"  )  ;", "doTest ( s ,     \"  [  1  ,     < warning >  2  <  / warning >  ]  \"  )  ;", "doTest ( s ,     \"  [  < warning >  \\  \"  1  \\  \"  <  / warning >  ,     < warning >  2  <  / warning >  ]  \"  )  ;", "doTest ( s ,     \"  [  < warning >  \\  \"  1  \\  \"  <  / warning >  ,     \\  \"  2  \\  \"  ]  \"  )  ;", "doTest ( s ,     \"  [  1  ,     \\  \"  2  \\  \"  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testArrayRefs"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   schema    =     . schema (  (  \"  {  \\ n \"     +     (  (  (  (  \"        \\  \" type \\  \"  :     \\  \" array \\  \"  ,  \\ n \"     +     \"        \\  \" items \\  \"  :     [  {  \\ n \"  )     +     \"              \\  \" type \\  \"  :     \\  \" number \\  \"  ,     \\  \" minimum \\  \"  :     1  8  \"  )     +     \"        }  ,     {  \\  \" type \\  \"     :     \\  \" string \\  \"  }  ]  \\ n \"  )     +     \"  }  \"  )  )  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     [  1  0  1  ,     < warning   descr =  \\  \" Type   is   not   allowed .    Expected :    string .  \\  \"  >  1  0  2  <  / warning >  ]  }  \"  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     [  1  0  1  ,     \\  \"  1  0  2  \\  \"  ]  }  \"  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     [  1  0  1  ,     \\  \"  1  0  2  \\  \"  ,     \\  \" additional \\  \"  ]  }  \"  )  ;", "@ Language (  \" JSON \"  )", "final   String   schema 2     =     . schema (  (  \"  {  \\ n \"     +     (  (  (  (  \"        \\  \" type \\  \"  :     \\  \" array \\  \"  ,  \\ n \"     +     \"        \\  \" items \\  \"  :     [  {  \\ n \"  )     +     \"              \\  \" type \\  \"  :     \\  \" number \\  \"  ,     \\  \" minimum \\  \"  :     1  8  \"  )     +     \"        }  ,     {  \\  \" type \\  \"     :     \\  \" string \\  \"  }  ]  ,  \\ n \"  )     +     \"  \\  \" additionalItems \\  \"  :    false }  \"  )  )  )  ;", "doTest ( schema 2  ,     \"  {  \\  \" prop \\  \"  :     [  1  0  1  ,     \\  \"  1  0  2  \\  \"  ,     < warning   descr =  \\  \" Additional   items   are   not   allowed \\  \"  >  \\  \" additional \\  \"  <  / warning >  ]  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testArrayTuples1"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   schema    =     . schema (  \"  {  \\  \" type \\  \"  :     \\  \" array \\  \"  ,     \\  \" uniqueItems \\  \"  :    true }  \"  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     [  1  ,  2  ]  }  \"  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     [  < warning   descr =  \\  \" Item   is   not   unique \\  \"  >  1  <  / warning >  ,  2  ,     \\  \" test \\  \"  ,     < warning   descr =  \\  \" Item   is   not   unique \\  \"  >  1  <  / warning >  ]  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testArrayUnique"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "String   s    =     \"  {  \\  \" properties \\  \"  :     {  \\  \" prop \\  \"  :     {  \\  \" type \\  \"  :     \\  \" string \\  \"  ,     \\  \" const \\  \"  :     \\  \" foo \\  \"  }  }  }  \"  ;", "doTest ( s ,     \"  {  \\  \" prop \\  \"  :     < warning >  \\  \" a \\  \"  <  / warning >  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" prop \\  \"  :     < warning >  5  <  / warning >  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" prop \\  \"  :     \\  \" foo \\  \"  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testConstV6"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "String   s    =     \"  {  \\  \" properties \\  \"  :     {  \\  \" prop \\  \"  :     {  \\  \" type \\  \"  :     \\  \" array \\  \"  ,     \\  \" contains \\  \"  :     {  \\  \" type \\  \"  :     \\  \" number \\  \"  }  }  }  }  \"  ;", "doTest ( s ,     \"  {  \\  \" prop \\  \"  :     < warning >  [  {  }  ,     \\  \" a \\  \"  ,    true ]  <  / warning >  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" prop \\  \"  :     [  {  }  ,     \\  \" a \\  \"  ,     1  ,    true ]  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testContainsV6"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "String   schemaText    =    FileUtil . loadFile ( new   File (  (  ( getTestDataPath (  )  )     +     \"  / cycledjson \"  )  )  )  ;", "String   inputText    =    FileUtil . loadFile ( new   File (  (  ( getTestDataPath (  )  )     +     \"  / testCycledjson \"  )  )  )  ;", "doTest ( schemaText ,    inputText )  ;", "}", "METHOD_END"], "methodName": ["testCycledSchema"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "String   schemaText    =    FileUtil . loadFile ( new   File (  (  ( getTestDataPath (  )  )     +     \"  / cycledWithRootRefInNotjson \"  )  )  )  ;", "String   inputText    =    FileUtil . loadFile ( new   File (  (  ( getTestDataPath (  )  )     +     \"  / testCycledWithRootRefInNotjson \"  )  )  )  ;", "doTest ( schemaText ,    inputText )  ;", "}", "METHOD_END"], "methodName": ["testCycledWithRootRefInNotSchema"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"  \\ n \"     +     \"        \\  \" properties \\  \"  :     {  \\ n \"  )     +     \"              \\  \" withFormat \\  \"  :     {  \\ n \"  )     +     \"                    \\  \" type \\  \"  :     \\  \" string \\  \"  ,  \"  )     +     \"                    \\  \" oneOf \\  \"  :     [  \\ n \"  )     +     \"                          {  \\ n \"  )     +     \"                                \\  \" format \\  \"  :  \\  \" hostname \\  \"  \\ n \"  )     +     \"                          }  ,  \\ n \"  )     +     \"                          {  \\ n \"  )     +     \"                                \\  \" format \\  \"  :     \\  \" ip 4  \\  \"  \\ n \"  )     +     \"                          }  \\ n \"  )     +     \"                    ]  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"        }  \\ n \"  )     +     \"  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" withFormat \\  \"  :     \\  \" localhost \\  \"  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testDoNotMarkOneOfThatDiffersWithFormat"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\  \" properties \\  \"  :     {  \\  \" prop \\  \"  :     {  \\  \" enum \\  \"  :     [  1  ,  2  ,  3  ,  \\  \"  1  8  \\  \"  ]  }  }  }  \"  ;", "doTest ( s ,     \"  {  \\  \" prop \\  \"  :     < warning   descr =  \\  \" Value   should   be   one   of :     [  1  ,     2  ,     3  ,     \\  \\  \\  \"  1  8  \\  \\  \\  \"  ]  \\  \"  >  1  8  <  / warning >  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" prop \\  \"  :     2  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" prop \\  \"  :     \\  \"  1  8  \\  \"  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" prop \\  \"  :     < warning   descr =  \\  \" Value   should   be   one   of :     [  1  ,     2  ,     3  ,     \\  \\  \\  \"  1  8  \\  \\  \\  \"  ]  \\  \"  >  \\  \"  2  \\  \"  <  / warning >  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEnum"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "String   exclusiveMi    =     \"  {  \\  \" properties \\  \"  :     {  \\  \" prop \\  \"  :     {  \\  \" exclusiveMinimum \\  \"  :     3  }  }  }  \"  ;", "doTest ( exclusiveMi ,     \"  {  \\  \" prop \\  \"  :     < warning >  2  <  / warning >  }  \"  )  ;", "doTest ( exclusiveMi ,     \"  {  \\  \" prop \\  \"  :     < warning >  3  <  / warning >  }  \"  )  ;", "doTest ( exclusiveMi ,     \"  {  \\  \" prop \\  \"  :     4  }  \"  )  ;", "@ Language (  \" JSON \"  )", "String   exclusiveMaxSchema    =     \"  {  \\  \" properties \\  \"  :     {  \\  \" prop \\  \"  :     {  \\  \" exclusiveMaximum \\  \"  :     3  }  }  }  \"  ;", "doTest ( exclusiveMaxSchema ,     \"  {  \\  \" prop \\  \"  :     2  }  \"  )  ;", "doTest ( exclusiveMaxSchema ,     \"  {  \\  \" prop \\  \"  :     < warning >  3  <  / warning >  }  \"  )  ;", "doTest ( exclusiveMaxSchema ,     \"  {  \\  \" prop \\  \"  :     < warning >  4  <  / warning >  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testExclusiveMinMaxV6"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "String   s    =     \"  {  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"        \\  \" if \\  \"  :     {  \\ n \"     +     \"              \\  \" properties \\  \"  :     {  \\ n \"  )     +     \"                    \\  \" a \\  \"  :     {  \\ n \"  )     +     \"                          \\  \" type \\  \"  :     \\  \" string \\  \"  \\ n \"  )     +     \"                    }  \\ n \"  )     +     \"              }  ,  \\ n \"  )     +     \"              \\  \" required \\  \"  :     [  \\  \" a \\  \"  ]  \\ n \"  )     +     \"        }  ,  \\ n \"  )     +     \"        \\  \" then \\  \"  :     {  \\ n \"  )     +     \"              \\  \" properties \\  \"  :     {  \\ n \"  )     +     \"                    \\  \" b \\  \"  :     {  \\ n \"  )     +     \"                          \\  \" type \\  \"  :     \\  \" number \\  \"  \\ n \"  )     +     \"                    }  \\ n \"  )     +     \"              }  ,  \\ n \"  )     +     \"              \\  \" required \\  \"  :     [  \\  \" b \\  \"  ]  \\ n \"  )     +     \"        }  ,  \\ n \"  )     +     \"        \\  \" else \\  \"  :     {  \\ n \"  )     +     \"              \\  \" properties \\  \"  :     {  \\ n \"  )     +     \"                    \\  \" c \\  \"  :     {  \\ n \"  )     +     \"                          \\  \" type \\  \"  :     \\  \" boolean \\  \"  \\ n \"  )     +     \"                    }  \\ n \"  )     +     \"              }  ,  \\ n \"  )     +     \"              \\  \" required \\  \"  :     [  \\  \" c \\  \"  ]  \\ n \"  )     +     \"        }  \\ n \"  )     +     \"  }  \"  )  ;", "doTest ( s ,     \"  < warning >  {  }  <  / warning >  \"  )  ;", "doTest ( s ,     \"  {  \\  \" c \\  \"  :     < warning >  5  <  / warning >  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" c \\  \"  :    true }  \"  )  ;", "doTest ( s ,     \"  < warning >  {  \\  \" a \\  \"  :     5  ,     \\  \" b \\  \"  :     5  }  <  / warning >  \"  )  ;", "doTest ( s ,     \"  {  \\  \" a \\  \"  :     5  ,     \\  \" c \\  \"  :     < warning >  5  <  / warning >  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" a \\  \"  :     5  ,     \\  \" c \\  \"  :    true }  \"  )  ;", "doTest ( s ,     \"  < warning >  {  \\  \" a \\  \"  :     \\  \" a \\  \"  ,     \\  \" c \\  \"  :    true }  <  / warning >  \"  )  ;", "doTest ( s ,     \"  {  \\  \" a \\  \"  :     \\  \" a \\  \"  ,     \\  \" b \\  \"  :     < warning > true <  / warning >  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" a \\  \"  :     \\  \" a \\  \"  ,     \\  \" b \\  \"  :     5  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testIfThenElseV7"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\  \" properties \\  \"  :     {  \\  \" prop \\  \"  :     {  \\  \" type \\  \"  :     \\  \" array \\  \"  ,     \\  \" items \\  \"  :     {  \\  \" enum \\  \"  :     [  1  ,  2  ,  3  ]  }  }  }  }  \"  ;", "doTest ( s ,     \"  {  \\  \" prop \\  \"  :     [  1  ,  3  ]  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" prop \\  \"  :     [  < warning   descr =  \\  \" Value   should   be   one   of :     [  1  ,     2  ,     3  ]  \\  \"  >  \\  \" out \\  \"  <  / warning >  ]  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testInnerObjectPropValueInArray"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   schema    =     . schema (  \"  {  \\  \" type \\  \"  :     \\  \" object \\  \"  ,     \\  \" properties \\  \"  :     {  \\  \" a \\  \"  :     {  }  ,     \\  \" b \\  \"  :     {  }  }  ,     \\  \" required \\  \"  :     [  \\  \" a \\  \"  ]  }  \"  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     {  \\  \" a \\  \"  :     1  1  }  }  \"  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     {  \\  \" a \\  \"  :     1  ,     \\  \" b \\  \"  :    true }  }  \"  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     < warning   descr =  \\  \" Missing   required   property    \\  ' a \\  '  \\  \"  >  {  \\  \" b \\  \"  :     \\  \" alarm \\  \"  }  <  / warning >  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testInnerRequired"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "String   sext    =    FileUtil . loadFile ( new   File (  (  ( getTestDataPath (  )  )     +     \"  / integerTypeWithMinMax _ sjson \"  )  )  )  ;", "String   inputText    =    FileUtil . loadFile ( new   File (  (  ( getTestDataPath (  )  )     +     \"  / integerTypeWithMinMax . json \"  )  )  )  ;", "doTest ( sext ,    inputText )  ;", "}", "METHOD_END"], "methodName": ["testIntegerTypeWithMinMax"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\ n \"     +     (  (  (  (  (  (  \"        \\  \" properties \\  \"  :     {  \\ n \"     +     \"              \\  \" array \\  \"  :  {  \\ n \"  )     +     \"                    \\  \" type \\  \"  :     \\  \" array \\  \"  ,  \\ n \"  )     +     \"                    \\  \" uniqueItems \\  \"  :    true \\ n \"  )     +     \"              }  \\ n \"  )     +     \"        }  \\ n \"  )     +     \"  }  \"  )  ;", "doTest ( s ,     (  \"  {  \\  \" array \\  \"  :     [  < warning   descr =  \\  \" Item   is   not   unique \\  \"  >  1  <  / warning >  ,  \"     +     (  (  (  (  (  (  \"  < warning   descr =  \\  \" Item   is   not   unique \\  \"  >  1  <  / warning >  ,  \"     +     \"  < warning   descr =  \\  \" Item   is   not   unique \\  \"  >  1  <  / warning >  ,  \"  )     +     \"  < warning   descr =  \\  \" Item   is   not   unique \\  \"  >  2  <  / warning >  ,  \"  )     +     \"  < warning   descr =  \\  \" Item   is   not   unique \\  \"  >  2  <  / warning >  ,  \"  )     +     \"  5  ,  \"  )     +     \"  < warning   descr =  \\  \" Item   is   not   unique \\  \"  >  3  <  / warning >  ,  \"  )     +     \"  < warning   descr =  \\  \" Item   is   not   unique \\  \"  >  3  <  / warning >  ]  }  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testManyDuplicatesInArray"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\ n \"     +     (  (  (  \"        \\  \" title \\  \"     :     \\  \" Match   anything \\  \"  ,  \\ n \"     +     \"        \\  \" description \\  \"     :     \\  \" This   is   a   s   that   matches   anything .  \\  \"  ,  \\ n \"  )     +     \"        \\  \" default \\  \"     :     \\  \" Default   value \\  \"  \\ n \"  )     +     \"  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" anything \\  \"  :     1  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testMetadataIsOk"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\  \" type \\  \"  :     \\  \" object \\  \"  ,     \\  \" minProperties \\  \"  :     1  ,     \\  \" maxProperties \\  \"  :     2  }  \"  ;", "doTest ( s ,     \"  < warning   descr =  \\  \" Number   of   properties   is   less   than    1  \\  \"  >  {  }  <  / warning >  \"  )  ;", "doTest ( s ,     \"  {  \\  \" a \\  \"  :     1  }  \"  )  ;", "doTest ( s ,     \"  < warning   descr =  \\  \" Number   of   properties   is   greater   than    2  \\  \"  >  {  \\  \" a \\  \"  :     1  ,     \\  \" b \\  \"  :     2  2  ,     \\  \" c \\  \"  :     3  3  }  <  / warning >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testMinMaxProperties"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "String   s    =     \"  {  \\  \" type \\  \"  :  \\  \" object \\  \"  ,  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"        \\  \" oneOf \\  \"  :     [  \\ n \"     +     \"              {  \\ n \"  )     +     \"                    \\  \" properties \\  \"  :     {  \\ n \"  )     +     \"                          \\  \" type \\  \"  :     {  \\ n \"  )     +     \"                                \\  \" type \\  \"  :     \\  \" string \\  \"  ,  \\ n \"  )     +     \"                                \\  \" oneOf \\  \"  :     [  \\ n \"  )     +     \"                                      {  \\ n \"  )     +     \"                                            \\  \" pattern \\  \"  :     \\  \"  ( good )  \\  \"  \\ n \"  )     +     \"                                      }  ,  \\ n \"  )     +     \"                                      {  \\ n \"  )     +     \"                                            \\  \" pattern \\  \"  :     \\  \"  ( ok )  \\  \"  \\ n \"  )     +     \"                                      }  \\ n \"  )     +     \"                                ]  \\ n \"  )     +     \"                          }  \\ n \"  )     +     \"                    }  \\ n \"  )     +     \"              }  ,  \\ n \"  )     +     \"              {  \\ n \"  )     +     \"                    \\  \" properties \\  \"  :     {  \\ n \"  )     +     \"                          \\  \" type \\  \"  :     {  \\ n \"  )     +     \"                                \\  \" type \\  \"  :     \\  \" string \\  \"  ,  \\ n \"  )     +     \"                                \\  \" pattern \\  \"  :     \\  \"  ^  ( fine )  \\  \"  \\ n \"  )     +     \"                          }  ,  \\ n \"  )     +     \"                          \\  \" extra \\  \"  :     {  \\ n \"  )     +     \"                                \\  \" type \\  \"  :     \\  \" string \\  \"  \\ n \"  )     +     \"                          }  \\ n \"  )     +     \"                    }  ,  \\ n \"  )     +     \"                    \\  \" required \\  \"  :     [  \\  \" type \\  \"  ,     \\  \" extra \\  \"  ]  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"        ]  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" type \\  \"  :     \\  \" good \\  \"  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" type \\  \"  :     \\  \" ok \\  \"  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" type \\  \"  :     < warning >  \\  \" doog \\  \"  <  / warning >  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" type \\  \"  :     < warning >  \\  \" ko \\  \"  <  / warning >  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNestedOneOf"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\  \" properties \\  \"  :     {  \\ n \"     +     (  \"              \\  \" not _ type \\  \"  :     {     \\  \" not \\  \"  :     {     \\  \" type \\  \"  :     \\  \" string \\  \"     }     }  \\ n \"     +     \"        }  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" not _ type \\  \"  :     < warning   descr =  \\  \" Validates   against    \\  ' not \\  '    s \\  \"  >  \\  \" wrong \\  \"  <  / warning >  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNotSchema"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\  \" properties \\  \"  :     {  \\ n \"     +     (  (  (  (  \"              \\  \" not _ type \\  \"  :     {  \\ n \"     +     \"                    \\  \" pattern \\  \"  :     \\  \"  ^  [ a - z ]  *  [  0  -  5  ]  *  $  \\  \"  ,  \\ n \"  )     +     \"                    \\  \" not \\  \"  :     {     \\  \" pattern \\  \"  :     \\  \"  ^  [ a - z ]  {  1  }  [  0  -  5  ]  $  \\  \"     }  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"        }  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" not _ type \\  \"  :     \\  \" va 4  \\  \"  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" not _ type \\  \"  :     < warning   descr =  \\  \" Validates   against    \\  ' not \\  '    s \\  \"  >  \\  \" a 4  \\  \"  <  / warning >  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" not _ type \\  \"  :     < warning   descr =  \\  \" String   is   violating   the   pattern :     \\  '  ^  [ a - z ]  *  [  0  -  5  ]  *  $  \\  '  \\  \"  >  \\  \"  4 a 4  \\  \"  <  / warning >  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNotSchemaCombinedWithNormal"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  (  \"  {     \\  \" properties \\  \"  :     {     \\  \" prop \\  \"  :     {  \\ n \"     +     (  (  (  (  \"        \\  \" type \\  \"  :     \\  \" number \\  \"  ,  \\ n \"     +     \"        \\  \" minimum \\  \"  :     0  ,  \\ n \"  )     +     \"        \\  \" maximum \\  \"  :     1  0  0  ,  \\ n \"  )     +     \"        \\  \" exclusiveMaximum \\  \"  :    true \\ n \"  )     +     \"  }  }  }  \"  )  )  ,     \"  {     \\  \" prop \\  \"  :     1  4  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNumberMinMax"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  {     \\  \" properties \\  \"  :     {     \\  \" prop \\  \"  :     {  \\  \" type \\  \"  :     \\  \" number \\  \"  ,     \\  \" multipleOf \\  \"  :     2  }  }  }  \"  ,     \"  {     \\  \" prop \\  \"  :     4  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNumberMultipleCorrect"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  {     \\  \" properties \\  \"  :     {     \\  \" prop \\  \"  :     {  \\  \" type \\  \"  :     \\  \" number \\  \"  ,     \\  \" multipleOf \\  \"  :     2  }  }  }  \"  ,     \"  {     \\  \" prop \\  \"  :     < warning   descr =  \\  \" Is   not   multiple   of    2  \\  \"  >  3  <  / warning >  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNumberMultipleWrong"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  \"        \\  \" properties \\  \"  :     {  \\ n \"     +     \"              \\  \" size \\  \"  :     {  \\ n \"  )     +     \"                    \\  \" type \\  \"  :     \\  \" object \\  \"  ,  \\ n \"  )     +     \"                    \\  \" minProperties \\  \"  :     2  ,  \\ n \"  )     +     \"                    \\  \" maxProperties \\  \"  :     3  ,  \\ n \"  )     +     \"                    \\  \" properties \\  \"  :     {  \\ n \"  )     +     \"                          \\  \" a \\  \"  :     {  \\ n \"  )     +     \"                                \\  \" type \\  \"  :     \\  \" boolean \\  \"  \\ n \"  )     +     \"                          }  \\ n \"  )     +     \"                    }  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"        }  \\ n \"  )     +     \"  }  \"  )  ;", "doTest ( s ,     (  \"  {  \\ n \"     +     (  (  (  (  (  \"        \\  \" size \\  \"  :     < warning   descr =  \\  \" Number   of   properties   is   greater   than    3  \\  \"  >  {  \\ n \"     +     \"              \\  \" a \\  \"  :     < warning   descr =  \\  \" Type   is   not   allowed .    Expected :    boolean .  \\  \"  >  1  <  / warning >  ,  \"  )     +     \"     \\  \" b \\  \"  :  3  ,     \\  \" c \\  \"  :     4  ,     \"  )     +     \"  \\  \" a \\  \"  :     < warning   descr =  \\  \" Type   is   not   allowed .    Expected :    boolean .  \\  \"  >  5  <  / warning >  \\ n \"  )     +     \"        }  <  / warning >  \\ n \"  )     +     \"  }  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testNumberOfSameNamedPropertiesCorrectlyChecked"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   innerTypeSchema    =     \"  {  \\  \" properties \\  \"  :     {  \\  \" only \\  \"  :     {  }  }  ,     \\  \" additionalProperties \\  \"  :    false }  \"  ;", "@ Language (  \" JSON \"  )", "final   String   schema    =     . schema (  (  (  (  (  \"  {  \\  \" type \\  \"  :     \\  \" array \\  \"  ,     \\  \" items \\  \"  :     {  \\  \" type \\  \"  :     \\  \" object \\  \"  ,  \"     +     (  \"  \\  \" properties \\  \"  :     {  \"     +     \"  \\  \" innerType \\  \"  :  \"  )  )     +    innerTypeSchema )     +     \"  }  ,     \\  \" additionalProperties \\  \"  :    false \"  )     +     \"  }  }  \"  )  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     [  {  \\  \" innerType \\  \"  :  {  \\  \" only \\  \"  :    true ,     < warning   descr =  \\  \" Property    \\  ' hidden \\  '    is   not   allowed \\  \"  >  \\  \" hidden \\  \"  :    false <  / warning >  }  }  ]  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testObjectDeeperInArray"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   schema    =     . schema (  (  \"  {  \\  \" type \\  \"  :     \\  \" array \\  \"  ,     \\  \" items \\  \"  :     {  \\  \" type \\  \"  :     \\  \" object \\  \"  ,  \"     +     (  (  (  \"  \\  \" properties \\  \"  :     {  \"     +     \"  \\  \" innerType \\  \"  :  {  }  ,     \\  \" innerValue \\  \"  :  {  }  \"  )     +     \"  }  ,     \\  \" additionalProperties \\  \"  :    false \"  )     +     \"  }  }  \"  )  )  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     [  {  \\  \" innerType \\  \"  :  {  }  ,     < warning   descr =  \\  \" Property    \\  ' alien \\  '    is   not   allowed \\  \"  >  \\  \" alien \\  \"  :  {  }  <  / warning >  }  ]  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testObjectInArray"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   List < String >    subSchemas    =    new   ArrayList <  >  (  )  ;", "subSchemas . add (  \"  {  \\  \" type \\  \"  :     \\  \" string \\  \"  }  \"  )  ;", "subSchemas . add (  \"  {  \\  \" type \\  \"  :     \\  \" boolean \\  \"  }  \"  )  ;", "@ Language (  \" JSON \"  )", "final   String   schema    =     . schema (  (  (  \"  {  \\  \" oneOf \\  \"  :     [  \"     +     ( StringUtil . join ( subSchemas ,     \"  ,     \"  )  )  )     +     \"  ]  }  \"  )  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     \\  \" abc \\  \"  }  \"  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :    true }  \"  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     < warning   descr =  \\  \" Type   is   not   allowed .    Expected   one   of :    boolean ,    string .  \\  \"  >  1  1  <  / warning >  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testOneOf"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "String   schemaText    =    FileUtil . loadFile ( new   File (  (  ( getTestDataPath (  )  )     +     \"  / oneOfjson \"  )  )  )  ;", "String   inputText    =    FileUtil . loadFile ( new   File (  (  ( getTestDataPath (  )  )     +     \"  / oneOf 1  . json \"  )  )  )  ;", "doTest ( schemaText ,    inputText )  ;", "}", "METHOD_END"], "methodName": ["testOneOf1"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "String   schemaText    =    FileUtil . loadFile ( new   File (  (  ( getTestDataPath (  )  )     +     \"  / oneOfjson \"  )  )  )  ;", "String   inputText    =    FileUtil . loadFile ( new   File (  (  ( getTestDataPath (  )  )     +     \"  / oneOf 2  . json \"  )  )  )  ;", "doTest ( schemaText ,    inputText )  ;", "}", "METHOD_END"], "methodName": ["testOneOf2"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   List < String >    subSchemas    =    new   ArrayList <  >  (  )  ;", "subSchemas . add (  \"  {  \\  \" type \\  \"  :     \\  \" string \\  \"  ,     \\  \" enum \\  \"  :     [  \\  \" a \\  \"  ,     \\  \" b \\  \"  ]  }  \"  )  ;", "subSchemas . add (  \"  {  \\  \" type \\  \"  :     \\  \" string \\  \"  ,     \\  \" enum \\  \"  :     [  \\  \" a \\  \"  ,     \\  \" c \\  \"  ]  }  \"  )  ;", "@ Language (  \" JSON \"  )", "final   String   schema    =     . schema (  (  (  \"  {  \\  \" oneOf \\  \"  :     [  \"     +     ( StringUtil . join ( subSchemas ,     \"  ,     \"  )  )  )     +     \"  ]  }  \"  )  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     \\  \" b \\  \"  }  \"  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     \\  \" c \\  \"  }  \"  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     < warning   descr =  \\  \" Validates   to   more   than   one   variant \\  \"  >  \\  \" a \\  \"  <  / warning >  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testOneOfForTwoMatches"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   List < String >    subSchemas    =    new   ArrayList <  >  (  )  ;", "subSchemas . add (  (  \"  {  \\  \" type \\  \"  :     \\  \" string \\  \"  ,  \\ n \"     +     (  (  \"                                \\  \" enum \\  \"  :     [  \\ n \"     +     \"                                      \\  \" off \\  \"  ,     \\  \" warn \\  \"  ,     \\  \" error \\  \"  \\ n \"  )     +     \"                                ]  }  \"  )  )  )  ;", "subSchemas . add (  \"  {  \\  \" type \\  \"  :     \\  \" integer \\  \"  }  \"  )  ;", "@ Language (  \" JSON \"  )", "final   String   schema    =     . schema (  (  (  \"  {  \\  \" oneOf \\  \"  :     [  \"     +     ( StringUtil . join ( subSchemas ,     \"  ,     \"  )  )  )     +     \"  ]  }  \"  )  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     \\  \" off \\  \"  }  \"  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     1  2  }  \"  )  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     < warning   descr =  \\  \" Value   should   be   one   of :     [  \\  \\  \\  \" off \\  \\  \\  \"  ,     \\  \\  \\  \" warn \\  \\  \\  \"  ,     \\  \\  \\  \" error \\  \\  \\  \"  ]  \\  \"  >  \\  \" wrong \\  \"  <  / warning >  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testOneOfSelectError"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "String   schemaText    =    FileUtil . loadFile ( new   File (  (  ( getTestDataPath (  )  )     +     \"  / oneOfjson \"  )  )  )  ;", "String   inputText    =    FileUtil . loadFile ( new   File (  (  ( getTestDataPath (  )  )     +     \"  / oneOfWithEmptyPropertyValue . json \"  )  )  )  ;", "doTest ( schemaText ,    inputText )  ;", "}", "METHOD_END"], "methodName": ["testOneOfWithEmptyPropertyValue"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\ n \"     +     (  (  (  (  (  \"        \\  \" properties \\  \"  :     {  \\ n \"     +     \"              \\  \" withPattern \\  \"  :     {  \\ n \"  )     +     \"                    \\  \" pattern \\  \"  :     \\  \" p [  0  -  9  ]  \\  \"  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"        }  \\ n \"  )     +     \"  }  \"  )  ;", "final   String   correctText    =     \"  {  \\ n \"     +     (  \"        \\  \" withPattern \\  \"  :     \\  \" p 1  \\  \"  \\ n \"     +     \"  }  \"  )  ;", "final   String   wrongText    =     \"  {  \\ n \"     +     (  \"        \\  \" withPattern \\  \"  :     < warning   descr =  \\  \" String   is   violating   the   pattern :     \\  ' p [  0  -  9  ]  \\  '  \\  \"  >  \\  \" wrong \\  \"  <  / warning >  \\ n \"     +     \"  }  \"  )  ;", "doTest ( s ,    correctText )  ;", "doTest ( s ,    wrongText )  ;", "}", "METHOD_END"], "methodName": ["testPatternForPropertyValue"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  \"        \\  \" type \\  \"  :     \\  \" object \\  \"  ,  \\ n \"     +     \"        \\  \" additionalProperties \\  \"  :    false ,  \\ n \"  )     +     \"        \\  \" patternProperties \\  \"  :     {  \\ n \"  )     +     \"              \\  \" p [  0  -  9  ]  \\  \"  :     {  \\ n \"  )     +     \"                    \\  \" type \\  \"  :     \\  \" string \\  \"  \\ n \"  )     +     \"              }  ,  \\ n \"  )     +     \"              \\  \" a [  0  -  9  ]  \\  \"  :     {  \\ n \"  )     +     \"                    \\  \" enum \\  \"  :     [  \\  \" auto !  \\  \"  ]  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"        }  \\ n \"  )     +     \"  }  \"  )  ;", "doTest ( s ,     (  \"  {  \\ n \"     +     (  (  (  (  \"        \\  \" p 1  \\  \"  :     < warning   descr =  \\  \" Type   is   not   allowed .    Expected :    string .  \\  \"  >  1  <  / warning >  ,  \\ n \"     +     \"        \\  \" p 2  \\  \"  :     \\  \"  3  \\  \"  ,  \\ n \"  )     +     \"        \\  \" a 2  \\  \"  :     \\  \" auto !  \\  \"  ,  \\ n \"  )     +     \"        \\  \" a 1  \\  \"  :     < warning   descr =  \\  \" Value   should   be   one   of :     [  \\  \\  \\  \" auto !  \\  \\  \\  \"  ]  \\  \"  >  \\  \" moto !  \\  \"  <  / warning >  \\ n \"  )     +     \"  }  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testPatternPropertiesFromIssue"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  \"        \\  \" patternProperties \\  \"  :     {  \\ n \"     +     \"              \\  \"  ^ A \\  \"     :     {  \\ n \"  )     +     \"                    \\  \" type \\  \"  :     \\  \" number \\  \"  \\ n \"  )     +     \"              }  ,  \\ n \"  )     +     \"              \\  \" B \\  \"  :     {  \\ n \"  )     +     \"                    \\  \" type \\  \"  :     \\  \" boolean \\  \"  \\ n \"  )     +     \"              }  ,  \\ n \"  )     +     \"              \\  \" C \\  \"  :     {  \\ n \"  )     +     \"                    \\  \" enum \\  \"  :     [  \\  \" test \\  \"  ,     \\  \" em \\  \"  ]  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"        }  \\ n \"  )     +     \"  }  \"  )  ;", "doTest ( s ,     (  \"  {  \\ n \"     +     (  (  (  (  (  \"        \\  \" Abezjana \\  \"  :     2  ,  \\ n \"     +     \"        \\  \" Auto \\  \"  :     < warning   descr =  \\  \" Type   is   not   allowed .    Expected :    number .  \\  \"  >  \\  \" no \\  \"  <  / warning >  ,  \\ n \"  )     +     \"        \\  \" BAe \\  \"  :     < warning   descr =  \\  \" Type   is   not   allowed .    Expected :    boolean .  \\  \"  >  2  2  <  / warning >  ,  \\ n \"  )     +     \"        \\  \" Boloto \\  \"  :     < warning   descr =  \\  \" Type   is   not   allowed .    Expected :    boolean .  \\  \"  >  2  <  / warning >  ,  \\ n \"  )     +     \"        \\  \" Cyan \\  \"  :     < warning   descr =  \\  \" Value   should   be   one   of :     [  \\  \\  \\  \" test \\  \\  \\  \"  ,     \\  \\  \\  \" em \\  \\  \\  \"  ]  \\  \"  >  \\  \" me \\  \"  <  / warning >  \\ n \"  )     +     \"  }  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testPatternPropertiesHighlighting"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\ n \"     +     (  (  (  (  (  \"        \\  \" properties \\  \"  :     {  \\ n \"     +     \"              \\  \" withPattern \\  \"  :     {  \\ n \"  )     +     \"                    \\  \" pattern \\  \"  :     \\  \"  ^  \\  \\  \\  \\ d {  4  }  \\  \\  \\  \\  -  (  0  ?  [  1  -  9  ]  |  1  [  0  1  2  ]  )  \\  \\  \\  \\  -  (  0  ?  [  1  -  9  ]  |  [  1  2  ]  [  0  -  9  ]  |  3  [  0  1  ]  )  $  \\  \"  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"        }  \\ n \"  )     +     \"  }  \"  )  ;", "@ Language (  \" JSON \"  )", "final   String   correctText    =     \"  {  \\ n \"     +     (  \"        \\  \" withPattern \\  \"  :     \\  \"  1  2  3  4  -  1  1  -  1  1  \\  \"  \\ n \"     +     \"  }  \"  )  ;", "final   String   wrongText    =     \"  {  \\ n \"     +     (  \"        \\  \" withPattern \\  \"  :     < warning   descr =  \\  \" String   is   violating   the   pattern :     \\  '  ^  \\  \\ d {  4  }  \\  \\  -  (  0  ?  [  1  -  9  ]  |  1  [  0  1  2  ]  )  \\  \\  -  (  0  ?  [  1  -  9  ]  |  [  1  2  ]  [  0  -  9  ]  |  3  [  0  1  ]  )  $  \\  '  \\  \"  >  \\  \" wrong \\  \"  <  / warning >  \\ n \"     +     \"  }  \"  )  ;", "doTest ( s ,    correctText )  ;", "doTest ( s ,    wrongText )  ;", "}", "METHOD_END"], "methodName": ["testPatternWithSpecialEscapedSymbols"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  {  \\  \" propertyNames \\  \"  :     {  \\  \" minLength \\  \"  :     7  }  }  \"  ,     \"  {  < warning >  \\  \" prop \\  \"  <  / warning >  :     2  }  \"  )  ;", "doTest (  \"  {  \\  \" properties \\  \"  :     {  \\  \" prop \\  \"  :     {  \\  \" propertyNames \\  \"  :     {  \\  \" minLength \\  \"  :     7  }  }  }  }  \"  ,     \"  {  \\  \" prop \\  \"  :     {  < warning >  \\  \" qq \\  \"  <  / warning >  :     7  }  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyNamesV6"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\ n \"     +     (  (  (  (  (  \"        \\  \" properties \\  \"  :     {  \\ n \"     +     \"              \\  \" withPattern \\  \"  :     {  \\ n \"  )     +     \"                    \\  \" pattern \\  \"  :     \\  \"  ^  [  ]  $  \\  \"  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"        }  \\ n \"  )     +     \"  }  \"  )  ;", "final   String   text    =     \"  {  \\  \" withPattern \\  \"  :  \"     +     \"     < warning   descr =  \\  \" Can   not   check   string   by   pattern   because   of   error :    Unclosed   character   class   near   index    3  \\ n ^  [  ]  $  \\ n          ^  \\  \"  >  \\  \"  (  1  2  4  )  5  5  5  -  4  2  1  6  \\  \"  <  / warning >  }  \"  ;", "doTest ( s ,    text )  ;", "}", "METHOD_END"], "methodName": ["testPropertyValueAlsoHighlightedIfPatternIsInvalid"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\  \" type \\  \"  :     \\  \" object \\  \"  ,     \\  \" properties \\  \"  :     {  \\  \" a \\  \"  :     {  }  ,     \\  \" b \\  \"  :     {  }  }  ,     \\  \" required \\  \"  :     [  \\  \" a \\  \"  ]  }  \"  ;", "doTest ( s ,     \"  {  \\  \" a \\  \"  :     1  1  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" a \\  \"  :     1  ,     \\  \" b \\  \"  :    true }  \"  )  ;", "doTest ( s ,     \"  < warning   descr =  \\  \" Missing   required   property    \\  ' a \\  '  \\  \"  >  {  \\  \" b \\  \"  :     \\  \" alarm \\  \"  }  <  / warning >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRequiredField"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "doTest ( JsonSchemaHighlightingTest . rootObjectRedefinedSchema (  )  ,     (  \"  {  < warning   descr =  \\  \" Property    \\  ' a \\  '    is   not   allowed \\  \"  >  \\  \" a \\  \"  :    true <  / warning >  ,  \"     +     \"  \\  \" r 1  \\  \"  :     \\  \" allowed !  \\  \"  }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testRootObjectRedefinedAdditionalPropertiesForbidden"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\ n \"     +     (  (  (  (  (  \"        \\  \" items \\  \"  :     [  \\ n \"     +     \"              {  \\ n \"  )     +     \"                    \\  \"  $ ref \\  \"  :     \\  \"  #  / items /  0  \\  \"  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"        ]  \\ n \"  )     +     \"  }  \"  )  ;", "doTest ( s ,     \"  [  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSelfArrayReferenceDoesNotThrowSOE"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\  \" properties \\  \"  :     {  \\  \" prop \\  \"  :     {  \\  \" type \\  \"  :     \\  \" string \\  \"  ,     \\  \" minLength \\  \"  :     2  ,     \\  \" maxLength \\  \"  :     3  }  }  }  \"  ;", "doTest ( s ,     \"  {  \\  \" prop \\  \"  :     < warning   descr =  \\  \" String   is   shorter   than    2  \\  \"  >  \\  \" s \\  \"  <  / warning >  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" prop \\  \"  :     \\  \" sh \\  \"  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" prop \\  \"  :     \\  \" sho \\  \"  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" prop \\  \"  :     < warning   descr =  \\  \" String   is   longer   than    3  \\  \"  >  \\  \" shor \\  \"  <  / warning >  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleString"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\ n \"     +     (  (  (  (  \"        \\  \" type \\  \"  :     \\  \" array \\  \"  ,  \\ n \"     +     \"        \\  \" items \\  \"  :     {  \\ n \"  )     +     \"              \\  \" type \\  \"  :     \\  \" number \\  \"  ,     \\  \" minimum \\  \"  :     1  8  \"  )     +     \"        }  \\ n \"  )     +     \"  }  \"  )  ;", "doTest ( s ,     \"  [  1  0  1  ,     1  0  2  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTopLevelArray"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\ n \"     +     (  (  (  (  \"        \\  \" type \\  \"  :     \\  \" array \\  \"  ,  \\ n \"     +     \"        \\  \" items \\  \"  :     {  \\ n \"  )     +     \"              \\  \" type \\  \"  :     \\  \" object \\  \"  ,     \\  \" properties \\  \"  :     {  \\  \" a \\  \"  :     {  \\  \" type \\  \"  :     \\  \" number \\  \"  }  }  \"  )     +     \"        }  \\ n \"  )     +     \"  }  \"  )  ;", "doTest ( s ,     \"  [  {  \\  \" a \\  \"  :     < warning   descr =  \\  \" Type   is   not   allowed .    Expected :    number .  \\  \"  > true <  / warning >  }  ]  \"  )  ;", "doTest ( s ,     \"  [  {  \\  \" a \\  \"  :     1  8  }  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTopLevelObjectArray"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\  \" definitions \\  \"  :     {  \\  \" address \\  \"  :     {  \\  \" type \\  \"  :     \\  \" object \\  \"  ,     \\  \" properties \\  \"  :     {  \\  \" street \\  \"  :     {  \\  \" type \\  \"  :     \\  \" string \\  \"  }  ,  \"     +     (  (  (  (  \"  \\  \" house \\  \"  :     {  \\  \" type \\  \"  :     \\  \" integer \\  \"  }  }  }  }  ,  \"     +     \"  \\  \" type \\  \"  :     \\  \" object \\  \"  ,     \\  \" properties \\  \"  :     {  \"  )     +     \"  \\  \" home \\  \"  :     {  \\  \"  $ ref \\  \"  :     \\  \"  #  / definitions / address \\  \"  }  ,     \"  )     +     \"  \\  \" office \\  \"  :     {  \\  \"  $ ref \\  \"  :     \\  \"  #  / definitions / address \\  \"  }  \"  )     +     \"  }  }  \"  )  ;", "doTest ( s ,     \"  {  \\  \" home \\  \"  :     {  \\  \" street \\  \"  :     \\  \" Broadway \\  \"  ,     \\  \" house \\  \"  :     1  1  }  }  \"  )  ;", "doTest ( s ,     (  \"  {  \\  \" home \\  \"  :     {  \\  \" street \\  \"  :     \\  \" Broadway \\  \"  ,     \\  \" house \\  \"  :     < warning   descr =  \\  \" Type   is   not   allowed .    Expected :    integer .  \\  \"  >  \\  \" unknown \\  \"  <  / warning >  }  ,  \"     +     \"  \\  \" office \\  \"  :     {  \\  \" street \\  \"  :     < warning   descr =  \\  \" Type   is   not   allowed .    Expected :    string .  \\  \"  >  5  <  / warning >  }  }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testUseDefinition"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "final   String   s    =     \"  {  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"        \\  \" definitions \\  \"  :     {  \\ n \"     +     \"              \\  \" options \\  \"  :     {  \\ n \"  )     +     \"                    \\  \" type \\  \"  :     \\  \" array \\  \"  ,  \\ n \"  )     +     \"                    \\  \" items \\  \"  :     {  \\ n \"  )     +     \"                          \\  \" type \\  \"  :     \\  \" number \\  \"  \\ n \"  )     +     \"                    }  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"        }  ,  \\ n \"  )     +     \"        \\  \" items \\  \"  :     [  \\ n \"  )     +     \"              {  \\ n \"  )     +     \"                    \\  \" type \\  \"  :     \\  \" boolean \\  \"  \\ n \"  )     +     \"              }  ,  \\ n \"  )     +     \"              {  \\ n \"  )     +     \"                    \\  \" type \\  \"  :     \\  \" boolean \\  \"  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"        ]  ,  \\ n \"  )     +     \"        \\  \" additionalItems \\  \"  :     {  \\ n \"  )     +     \"              \\  \"  $ ref \\  \"  :     \\  \"  #  / definitions / options / items \\  \"  \\ n \"  )     +     \"        }  \\ n \"  )     +     \"  }  \"  )  ;", "doTest ( s ,     \"  [ true ,    true ]  \"  )  ;", "doTest ( s ,     \"  [ true ,    true ,     1  ,     2  ,     3  ]  \"  )  ;", "doTest ( s ,     \"  [ true ,    true ,     1  ,     < warning >  \\  \"  2  \\  \"  <  / warning >  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testValidateAdditionalItems"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "@ Language (  \" JSON \"  )", "String   schemaText    =    FileUtil . loadFile ( new   File (  (  ( getTestDataPath (  )  )     +     \"  / cycledWithRootRefjson \"  )  )  )  ;", "String   inputText    =    FileUtil . loadFile ( new   File (  (  ( getTestDataPath (  )  )     +     \"  / testCycledWithRootRefjson \"  )  )  )  ;", "doTest ( schemaText ,    inputText )  ;", "}", "METHOD_END"], "methodName": ["testWithRootRefCycledSchema"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   String   subSchema 1     =     \"  {  \\  \" enum \\  \"  :     [  1  ,  2  ,  3  ,  4  ,  5  ]  }  \"  ;", "final   String   subSchema 2     =     \"  {  \\  \" type \\  \"  :     \\  \" array \\  \"  ,     \\  \" items \\  \"  :     {  \\  \" properties \\  \"  :     {  \\  \" kilo \\  \"  :     {  }  }  ,     \\  \" additionalProperties \\  \"  :    false }  }  \"  ;", "@ Language (  \" JSON \"  )", "final   String   schema    =     (  (  (  \"  {  \\  \" properties \\  \"  :     {  \\  \" prop \\  \"  :     {  \\  \" oneOf \\  \"  :     [  \"     +    subSchema 1  )     +     \"  ,     \"  )     +    subSchema 2  )     +     \"  ]  }  }  }  \"  ;", "doTest ( schema ,     \"  {  \\  \" prop \\  \"  :     [  {  < warning   descr =  \\  \" Property    \\  ' foxtrot \\  '    is   not   allowed \\  \"  >  \\  \" foxtrot \\  \"  :     1  5  <  / warning >  ,     \\  \" kilo \\  \"  :     2  0  }  ]  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testWithWaySelection"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaHighlightingTest"}, {"methodBody": ["METHOD_START", "{", "final   JsonSchemaConfigurable   configurable    =    new   JsonSchemaConfigurable ( myProject ,     \"  \"  ,    info ,    myTreeUpdater ,    true )  ;", "configurable . setError ( myError )  ;", "final   MyNode   node    =    new   MyNode ( configurable ,    info . isApplicationLevel (  )  )  ;", "addNode ( node ,    myRoot )  ;", "selectNodeInTree ( node ,    true )  ;", "}", "METHOD_END"], "methodName": ["addCreatedMappings"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsConfigurable"}, {"methodBody": ["METHOD_START", "{", "addCreatedMappings ( new   UserDefinedJsonSchemaConfiguration ( createUniqueName (  \" new   schema \"  )  ,    JsonSchemaVersion . SCHEMA _  4  ,     \"  \"  ,    false ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["addProjectSchema"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsConfigurable"}, {"methodBody": ["METHOD_START", "{", "max    =     -  1  ;", "Enumeration   children    =    myRoot . children (  )  ;", "while    ( children . hasMoreElements (  )  )     {", "Object   element    =    children . nextElement (  )  ;", "if    (  !  ( element   instanceof   MyNode )  )", "continue ;", "String   displayName    =     (  ( MyNode )     ( element )  )  . getDisplayName (  )  ;", "if    ( displayName . startsWith ( s )  )     {", "String   lastPart    =    displayName . substring ( s . length (  )  )  . trim (  )  ;", "if    (  (  ( lastPart . length (  )  )     =  =     0  )     &  &     ( max    =  =     (  -  1  )  )  )     {", "max    =     1  ;", "continue ;", "}", "i    =     . tryParseInt ( lastPart )  ;", "if    ( i    =  =     (  -  1  )  )", "continue ;", "max    =     ( i    >    max )     ?    i    :    max ;", "}", "}", "return   max    =  =     (  -  1  )     ?    s    :     ( s    +     \"     \"  )     +     ( max    +     1  )  ;", "}", "METHOD_END"], "methodName": ["createUniqueName"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsConfigurable"}, {"methodBody": ["METHOD_START", "{", "myRoot . removeAllChildren (  )  ;", "if    ( myProject . isDefault (  )  )", "return ;", "final   List < UserDefinedJsonSchemaConfiguration >    list    =    getStoredList (  )  ;", "for    ( UserDefinedJsonSchemaConfiguration   info    :    list )     {", "String   pathToSchema    =    info . getRelativePathToSchema (  )  ;", "final   JsonSchema   configurable    =    new   JsonSchema ( myProject ,     ( JsonSchema . isHttpPath ( pathToSchema )     ?    pathToSchema    :    new   File ( myProject . getBasePath (  )  ,    pathToSchema )  . getPath (  )  )  ,    info ,    myTreeUpdater ,    false )  ;", "configurable . setError ( myError )  ;", "myRoot . add ( new   MyNode ( configurable ,    info . isApplicationLevel (  )  )  )  ;", "}", "(  ( DefaultTreeModel )     ( myTree . getModel (  )  )  )  . reload ( myRoot )  ;", "if    ( myRoot . children (  )  . hasMoreElements (  )  )     {", "myTree . addSelectionRow (  0  )  ;", "}", "}", "METHOD_END"], "methodName": ["fillTree"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsConfigurable"}, {"methodBody": ["METHOD_START", "{", "return    (  ( JsonSchemaConfigurable )     ( node . getConfigurable (  )  )  )  . getSchema (  )  ;", "}", "METHOD_END"], "methodName": ["getSchemaInfo"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsConfigurable"}, {"methodBody": ["METHOD_START", "{", "final   List < UserDefinedJsonSchemaConfiguration >    list    =    new   ArrayList <  >  (  )  ;", "final   Map < String ,    UserDefinedJsonSchemaConfiguration >    projectState    =    JsonSchemaMappingsProjectConfiguration . getInstance ( myProject )  . getStateMap (  )  ;", "if    ( projectState    !  =    null )     {", "list . addAll ( projectState . values (  )  )  ;", "}", "Collections . sort ( list ,     . COMPARATOR )  ;", "return   list ;", "}", "METHOD_END"], "methodName": ["getStoredList"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsConfigurable"}, {"methodBody": ["METHOD_START", "{", "final   List < UserDefinedJsonSchemaConfiguration >    uiList    =    new   ArrayList <  >  (  )  ;", "final   Enumeration   children    =    myRoot . children (  )  ;", "while    ( children . hasMoreElements (  )  )     {", "final   MyNode   node    =     (  ( MyNode )     ( children . nextElement (  )  )  )  ;", "if    ( applyChildren )     {", "node . getConfigurable (  )  . apply (  )  ;", "uiList . add (  . getSchemaInfo ( node )  )  ;", "} else    {", "uiList . add (  (  ( JsonSchemaConfigurable )     ( node . getConfigurable (  )  )  )  . getUiSchema (  )  )  ;", "}", "}", "Collections . sort ( uiList ,     . COMPARATOR )  ;", "return   uiList ;", "}", "METHOD_END"], "methodName": ["getUiList"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsConfigurable"}, {"methodBody": ["METHOD_START", "{", "try    {", "rurn   Integer . parseInt ( s )  ;", "}    catch    ( NumberFormatException   e )     {", "rurn    -  1  ;", "}", "}", "METHOD_END"], "methodName": ["tryParseInt"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsConfigurable"}, {"methodBody": ["METHOD_START", "{", "final   MultiMap < String ,    UserDefinedJsonSchemaConfiguration . Item >    patternsMap    =    new   MultiMap (  )  ;", "final   StringBuilder   sb    =    new   StringBuilder (  )  ;", "final   List < UserDefinedJsonSchemaConfiguration >    list ;", "try    {", "list    =    getUiList ( false )  ;", "}    catch    ( ConfigurationException   e )     {", "return ;", "}", "for    ( UserDefinedJsonSchemaConfiguration   info    :    list )     {", "final   JsonSchemaPatternComparator   comparator    =    new   JsonSchemaPatternComparator ( myProject )  ;", "final   List < UserDefinedJsonSchemaConfiguration . Item >    patterns    =    info . getPatterns (  )  ;", "for    ( UserDefinedJsonSchemaConfiguration . Item   pattern    :    patterns )     {", "for    ( Map . Entry < String ,    Collection < UserDefinedJsonSchemaConfiguration . Item >  >    entry    :    patternsMap . entrySet (  )  )     {", "for    ( UserDefinedJsonSchemaConfiguration . Item   item    :    entry . getValue (  )  )     {", "final   ThreeState   similar    =    comparator . isSimilar ( pattern ,    item )  ;", "if    ( NO . equals ( similar )  )", "continue ;", "if    (  ( sb . length (  )  )     >     0  )", "sb . append (  '  \\ n '  )  ;", "sb . append (  \"  '  \"  )  . append ( pattern . getPresentation (  )  )  . append (  \"  '    for   schema    '  \"  )  . append ( info . getName (  )  )  . append (  \"  '    and    '  \"  )  . append ( item . getPresentation (  )  )  . append (  \"  '    for   schema    '  \"  )  . append ( entry . getKey (  )  )  . append (  \"  '  \"  )  ;", "}", "}", "}", "patternsMap . put ( info . getName (  )  ,    patterns )  ;", "}", "if    (  ( sb . length (  )  )     >     0  )     {", "myError    =     \" Conflicting   mappings :  \\ n \"     +     ( sb . toString (  )  )  ;", "} else    {", "myError    =    null ;", "}", "final   Enumeration   children    =    myRoot . children (  )  ;", "while    ( children . hasMoreElements (  )  )     {", "Object   o    =    children . nextElement (  )  ;", "if    (  ( o   instanceof   MyNode )     &  &     (  (  (  ( MyNode )     ( o )  )  . get (  )  )    instanceof   JsonSchema )  )     {", "(  ( JsonSchema )     (  (  ( MyNode )     ( o )  )  . get (  )  )  )  . setError ( myError )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["updateWarningText"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsConfigurable"}, {"methodBody": ["METHOD_START", "{", "final   Set < String >    set    =    new   HashSet <  >  (  )  ;", "for    ( UserDefinedConfiguration   info    :    list )     {", "if    ( set . contains ( info . getName (  )  )  )     {", "throw   new   ConfigurationException (  (  (  \" Duplicate   schema   name :     '  \"     +     ( info . getName (  )  )  )     +     \"  '  \"  )  )  ;", "}", "set . add ( info . getName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsConfigurable"}, {"methodBody": ["METHOD_START", "{", "return   ServiceManager . getService ( project ,    JsonSchemaMappingsProjectConfiguration . class )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsProjectConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableMap ( myState . myState )  ;", "}", "METHOD_END"], "methodName": ["getStateMap"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsProjectConfiguration"}, {"methodBody": ["METHOD_START", "{", "final   Optional < UserDefinedJsonSchemaConfiguration >    old    =    myState . myState . values (  )  . stream (  )  . filter (  (    schema )     -  >    FileUtil . pathsEqual ( schema . getRelativePathToSchema (  )  ,    oldRelativePath )  )  . findFirst (  )  ;", "old . ifPresent (  (    configuration )     -  >     {", "configuration . setRelativePathToSchema ( newRelativePath )  ;", "JsonSchemaService . Impl . get ( project )  . reset (  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["schemaFileMoved"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsProjectConfiguration"}, {"methodBody": ["METHOD_START", "{", "myState    =    new   JsonSchemaMappingsProjectConfiguration . MyState ( state )  ;", "}", "METHOD_END"], "methodName": ["setState"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsProjectConfiguration"}, {"methodBody": ["METHOD_START", "{", "DumbAwareAction . create (  (    e )     -  >     {", "String   pathTo    =    myField . getText (  )  ;", "if    (  ( StringUtil . isEmptyOrSpaces ( pathTo )  )     |  |     ( isHttpPath ( pathTo )  )  )", "return ;", "VirtualFile   virtualFile    =    LocalFileSystem . getInstance (  )  . refreshAndFindFileByIoFile ( new   File ( pathTo )  )  ;", "if    ( virtualFile    =  =    null )     {", "BalloonBuilder   balloonBuilder    =    JBPopupFactory . getInstance (  )  . createHtmlTextBalloonBuilder ( JsonBundle . message (  \" json . schema . file . not . found \"  )  ,    UIUtil . getBalloonErrorIcon (  )  ,    MessageType . ERROR . getPopupBackground (  )  ,    null )  ;", "Balloon   balloon    =    balloonBuilder . setFadeoutTime ( TimeUnit . SECONDS . toMillis (  3  )  )  . createBalloon (  )  ;", "balloon . showInCenterOf ( myField )  ;", "return ;", "}", "new   OpenFileDescriptor ( myProject ,    virtualFile )  . navigate ( true )  ;", "}  )  . registerCustomShortcutSet ( CommonShortcuts . getEditSource (  )  ,    myField )  ;", "}", "METHOD_END"], "methodName": ["attachNavigateToSchema"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsView"}, {"methodBody": ["METHOD_START", "{", "return   new   ColumnInfo [  ]  {    new   ColumnInfo < UserDefinedJsonSchemaConfiguration . Item ,    String >  (  \"  \"  )     {", "@ Nullable", "@ Override", "public   String   valueOf ( UserDefinedJsonSchemaConfiguration . Item   item )     {", "return   item . getPresentation (  )  ;", "}", "}     }  ;", "}", "METHOD_END"], "methodName": ["createColumns"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsView"}, {"methodBody": ["METHOD_START", "{", "myProject    =    project ;", "myTableView    =    new   com . intellij . ui . table . TableView (  )  ;", "myTableView . getTableHeader (  )  . setVisible ( false )  ;", "final   ToolbarDecorator   decorator    =    ToolbarDecorator . createDecorator ( myTableView )  ;", "final    . MyEditActionButtonRunnableImpl   editAction    =    new    . MyEditActionButtonRunnableImpl ( project )  ;", "decorator . setRemoveAction ( new    . MyRemoveActionButtonRunnable (  )  )  . setAddAction ( new    . MyAddActionButtonRunnable ( project )  )  . setEditAction ( editAction )  . disableUpDownActions (  )  ;", "myTableView . addMouseListener ( new   MouseAdapter (  )     {", "@ Override", "public   void   mouseClicked ( MouseEvent   e )     {", "if    (  ( e . getClickCount (  )  )     =  =     2  )     {", "editAction . execute (  )  ;", "}", "}", "}  )  ;", "JBTextField   schemaFieldBacking    =    new   JBTextField (  )  ;", "schemaFieldBacking . getEmptyText (  )  . setText (  \" Please   specify   schema   file   or   URL   here \"  )  ;", "mySchemaField    =    new   com . intellij . openapi . ui . TextFieldWithBrowseButton ( schemaFieldBacking )  ;", "SwingHelper . installFileCompletionAndBrowseDialog ( myProject ,    mySchemaField ,    JsonBundle . message (  \" json . schema . add . schema . chooser . title \"  )  ,    FileChooserDescriptorFactory . createSingleFileDescriptor (  )  )  ;", "attachNavigateToSchema (  )  ;", "myError    =    SwingHelper . createHtmlLabel ( JsonBundle . message (  \" json . schema . conflicting . mappings \"  )  ,    null ,     (    s )     -  >     {", "final   BalloonBuilder   builder    =    JBPopupFactory . getInstance (  )  . createHtmlTextBalloonBuilder ( myErrorText ,    UIUtil . getBalloonWarningIcon (  )  ,    MessageType . WARNING . getPopupBackground (  )  ,    null )  ;", "builder . setDisposable ( this )  ;", "builder . setHideOnClickOutside ( true )  ;", "builder . setCloseButtonEnabled ( true )  ;", "builder . createBalloon (  )  . showInCenterOf ( myError )  ;", "}  )  ;", "final   FormBuilder   builder    =    FormBuilder . createFormBuilder (  )  ;", "final   ErrorLabel   label    =    new   ErrorLabel ( JsonBundle . message (  \" json . schema . file . selector . title \"  )  )  ;", "schemaFieldBacking . getDocument (  )  . addDocumentListener ( new    . SchemaFieldErrorMessageProvider ( schemaFieldBacking ,    label )  )  ;", "if    ( schemaFieldBacking . getText (  )  . isEmpty (  )  )     {", "label . setErrorText (  \" Schema   path   cannot   be   empty \"  ,    RED )  ;", "}", "builder . addLabeledComponent ( label ,    mySchemaField )  ;", "label . setLabelFor ( mySchemaField )  ;", "label . setBorder ( Borders . empty (  0  ,     1  0  )  )  ;", "mySchemaField . setBorder ( Borders . emptyRight (  1  0  )  )  ;", "JBLabel   versionLabel    =    new   JBLabel (  \" Schema   version :  \"  )  ;", "mySchemaVersionComboBox    =    new   com . intellij . openapi . ui . ComboBox ( new   DefaultComboBoxModel ( JsonSchemaVersion . values (  )  )  )  ;", "versionLabel . setLabelFor ( mySchemaVersionComboBox )  ;", "versionLabel . setBorder ( Borders . empty (  0  ,     1  0  )  )  ;", "builder . addLabeledComponent ( versionLabel ,    mySchemaVersionComboBox )  ;", "final   JPanel   wrapper    =    new   JPanel ( new   BorderLayout (  )  )  ;", "wrapper . setBorder ( Borders . empty (  0  ,     1  0  )  )  ;", "myErrorIcon    =    new   JBLabel ( UIUtil . getBalloonWarningIcon (  )  )  ;", "wrapper . add ( myErrorIcon ,    BorderLayout . WEST )  ;", "wrapper . add ( myError ,    BorderLayout . CENTER )  ;", "builder . addComponent ( wrapper )  ;", "builder . addComponentFillVertically ( decorator . createPanel (  )  ,     5  )  ;", "myComponent    =    builder . getPanel (  )  ;", "}", "METHOD_END"], "methodName": ["createUI"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsView"}, {"methodBody": ["METHOD_START", "{", "return   myComponent ;", "}", "METHOD_END"], "methodName": ["getComponent"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsView"}, {"methodBody": ["METHOD_START", "{", "return   myTableView . getListTableModel (  )  . getItems (  )  ;", "}", "METHOD_END"], "methodName": ["getData"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsView"}, {"methodBody": ["METHOD_START", "{", "text    =    text . trim (  )  ;", "if    (  ( project . isDefault (  )  )     |  |     (  ( project . getBasePath (  )  )     =  =    null )  )", "return   text ;", "if    ( StrUtil . isEmptyOrSpaces ( text )  )", "return   text ;", "final   File   ioFile    =    new   File ( text )  ;", "if    (  !  ( ioFile . isAbsolute (  )  )  )", "return   text ;", "final   Str   relativePath    =    FileUtil . getRelativePath ( new   File ( project . getBasePath (  )  )  ,    ioFile )  ;", "return   relativePath    =  =    null    ?    text    :    relativePath ;", "}", "METHOD_END"], "methodName": ["getRelativePath"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsView"}, {"methodBody": ["METHOD_START", "{", "String   schemaFieldText    =    mySchemaField . getText (  )  ;", "if    ( JsonSchemaConfigurable . isHttpPath ( schemaFieldText )  )", "return   schemaFieldText ;", "return   FileUtil . toSystemDependentName (  . getRelativePath ( myProject ,    schemaFieldText )  )  ;", "}", "METHOD_END"], "methodName": ["getSchemaSubPath"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsView"}, {"methodBody": ["METHOD_START", "{", "return    (  ( JsonSchemaVersion )     ( mySchemaVersionComboBox . getSelectedItem (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSchemaVersion"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsView"}, {"methodBody": ["METHOD_START", "{", "return   myInitialized ;", "}", "METHOD_END"], "methodName": ["isInitialized"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsView"}, {"methodBody": ["METHOD_START", "{", "mySchemaField . getButton (  )  . doClick (  )  ;", "}", "METHOD_END"], "methodName": ["runFileChooser"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsView"}, {"methodBody": ["METHOD_START", "{", "myErrorText    =    text ;", "myError . sVisible (  ( text    !  =    null )  )  ;", "myErrorIcon . sVisible (  ( text    !  =    null )  )  ;", "}", "METHOD_END"], "methodName": ["setError"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsView"}, {"methodBody": ["METHOD_START", "{", "myInitialized    =    true ;", "mySchemaField . setText ( schemaFilePath )  ;", "mySchemaVersionComboBox . setSelectedItem ( version )  ;", "myTableView . setModelAndUpdateColumns ( new   ListTableModel (  . createColumns (  )  ,    new   ArrayList ( data )  )  )  ;", "}", "METHOD_END"], "methodName": ["setItems"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaMappingsView"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( StringUtil . isEmptyOrSpaces ( beforeAfter . getBefore (  )  )  )  )     &  &     ( item . getPath (  )  . startsWith ( beforeAfter . getBefore (  )  )  )  )     {", "return   ThreeState . YES ;", "}", "if    (  (  !  ( StringUtil . isEmptyOrSpaces ( beforeAfter . getAfter (  )  )  )  )     &  &     ( item . getPath (  )  . endsWith ( beforeAfter . getAfter (  )  )  )  )     {", "return   ThreeState . YES ;", "}", "return   ThreeState . UNSURE ;", "}", "METHOD_END"], "methodName": ["checkOneSideWithoutWildcard"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaPatternComparator"}, {"methodBody": ["METHOD_START", "{", "final   File   leftFile    =    new   File ( myProject . getBasePath (  )  ,    left . getPath (  )  )  ;", "final   File   rightFile    =    new   File ( myProject . getBasePath (  )  ,    right . getPath (  )  )  ;", "if    ( left . isDirectory (  )  )     {", "if    ( FileUtil . isAncestor ( leftFile ,    rightFile ,    true )  )", "return   ThreeState . YES ;", "}", "if    ( right . isDirectory (  )  )     {", "if    ( FileUtil . isAncestor ( rightFile ,    leftFile ,    true )  )", "return   ThreeState . YES ;", "}", "return    ( FileUtil . filesEqual ( leftFile ,    rightFile )  )     &  &     (  ( left . isDirectory (  )  )     =  =     ( right . isDirectory (  )  )  )     ?    ThreeState . YES    :    ThreeState . NO ;", "}", "METHOD_END"], "methodName": ["comparePaths"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaPatternComparator"}, {"methodBody": ["METHOD_START", "{", "if    ( leftItem . getPath (  )  . equals ( rightItem . getPath (  )  )  )", "return   ThreeState . YES ;", "final   BeforeAfter < String >    left    =     . getBeforeAfterAroundWildCards ( leftItem . getPath (  )  )  ;", "final   BeforeAfter < String >    right    =     . getBeforeAfterAroundWildCards ( rightItem . getPath (  )  )  ;", "if    (  ( left    =  =    null )     |  |     ( right    =  =    null )  )     {", "if    (  ( left    =  =    null )     &  &     ( right    =  =    null )  )", "return   leftItem . getPath (  )  . equals ( rightItem . getPath (  )  )     ?    ThreeState . YES    :    ThreeState . NO ;", "if    ( left    =  =    null )     {", "return    . checkOneSideWithoutWildcard ( leftItem ,    right )  ;", "}", "return    . checkOneSideWithoutWildcard ( rightItem ,    left )  ;", "}", "if    (  (  !  ( StringUtil . isEmptyOrSpaces ( left . getBefore (  )  )  )  )     &  &     (  !  ( StringUtil . isEmptyOrSpaces ( right . getBefore (  )  )  )  )  )     {", "if    (  ( left . getBefore (  )  . startsWith ( right . getBefore (  )  )  )     |  |     ( right . getBefore (  )  . startsWith ( left . getBefore (  )  )  )  )     {", "return   ThreeState . YES ;", "}", "return   ThreeState . NO ;", "}", "if    (  (  !  ( StringUtil . isEmptyOrSpaces ( left . getAfter (  )  )  )  )     &  &     (  !  ( StringUtil . isEmptyOrSpaces ( right . getAfter (  )  )  )  )  )     {", "if    (  ( left . getAfter (  )  . endsWith ( right . getAfter (  )  )  )     |  |     ( right . getAfter (  )  . endsWith ( left . getAfter (  )  )  )  )     {", "return   ThreeState . YES ;", "}", "return   ThreeState . NO ;", "}", "return   ThreeState . UNSURE ;", "}", "METHOD_END"], "methodName": ["comparePatterns"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaPatternComparator"}, {"methodBody": ["METHOD_START", "{", "final      firstIdx    =    pattern . indexOf (  '  *  '  )  ;", "final      lastIdx    =    pattern . lastIndexOf (  '  *  '  )  ;", "if    (  ( firstIdx    <     0  )     |  |     ( lastIdx    <     0  )  )", "return   null ;", "return   new   com . intellij . util . BeforeAfter ( pattern . substring (  0  ,    firstIdx )  ,    pattern . substring (  ( lastIdx    +     1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getBeforeAfterAroundWildCards"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaPatternComparator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( itemLeft . isPattern (  )  )     !  =     ( itemRight . isPattern (  )  )  )", "return   com . intellij . util . ThreeState . NO ;", "if    ( itemLeft . isPattern (  )  )", "return    . comparePatterns ( itemLeft ,    itemRight )  ;", "return   comparePaths ( itemLeft ,    itemRight )  ;", "}", "METHOD_END"], "methodName": ["isSimilar"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaPatternComparator"}, {"methodBody": ["METHOD_START", "{", "return   new   UserDefinedJsonSchemaConfiguration . Item ( d ,    false ,    true )  ;", "}", "METHOD_END"], "methodName": ["d"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaPatternComparatorTest"}, {"methodBody": ["METHOD_START", "{", "return   new   UserDefinedJsonSchemaConfiguration . Item ( f ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["f"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaPatternComparatorTest"}, {"methodBody": ["METHOD_START", "{", "return   new   UserDefinedJsonSchemaConfiguration . Item ( p ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["p"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaPatternComparatorTest"}, {"methodBody": ["METHOD_START", "{", "final   JsonSchemaPatternComparator   comparator    =    new   JsonSchemaPatternComparator ( getProject (  )  )  ;", "Assert . assertEquals ( YES ,    comparator . isSimilar (  . d (  \" test \"  )  ,     . d (  \" test \"  )  )  )  ;", "Assert . assertEquals ( YES ,    comparator . isSimilar (  . d (  \"  .  / test \"  )  ,     . d (  \" test \"  )  )  )  ;", "Assert . assertEquals ( NO ,    comparator . isSimilar (  . d (  \"  .  .  / test \"  )  ,     . d (  \" test \"  )  )  )  ;", "Assert . assertEquals ( YES ,    comparator . isSimilar (  . d (  \"  .  .  \"  )  ,     . d (  \" test \"  )  )  )  ;", "Assert . assertEquals ( NO ,    comparator . isSimilar (  . d (  \" another \"  )  ,     . d (  \" test \"  )  )  )  ;", "Assert . assertEquals ( YES ,    comparator . isSimilar (  . d (  \" test / child \"  )  ,     . d (  \" test \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["test2Dirs"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaPatternComparatorTest"}, {"methodBody": ["METHOD_START", "{", "final   JsonSchemaPatternComparator   comparator    =    new   JsonSchemaPatternComparator ( getProject (  )  )  ;", "Assert . assertEquals ( YES ,    comparator . isSimilar (  . f (  \" test \"  )  ,     . f (  \" test \"  )  )  )  ;", "Assert . assertEquals ( YES ,    comparator . isSimilar (  . f (  \"  .  / test \"  )  ,     . f (  \" test \"  )  )  )  ;", "Assert . assertEquals ( NO ,    comparator . isSimilar (  . f (  \"  .  .  / test \"  )  ,     . f (  \" test \"  )  )  )  ;", "Assert . assertEquals ( NO ,    comparator . isSimilar (  . f (  \" other \"  )  ,     . f (  \" test \"  )  )  )  ;", "Assert . assertEquals ( YES ,    comparator . isSimilar (  . f (  \" one /  .  .  / one / two \"  )  ,     . f (  \" one / two \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["test2Files"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaPatternComparatorTest"}, {"methodBody": ["METHOD_START", "{", "final   JsonSchemaPatternComparator   comparator    =    new   JsonSchemaPatternComparator ( getProject (  )  )  ;", "Assert . assertEquals ( NO ,    comparator . isSimilar (  . d (  \" test \"  )  ,     . f (  \" test \"  )  )  )  ;", "Assert . assertEquals ( YES ,    comparator . isSimilar (  . d (  \" test \"  )  ,     . f (  \" test / lower \"  )  )  )  ;", "Assert . assertEquals ( YES ,    comparator . isSimilar (  . d (  \" test \"  )  ,     . f (  \"  .  / test / lower \"  )  )  )  ;", "Assert . assertEquals ( YES ,    comparator . isSimilar (  . d (  \"  .  .  \"  )  ,     . f (  \" test / lower \"  )  )  )  ;", "Assert . assertEquals ( NO ,    comparator . isSimilar (  . d (  \" one \"  )  ,     . f (  \" test / lower \"  )  )  )  ;", "Assert . assertEquals ( NO ,    comparator . isSimilar (  . d (  \" one \"  )  ,     . f (  \" test \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testDirAndFile"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaPatternComparatorTest"}, {"methodBody": ["METHOD_START", "{", "final   JsonSchemaPatternComparator   comparator    =    new   JsonSchemaPatternComparator ( getProject (  )  )  ;", "Assert . assertEquals ( YES ,    comparator . isSimilar (  . p (  \" test \"  )  ,     . p (  \" test \"  )  )  )  ;", "Assert . assertEquals ( YES ,    comparator . isSimilar (  . p (  \" test \"  )  ,     . p (  \" tes *  \"  )  )  )  ;", "Assert . assertEquals ( YES ,    comparator . isSimilar (  . p (  \" tes *  \"  )  ,     . p (  \" test \"  )  )  )  ;", "Assert . assertEquals ( YES ,    comparator . isSimilar (  . p (  \" test \"  )  ,     . p (  \"  * est \"  )  )  )  ;", "Assert . assertEquals ( YES ,    comparator . isSimilar (  . p (  \" testwords \"  )  ,     . p (  \" test * words \"  )  )  )  ;", "Assert . assertEquals ( YES ,    comparator . isSimilar (  . p (  \" testwords \"  )  ,     . p (  \"  * test * words \"  )  )  )  ;", "Assert . assertEquals ( NO ,    comparator . isSimilar (  . p (  \"  *  . abc \"  )  ,     . p (  \"  *  . cde \"  )  )  )  ;", "Assert . assertEquals ( UNSURE ,    comparator . isSimilar (  . p (  \"  *  . abc \"  )  ,     . p (  \" start .  *  \"  )  )  )  ;", "Assert . assertEquals ( UNSURE ,    comparator . isSimilar (  . p (  \" two * words \"  )  ,     . p (  \" circus \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testPatterns"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaPatternComparatorTest"}, {"methodBody": ["METHOD_START", "{", "final   ThrowableRunnable < Exception >    test    =     (  )     -  >    skeleton ( new   Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    getModuleDir ( getProject (  )  )  ;", "addSchema ( new   UserDefinedJsonSchemaConfiguration ( jsonFileNameWithoutExtension ,    JsonSchemaVersion . SCHEMA _  4  ,     (  (  ( moduleDir    +     \"  /  \"  )     +    jsonFileNameWithoutExtension )     +     \"  . json \"  )  ,    false ,    Collections . emptyList (  )  )  )  ;", "myDoCompletion    =    false ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     (  (  \"  /  \"     +    jsonFileNameWithoutExtension )     +     \"  . json \"  )  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "doHighlighting (  )  ;", "}", "}  )  ;", "PlatformTestUtil . start ( getTestName ( false )  ,    expectedMs ,    test )  . attempts (  1  )  . usesAllCPUCores (  )  . assertTiming (  )  ;", "}", "METHOD_END"], "methodName": ["doPerformanceTest"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaPerformanceTest"}, {"methodBody": ["METHOD_START", "{", "doPerformanceTest (  8  0  0  0  ,     \" swagger \"  )  ;", "}", "METHOD_END"], "methodName": ["testSwaggerHighlighting"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaPerformanceTest"}, {"methodBody": ["METHOD_START", "{", "doPerformanceTest (  7  0  0  0  ,     \" tslint - schema \"  )  ;", "}", "METHOD_END"], "methodName": ["testTsLintSchema"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaPerformanceTest"}, {"methodBody": ["METHOD_START", "{", "enableInspectionTool ( new   JsonSchemaComplianceInspection (  )  )  ;", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "final   UserDefinedJsonSchemaConfiguration   pattern    =    new   UserDefinedJsonSchemaConfiguration (  \" pattern \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / patternSchema . json \"  )  ,    false ,    Collections . emptyList (  )  )  ;", "addSchema ( pattern )  ;", "myDoCompletion    =    false ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     \"  / patternSchema . json \"  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "checkHighlighting ( new   com . intellij . testFramework . ExpectedHighlightingData ( new   DocumentImpl (  (  \"  {  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"        \\  \" properties \\  \"  :     {  \\ n \"     +     \"              \\  \" withPattern \\  \"  :     {  \\ n \"  )     +     \"                    \\  \" pattern \\  \"  :     < warning   descr =  \\  \" Unclosed   character   class   near   index    3  \\ n \"  )     +     \"  ^  [  ]  $  \\ n \"  )     +     \"           ^  \\  \"  >  \\  \"  ^  [  ]  $  \\  \"  <  / warning >  \\ n \"  )     +     \"              }  ,  \\ n \"  )     +     \"              \\  \" everythingFine \\  \"  :     {  \\ n \"  )     +     \"                    \\  \" pattern \\  \"  :     \\  \"  ^  [ a ]  $  \\  \"  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"        }  ,  \\ n \"  )     +     \"        \\  \" patternProperties \\  \"  :     {  \\ n \"  )     +     \"              < warning   descr =  \\  \" Unclosed   character   class   near   index    8  \\ n \"  )     +     \"  .  * p [  0  -  9  .  *  \\ n \"  )     +     \"                          ^  \\  \"  >  \\  \" p [  0  -  9  \\  \"  <  / warning >  :     {  }  ,  \\ n \"  )     +     \"              < warning   descr =  \\  \" Unclosed   character   class   near   index    8  \\ n \"  )     +     \"  .  * b [  0  -  7  .  *  \\ n \"  )     +     \"                          ^  \\  \"  >  \\  \" b [  0  -  7  \\  \"  <  / warning >  :     {  }  \\ n \"  )     +     \"        }  \\ n \"  )     +     \"  }  \"  )  )  )  ,    true ,    true ,    false ,    myFile )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testPatterns"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaSelfHighligthingTest"}, {"methodBody": ["METHOD_START", "{", "JsonSchemaTestServiceImpl . provider    =    newProvider ;", "}", "METHOD_END"], "methodName": ["setProvider"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaTestServiceImpl"}, {"methodBody": ["METHOD_START", "{", "final   JsonSchemaVfsListener . MyUpdater   updater    =    new   JsonSchemaVfsListener . MyUpdater ( project ,    service )  ;", "ApplicationManager . getApplication (  )  . getMessageBus (  )  . connect ( project )  . subscribe ( VFS _ CHANGES ,    new   JsonSchemaVfsListener ( updater )  )  ;", "PsiManager . getInstance ( project )  . addPsiTreeChangeListener ( new   PsiTreeAnyChangeAbstractAdapter (  )     {", "@ Override", "protected   void   onChange (  @ Nullable", "PsiFile   file )     {", "if    ( file    !  =    null )", "updater . onFileChange ( file . getViewProvider (  )  . getVirtualFile (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["startListening"], "fileName": "com.jetbrains.jsonSchema.JsonSchemaVfsListener"}, {"methodBody": ["METHOD_START", "{", "return   myCalculatedPatterns . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getCalculatedPatterns"], "fileName": "com.jetbrains.jsonSchema.UserDefinedJsonSchemaConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.jetbrains.jsonSchema.UserDefinedJsonSchemaConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   patterns ;", "}", "METHOD_END"], "methodName": ["getPatterns"], "fileName": "com.jetbrains.jsonSchema.UserDefinedJsonSchemaConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    (  ( project . getBasePath (  )  )     =  =    null )     {", "return   null ;", "}", "al   String   path    =    FileUtilRt . toSystemIndependentName ( StringUtil . notNullize ( pattern . path )  )  ;", "al   List < String >    parts    =    ContainerUtil . filter ( StringUtil . split ( path ,     \"  /  \"  )  ,     (    s )     -  >     !  (  \"  .  \"  . equals ( s )  )  )  ;", "if    ( parts . isEmpty (  )  )     {", "return   project . getBaseDir (  )  ;", "} else    {", "return   VfsUtil . dRelativeFile ( project . getBaseDir (  )  ,    ArrayUtil . toStringArray ( parts )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getRelativeFile"], "fileName": "com.jetbrains.jsonSchema.UserDefinedJsonSchemaConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   relativePathToSchema ;", "}", "METHOD_END"], "methodName": ["getRelativePathToSchema"], "fileName": "com.jetbrains.jsonSchema.UserDefinedJsonSchemaConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   schemaVersion ;", "}", "METHOD_END"], "methodName": ["getSchemaVersion"], "fileName": "com.jetbrains.jsonSchema.UserDefinedJsonSchemaConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   applicationLevel ;", "}", "METHOD_END"], "methodName": ["isApplicationLevel"], "fileName": "com.jetbrains.jsonSchema.UserDefinedJsonSchemaConfiguration"}, {"methodBody": ["METHOD_START", "{", "final   List < PairProcessor < Project ,    VirtualFile >  >    result    =    new   com . intellij . util . SmartList (  )  ;", "for    ( final    . Item   patternText    :    patterns )     {", "if    ( patternText . pattern )     {", "result . add ( new   PairProcessor < Project ,    VirtualFile >  (  )     {", "private   final   Pattern   pattern    =    PatternUtil . fromMask ( patternText . path )  ;", "@ Override", "public   boolean   process ( Project   project ,    VirtualFile   file )     {", "return   JsonSchemaObject . matchPattern ( pattern ,    file . getName (  )  )  ;", "}", "}  )  ;", "} else", "if    ( patternText . directory )     {", "result . add (  (    project ,    vfile )     -  >     {", "final   VirtualFile   relativeFile    =    getRelativeFile ( project ,    patternText )  ;", "return    ( relativeFile    !  =    null )     &  &     ( com . intellij . openapi . vfs . VfsUtilCore . isAncestor ( relativeFile ,    vfile ,    true )  )  ;", "}  )  ;", "} else    {", "result . add (  (    project ,    vfile )     -  >    vfile . equals ( getRelativeFile ( project ,    patternText )  )  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["recalculatePatterns"], "fileName": "com.jetbrains.jsonSchema.UserDefinedJsonSchemaConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . applicationLevel    =    applicationLevel ;", "}", "METHOD_END"], "methodName": ["setApplicationLevel"], "fileName": "com.jetbrains.jsonSchema.UserDefinedJsonSchemaConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "com.jetbrains.jsonSchema.UserDefinedJsonSchemaConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . patterns . clear (  )  ;", "if    ( patterns    !  =    null )", "this . patterns . addAll ( patterns )  ;", "Collections . sort ( this . patterns ,     . ITEM _ COMPARATOR )  ;", "myCalculatedPatterns . drop (  )  ;", "}", "METHOD_END"], "methodName": ["setPatterns"], "fileName": "com.jetbrains.jsonSchema.UserDefinedJsonSchemaConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . relativePathToSchema    =    relativePathToSchema ;", "}", "METHOD_END"], "methodName": ["setRelativePathToSchema"], "fileName": "com.jetbrains.jsonSchema.UserDefinedJsonSchemaConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . schemaVersion    =    schemaVersion ;", "}", "METHOD_END"], "methodName": ["setSchemaVersion"], "fileName": "com.jetbrains.jsonSchema.UserDefinedJsonSchemaConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    ( JsonLikePsiWalker . JSON _ ORIGINAL _ PSI _ WALKER . handles ( element )  )", "return   JsonLikePsiWalker . JSON _ ORIGINAL _ PSI _ WALKER ;", "return   Arrays . stream ( Extensions . getExtensions ( JsonLikePsiWalkerFactory . EXTENSION _ POINT _ NAME )  )  . filter (  (    extension )     -  >    extension . handles ( element )  )  . findFirst (  )  . map (  (    extension )     -  >    extension . create ( schemaObject )  )  . orElse ( null )  ;", "}", "METHOD_END"], "methodName": ["getWalker"], "fileName": "com.jetbrains.jsonSchema.extension.JsonLikePsiWalker"}, {"methodBody": ["METHOD_START", "{", "return   JsonSchemaVersion . SCHEMA _  4  ;", "}", "METHOD_END"], "methodName": ["getSchemaVersion"], "fileName": "com.jetbrains.jsonSchema.extension.JsonSchemaFileProvider"}, {"methodBody": ["METHOD_START", "{", "URL   url    =    baseClass . getResource ( resourcePath )  ;", "if    ( url    =  =    null )     {", ". LOG . error (  (  \" Cannot   find   resource    \"     +    resourcePath )  )  ;", "return   null ;", "}", "VirtualFile   file    =    VfsUtil . findFileByURL ( url )  ;", "if    ( file    =  =    null )     {", ". LOG . error (  (  \" Cannot   find   file   by    \"     +    resourcePath )  )  ;", "return   null ;", "}", "return   file ;", "}", "METHOD_END"], "methodName": ["getResourceFile"], "fileName": "com.jetbrains.jsonSchema.extension.JsonSchemaProviderFactory"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isShouldBeIgnored"], "fileName": "com.jetbrains.jsonSchema.extension.adapters.JsonValueAdapter"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["shouldCheckIntegralRequirements"], "fileName": "com.jetbrains.jsonSchema.extension.adapters.JsonValueAdapter"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   file    =    psiFile . getViewProvider (  )  . getVirtualFile (  )  ;", "return    . Impl . get ( psiFile . getProject (  )  )  . isSchemaFile ( file )  ;", "}", "METHOD_END"], "methodName": ["isSchemaFile"], "fileName": "com.jetbrains.jsonSchema.ide.JsonSchemaService"}, {"methodBody": ["METHOD_START", "{", "id    =     ( id . endsWith (  \"  #  \"  )  )     ?    id . substring (  0  ,     (  ( id . length (  )  )     -     1  )  )     :    id ;", "return   id . startsWith (  \"  #  \"  )     ?    id . substring (  1  )     :    id ;", "}", "METHOD_END"], "methodName": ["normalizeId"], "fileName": "com.jetbrains.jsonSchema.ide.JsonSchemaService"}, {"methodBody": ["METHOD_START", "{", "final   CachedValueProvider < T >    provider    =    new   CachedValueProviderOnPsiFile < T >  ( psiFile )     {", "@ Override", "@ Nullable", "public   T   evaluate (  @ NotNull", "PsiFile   psiFile )     {", "return   eval . fun ( psiFile )  ;", "}", "}  ;", "return   ReadAction . compute (  (  )     -  >    CachedValuesManager . getCachedValue ( psiFile ,    key ,    provider )  )  ;", "}", "METHOD_END"], "methodName": ["getOrCompute"], "fileName": "com.jetbrains.jsonSchema.impl.CachedValueProviderOnPsiFile"}, {"methodBody": ["METHOD_START", "{", "final      position    =    EditorTestUtil . getCaretPosition ( text )  ;", "Assert . assertTrue (  ( position    >     0  )  )  ;", "final   String   completionText    =    text . replace (  \"  < caret >  \"  ,     \" IntelliJIDEARulezzz \"  )  ;", "final   PsiFile   file    =    createFile ( myModule ,     (  \" tslint .  \"     +    extension )  ,    completionText )  ;", "final   PsiElement   element    =    file . findElementAt ( position )  ;", "Assert . assertNotNull ( element )  ;", "final   PsiFile   schemaFile    =    createFile ( myModule ,     \" testSchema . json \"  ,    schema )  ;", "final   JsonSchemaObject   schemaObject    =    JsonSchemaReader . readFromFile ( myProject ,    schemaFile . getVirtualFile (  )  )  ;", "Assert . assertNotNull ( schemaObject )  ;", "final   List < LookupElement >    foundVariants    =    JsonContributor . getCompletionVariants ( schemaObject ,    element ,    element )  ;", "Collections . sort ( foundVariants ,    Comparator . comparing ( LookupElement :  : getLookupString )  )  ;", "myItems    =    foundVariants . toArray ( EMPTY _ ARRAY )  ;", "assertStringItems ( variants )  ;", "}", "METHOD_END"], "methodName": ["testBySchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonBySchemaCompletionBaseTest"}, {"methodBody": ["METHOD_START", "{", "baseTest ( folder ,    testFile ,     (  )     -  >     {", "ce (  )  ;", "assertStringItems ( items )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["baseCompletionTest"], "fileName": "com.jetbrains.jsonSchema.impl.JsonBySchemaHeavyCompletionTest"}, {"methodBody": ["METHOD_START", "{", "baseTest ( folder ,    testFile ,     (  )     -  >     {", "final   CodeCompletionHandlerBase   handlerBase    =    new   CodeCompletionHandlerBase ( ype . BASIC )  ;", "handlerBase . invokeCompletion ( getProject (  )  ,    getEditor (  )  )  ;", "if    (  ( myItems )     !  =    null )     {", "selectItem ( myItems [  0  ]  )  ;", "}", "try    {", "checkResultByFile (  (  (  (  (  \"  /  \"     +    folder )     +     \"  /  \"  )     +    testFile )     +     \"  _ after . json \"  )  )  ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["baseInsertTest"], "fileName": "com.jetbrains.jsonSchema.impl.JsonBySchemaHeavyCompletionTest"}, {"methodBody": ["METHOD_START", "{", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   registerSchemes (  )     {", "final   String   moduleDir    =    JsonSchemaHeavyAbstractTest . getModuleDir ( getProject (  )  )  ;", "final   UserDefinedJsonSchemaConfiguration   base    =    new   UserDefinedJsonSchemaConfiguration (  \" base \"  ,    JsonSchemaVersion . SCHEMA _  4  ,     ( moduleDir    +     \"  / Schema . json \"  )  ,    false ,    Collections . singletonList ( new   UserDefinedJsonSchemaConfiguration . Item (  ( testFile    +     \"  . json \"  )  ,    true ,    false )  )  )  ;", "addSchema ( base )  ;", "}", "@ Override", "public   void   configureFiles (  )     {", "configureByFiles ( null ,     (  (  (  (  \"  /  \"     +    folder )     +     \"  /  \"  )     +    testFile )     +     \"  . json \"  )  ,     (  (  \"  /  \"     +    folder )     +     \"  / Schema . json \"  )  )  ;", "}", "@ Override", "public   void   doCheck (  )     {", "checker . run (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["baseTest"], "fileName": "com.jetbrains.jsonSchema.impl.JsonBySchemaHeavyCompletionTest"}, {"methodBody": ["METHOD_START", "{", "baseInsertTest (  \" insertArrayOrObjectLiteral \"  ,     \" arrayLiteral \"  )  ;", "ce (  )  ;", "assertStringItems (  \"  1  \"  ,     \"  2  \"  ,     \"  3  \"  )  ;", "}", "METHOD_END"], "methodName": ["testArrayLiteral"], "fileName": "com.jetbrains.jsonSchema.impl.JsonBySchemaHeavyCompletionTest"}, {"methodBody": ["METHOD_START", "{", "baseTest ( getTestName ( true )  ,     \" testEditing \"  ,     (  )     -  >     {", "complete (  )  ;", "assertStringItems (  \"  \\  \" preserve \\  \"  \"  ,     \"  \\  \" react \\  \"  \"  ,     \"  \\  \" react - native \\  \"  \"  )  ;", "final   PsiFile   schema    =    myFile . getParent (  )  . findFile (  \" json \"  )  ;", "final   int   idx    =    schema . getText (  )  . indexOf (  \" react - native \"  )  ;", "Assert . assertTrue (  ( idx    >     0  )  )  ;", "PsiElement   element    =    schema . findElementAt ( idx )  ;", "element    =     ( element   instanceof   JsonStringLiteral )     ?    element    :    PsiTreeUtil . getParentOfType ( element ,     . class )  ;", "Assert . assertTrue (  ( element   instanceof   JsonStringLiteral )  )  ;", "final   PsiFile   dummy    =    PsiFileFactory . getInstance ( myProject )  . createFileFromText (  \" test . json \"  ,    JsonFileType . INSTANCE ,     \"  {  \\  \" a \\  \"  :     \\  \" completelyChanged \\  \"  }  \"  )  ;", "Assert . assertTrue (  ( dummy   instanceof   JsonFile )  )  ;", "final   JsonValue   top    =     (  ( JsonFile )     ( dummy )  )  . getTopLevelValue (  )  ;", "final   JsonValue   newLiteral    =     (  ( JsonObject )     ( top )  )  . findProperty (  \" a \"  )  . getValue (  )  ;", "PsiElement   finalElement    =    element ;", "WriteAction . run (  (  )     -  >    finalElement . replace ( newLiteral )  )  ;", "complete (  )  ;", "assertStringItems (  \"  \\  \" completelyChanged \\  \"  \"  ,     \"  \\  \" preserve \\  \"  \"  ,     \"  \\  \" react \\  \"  \"  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testEditingSchemaAffectsCompletion"], "fileName": "com.jetbrains.jsonSchema.impl.JsonBySchemaHeavyCompletionTest"}, {"methodBody": ["METHOD_START", "{", "baseInsertTest (  \" insertPropertyName \"  ,     \" testIncompleteNameWithDefaultStringValue \"  )  ;", "}", "METHOD_END"], "methodName": ["testIncompleteNameWithDefaultStringValue"], "fileName": "com.jetbrains.jsonSchema.impl.JsonBySchemaHeavyCompletionTest"}, {"methodBody": ["METHOD_START", "{", "baseInsertTest (  \" insertPropertyName \"  ,     \" testBooleanType \"  )  ;", "}", "METHOD_END"], "methodName": ["testInsertBooleanType"], "fileName": "com.jetbrains.jsonSchema.impl.JsonBySchemaHeavyCompletionTest"}, {"methodBody": ["METHOD_START", "{", "baseInsertTest (  \" insertPropertyName \"  ,     \" testBooleanTypeComma \"  )  ;", "}", "METHOD_END"], "methodName": ["testInsertBooleanTypeComma"], "fileName": "com.jetbrains.jsonSchema.impl.JsonBySchemaHeavyCompletionTest"}, {"methodBody": ["METHOD_START", "{", "baseInsertTest ( getTestName ( true )  ,     \" testValue \"  )  ;", "}", "METHOD_END"], "methodName": ["testInsertEnumValue"], "fileName": "com.jetbrains.jsonSchema.impl.JsonBySchemaHeavyCompletionTest"}, {"methodBody": ["METHOD_START", "{", "baseInsertTest (  \" insertPropertyName \"  ,     \" testIntegerType \"  )  ;", "}", "METHOD_END"], "methodName": ["testInsertIntegerType"], "fileName": "com.jetbrains.jsonSchema.impl.JsonBySchemaHeavyCompletionTest"}, {"methodBody": ["METHOD_START", "{", "baseInsertTest (  \" insertPropertyName \"  ,     \" testIntegerTypeComma \"  )  ;", "}", "METHOD_END"], "methodName": ["testInsertIntegerTypeComma"], "fileName": "com.jetbrains.jsonSchema.impl.JsonBySchemaHeavyCompletionTest"}, {"methodBody": ["METHOD_START", "{", "baseInsertTest (  \" insertPropertyName \"  ,     \" testNameWithDefaultIntegerValue \"  )  ;", "}", "METHOD_END"], "methodName": ["testInsertNameWithDefaultIntegerValue"], "fileName": "com.jetbrains.jsonSchema.impl.JsonBySchemaHeavyCompletionTest"}, {"methodBody": ["METHOD_START", "{", "baseInsertTest (  \" insertPropertyName \"  ,     \" testNameWithDefaultStringValue \"  )  ;", "}", "METHOD_END"], "methodName": ["testInsertNameWithDefaultStringValue"], "fileName": "com.jetbrains.jsonSchema.impl.JsonBySchemaHeavyCompletionTest"}, {"methodBody": ["METHOD_START", "{", "baseInsertTest (  \" insertPropertyName \"  ,     \" testObjectType \"  )  ;", "}", "METHOD_END"], "methodName": ["testInsertObjectType"], "fileName": "com.jetbrains.jsonSchema.impl.JsonBySchemaHeavyCompletionTest"}, {"methodBody": ["METHOD_START", "{", "baseInsertTest (  \" insertPropertyName \"  ,     \" testName \"  )  ;", "}", "METHOD_END"], "methodName": ["testInsertPropertyName"], "fileName": "com.jetbrains.jsonSchema.impl.JsonBySchemaHeavyCompletionTest"}, {"methodBody": ["METHOD_START", "{", "baseInsertTest (  \" insertPropertyName \"  ,     \" testStringType \"  )  ;", "}", "METHOD_END"], "methodName": ["testInsertStringType"], "fileName": "com.jetbrains.jsonSchema.impl.JsonBySchemaHeavyCompletionTest"}, {"methodBody": ["METHOD_START", "{", "baseInsertTest (  \" insertPropertyName \"  ,     \" testNameWithDefaultIntegerValueNoQuotesComma \"  )  ;", "}", "METHOD_END"], "methodName": ["testNameWithDefaultIntegerValueNoQuotesComma"], "fileName": "com.jetbrains.jsonSchema.impl.JsonBySchemaHeavyCompletionTest"}, {"methodBody": ["METHOD_START", "{", "baseInsertTest (  \" insertPropertyName \"  ,     \" testNameWithDefaultStringValueComma \"  )  ;", "}", "METHOD_END"], "methodName": ["testNameWithDefaultStringValueComma"], "fileName": "com.jetbrains.jsonSchema.impl.JsonBySchemaHeavyCompletionTest"}, {"methodBody": ["METHOD_START", "{", "baseInsertTest (  \" insertPropertyName \"  ,     \" testNameWithDefaultStringValueNoQuotes \"  )  ;", "}", "METHOD_END"], "methodName": ["testNameWithDefaultStringValueNoQuotes"], "fileName": "com.jetbrains.jsonSchema.impl.JsonBySchemaHeavyCompletionTest"}, {"methodBody": ["METHOD_START", "{", "baseInsertTest (  \" insertArrayOrObjectLiteral \"  ,     \" objectLiteral \"  )  ;", "ce (  )  ;", "assertStringItems (  \"  \\  \" insideTopObject 1  \\  \"  \"  ,     \"  \\  \" insideTopObject 2  \\  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testObjectLiteral"], "fileName": "com.jetbrains.jsonSchema.impl.JsonBySchemaHeavyCompletionTest"}, {"methodBody": ["METHOD_START", "{", "baseCompletionTest (  \" oneOfWithEnumValue \"  ,     \" oneOfWithEmptyPropertyValue \"  ,     \"  \\  \" business \\  \"  \"  ,     \"  \\  \" home \\  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testOneOfWithNotFilledPropertyValue"], "fileName": "com.jetbrains.jsonSchema.impl.JsonBySchemaHeavyCompletionTest"}, {"methodBody": ["METHOD_START", "{", "baseInsertTest (  \" insertPropertyName \"  ,     \" testStringTypeComma \"  )  ;", "}", "METHOD_END"], "methodName": ["testStringTypeComma"], "fileName": "com.jetbrains.jsonSchema.impl.JsonBySchemaHeavyCompletionTest"}, {"methodBody": ["METHOD_START", "{", "JsonValue   value    =     (  ( JsonFile )     ( catalog )  )  . getTopLevelValue (  )  ;", "if    (  !  ( value   instanceof   JsonObject )  )", "return   null ;", "JsonProperty   schemas    =     (  ( JsonObject )     ( value )  )  . findProperty (  \" schemas \"  )  ;", "if    ( schemas    =  =    null )", "return   null ;", "JsonValue   schemasValue    =    schemas . getValue (  )  ;", "if    (  !  ( schemasValue   instanceof   JsonArray )  )", "return   null ;", "List < Pair < Collection < String >  ,    String >  >    catalogMap    =    ContainerUtil . newArrayList (  )  ;", ". fillMap (  (  ( JsonArray )     ( schemasValue )  )  ,    catalogMap )  ;", "return   catalogMap ;", "}", "METHOD_END"], "methodName": ["computeSchemaCatalog"], "fileName": "com.jetbrains.jsonSchema.impl.JsonCachedValues"}, {"methodBody": ["METHOD_START", "{", "final   JsonObject   topLevelValue    =    ObjectUtils . tryCast (  (  ( JsonFile )     ( f )  )  . getTopLevelValue (  )  ,    JsonObject . class )  ;", "if    ( topLevelValue    !  =    null )     {", "return   new   JReader (  )  . read ( topLevelValue )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["computeSchemaObject"], "fileName": "com.jetbrains.jsonSchema.impl.JsonCachedValues"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( f   instanceof   JsonFile )  )", "return   null ;", "JsonValue   topLevelValue    =     (  ( JsonFile )     ( f )  )  . getTopLevelValue (  )  ;", "if    (  !  ( topLevelValue   instanceof   JsonObject )  )", "return   null ;", "JsonProperty   s =     (  ( JsonObject )     ( topLevelValue )  )  . findProperty (  \"  $ s )  ;", "if    ( s =  =    null )", "return   null ;", "JsonValue   value    =    sgetValue (  )  ;", "return   value   instanceof   JsonStringLiteral    ?    StringUtil . trimEnd (  (  ( JsonStringLiteral )     ( value )  )  . getValue (  )  ,     \"  #  \"  )     :    null ;", "}", "METHOD_END"], "methodName": ["fetchSchemaUrl"], "fileName": "com.jetbrains.jsonSchema.impl.JsonCachedValues"}, {"methodBody": ["METHOD_START", "{", "for    ( JsonValue   value    :    array . getValueList (  )  )     {", "if    (  !  ( value   instanceof   JsonObject )  )", "continue ;", "JsonProperty   fileMatch    =     (  ( JsonObject )     ( value )  )  . findProperty (  \" fileMatch \"  )  ;", "if    ( fileMatch    =  =    null )", "continue ;", "Collection < String >    masks    =     . resolveMasks ( fileMatch . getValue (  )  )  ;", "JsonProperty   url    =     (  ( JsonObject )     ( value )  )  . findProperty (  \" url \"  )  ;", "if    ( url    !  =    null )     {", "JsonValue   urlValue    =    url . getValue (  )  ;", "if    ( urlValue   instanceof   JsonStringLiteral )     {", "String   urlStringValue    =     (  ( JsonStringLiteral )     ( urlValue )  )  . getValue (  )  ;", "if    (  !  ( StringUtil . isEmpty ( urlStringValue )  )  )     {", "catalogMap . add ( Pair . create ( masks ,    urlStringValue )  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["fillMap"], "fileName": "com.jetbrains.jsonSchema.impl.JsonCachedValues"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( catalog . isValid (  )  )  )", "return   null ;", "final   PsiFile   psiFile    =     . resolveFile ( catalog ,    project )  ;", "if    (  !  ( psiFile   instanceof   JsonFile )  )", "return   null ;", "return   CachedValueProviderOnPsiFile . getOrCompute ( psiFile ,     :  : computeSchemaCatalog ,     . SCHEMA _ CATALOG _ CACHE _ KEY )  ;", "}", "METHOD_END"], "methodName": ["getSchemaCatalog"], "fileName": "com.jetbrains.jsonSchema.impl.JsonCachedValues"}, {"methodBody": ["METHOD_START", "{", "String   schemaUrl    =    JsonCachedValues . getSchemaUrlFromSchemaProperty ( file ,    project )  ;", "if    ( schemaUrl    !  =    null )     {", "VirtualFile   virtualFile    =    JsonFileResolver . resolveSchemaByReference ( file ,    schemaUrl )  ;", "if    ( virtualFile    !  =    null )", "return   virtualFile ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getSchemaFileFromSchemaProperty"], "fileName": "com.jetbrains.jsonSchema.impl.JsonCachedValues"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( schemaFile . isValid (  )  )  )", "return   null ;", "final   PsiFile   psiFile    =     . resolveFile ( schemaFile ,    project )  ;", "if    (  !  ( psiFile   instanceof   JsonFile )  )", "return   null ;", "return   CachedValueProviderOnPsiFile . getOrCompute ( psiFile ,     :  : getSchemaId ,     . SCHEMA _ ID _ CACHE _ KEY )  ;", "}", "METHOD_END"], "methodName": ["getSchemaId"], "fileName": "com.jetbrains.jsonSchema.impl.JsonCachedValues"}, {"methodBody": ["METHOD_START", "{", "final   JsonObject   topLevelValue    =    ObjectUtils . tryCast (  (  ( JsonFile )     ( psiFile )  )  . getTopLevelValue (  )  ,    JsonObject . class )  ;", "return   topLevelValue    =  =    null    ?    null    :     . readId ( topLevelValue )  ;", "}", "METHOD_END"], "methodName": ["getSchemaId"], "fileName": "com.jetbrains.jsonSchema.impl.JsonCachedValues"}, {"methodBody": ["METHOD_START", "{", "JsonFileResolver . startFetchingHttpFileIfNeeded ( schemaFile )  ;", "final   PsiFile   psiFile    =     . resolveFile ( schemaFile ,    project )  ;", "if    (  !  ( psiFile   instanceof   JsonFile )  )", "return   null ;", "return   CachedValueProviderOnPsiFile . getOrCompute ( psiFile ,     :  : computeSchemaObject ,     . JSON _ OBJECT _ CACHE _ KEY )  ;", "}", "METHOD_END"], "methodName": ["getSchemaObject"], "fileName": "com.jetbrains.jsonSchema.impl.JsonCachedValues"}, {"methodBody": ["METHOD_START", "{", "PsiFile   psiFile    =    JsonCachedValues . resolveFile ( file ,    project )  ;", "return    !  ( psiFile   instanceof   JsonFile )     ?    null    :    CachedValueProviderOnPsiFile . getOrCompute ( psiFile ,    JsonCachedValues :  : fetchSchemaUrl ,    JsonCachedValues . SCHEMA _ URL _ KEY )  ;", "}", "METHOD_END"], "methodName": ["getSchemaUrlFromSchemaProperty"], "fileName": "com.jetbrains.jsonSchema.impl.JsonCachedValues"}, {"methodBody": ["METHOD_START", "{", "String   idPropertyV 6     =    JsonCachedValues . readIdProperty ( object ,     \"  $ id \"  )  ;", "if    ( idPropertyV 6     !  =    null )", "return   idPropertyV 6  ;", "return   JsonCachedValues . readIdProperty ( object ,     \" id \"  )  ;", "}", "METHOD_END"], "methodName": ["readId"], "fileName": "com.jetbrains.jsonSchema.impl.JsonCachedValues"}, {"methodBody": ["METHOD_START", "{", "final   JsonProperty   property    =    object . findProperty ( id )  ;", "if    (  ( property    !  =    null )     &  &     (  ( property . getValue (  )  )    instanceof   JsonStringLiteral )  )     {", "return   JService . normalizeId ( StringUtil . unquoteString ( property . getValue (  )  . getText (  )  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["readIdProperty"], "fileName": "com.jetbrains.jsonSchema.impl.JsonCachedValues"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( file . isValid (  )  )  )", "return   null ;", "return   PsiManager . getInstance ( project )  . findFile ( file )  ;", "}", "METHOD_END"], "methodName": ["resolveFile"], "fileName": "com.jetbrains.jsonSchema.impl.JsonCachedValues"}, {"methodBody": ["METHOD_START", "{", "if    ( value   instanceof   JsonStringLiteral )     {", "return   ContainerUtil . createMaybeSingletonList (  (  ( JsonStringLiteral )     ( value )  )  . get (  )  )  ;", "}", "if    ( value   instanceof   JsonArray )     {", "List < String >    strings    =    ContainerUtil . newArrayList (  )  ;", "for    ( Json   val    :     (  ( JsonArray )     ( value )  )  . getList (  )  )     {", "if    ( val   instanceof   JsonStringLiteral )     {", "strings . add (  (  ( JsonStringLiteral )     ( val )  )  . get (  )  )  ;", "}", "}", "return   strings ;", "}", "return   ContainerUtil . emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["resolveMasks"], "fileName": "com.jetbrains.jsonSchema.impl.JsonCachedValues"}, {"methodBody": ["METHOD_START", "{", "PsiElement   parent    =    element . getParent (  )  ;", "return    (  ( parent    !  =    null )     &  &     (  ( element   instanceof   JsonElement )     |  |     (  ( element   instanceof   LeafPsiElement )     &  &     ( parent   instanceof   JsonElement )  )  )  )     &  &     ( JsonDialectUtil . isStandardJson ( CompletionUtil . getOrSelf ( parent )  )  )  ;", "}", "METHOD_END"], "methodName": ["handles"], "fileName": "com.jetbrains.jsonSchema.impl.JsonOriginalPsiWalker"}, {"methodBody": ["METHOD_START", "{", "final   JsonSchemaType   matchingSchemaType    =    JsonSchemaAnnotatorChecker . getMatchingSchemaType ( schema ,    type )  ;", "if    ( matchingSchemaType    !  =    null )", "return   matchingSchemaType . equals ( type )  ;", "if    (  ( schema . getEnum (  )  )     !  =    null )     {", "return   JsonSchemaAnnotatorChecker . PRIMITIVE _ TYPES . contains ( type )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["areSchemaTypesCompatible"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "final   JsonArrayValueAdapter   asArray    =    value . getAsArray (  )  ;", "if    ( asArray    =  =    null )", "return ;", "final   List < JsonValueAdapter >    elements    =    asArray . getElements (  )  ;", "if    (  (  ( sgetMinLength (  )  )     !  =    null )     &  &     (  ( elements . size (  )  )     <     ( sgetMinLength (  )  )  )  )     {", "error (  (  \" Array   is   shorter   than    \"     +     ( sgetMinLength (  )  )  )  ,    value . getDelegate (  )  )  ;", "return ;", "}", "checkArrayItems ( value ,    elements ,    s ;", "}", "METHOD_END"], "methodName": ["checkArray"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "if    ( schema . isUniqueItems (  )  )     {", "final   MultiMap < String ,    JsonValueAdapter >    valueTexts    =    new   MultiMap (  )  ;", "for    ( JsonValueAdapter   adapter    :    list )     {", "valueTexts . putValue ( adapter . getDelegate (  )  . getText (  )  ,    adapter )  ;", "}", "for    ( Map . Entry < String ,    Collection < JsonValueAdapter >  >    entry    :    valueTexts . entrySet (  )  )     {", "if    (  ( entry . getValue (  )  . size (  )  )     >     1  )     {", "for    ( JsonValueAdapter   item    :    entry . getValue (  )  )     {", "error (  \" Item   is   not   unique \"  ,    item . getDelegate (  )  )  ;", "}", "}", "}", "}", "if    (  ( schema . getContainsSchema (  )  )     !  =    null )     {", "boolean   match    =    false ;", "for    ( JsonValueAdapter   item    :    list )     {", "final      checker    =     . checkByMatchResult ( item ,    new   JsonSchemaResolver ( schema . getContainsSchema (  )  )  . detailedResolve (  )  )  ;", "if    (  ( checker    =  =    null )     |  |     (  (  ( checker . myErrors . size (  )  )     =  =     0  )     &  &     (  !  ( checker . myHadTypeError )  )  )  )     {", "match    =    true ;", "break ;", "}", "}", "if    (  ! match )     {", "error (  \" No   match   for    ' contains '    rule \"  ,    array . getDelegate (  )  )  ;", "}", "}", "if    (  ( schema . getItemsSchema (  )  )     !  =    null )     {", "for    ( JsonValueAdapter   item    :    list )     {", "checkObjectBySchemaRecordErrors ( schema . getItemsSchema (  )  ,    item )  ;", "}", "} else", "if    (  ( schema . getItemsSchemaList (  )  )     !  =    null )     {", "final   Iterator < JsonSchemaObject >    iterator    =    schema . getItemsSchemaList (  )  . iterator (  )  ;", "for    ( JsonValueAdapter   arrayValue    :    list )     {", "if    ( iterator . hasNext (  )  )     {", "checkObjectBySchemaRecordErrors ( iterator . next (  )  ,    arrayValue )  ;", "} else    {", "if    (  !  ( Boolean . TRUE . equals ( schema . getAdditionalItemsAllowed (  )  )  )  )     {", "error (  \" Additional   items   are   not   allowed \"  ,    arrayValue . getDelegate (  )  )  ;", "} else", "if    (  ( schema . getAdditionalItemsSchema (  )  )     !  =    null )     {", "checkObjectBySchemaRecordErrors ( schema . getAdditionalItemsSchema (  )  ,    arrayValue )  ;", "}", "}", "}", "}", "if    (  (  ( schema . getMinItems (  )  )     !  =    null )     &  &     (  ( list . size (  )  )     <     ( schema . getMinItems (  )  )  )  )     {", "error (  (  \" Array   is   shorter   than    \"     +     ( schema . getMinItems (  )  )  )  ,    array . getDelegate (  )  )  ;", "}", "if    (  (  ( schema . getMaxItems (  )  )     !  =    null )     &  &     (  ( list . size (  )  )     >     ( schema . getMaxItems (  )  )  )  )     {", "error (  (  \" Array   is   longer   than    \"     +     ( schema . getMaxItems (  )  )  )  ,    array . getDelegate (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkArrayItems"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "final   List < JsonSchemaAnnotatorChecker >    checkers    =    new   ArrayList <  >  (  )  ;", "if    (  ( result . myExcludingSchemas . isEmpty (  )  )     &  &     (  ( result . mySchemas . size (  )  )     =  =     1  )  )     {", "final   JsonSchemaAnnotatorChecker   checker    =    new   JsonSchemaAnnotatorChecker (  )  ;", "checker . checkByScheme ( elementToCheck ,    result . mySchemas . iterator (  )  . next (  )  )  ;", "checkers . add ( checker )  ;", "} else    {", "if    (  !  ( result . mySchemas . isEmpty (  )  )  )     {", "checkers . add ( JsonSchemaAnnotatorChecker . processSchemasVariants ( result . mySchemas ,    elementToCheck ,    false )  . getSecond (  )  )  ;", "}", "if    (  !  ( result . myExcludingSchemas . isEmpty (  )  )  )     {", "final   List < JsonSchemaObject >    selectedSchemas    =    new   com . intellij . util . SmartList (  )  ;", "final   List < JsonSchemaAnnotatorChecker >    list    =    result . myExcludingSchemas . stream (  )  . map (  (    group )     -  >     {", "final   Pair < JsonSchemaObject ,    JsonSchemaAnnotatorChecker >    pair    =    JsonSchemaAnnotatorChecker . processSchemasVariants ( group ,    elementToCheck ,    true )  ;", "if    (  ( pair . getFirst (  )  )     !  =    null )", "selectedSchemas . add ( pair . getFirst (  )  )  ;", "return   pair . getSecond (  )  ;", "}  )  . collect ( Collectors . toList (  )  )  ;", "checkers . add ( JsonSchemaAnnotatorChecker . mergeErrors ( list ,    selectedSchemas )  )  ;", "}", "}", "if    ( checkers . isEmpty (  )  )", "return   null ;", "if    (  ( checkers . size (  )  )     =  =     1  )", "return   checkers . get (  0  )  ;", "return   checkers . stream (  )  . filter (  (    checker )     -  >     !  ( checker . isHadTypeError (  )  )  )  . findFirst (  )  . orElse ( checkers . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["checkByMatchResult"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "final   JsonSchemaType   type    =    JsonSchemaType . getType ( value )  ;", "if    ( type    !  =    null )     {", "JsonSchemaType   schemaType    =     . getMatchingSchemaType ( schema ,    type )  ;", "if    (  ( schemaType    !  =    null )     &  &     (  !  ( schemaType . equals ( type )  )  )  )     {", "typeError ( value . getDelegate (  )  ,    schemaType )  ;", "} else    {", "if    ( JsonSchemaType .  _ boolean . equals ( type )  )     {", "checkForEnum ( value . getDelegate (  )  ,    schema )  ;", "} else", "if    (  ( JsonSchemaType .  _ number . equals ( type )  )     |  |     ( JsonSchemaType .  _ integer . equals ( type )  )  )     {", "checkNumber ( value . getDelegate (  )  ,    schema ,    type )  ;", "checkForEnum ( value . getDelegate (  )  ,    schema )  ;", "} else", "if    ( JsonSchemaType .  _ string . equals ( type )  )     {", "checkString ( value . getDelegate (  )  ,    schema )  ;", "checkForEnum ( value . getDelegate (  )  ,    schema )  ;", "} else", "if    ( JsonSchemaType .  _ array . equals ( type )  )     {", "checkArray ( value ,    schema )  ;", "checkForEnum ( value . getDelegate (  )  ,    schema )  ;", "} else", "if    ( JsonSchemaType .  _ object . equals ( type )  )     {", "checkObject ( value ,    schema )  ;", "checkForEnum ( value . getDelegate (  )  ,    schema )  ;", "}", "}", "}", "if    (  (  (  !  ( myHadTypeError )  )     |  |     ( myErrors . isEmpty (  )  )  )     &  &     (  !  ( value . isShouldBeIgnored (  )  )  )  )     {", "PsiElement   delegate    =    value . getDelegate (  )  ;", "checkForEnum ( delegate ,    schema )  ;", "if    (  (  . hasNumberChecks ( schema )  )     &  &     ( value . isNumberLiteral (  )  )  )     {", "checkNumber ( delegate ,    schema ,    JsonSchemaType .  _ number )  ;", "}", "if    (  (  . hasStringChecks ( schema )  )     &  &     ( value . isStringLiteral (  )  )  )     {", "checkString ( delegate ,    schema )  ;", "}", "if    (  (  . hasArrayChecks ( schema )  )     &  &     ( value . isArray (  )  )  )     {", "checkArray ( value ,    schema )  ;", "}", "if    (  . hasMinMaxLengthChecks ( schema )  )     {", "if    ( value . isStringLiteral (  )  )     {", "checkString ( delegate ,    schema )  ;", "} else", "if    ( value . isArray (  )  )     {", "checkArray ( value ,    schema )  ;", "}", "}", "if    (  (  . hasObjectChecks ( schema )  )     &  &     ( value . isObject (  )  )  )     {", "checkObject ( value ,    schema )  ;", "}", "}", "if    (  ( schema . getNot (  )  )     !  =    null )     {", "final   MatchResult   result    =    new   JsonSchemaResolver ( schema . getNot (  )  )  . detailedResolve (  )  ;", "if    (  ( result . mySchemas . isEmpty (  )  )     &  &     ( result . myExcludingSchemas . isEmpty (  )  )  )", "return ;", "if    (  ( result . mySchemas . stream (  )  . anyMatch (  (    s )     -  >    schema . getJsonObject (  )  . equals ( s . getJsonObject (  )  )  )  )     |  |     ( result . myExcludingSchemas . stream (  )  . flatMap ( Collection :  : stream )  . anyMatch (  (    s )     -  >    schema . getJsonObject (  )  . equals ( s . getJsonObject (  )  )  )  )  )", "return ;", "final      checker    =     . checkByMatchResult ( value ,    result )  ;", "if    (  ( checker    =  =    null )     |  |     ( checker . isCorrect (  )  )  )", "error (  \" Validates   against    ' not '    schema \"  ,    value . getDelegate (  )  )  ;", "}", "if    (  ( schema . getIf (  )  )     !  =    null )     {", "MatchResult   result    =    new   JsonSchemaResolver ( schema . getIf (  )  )  . detailedResolve (  )  ;", "if    (  ( result . mySchemas . isEmpty (  )  )     &  &     ( result . myExcludingSchemas . isEmpty (  )  )  )", "return ;", "final      checker    =     . checkByMatchResult ( value ,    result )  ;", "if    ( checker    !  =    null )     {", "if    ( checker . isCorrect (  )  )     {", "JsonSchemaObject   then    =    schema . getThen (  )  ;", "if    ( then    =  =    null )     {", "error (  \" Validates   against    ' if '    branch   but   no    ' then '    branch   is   present \"  ,    value . getDelegate (  )  )  ;", "} else    {", "checkObjectBySchemaRecordErrors ( then ,    value )  ;", "}", "} else    {", "JsonSchemaObject   schemaElse    =    schema . getElse (  )  ;", "if    ( schemaElse    =  =    null )     {", "error (  \" Validates   counter    ' if '    branch   but   no    ' else '    branch   is   present \"  ,    value . getDelegate (  )  )  ;", "} else    {", "checkObjectBySchemaRecordErrors ( schemaElse ,    value )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["checkByScheme"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( schema . getEnum (  )  )     =  =    null )     |  |     (  ( schema . getPattern (  )  )     !  =    null )  )", "return ;", "final   JsonLikePsiWalker   walker    =    JsonLikePsiWalker . getWalker ( value ,    schema )  ;", "if    ( walker    =  =    null )", "return ;", "final   String   text    =    StringUtil . notNullize ( value . getText (  )  )  ;", "final   List < Object >    objects    =    schema . getEnum (  )  ;", "for    ( Object   object    :    objects )     {", "if    ( walker . onlyDoubleQuotesForStringLiterals (  )  )     {", "if    ( object . toString (  )  . equalsIgnoreCase ( text )  )", "return ;", "} else    {", "if    (  . equalsIgnoreQuotesAndCase ( object . toString (  )  ,    text )  )", "return ;", "}", "}", "error (  (  (  \" Value   should   be   one   of :     [  \"     +     ( StringUtil . join ( objects ,     (    o )     -  >    o . toString (  )  ,     \"  ,     \"  )  )  )     +     \"  ]  \"  )  ,    value )  ;", "}", "METHOD_END"], "methodName": ["checkForEnum"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "Number   exclusiveMaximumNumber    =    schema . getExclusiveMaximumNumber (  )  ;", "if    ( exclusiveMaximumNumber    !  =    null )     {", "if    ( Type .  _ integer . equals ( propValueType )  )     {", "final      intValue    =    exclusiveMaximumNumber . intValue (  )  ;", "if    (  ( value . intValue (  )  )     >  =    intValue )     {", "error (  (  \" Greater   than   an   exclusive   maximum    \"     +    intValue )  ,    propertyValue )  ;", "}", "} else    {", "final   double   doubleValue    =    exclusiveMaximumNumber . doubleValue (  )  ;", "if    (  ( value . doubleValue (  )  )     >  =    doubleValue )     {", "error (  (  \" Greater   than   an   exclusive   maximum    \"     +    exclusiveMaximumNumber )  ,    propertyValue )  ;", "}", "}", "}", "Number   maximum    =    schema . getMaximum (  )  ;", "if    ( maximum    =  =    null )", "return ;", "boolean   isExclusive    =    Boolean . TRUE . equals ( schema . isExclusiveMaximum (  )  )  ;", "if    ( Type .  _ integer . equals ( propValueType )  )     {", "final      intValue    =    maximum . intValue (  )  ;", "if    ( isExclusive )     {", "if    (  ( value . intValue (  )  )     >  =    intValue )     {", "error (  (  \" Greater   than   an   exclusive   maximum    \"     +    intValue )  ,    propertyValue )  ;", "}", "} else    {", "if    (  ( value . intValue (  )  )     >    intValue )     {", "error (  (  \" Greater   than   a   maximum    \"     +    intValue )  ,    propertyValue )  ;", "}", "}", "} else    {", "final   double   doubleValue    =    maximum . doubleValue (  )  ;", "if    ( isExclusive )     {", "if    (  ( value . doubleValue (  )  )     >  =    doubleValue )     {", "error (  (  \" Greater   than   an   exclusive   maximum    \"     +    maximum )  ,    propertyValue )  ;", "}", "} else    {", "if    (  ( value . doubleValue (  )  )     >    doubleValue )     {", "error (  (  \" Greater   than   a   maximum    \"     +    maximum )  ,    propertyValue )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["checkMaximum"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "Number   exclusiveMinimumNumber    =    schema . getExclusiveMinimumNumber (  )  ;", "if    ( exclusiveMinimumNumber    !  =    null )     {", "if    ( Type .  _ integer . equals ( schemaType )  )     {", "final      intValue    =    exclusiveMinimumNumber . intValue (  )  ;", "if    (  ( value . intValue (  )  )     <  =    intValue )     {", "error (  (  \" Less   than   an   exclusive   minimum \"     +    intValue )  ,    propertyValue )  ;", "}", "} else    {", "final   double   doubleValue    =    exclusiveMinimumNumber . doubleValue (  )  ;", "if    (  ( value . doubleValue (  )  )     <  =    doubleValue )     {", "error (  (  \" Less   than   an   exclusive   minimum    \"     +    exclusiveMinimumNumber )  ,    propertyValue )  ;", "}", "}", "}", "Number   minimum    =    schema . getMinimum (  )  ;", "if    ( minimum    =  =    null )", "return ;", "boolean   isExclusive    =    Boolean . TRUE . equals ( schema . isExclusiveMinimum (  )  )  ;", "if    ( Type .  _ integer . equals ( schemaType )  )     {", "final      intValue    =    minimum . intValue (  )  ;", "if    ( isExclusive )     {", "if    (  ( value . intValue (  )  )     <  =    intValue )     {", "error (  (  \" Less   than   an   exclusive   minimum    \"     +    intValue )  ,    propertyValue )  ;", "}", "} else    {", "if    (  ( value . intValue (  )  )     <    intValue )     {", "error (  (  \" Less   than   a   minimum    \"     +    intValue )  ,    propertyValue )  ;", "}", "}", "} else    {", "final   double   doubleValue    =    minimum . doubleValue (  )  ;", "if    ( isExclusive )     {", "if    (  ( value . doubleValue (  )  )     <  =    doubleValue )     {", "error (  (  \" Less   than   an   exclusive   minimum    \"     +    minimum )  ,    propertyValue )  ;", "}", "} else    {", "if    (  ( value . doubleValue (  )  )     <    doubleValue )     {", "error (  (  \" Less   than   a   minimum    \"     +    minimum )  ,    propertyValue )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["checkMinimum"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "Number   value ;", "if    ( Type .  _ integer . equals ( schemaType )  )     {", "try    {", "value    =    Integer . valueOf ( propValue . getText (  )  )  ;", "}    catch    ( NumberFormatException   e )     {", "error (  \" Integer   value   expected \"  ,    propValue )  ;", "return ;", "}", "} else    {", "try    {", "value    =    Double . valueOf ( propValue . getText (  )  )  ;", "}    catch    ( NumberFormatException   e )     {", "error (  \" Double   value   expected \"  ,    propValue )  ;", "return ;", "}", "}", "final   Number   multipleOf    =    schema . getMultipleOf (  )  ;", "if    ( multipleOf    !  =    null )     {", "final   double   leftOver    =     ( value . doubleValue (  )  )     %     ( multipleOf . doubleValue (  )  )  ;", "if    ( leftOver    >     1  .  0 E -  6  )     {", "final   String   multipleOfValue    =    String . valueOf (  (  ( Math . abs (  (  ( multipleOf . doubleValue (  )  )     -     ( multipleOf . intValue (  )  )  )  )  )     <     1  .  0 E -  6     ?    multipleOf . intValue (  )     :    multipleOf )  )  ;", "error (  (  \" Is   not   multiple   of    \"     +    multipleOfValue )  ,    propValue )  ;", "return ;", "}", "}", "checkMinimum ( schema ,    value ,    propValue ,    schemaType )  ;", "checkMaximum ( schema ,    value ,    propValue ,    schemaType )  ;", "}", "METHOD_END"], "methodName": ["checkNumber"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "final   JsonObjectValueAdapter   object    =    value . getAsObject (  )  ;", "if    ( object    =  =    null )", "return ;", "final   List < JsonPropertyAdapter >    propertyList    =    object . getPropertyList (  )  ;", "final   Set < String >    set    =    new   HashSet <  >  (  )  ;", "for    ( JsonPropertyAdapter   property    :    propertyList )     {", "final   String   name    =    StringUtil . notNullize ( property . getName (  )  )  ;", "Object   propertyNamesSchema    =    schema . getPropertyNamesSchema (  )  ;", "if    ( propertyNamesSchema    !  =    null )     {", "JsonValueAdapter   nameValueAdapter    =    property . getNameValueAdapter (  )  ;", "if    ( nameValueAdapter    !  =    null )     {", "checkByScheme ( nameValueAdapter ,    propertyNamesSchema )  ;", "}", "}", "final   VariantsTreeBuilder . Step   step    =    VariantsTreeBuilder . Step . createPropertyStep ( name )  ;", "final   Pair < ThreeState ,    Object >    pair    =    step . step ( schema ,    true )  ;", "if    (  ( NO . equals ( pair . getFirst (  )  )  )     &  &     (  !  ( set . contains ( name )  )  )  )     {", "error ( JsonBundle . message (  \" json . schema . annotation . not . allowed . property \"  ,    name )  ,    property . getDelegate (  )  )  ;", "} else", "if    (  ( ThreeState . UNSURE . equals ( pair . getFirst (  )  )  )     &  &     (  ( property . getValue (  )  )     !  =    null )  )     {", "checkObjectBySchemaRecordErrors ( pair . getSecond (  )  ,    property . getValue (  )  )  ;", "}", "set . add ( name )  ;", "}", "if    ( object . shouldCheckIntegralRequirements (  )  )     {", "final   List < String >    required    =    schema . getRequired (  )  ;", "if    ( required    !  =    null )     {", "for    ( String   req    :    required )     {", "if    (  !  ( set . contains ( req )  )  )     {", "error (  (  (  \" Missing   required   property    '  \"     +    req )     +     \"  '  \"  )  ,    value . getDelegate (  )  )  ;", "}", "}", "}", "if    (  (  ( schema . getMinProperties (  )  )     !  =    null )     &  &     (  ( propertyList . size (  )  )     <     ( schema . getMinProperties (  )  )  )  )     {", "error (  (  \" Number   of   properties   is   less   than    \"     +     ( schema . getMinProperties (  )  )  )  ,    value . getDelegate (  )  )  ;", "}", "if    (  (  ( schema . getMaxProperties (  )  )     !  =    null )     &  &     (  ( propertyList . size (  )  )     >     ( schema . getMaxProperties (  )  )  )  )     {", "error (  (  \" Number   of   properties   is   greater   than    \"     +     ( schema . getMaxProperties (  )  )  )  ,    value . getDelegate (  )  )  ;", "}", "final   Map < String ,    List < String >  >    dependencies    =    schema . getPropertyDependencies (  )  ;", "if    ( dependencies    !  =    null )     {", "for    ( Map . Entry < String ,    List < String >  >    entry    :    dependencies . entrySet (  )  )     {", "if    ( set . contains ( entry . getKey (  )  )  )     {", "final   List < String >    list    =    entry . getValue (  )  ;", "for    ( String   s    :    list )     {", "if    (  !  ( set . contains ( s )  )  )     {", "error (  (  (  (  (  \" Dependency   is   violated :     '  \"     +    s )     +     \"  '    must   be   specified ,    since    '  \"  )     +     ( entry . getKey (  )  )  )     +     \"  '    is   specified \"  )  ,    value . getDelegate (  )  )  ;", "}", "}", "}", "}", "}", "final   Map < String ,    Object >    schemaDependencies    =    schema . getSchemaDependencies (  )  ;", "if    ( schemaDependencies    !  =    null )     {", "for    ( Map . Entry < String ,    Object >    entry    :    schemaDependencies . entrySet (  )  )     {", "if    ( set . contains ( entry . getKey (  )  )  )     {", "checkObjectBySchemaRecordErrors ( entry . getValue (  )  ,    value )  ;", "}", "}", "}", "}", "validateAs ( object . getDelegate (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkObject"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "final   JsonSchemaAnnotatorChecker   checker    =    JsonSchemaAnnotatorChecker . checkByMatchResult ( object ,    new   JsonSchemaResolver ( schema )  . detailedResolve (  )  )  ;", "if    ( checker    !  =    null )     {", "myHadTypeError    =    checker . isHadTypeError (  )  ;", "myErrors . putAll ( checker . getErrors (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkObjectBySchemaRecordErrors"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "final   String   value    =    StringUtil . unquoteString ( propValue . getText (  )  )  ;", "if    (  ( sgetMinLength (  )  )     !  =    null )     {", "if    (  ( value . length (  )  )     <     ( sgetMinLength (  )  )  )     {", "error (  (  \" String   is   shorter   than    \"     +     ( sgetMinLength (  )  )  )  ,    propValue )  ;", "return ;", "}", "}", "if    (  ( sgetMaxLength (  )  )     !  =    null )     {", "if    (  ( value . length (  )  )     >     ( sgetMaxLength (  )  )  )     {", "error (  (  \" String   is   longer   than    \"     +     ( sgetMaxLength (  )  )  )  ,    propValue )  ;", "return ;", "}", "}", "if    (  ( sgetPattern (  )  )     !  =    null )     {", "if    (  ( sgetPatternError (  )  )     !  =    null )     {", "error (  (  \" Can   not   check   string   by   pattern   because   of   error :     \"     +     ( StringUtil . convertLineSeparators ( sgetPatternError (  )  )  )  )  ,    propValue )  ;", "}", "if    (  !  ( scheckByPattern ( value )  )  )     {", "error (  (  (  \" String   is   violating   the   pattern :     '  \"     +     ( StringUtil . convertLineSeparators ( sgetPattern (  )  )  )  )     +     \"  '  \"  )  ,    propValue )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkString"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "final   boolean   quoted 1     =    StringUtil . isQuotedString ( s 1  )  ;", "final   boolean   quoted 2     =    StringUtil . isQuotedString ( s 2  )  ;", "if    ( quoted 1     !  =    quoted 2  )", "return   false ;", "if    (  ! quoted 1  )", "return   s 1  . equalsIgnoreCase ( s 2  )  ;", "return   StringUtil . unquoteString ( s 1  )  . equalsIgnoreCase ( StringUtil . unquoteString ( s 2  )  )  ;", "}", "METHOD_END"], "methodName": ["equalsIgnoreQuotesAndCase"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "if    ( myErrors . containsKey ( holder )  )", "return ;", "myErrors . put ( holder ,    error )  ;", "}", "METHOD_END"], "methodName": ["error"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "return   myErrors ;", "}", "METHOD_END"], "methodName": ["getErrors"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "final   List < JsonSchemaType >    list    =    new   ArrayList <  >  (  )  ;", "for    ( JsonSchemaObject   schema    :    schemas )     {", "final   JsonSchemaType   type    =    schema . getType (  )  ;", "if    ( type    !  =    null )     {", "list . add ( type )  ;", "} else    {", "final   List < JsonSchemaType >    variants    =    schema . getTypeVariants (  )  ;", "if    ( variants    !  =    null )     {", "list . addAll ( variants )  ;", "}", "}", "}", "return   list . isEmpty (  )     ?     . NO _ TYPES    :    list . toArray (  . NO _ TYPES )  ;", "}", "METHOD_END"], "methodName": ["getExpectedTypes"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "if    (  ( schema . getType (  )  )     !  =    null )     {", "final   Type   matchType    =    schema . getType (  )  ;", "if    ( matchType    !  =    null )     {", "if    (  ( Type .  _ integer . equals ( input )  )     &  &     ( Type .  _ number . equals ( matchType )  )  )     {", "return   input ;", "}", "return   matchType ;", "}", "}", "if    (  ( schema . getTypeVariants (  )  )     !  =    null )     {", "List < Type >    matchTypes    =    schema . getTypeVariants (  )  ;", "if    ( matchTypes . contains ( input )  )     {", "return   input ;", "}", "if    (  ( Type .  _ integer . equals ( input )  )     &  &     ( matchTypes . contains ( Type .  _ number )  )  )     {", "return   input ;", "}", "return   matchTypes . get (  0  )  ;", "}", "if    (  (  !  ( schema . getProperties (  )  . isEmpty (  )  )  )     &  &     ( Type .  _ object . equals ( input )  )  )", "return   Type .  _ object ;", "return   null ;", "}", "METHOD_END"], "methodName": ["getMatchingSchemaType"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( schema . isUniqueItems (  )  )     |  |     (  ( schema . getContainsSchema (  )  )     !  =    null )  )     |  |     (  ( schema . getItemsSchema (  )  )     !  =    null )  )     |  |     (  ( schema . getItemsSchemaList (  )  )     !  =    null )  )     |  |     (  ( schema . getMinItems (  )  )     !  =    null )  )     |  |     (  ( schema . getMaxItems (  )  )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["hasArrayChecks"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "return    (  ( schema . getMinLength (  )  )     !  =    null )     |  |     (  ( schema . getMaxLength (  )  )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["hasMinMaxLengthChecks"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( schema . getMultipleOf (  )  )     !  =    null )     |  |     (  ( schema . getExclusiveMinimumNumber (  )  )     !  =    null )  )     |  |     (  ( schema . getExclusiveMaximumNumber (  )  )     !  =    null )  )     |  |     (  ( schema . getMaximum (  )  )     !  =    null )  )     |  |     (  ( schema . getMinimum (  )  )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["hasNumberChecks"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  (  !  ( schema . getProperties (  )  . isEmpty (  )  )  )     |  |     (  ( schema . getPropertyNamesSchema (  )  )     !  =    null )  )     |  |     (  ( schema . getPropertyDependencies (  )  )     !  =    null )  )     |  |     ( schema . hasPatternProperties (  )  )  )     |  |     (  ( schema . getRequired (  )  )     !  =    null )  )     |  |     (  ( schema . getMinProperties (  )  )     !  =    null )  )     |  |     (  ( schema . getMaxProperties (  )  )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["hasObjectChecks"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "return    (  ( schema . getPattern (  )  )     !  =    null )     |  |     (  ( schema . getFormat (  )  )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["hasStringChecks"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "return   myErrors . isEmpty (  )  ;", "}", "METHOD_END"], "methodName": ["isCorrect"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "return   myHadTypeError ;", "}", "METHOD_END"], "methodName": ["isHadTypeError"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "final   Set < String >    skipErrors    =    selectedSchemas . stream (  )  . filter ( Predicates . notNull (  )  )  . map (  (    schema )     -  >    schema . getProperties (  )  . keySet (  )  )  . flatMap ( Set :  : stream )  . map (  (    name )     -  >    JsonBundle . message (  \" json . schema . annotation . not . allowed . property \"  ,    name )  )  . collect ( Collectors . toSet (  )  )  ;", "final      checker    =    new    (  )  ;", "for    (    ch    :    list )     {", "for    ( Map . Entry < PsiElement ,    String >    element    :    ch . myErrors . entrySet (  )  )     {", "if    ( skipErrors . contains ( element . getValue (  )  )  )     {", "continue ;", "}", "checker . myErrors . put ( element . getKey (  )  ,    element . getValue (  )  )  ;", "}", "}", "return   checker ;", "}", "METHOD_END"], "methodName": ["mergeErrors"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "final   Map < PsiElement ,    String >    errors    =    new   HashMap <  >  (  )  ;", "JsonSchemaObject   current    =    null ;", "for    ( JsonSchemaObject   object    :    anyOf )     {", "final      checker    =    new    (  )  ;", "checker . checkByScheme ( value ,    object )  ;", "if    ( checker . isCorrect (  )  )     {", "return   object ;", "}", "if    (  ( errors . isEmpty (  )  )     &  &     (  !  ( checker . isHadTypeError (  )  )  )  )     {", "current    =    object ;", "errors . clear (  )  ;", "errors . putAll ( checker . getErrors (  )  )  ;", "}", "}", "if    (  !  ( errors . isEmpty (  )  )  )     {", "for    ( Map . Entry < PsiElement ,    String >    entry    :    errors . entrySet (  )  )     {", "error ( entry . getValue (  )  ,    entry . getKey (  )  )  ;", "}", "}", "return   current ;", "}", "METHOD_END"], "methodName": ["processAnyOf"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "final   Map < PsiElement ,    String >    errors    =    new   HashMap <  >  (  )  ;", "boolean   wasTypeError    =    false ;", "final   List < JsonSchemaObject >    correct    =    new   com . intellij . util . SmartList (  )  ;", "JsonSchemaObject   current    =    null ;", "for    ( JsonSchemaObject   object    :    oneOf )     {", "if    ( object . isShouldValidateAgainstJSType (  )  )", "continue ;", "final      checker    =    new    (  )  ;", "checker . checkByScheme ( value ,    object )  ;", "if    ( checker . isCorrect (  )  )     {", "current    =    object ;", "errors . clear (  )  ;", "correct . add ( object )  ;", "} else    {", "if    (  (  ( errors . isEmpty (  )  )     |  |     ( wasTypeError    &  &     (  !  ( checker . isHadTypeError (  )  )  )  )  )     |  |     (  ( errors . size (  )  )     >     ( checker . getErrors (  )  . size (  )  )  )  )     {", "wasTypeError    =    checker . isHadTypeError (  )  ;", "current    =    object ;", "errors . clear (  )  ;", "errors . putAll ( checker . getErrors (  )  )  ;", "}", "}", "}", "if    (  ( correct . size (  )  )     =  =     1  )", "return   current ;", "if    (  ( correct . size (  )  )     >     0  )     {", "final   JsonSchemaType   type    =    JsonSchemaType . getType ( value )  ;", "if    ( type    !  =    null )     {", "if    (  !  (  . schemesDifferWithNotCheckedProperties ( correct )  )  )     {", "error (  \" Validates   to   more   than   one   variant \"  ,    value . getDelegate (  )  )  ;", "}", "}", "} else    {", "if    (  !  ( errors . isEmpty (  )  )  )     {", "for    ( Map . Entry < PsiElement ,    String >    entry    :    errors . entrySet (  )  )     {", "error ( entry . getValue (  )  ,    entry . getKey (  )  )  ;", "}", "}", "}", "return   current ;", "}", "METHOD_END"], "methodName": ["processOneOf"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "final   JsonSchemaAnnotatorChecker   checker    =    new   JsonSchemaAnnotatorChecker (  )  ;", "final   JsonSchemaType   type    =    JsonSchemaType . getType ( value )  ;", "JsonSchemaObject   selected    =    null ;", "if    ( type    =  =    null )     {", "if    (  !  ( value . isShouldBeIgnored (  )  )  )", "checker . typeError ( value . getDelegate (  )  ,    JsonSchemaAnnotatorChecker . getExpectedTypes ( collection )  )  ;", "} else    {", "final   List < JsonSchemaObject >    filtered    =    ContainerUtil . newArrayListWithCapacity ( collection . size (  )  )  ;", "for    ( JsonSchemaObject   schema    :    collection )     {", "if    (  !  ( JsonSchemaAnnotatorChecker . areSchemaTypesCompatible ( schema ,    type )  )  )", "continue ;", "filtered . add ( schema )  ;", "}", "if    ( filtered . isEmpty (  )  )", "checker . typeError ( value . getDelegate (  )  ,    JsonSchemaAnnotatorChecker . getExpectedTypes ( collection )  )  ;", "else", "if    (  ( filtered . size (  )  )     =  =     1  )     {", "selected    =    filtered . get (  0  )  ;", "checker . checkByScheme ( value ,    selected )  ;", "} else    {", "if    ( isOneOf )     {", "selected    =    checker . processOneOf ( value ,    filtered )  ;", "} else    {", "selected    =    checker . processAnyOf ( value ,    filtered )  ;", "}", "}", "}", "return   Pair . create ( selected ,    checker )  ;", "}", "METHOD_END"], "methodName": ["processSchemasVariants"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "final   Map < JsonContainer ,    String >    invalidPatternProperties    =    schema . getInvalidPatternProperties (  )  ;", "if    ( invalidPatternProperties    =  =    null )", "return ;", "for    ( Map . Entry < JsonContainer ,    String >    entry    :    invalidPatternProperties . entrySet (  )  )     {", "final   JsonContainer   element    =    entry . getKey (  )  ;", "if    (  ( element    =  =    null )     |  |     (  !  ( element . isValid (  )  )  )  )", "continue ;", "final   PsiElement   parent    =    element . getParent (  )  ;", "if    ( parent   instanceof   JsonProperty )     {", "error ( StringUtil . convertLineSeparators ( entry . getValue (  )  )  ,     (  ( JsonProperty )     ( parent )  )  . getNameElement (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["reportInvalidPatternProperties"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "for    ( JsonSchemaObject   prop    :    schema . getProperties (  )  . values (  )  )     {", "final   String   patternError    =    prop . getPatternError (  )  ;", "if    (  ( patternError    =  =    null )     |  |     (  ( prop . getPattern (  )  )     =  =    null )  )     {", "continue ;", "}", "final   JsonContainer   element    =    prop . getJsonObject (  )  ;", "if    (  (  !  ( element   instanceof   JsonObject )  )     |  |     (  !  ( element . isValid (  )  )  )  )     {", "continue ;", "}", "final   JsonProperty   pattern    =     (  ( JsonObject )     ( element )  )  . findProperty (  \" pattern \"  )  ;", "if    ( pattern    !  =    null )     {", "error ( StringUtil . convertLineSeparators ( patternError )  ,    pattern . getValue (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["reportPatternErrors"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "return   list . stream (  )  . anyMatch (  (    s )     -  >     !  ( StringUtil . isEmptyOrSpaces ( s . getFormat (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["schemesDifferWithNotCheckedProperties"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "final   Iterator < JsonSchemaVariantsTreeBuilder . Step >    iterator    =    position . iterator (  )  ;", "boolean   canSkip    =    true ;", "while    ( iterator . hasNext (  )  )     {", "final   JsonSchemaVariantsTreeBuilder . Step   step    =    iterator . next (  )  ;", "if    (  ( canSkip    &  &     ( step . isFromObject (  )  )  )     &  &     ( JsonSchemaObject . PROPERTIES . equals ( step . getName (  )  )  )  )     {", "iterator . remove (  )  ;", "canSkip    =    false ;", "} else    {", "canSkip    =    true ;", "}", "}", "return   position ;", "}", "METHOD_END"], "methodName": ["skipProperties"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "if    (  ( allowedTypes . length )     >     0  )     {", "if    (  ( allowedTypes . length )     =  =     1  )     {", "error ( String . format (  \" Type   is   not   allowed .    Expected :     % s .  \"  ,    allowedTypes [  0  ]  . getName (  )  )  ,    value )  ;", "} else    {", "final   String   typesText    =    Arrays . stream ( allowedTypes )  . map ( Type :  : getName )  . distinct (  )  . sorted ( Comparator . naturalOrder (  )  )  . collect ( Collectors . joining (  \"  ,     \"  )  )  ;", "error ( String . format (  \" Type   is   not   allowed .    Expected   one   of :     % s .  \"  ,    typesText )  ,    value )  ;", "}", "} else    {", "error (  \" Type   is   not   allowed \"  ,    value )  ;", "}", "myHadTypeError    =    true ;", "}", "METHOD_END"], "methodName": ["typeError"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "final   JsonObject   object    =    ObjectUtils . tryCast ( objElement ,    JsonObject . class )  ;", "if    ( object    =  =    null )", "return ;", "if    (  !  ( JsonSchemaService . isSchemaFile ( objElement . getContainingFile (  )  )  )  )     {", "return ;", "}", "final   VirtualFile   schemaFile    =    object . getContainingFile (  )  . getVirtualFile (  )  ;", "if    ( schemaFile    =  =    null )", "return ;", "final   JsonSchemaObject   schemaObject    =    JsonSchemaService . Impl . get ( object . getProject (  )  )  . getSchemaObjectForSchemaFile ( schemaFile )  ;", "if    ( schemaObject    =  =    null )", "return ;", "final   List < JsonSchemaVariantsTreeBuilder . Step >    position    =    JsonOriginalPsiWalker . INSTANCE . findPosition ( object ,    true )  ;", "if    ( position    =  =    null )", "return ;", "final   List < JsonSchemaVariantsTreeBuilder . Step >    steps    =     . skipProperties ( position )  ;", "final   MatchResult   result    =    new   JsonSchemaResolver ( schemaObject ,    false ,    steps )  . detailedResolve (  )  ;", "for    ( JsonSchemaObject   s    :    result . mySchemas )     {", "reportInvalidPatternProperties ( s )  ;", "reportPatternErrors ( s )  ;", "}", "result . myExcludingSchemas . stream (  )  . flatMap ( Set :  : stream )  . filter (  (    s )     -  >    schemaFile . equals ( s . getSchemaFile (  )  )  )  . forEach (  (    schema )     -  >     {", "reportInvalidPatternProperties ( schema )  ;", "reportPatternErrors ( schema )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["validateAsJsonSchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaAnnotatorChecker"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   completionPosition    =     (  ( parameters . getOriginalPosition (  )  )     !  =    null )     ?    parameters . getOriginalPosition (  )     :    parameters . getPosition (  )  ;", "new    . Worker ( rootSchema ,    parameters . getPosition (  )  ,    completionPosition ,    result )  . work (  )  ;", "result . stopHere (  )  ;", "}", "METHOD_END"], "methodName": ["doCompletion"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "Project   project    =    context . getProject (  )  ;", "PsiDocumentManager . getInstance ( project )  . commitDocument ( context . getDocument (  )  )  ;", "CodeStyleManager   codeStyleManager    =    CodeStyleManager . getInstance ( project )  ;", "codeStyleManager . reformatText ( context . getFile (  )  ,    context . getStartOffset (  )  ,     (  ( context . getTailOffset (  )  )     +    offset )  )  ;", "}", "METHOD_END"], "methodName": ["formatInsertedString"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "final   List < LookupElement >    result    =    new   ArrayList <  >  (  )  ;", "new    . Worker ( schema ,    position ,    originalPosition ,     (    element )     -  >    result . add ( element )  )  . work (  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getCompletionVariants"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "final   boolean   isNumber    =     (  ( type    !  =    null )     &  &     (  ( JsonSchemaType .  _ integer . equals ( type )  )     |  |     ( JsonSchemaType .  _ number . equals ( type )  )  )  )     |  |     (  ( type    =  =    null )     &  &     (  (  ( defaultValue    !  =    null )     &  &     (  !  ( StringUtil . isQuotedString ( defaultValue )  )  )  )     |  |     (  ( values    !  =    null )     &  &     ( ContainerUtil . and ( values ,     (    v )     -  >     !  ( v   instanceof   String )  )  )  )  )  )  ;", "boolean   hasValues    =     !  ( ContainerUtil . isEmpty ( values )  )  ;", "boolean   hasDefaultValue    =     !  ( StringUtil . isEmpty ( defaultValue )  )  ;", "String   stringToInsert    =     (  \"  :  \"     +     ( hasDefaultValue    ?    defaultValue    :    isNumber    ?     \"  \"     :     \"  \\  \"  \\  \"  \"  )  )     +    comma ;", "EditorModificationUtil . insertStringAtCaret ( editor ,    stringToInsert ,    false ,    true ,     1  )  ;", "if    (  (  ! isNumber )     |  |    hasDefaultValue )     {", "SelectionModel   model    =    editor . getSelectionModel (  )  ;", "caretStart    =    model . getSelectionStart (  )  ;", "newOffset    =    caretStart    +     ( hasDefaultValue    ?    defaultValue . length (  )     :     1  )  ;", "if    ( hasDefaultValue    &  &     (  ! isNumber )  )", "newOffset -  -  ;", "model . setSelection (  ( isNumber    ?    caretStart    :    caretStart    +     1  )  ,    newOffset )  ;", "editor . getCaretModel (  )  . moveToOffset ( newOffset )  ;", "}", ". formatInsertedString ( context ,    stringToInsert . length (  )  )  ;", "if    ( hasValues )     {", "AutoPopupController . getInstance ( context . getProject (  )  )  . autoPopupMemberLookup ( context . getEditor (  )  ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["insertPropertyWithEnum"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "if    ( provider    =  =    null )", "return ;", "final   SchemaType   schemaType    =    provider . getSchemaType (  )  ;", "switch    ( schemaType )     {", "case   schema    :", "UsageTrigger . trigger (  . SCHEMA _ USAGE _ KEY )  ;", "break ;", "case   userSchema    :", "UsageTrigger . trigger (  . USER _ USAGE _ KEY )  ;", "break ;", "case   embeddedSchema    :", "UsageTrigger . trigger (  . BUILTIN _ USAGE _ KEY )  ;", "break ;", "case   remoteSchema    :", "UsageTrigger . trigger (  . REMOTE _ USAGE _ KEY )  ;", "break ;", "}", "}", "METHOD_END"], "methodName": ["updateStat"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "final   JsonPropertyAdapter   firstProp    =    myWalker . getParentPropertyAdapter ( element )  ;", "if    (  ( firstProp    !  =    null )     &  &     (  ( firstProp . getValue (  )  )     !  =    null )  )     {", "final   List < VariantsTreeBuilder . Step >    position    =    myWalker . findPosition ( firstProp . getDelegate (  )  ,    true )  ;", "if    (  ( position    =  =    null )     |  |     ( position . isEmpty (  )  )  )", "return ;", "final   MatchResult   result    =    new   Resolver ( myRootSchema ,    false ,    position )  . detailedResolve (  )  ;", "createWarnings ( AnnotatorChecker . checkByMatchResult ( firstProp . getValue (  )  ,    result )  )  ;", "}", "checkRoot ( element ,    firstProp )  ;", "}", "METHOD_END"], "methodName": ["annotate"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaComplianceChecker"}, {"methodBody": ["METHOD_START", "{", "Set < PsiElement >    data    =    mySession . getUserData ( JsonSchemaComplianceChecker . ANNOTATED _ PROPERTIES )  ;", "if    ( data    =  =    null )     {", "data    =    new   HashSet (  )  ;", "mySession . putUserData ( JsonSchemaComplianceChecker . ANNOTATED _ PROPERTIES ,    data )  ;", "}", "if    ( data . contains ( property )  )", "return   true ;", "data . add ( property )  ;", "return   false ;", "}", "METHOD_END"], "methodName": ["checkIfAlreadyProcessed"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaComplianceChecker"}, {"methodBody": ["METHOD_START", "{", "JsonValueAdapter   rootToCheck ;", "if    ( firstProp    =  =    null )     {", "rootToCheck    =     . findTopLevelElement ( myWalker ,    element )  ;", "} else    {", "rootToCheck    =    firstProp . getParentObject (  )  ;", "if    ( rootToCheck    =  =    null )", "rootToCheck    =    firstProp . getParentArray (  )  ;", "if    (  ( rootToCheck    =  =    null )     |  |     (  !  ( myWalker . isTopJsonElement ( rootToCheck . getDelegate (  )  . getParent (  )  )  )  )  )     {", "return ;", "}", "}", "if    ( rootToCheck    !  =    null )     {", "final   MatchResult   matchResult    =    new   JsonSchemaResolver ( myRootSchema )  . detailedResolve (  )  ;", "createWarnings ( JsonSchemaAnnotatorChecker . checkByMatchResult ( rootToCheck ,    matchResult )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkRoot"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaComplianceChecker"}, {"methodBody": ["METHOD_START", "{", "if    (  ( checker    !  =    null )     &  &     (  !  ( checker . isCorrect (  )  )  )  )     {", "for    ( Map . Entry < PsiElement ,    String >    entry    :    checker . getErrors (  )  . entrySet (  )  )     {", "if    ( checkIfAlreadyProcessed ( entry . getKey (  )  )  )", "continue ;", "String   value    =    entry . getValue (  )  ;", "if    (  ( myMessagePrefix )     !  =    null )", "value    =     ( myMessagePrefix )     +    value ;", "myHolder . registerProblem ( entry . getKey (  )  ,    value )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["createWarnings"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaComplianceChecker"}, {"methodBody": ["METHOD_START", "{", "final   Ref < PsiElement >    ref    =    new   Ref (  )  ;", "PsiTreeUtil . findFirstParent ( element ,     (    el )     -  >     {", "final   boolean   isTop    =    walker . isTopElement ( el )  ;", "if    (  ! isTop )", "ref . set ( el )  ;", "return   isTop ;", "}  )  ;", "return   ref . isNull (  )     ?    null    :    walker . createValueAdapter ( ref . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["findTopLevelElement"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaComplianceChecker"}, {"methodBody": ["METHOD_START", "{", "final   JsonLikePsiWalker   walker    =    JsonLikePsiWalker . getWalker ( element ,    rootSchema )  ;", "if    ( walker    =  =    null )", "return ;", "new   Checker ( rootSchema ,    holder ,    walker ,    session )  . annotate ( element )  ;", "}", "METHOD_END"], "methodName": ["annotate"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaComplianceInspection"}, {"methodBody": ["METHOD_START", "{", "return   JsonBundle . message (  \" json . schema . inspection . compliance . name \"  )  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaComplianceInspection"}, {"methodBody": ["METHOD_START", "{", "final   List < Pair < Boolean ,    String >  >    pairList    =    schemaFiles . stream (  )  . map (  (    file )     -  >    myJsonSchemaService . getSchemaProvider ( file )  )  . filter ( Objects :  : nonNull )  . map (  (    provider )     -  >    Pair . create ( SchemaType . userSchema . equals ( provider . getSchemaType (  )  )  ,    provider . getName (  )  )  )  . collect ( Collectors . toList (  )  )  ;", "final   long   numOfSystemSchemas    =    pairList . stream (  )  . filter (  (    pair )     -  >     !  ( pair . getFirst (  )  )  )  . count (  )  ;", "if    (  (  ( pairList . size (  )  )     =  =     2  )     &  &     ( numOfSystemSchemas    =  =     1  )  )", "return   null ;", "final   boolean   withTypes    =    numOfSystemSchemas    >     0  ;", "return   pairList . stream (  )  . map (  (    pair )     -  >     {", "if    ( withTypes )     {", "return   String . format (  \"  % s   schema    '  % s '  \"  ,     ( Boolean . TRUE . equals ( pair . getFirst (  )  )     ?     \" user \"     :     \" system \"  )  ,    pair . getSecond (  )  )  ;", "} else    {", "return   pair . getSecond (  )  ;", "}", "}  )  . collect ( Collectors . joining (  \"  ;     \"  ,     \"  < html > There   are   several   JSON   Schemas   mapped   to   this   file :     \"  ,     \"  <  / html >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["createMessage"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaConflictNotificationProvider"}, {"methodBody": ["METHOD_START", "{", "element    =    ObjectUtils . coalesce ( originalElement ,    element )  ;", "final   PsiFile   containingFile    =    element . getContainingFile (  )  ;", "if    ( containingFile    =  =    null )", "return   null ;", "final   JsonSchemaService   service    =    JsonSchemaService . Impl . get ( element . getProject (  )  )  ;", "final   JsonSchemaObject   rootSchema    =    service . getSchemaObject ( containingFile . getViewProvider (  )  . getVirtualFile (  )  )  ;", "if    ( rootSchema    =  =    null )", "return   null ;", "return    . generateDoc ( element ,    rootSchema ,    preferShort )  ;", "}", "METHOD_END"], "methodName": ["findSchemaAndGenerateDoc"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "final   JsonLikePsiWalker   walker    =    JsonLikePsiWalker . getWalker ( element ,    rootSchema )  ;", "if    ( walker    =  =    null )", "return   null ;", "final   PsiElement   checkable    =    walker . goUpToCheckable ( element )  ;", "if    ( checkable    =  =    null )", "return   null ;", "final   List < JsonSchemaVariantsTreeBuilder . Step >    position    =    walker . findPosition ( checkable ,    true )  ;", "if    ( position    =  =    null )", "return   null ;", "final   Collection < JsonSchemaObject >    schemas    =    new   JsonSchemaResolver ( rootSchema ,    true ,    position )  . resolve (  )  ;", "for    ( JsonSchemaObject   schema    :    schemas )     {", "final   String   htmlDescription    =     . getBestDocumentation ( preferShort ,    schema )  ;", "if    ( htmlDescription    !  =    null )", "return   htmlDescription ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["generateDoc"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "final   String   htmlDescription    =    schema . getHtmlDescription (  )  ;", "final   String   description    =    schema . getDescription (  )  ;", "final   String   title    =    schema . getTitle (  )  ;", "if    ( preferShort    &  &     (  !  ( StringUtil . isEmptyOrSpaces ( title )  )  )  )     {", "return    . plainTextPostProcess ( title )  ;", "} else", "if    (  !  ( StringUtil . isEmptyOrSpaces ( htmlDescription )  )  )     {", "return   htmlDescription ;", "} else", "if    (  !  ( StringUtil . isEmptyOrSpaces ( description )  )  )     {", "return    . plainTextPostProcess ( description )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getBestDocumentation"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "return   StringUtil . escapeXml ( text )  . replace (  \"  \\  \\ n \"  ,     \"  < br /  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["plainTextPostProcess"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaDocumentationProvider"}, {"methodBody": ["METHOD_START", "{", "pattern    =     (  (  ( pattern . startsWith (  \"  ^  \"  )  )     |  |     ( pattern . startsWith (  \"  *  \"  )  )  )     |  |     ( pattern . startsWith (  \"  .  \"  )  )  )     ?    pattern    :     \"  .  *  \"     +    pattern ;", "pattern    =     (  (  ( pattern . endsWith (  \"  +  \"  )  )     |  |     ( pattern . endsWith (  \"  *  \"  )  )  )     |  |     ( pattern . endsWith (  \"  $  \"  )  )  )     ?    pattern    :    pattern    +     \"  .  *  \"  ;", "pattern    =    pattern . reace (  \"  \\  \\  \\  \\  \"  ,     \"  \\  \\  \"  )  ;", "return   pattern ;", "}", "METHOD_END"], "methodName": ["adaptSchemaPattern"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return    (  ( myPattern )     !  =    null )     &  &     ( myPattern . checkByPattern ( value )  )  ;", "}", "METHOD_END"], "methodName": ["checkByPattern"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   Pair . create ( Pattern . compile (  . adaptSchemaPattern ( pattern )  )  ,    null )  ;", "}    catch    ( PatternSyntaxException   e )     {", "return   Pair . create ( null ,    e . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["compilePattern"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "if    (  ( source    =  =    null )     |  |     ( source . isEmpty (  )  )  )", "return   target ;", "if    ( target    =  =    null )", "target    =    new   ArrayList <  >  (  )  ;", "target . addAll ( source )  ;", "return   target ;", "}", "METHOD_END"], "methodName": ["copyList"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "if    (  ( source    =  =    null )     |  |     ( source . isEmpty (  )  )  )", "return   target ;", "if    ( target    =  =    null )", "target    =    new   HashMap <  >  (  )  ;", "target . putAll ( source )  ;", "return   target ;", "}", "METHOD_END"], "methodName": ["copyMap"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "if    (  (  \"  #  \"  . equals ( ref )  )     |  |     ( StringUtil . isEmpty ( ref )  )  )     {", "return   this ;", "}", "if    (  !  ( ref . startsWith (  \"  #  /  \"  )  )  )     {", "return   null ;", "}", "ref    =    ref . substring (  2  )  ;", "final   List < String >    parts    =    StringUtil . split ( ref ,     \"  /  \"  )  ;", "current    =    this ;", "for    (    i    =     0  ;    i    <     ( parts . size (  )  )  ;    i +  +  )     {", "if    ( current    =  =    null )", "return   null ;", "final   String   part    =    parts . get ( i )  ;", "if    (  . DEFINITIONS . equals ( part )  )     {", "if    ( i    =  =     (  ( parts . size (  )  )     -     1  )  )", "return   null ;", "final   String   nextPart    =    parts . get (  (  +  + i )  )  ;", "current    =     (  ( current . getDefinitionsMap (  )  )     =  =    null )     ?    null    :    current . getDefinitionsMap (  )  . get ( nextPart )  ;", "continue ;", "}", "if    (  . PROPERTIES . equals ( part )  )     {", "if    ( i    =  =     (  ( parts . size (  )  )     -     1  )  )", "return   null ;", "current    =    current . getProperties (  )  . get ( parts . get (  (  +  + i )  )  )  ;", "continue ;", "}", "if    (  . ITEMS . equals ( part )  )     {", "if    ( i    =  =     (  ( parts . size (  )  )     -     1  )  )     {", "current    =    current . getItemsSchema (  )  ;", "} else    {", "Integer   next    =     . tryParseInt ( parts . get (  (  +  + i )  )  )  ;", "List <  >    itemsSchemaList    =    current . getItemsSchemaList (  )  ;", "if    (  (  ( itemsSchemaList    !  =    null )     &  &     ( next    !  =    null )  )     &  &     ( next    <     ( itemsSchemaList . size (  )  )  )  )     {", "current    =    itemsSchemaList . get ( next )  ;", "}", "}", "continue ;", "}", "if    (  . ADDITIONAL _ ITEMS . equals ( part )  )     {", "if    ( i    =  =     (  ( parts . size (  )  )     -     1  )  )     {", "current    =    current . getAdditionalItemsSchema (  )  ;", "}", "continue ;", "}", "current    =     (  ( current . getDefinitionsMap (  )  )     =  =    null )     ?    null    :    current . getDefinitionsMap (  )  . get ( part )  ;", "}", "return   current ;", "}", "METHOD_END"], "methodName": ["findRelativeDefinition"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return    (  ( myAdditionalItemsAllowed )     =  =    null )     |  |     ( myAdditionalItemsAllowed )  ;", "}", "METHOD_END"], "methodName": ["getAdditionalItemsAllowed"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myAdditionalItemsSchema ;", "}", "METHOD_END"], "methodName": ["getAdditionalItemsSchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return    (  ( myAdditionalPropertiesAllowed )     =  =    null )     |  |     ( myAdditionalPropertiesAllowed )  ;", "}", "METHOD_END"], "methodName": ["getAdditionalPropertiesAllowed"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myAdditionalPropertiesSchema ;", "}", "METHOD_END"], "methodName": ["getAdditionalPropertiesSchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myAllOf ;", "}", "METHOD_END"], "methodName": ["getAllOf"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myAnyOf ;", "}", "METHOD_END"], "methodName": ["getAnyOf"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myContainsSchema ;", "}", "METHOD_END"], "methodName": ["getContainsSchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "if    ( JsonSchemaType .  _ integer . equals ( myType )  )", "return    ( myDefault )    instanceof   Number    ?     (  ( Number )     ( myDefault )  )  . intValue (  )     :    myDefault ;", "return   myDefault ;", "}", "METHOD_END"], "methodName": ["getDefault"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myDefinitionsMap ;", "}", "METHOD_END"], "methodName": ["getDefinitionsMap"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myDescription ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myElse ;", "}", "METHOD_END"], "methodName": ["getElse"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myEnum ;", "}", "METHOD_END"], "methodName": ["getEnum"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myExclusiveMaximumNumber ;", "}", "METHOD_END"], "methodName": ["getExclusiveMaximumNumber"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myExclusiveMinimumNumber ;", "}", "METHOD_END"], "methodName": ["getExclusiveMinimumNumber"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myFormat ;", "}", "METHOD_END"], "methodName": ["getFormat"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myHtmlDescription ;", "}", "METHOD_END"], "methodName": ["getHtmlDescription"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myId ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myIf ;", "}", "METHOD_END"], "methodName": ["getIf"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myPatternProperties )     !  =    null )     {", "final   Map < String ,    String >    patterns    =    myPatternProperties . getInvalidPatterns (  )  ;", "return   patterns . entrySet (  )  . stream (  )  . map (  (    entry )     -  >     {", "final      object    =    myPatternProperties . getSchemaForPattern ( entry . getKey (  )  )  ;", "assert   object    !  =    null ;", "return   Pair . create ( object . getJsonObject (  )  ,    entry . getValue (  )  )  ;", "}  )  . collect ( Collectors . toMap (  (    o )     -  >    o . getFirst (  )  ,     (    o )     -  >    o . getSecond (  )  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getInvalidPatternProperties"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myItemsSchema ;", "}", "METHOD_END"], "methodName": ["getItemsSchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myItemsSchemaList ;", "}", "METHOD_END"], "methodName": ["getItemsSchemaList"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myJsonObject ;", "}", "METHOD_END"], "methodName": ["getJsonObject"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myPatternProperties )     =  =    null )", "return   null ;", "return   myPatternProperties . getPatternProperty ( name )  ;", "}", "METHOD_END"], "methodName": ["getMatchingPatternPropertySchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myMaxItems ;", "}", "METHOD_END"], "methodName": ["getMaxItems"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myMaxLength ;", "}", "METHOD_END"], "methodName": ["getMaxLength"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myMaxProperties ;", "}", "METHOD_END"], "methodName": ["getMaxProperties"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myMaximum ;", "}", "METHOD_END"], "methodName": ["getMaximum"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myMinItems ;", "}", "METHOD_END"], "methodName": ["getMinItems"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myMinLength ;", "}", "METHOD_END"], "methodName": ["getMinLength"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myMinProperties ;", "}", "METHOD_END"], "methodName": ["getMinProperties"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myMinimum ;", "}", "METHOD_END"], "methodName": ["getMinimum"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myMultipleOf ;", "}", "METHOD_END"], "methodName": ["getMultipleOf"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myNot ;", "}", "METHOD_END"], "methodName": ["getNot"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myOneOf ;", "}", "METHOD_END"], "methodName": ["getOneOf"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return    ( myPattern )     =  =    null    ?    null    :    myPattern . getPattern (  )  ;", "}", "METHOD_END"], "methodName": ["getPattern"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return    ( myPattern )     =  =    null    ?    null    :    myPattern . getPatternError (  )  ;", "}", "METHOD_END"], "methodName": ["getPatternError"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myProperties ;", "}", "METHOD_END"], "methodName": ["getProperties"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myPropertyDependencies ;", "}", "METHOD_END"], "methodName": ["getPropertyDependencies"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myPropertyNamesSchema ;", "}", "METHOD_END"], "methodName": ["getPropertyNamesSchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myRef ;", "}", "METHOD_END"], "methodName": ["getRef"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myRequired ;", "}", "METHOD_END"], "methodName": ["getRequired"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   mySchema ;", "}", "METHOD_END"], "methodName": ["getSchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   mySchemaDependencies ;", "}", "METHOD_END"], "methodName": ["getSchemaDependencies"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myJsonObject . getContainingFile (  )  . getViewProvider (  )  . getVirtualFile (  )  ;", "}", "METHOD_END"], "methodName": ["getSchemaFile"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myThen ;", "}", "METHOD_END"], "methodName": ["getThen"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myTitle ;", "}", "METHOD_END"], "methodName": ["getTitle"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myType ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myTypeVariants ;", "}", "METHOD_END"], "methodName": ["getTypeVariants"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return    ( myPatternProperties )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasPatternProperties"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myExclusiveMaximum ;", "}", "METHOD_END"], "methodName": ["isExclusiveMaximum"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myExclusiveMinimum ;", "}", "METHOD_END"], "methodName": ["isExclusiveMinimum"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   myShouldValidateAgainstJSType ;", "}", "METHOD_END"], "methodName": ["isShouldValidateAgainstJSType"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "return   Boolean . TRUE . equals ( myUniqueItems )  ;", "}", "METHOD_END"], "methodName": ["isUniqueItems"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   pattern . matcher ( StringUtil . newBombedCharSequence ( s ,     3  0  0  )  )  . matches (  )  ;", "}    catch    ( ProcessCanceledException   e )     {", "return   false ;", "}    catch    ( Exception   e )     {", "Logger . getInstance (  . class )  . info ( e )  ;", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["matchPattern"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myProperties . putAll ( other . myProperties )  ;", "myDefinitionsMap    =     . copyMap ( myDefinitionsMap ,    other . myDefinitionsMap )  ;", "final   Map < String ,     >    map    =     . copyMap (  (  ( myPatternProperties )     =  =    null    ?    null    :    myPatternProperties . mySchemasMap )  ,     (  ( other . myPatternProperties )     =  =    null    ?    null    :    other . myPatternProperties . mySchemasMap )  )  ;", "myPatternProperties    =     ( map    =  =    null )     ?    null    :    new    . PatternProperties ( map )  ;", "if    (  !  ( StringUtil . isEmptyOrSpaces ( other . myTitle )  )  )     {", "myTitle    =    other . myTitle ;", "}", "if    (  !  ( StringUtil . isEmptyOrSpaces ( other . myDescription )  )  )     {", "myDescription    =    other . myDescription ;", "}", "if    (  !  ( StringUtil . isEmptyOrSpaces ( other . myHtmlDescription )  )  )     {", "myHtmlDescription    =    other . myHtmlDescription ;", "}", "if    (  ( other . myType )     !  =    null )", "myType    =    other . myType ;", "if    (  ( other . myDefault )     !  =    null )", "myDefault    =    other . myDefault ;", "if    (  ( other . myRef )     !  =    null )", "myRef    =    other . myRef ;", "if    (  ( other . myFormat )     !  =    null )", "myFormat    =    other . myFormat ;", "myTypeVariants    =     . copyList ( myTypeVariants ,    other . myTypeVariants )  ;", "if    (  ( other . myMultipleOf )     !  =    null )", "myMultipleOf    =    other . myMultipleOf ;", "if    (  ( other . myMaximum )     !  =    null )", "myMaximum    =    other . myMaximum ;", "if    (  ( other . myExclusiveMaximumNumber )     !  =    null )", "myExclusiveMaximumNumber    =    other . myExclusiveMaximumNumber ;", "myExclusiveMaximum    |  =    other . myExclusiveMaximum ;", "if    (  ( other . myMinimum )     !  =    null )", "myMinimum    =    other . myMinimum ;", "if    (  ( other . myExclusiveMinimumNumber )     !  =    null )", "myExclusiveMinimumNumber    =    other . myExclusiveMinimumNumber ;", "myExclusiveMinimum    |  =    other . myExclusiveMinimum ;", "if    (  ( other . myMaxLength )     !  =    null )", "myMaxLength    =    other . myMaxLength ;", "if    (  ( other . myMinLength )     !  =    null )", "myMinLength    =    other . myMinLength ;", "if    (  ( other . myPattern )     !  =    null )", "myPattern    =    other . myPattern ;", "if    (  ( other . myAdditionalPropertiesAllowed )     !  =    null )", "myAdditionalPropertiesAllowed    =    other . myAdditionalPropertiesAllowed ;", "if    (  ( other . myAdditionalPropertiesSchema )     !  =    null )", "myAdditionalPropertiesSchema    =    other . myAdditionalPropertiesSchema ;", "if    (  ( other . myPropertyNamesSchema )     !  =    null )", "myPropertyNamesSchema    =    other . myPropertyNamesSchema ;", "if    (  ( other . myAdditionalItemsAllowed )     !  =    null )", "myAdditionalItemsAllowed    =    other . myAdditionalItemsAllowed ;", "if    (  ( other . myAdditionalItemsSchema )     !  =    null )", "myAdditionalItemsSchema    =    other . myAdditionalItemsSchema ;", "if    (  ( other . myItemsSchema )     !  =    null )", "myItemsSchema    =    other . myItemsSchema ;", "if    (  ( other . myContainsSchema )     !  =    null )", "myContainsSchema    =    other . myContainsSchema ;", "myItemsSchemaList    =     . copyList ( myItemsSchemaList ,    other . myItemsSchemaList )  ;", "if    (  ( other . myMaxItems )     !  =    null )", "myMaxItems    =    other . myMaxItems ;", "if    (  ( other . myMinItems )     !  =    null )", "myMinItems    =    other . myMinItems ;", "if    (  ( other . myUniqueItems )     !  =    null )", "myUniqueItems    =    other . myUniqueItems ;", "if    (  ( other . myMaxProperties )     !  =    null )", "myMaxProperties    =    other . myMaxProperties ;", "if    (  ( other . myMinProperties )     !  =    null )", "myMinProperties    =    other . myMinProperties ;", "myRequired    =     . copyList ( myRequired ,    other . myRequired )  ;", "myPropertyDependencies    =     . copyMap ( myPropertyDependencies ,    other . myPropertyDependencies )  ;", "mySchemaDependencies    =     . copyMap ( mySchemaDependencies ,    other . mySchemaDependencies )  ;", "if    (  ( other . myEnum )     !  =    null )", "myEnum    =    other . myEnum ;", "myAllOf    =     . copyList ( myAllOf ,    other . myAllOf )  ;", "myAnyOf    =     . copyList ( myAnyOf ,    other . myAnyOf )  ;", "myOneOf    =     . copyList ( myOneOf ,    other . myOneOf )  ;", "if    (  ( other . myNot )     !  =    null )", "myNot    =    other . myNot ;", "if    (  ( other . myIf )     !  =    null )", "myIf    =    other . myIf ;", "if    (  ( other . myThen )     !  =    null )", "myThen    =    other . myThen ;", "if    (  ( other . myElse )     !  =    null )", "myElse    =    other . myElse ;", "myShouldValidateAgainstJSType    |  =    other . myShouldValidateAgainstJSType ;", "}", "METHOD_END"], "methodName": ["mergeValues"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myAdditionalItemsAllowed    =    additionalItemsAllowed ;", "}", "METHOD_END"], "methodName": ["setAdditionalItemsAllowed"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myAdditionalItemsSchema    =    additionalItemsSchema ;", "}", "METHOD_END"], "methodName": ["setAdditionalItemsSchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myAdditionalPropertiesAllowed    =    additionalPropertiesAllowed ;", "}", "METHOD_END"], "methodName": ["setAdditionalPropertiesAllowed"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myAdditionalPropertiesSchema    =    additionalPropertiesSchema ;", "}", "METHOD_END"], "methodName": ["setAdditionalPropertiesSchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myAllOf    =    allOf ;", "}", "METHOD_END"], "methodName": ["setAllOf"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myAnyOf    =    anyOf ;", "}", "METHOD_END"], "methodName": ["setAnyOf"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myContainsSchema    =    containsSchema ;", "}", "METHOD_END"], "methodName": ["setContainsSchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myDefault    =    aDefault ;", "}", "METHOD_END"], "methodName": ["setDefault"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myDefinitionsMap    =    definitionsMap ;", "}", "METHOD_END"], "methodName": ["setDefinitionsMap"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myDescription    =    JsonSchemaObject . unescapeJsonString ( description )  ;", "}", "METHOD_END"], "methodName": ["setDescription"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myElse    =    anElse ;", "}", "METHOD_END"], "methodName": ["setElse"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myEnum    =    anEnum ;", "}", "METHOD_END"], "methodName": ["setEnum"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myExclusiveMaximum    =    exclusiveMaximum ;", "}", "METHOD_END"], "methodName": ["setExclusiveMaximum"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myExclusiveMaximumNumber    =    exclusiveMaximumNumber ;", "}", "METHOD_END"], "methodName": ["setExclusiveMaximumNumber"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myExclusiveMinimum    =    exclusiveMinimum ;", "}", "METHOD_END"], "methodName": ["setExclusiveMinimum"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myExclusiveMinimumNumber    =    exclusiveMinimumNumber ;", "}", "METHOD_END"], "methodName": ["setExclusiveMinimumNumber"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myFormat    =    format ;", "}", "METHOD_END"], "methodName": ["setFormat"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myHtmlDescription    =    JsonSchemaObject . unescapeJsonString ( htmlDescription )  ;", "}", "METHOD_END"], "methodName": ["setHtmlDescription"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myId    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myIf    =    anIf ;", "}", "METHOD_END"], "methodName": ["setIf"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myItemsSchema    =    itemsSchema ;", "}", "METHOD_END"], "methodName": ["setItemsSchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myItemsSchemaList    =    itemsSchemaList ;", "}", "METHOD_END"], "methodName": ["setItemsSchemaList"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myMaxItems    =    maxItems ;", "}", "METHOD_END"], "methodName": ["setMaxItems"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myMaxLength    =    maxLength ;", "}", "METHOD_END"], "methodName": ["setMaxLength"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myMaxProperties    =    maxProperties ;", "}", "METHOD_END"], "methodName": ["setMaxProperties"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myMaximum    =    maximum ;", "}", "METHOD_END"], "methodName": ["setMaximum"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myMinItems    =    minItems ;", "}", "METHOD_END"], "methodName": ["setMinItems"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myMinLength    =    minLength ;", "}", "METHOD_END"], "methodName": ["setMinLength"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myMinProperties    =    minProperties ;", "}", "METHOD_END"], "methodName": ["setMinProperties"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myMinimum    =    minimum ;", "}", "METHOD_END"], "methodName": ["setMinimum"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myMultipleOf    =    multipleOf ;", "}", "METHOD_END"], "methodName": ["setMultipleOf"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myNot    =    not ;", "}", "METHOD_END"], "methodName": ["setNot"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myOneOf    =    oneOf ;", "}", "METHOD_END"], "methodName": ["setOneOf"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myPattern    =     ( pattern    =  =    null )     ?    null    :    new   JsonSchemaObject . PropertyNamePattern ( pattern )  ;", "}", "METHOD_END"], "methodName": ["setPattern"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myPatternProperties    =    new   JsonSchemaObject . PatternProperties ( patternProperties )  ;", "}", "METHOD_END"], "methodName": ["setPatternProperties"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myProperties    =    properties ;", "}", "METHOD_END"], "methodName": ["setProperties"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myPropertyDependencies    =    propertyDependencies ;", "}", "METHOD_END"], "methodName": ["setPropertyDependencies"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myPropertyNamesSchema    =    propertyNamesSchema ;", "}", "METHOD_END"], "methodName": ["setPropertyNamesSchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myRef    =    ref ;", "}", "METHOD_END"], "methodName": ["setRef"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myRequired    =    required ;", "}", "METHOD_END"], "methodName": ["setRequired"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "mySchema    =    schema ;", "}", "METHOD_END"], "methodName": ["setSchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "mySchemaDependencies    =    schemaDependencies ;", "}", "METHOD_END"], "methodName": ["setSchemaDependencies"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myThen    =    then ;", "}", "METHOD_END"], "methodName": ["setThen"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myTitle    =    JsonSchemaObject . unescapeJsonString ( title )  ;", "}", "METHOD_END"], "methodName": ["setTitle"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myType    =    type ;", "}", "METHOD_END"], "methodName": ["setType"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myTypeVariants    =    typeVariants ;", "}", "METHOD_END"], "methodName": ["setTypeVariants"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myUniqueItems    =    uniqueItems ;", "}", "METHOD_END"], "methodName": ["setUniqueItems"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "myShouldValidateAgainstJSType    =    true ;", "}", "METHOD_END"], "methodName": ["shouldValidateAgainstJSType"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "try    {", "rurn   Integer . parseInt ( s )  ;", "}    catch    ( Exception    _  _  )     {", "rurn   null ;", "}", "}", "METHOD_END"], "methodName": ["tryParseInt"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   String   object    =    String . format (  \"  {  \\  \" prop \\  \"  :     \\  \"  % s \\  \"  }  \"  ,    text )  ;", "return   new   Gson (  )  . fromJson ( object ,    Json . class )  . get (  \" prop \"  )  . getAsString (  )  ;", "}    catch    ( JsonParseException   e )     {", "return   text ;", "}", "}", "METHOD_END"], "methodName": ["unescapeJsonString"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaObject"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Runtime . getRuntime (  )  . availableProcessors (  )  )     <     2  )", "return ;", "Assert . assertTrue ( file . exists (  )  )  ;", "final   AtomicBoolean   done    =    new   AtomicBoolean (  )  ;", "final   AtomicReference < Exception >    error    =    new   AtomicReference <  >  (  )  ;", "final   Semaphore   semaphore    =    new   Semaphore (  )  ;", "semaphore . down (  )  ;", "final   Thread   thread    =    new   Thread (  (  )     -  >     {", "try    {", "ReadAction . run (  (  )     -  >    getObject ( file )  )  ;", "done . set ( true )  ;", "}    catch    ( Exception   e )     {", "error . set ( e )  ;", "}    finally    {", "semaphore . up (  )  ;", "}", "}  ,     (  (  ( getClass (  )  . getName (  )  )     +     \"  :    read   test   json   schema    \"  )     +     ( file . getName (  )  )  )  )  ;", "thread . setDaemon ( true )  ;", "try    {", "thread . start (  )  ;", "semaphore . waitFor ( TimeUnit . SECONDS . toMillis (  1  2  0  )  )  ;", "if    (  ( error . get (  )  )     !  =    null )", "throw   error . get (  )  ;", "Assert . assertTrue (  \" Reading   test   schema   hung !  \"  ,    done . get (  )  )  ;", "}    finally    {", "thread . interrupt (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doTestSchemaReadNotHung"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReadTest"}, {"methodBody": ["METHOD_START", "{", "Assert . assertTrue ( file . exists (  )  )  ;", "final   VirtualFile   virtualFile    =    LocalFileSystem . getInstance (  )  . refreshAndFindFileByIoFile ( file )  ;", "Assert . assertNotNull ( virtualFile )  ;", "return   er . readFromFile ( myProject ,    virtualFile )  ;", "}", "METHOD_END"], "methodName": ["getSchemaObject"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReadTest"}, {"methodBody": ["METHOD_START", "{", "final   File   file    =    new   File ( PlatformTestUtil . getCommunityPath (  )  ,     \" json / tests / testData / jsonSchema / arrayItemsSchema . json \"  )  ;", "final   JsonSchemaObject   read    =    getSchemaObject ( file )  ;", "final   Map < String ,    JsonSchemaObject >    properties    =    read . getProperties (  )  ;", "Assert . assertEquals (  1  ,    properties . size (  )  )  ;", "final   JsonSchemaObject   object    =    properties . get (  \" color - hex - case \"  )  ;", "final   List < JsonSchemaObject >    oneOf    =    object . getOneOf (  )  ;", "Assert . assertEquals (  2  ,    oneOf . size (  )  )  ;", "final   JsonSchemaObject   second    =    oneOf . get (  1  )  ;", "final   List < JsonSchemaObject >    list    =    second . getItemsSchemaList (  )  ;", "Assert . assertEquals (  2  ,    list . size (  )  )  ;", "final   JsonSchemaObject   firstItem    =    list . get (  0  )  ;", "Assert . assertEquals (  \"  #  / definitions / lowerUpper \"  ,    firstItem . getRef (  )  )  ;", "final   JsonSchemaObject   definition    =    read . findRelativeDefinition ( firstItem . getRef (  )  )  ;", "Assert . assertNotNull ( definition )  ;", "final   List < Object >    anEnum    =    definition . getEnum (  )  ;", "Assert . assertEquals (  2  ,    anEnum . size (  )  )  ;", "Assert . assertTrue ( anEnum . contains (  \"  \\  \" lower \\  \"  \"  )  )  ;", "Assert . assertTrue ( anEnum . contains (  \"  \\  \" upper \\  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testArrayItemsSchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReadTest"}, {"methodBody": ["METHOD_START", "{", "final   JsonSchemaService   service    =    JsonSchemaService . Impl . get ( myProject )  ;", "final   List < JsonSchemaFileProvider >    providers    =    new   JsonSchemaProjectSelfProviderFactory (  )  . getProviders ( myProject )  ;", "Assert . assertEquals ( JsonSchemaProjectSelfProviderFactory . TOTAL _ PROVIDERS ,    providers . size (  )  )  ;", "for    ( JsonSchemaFileProvider   provider    :    providers )     {", "final   VirtualFile   mainSchema    =    provider . getSchemaFile (  )  ;", "assertNotNull ( mainSchema )  ;", "assertTrue ( service . isSchemaFile ( mainSchema )  )  ;", "enableInspectionTool ( new   JsonSchemaComplianceInspection (  )  )  ;", "Disposer . register ( getTestRootDisposable (  )  ,    new   Disposable (  )     {", "@ Override", "public   void   dispose (  )     {", "JsonSchemaTestServiceImpl . setProvider ( null )  ;", "}", "}  )  ;", "configureByExistingFile ( mainSchema )  ;", "final   List < HighlightInfo >    infos    =    doHighlighting (  )  ;", "for    ( HighlightInfo   info    :    infos )     {", "if    (  !  ( INFORMATION . equals ( info . getSeverity (  )  )  )  )     {", "fail ( String . format (  \"  % s   in :     % s \"  ,    info . getDescription (  )  ,    myEditor . getDocument (  )  . getText ( new   com . intellij . openapi . util . TextRange ( info . getStartOffset (  )  ,    info . getEndOffset (  )  )  )  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testMainSchemaHighlighting"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReadTest"}, {"methodBody": ["METHOD_START", "{", "final   File   file    =    new   File ( PlatformTestUtil . getCommunityPath (  )  ,     \" json / tests / testData / jsonSchema / schema . json \"  )  ;", "final   JsonSchemaObject   read    =    getSchemaObject ( file )  ;", "Assert . assertEquals (  \" http :  /  / json - schema . org / draft -  0  4  / schema #  \"  ,    read . getId (  )  )  ;", "Assert . assertTrue ( read . getDefinitionsMap (  )  . containsKey (  \" positiveInteger \"  )  )  ;", "Assert . assertTrue ( read . getProperties (  )  . containsKey (  \" multipleOf \"  )  )  ;", "Assert . assertTrue ( read . getProperties (  )  . containsKey (  \" type \"  )  )  ;", "Assert . assertTrue ( read . getProperties (  )  . containsKey (  \" additionalProperties \"  )  )  ;", "Assert . assertEquals (  2  ,    read . getProperties (  )  . get (  \" additionalItems \"  )  . getAnyOf (  )  . size (  )  )  ;", "Assert . assertEquals (  \"  #  \"  ,    read . getProperties (  )  . get (  \" additionalItems \"  )  . getAnyOf (  )  . get (  1  )  . getRef (  )  )  ;", "final   JsonSchemaObject   required    =    read . getProperties (  )  . get (  \" required \"  )  ;", "Assert . assertEquals (  \"  #  / definitions / stringArray \"  ,    required . getRef (  )  )  ;", "final   JsonSchemaObject   minLength    =    read . getProperties (  )  . get (  \" minLength \"  )  ;", "Assert . assertEquals (  \"  #  / definitions / positiveIntegerDefault 0  \"  ,    minLength . getRef (  )  )  ;", "}", "METHOD_END"], "methodName": ["testReadSchemaItself"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReadTest"}, {"methodBody": ["METHOD_START", "{", "final   File   file    =    new   File ( PlatformTestUtil . getCommunityPath (  )  ,     \" json / tests / testData / jsonSchema / withNotesCustomTag . json \"  )  ;", "final   JsonSchemaObject   read    =    getSchemaObject ( file )  ;", "Assert . assertTrue ( read . getDefinitionsMap (  )  . get (  \" common \"  )  . getProperties (  )  . containsKey (  \" id \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testReadSchemaWithCustomTags"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReadTest"}, {"methodBody": ["METHOD_START", "{", "doTestSchemaReadNotHung ( new   File ( PlatformTestUtil . getCommunityPath (  )  ,     \" json / tests / testData / jsonSchema / WithWrongItems . json \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testReadSchemaWithWrongItems"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReadTest"}, {"methodBody": ["METHOD_START", "{", "doTestSchemaReadNotHung ( new   File ( PlatformTestUtil . getCommunityPath (  )  ,     \" json / tests / testData / jsonSchema / WithWrongRequired . json \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testReadSchemaWithWrongRequired"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReadTest"}, {"methodBody": ["METHOD_START", "{", "final   long   length    =    file . getLength (  )  ;", "final   String   fileName    =    file . getName (  )  ;", "if    ( length    >     (  . MAX _ SCHEMA _ LENGTH )  )     {", "return   String . format (  \" JSON   schema   was   not   loaded   from    '  % s '    because   it ' s   too   large    ( file   size   is    % d   bytes )  .  \"  ,    fileName ,    length )  ;", "}", "if    ( length    =  =     0  )     {", "return   String . format (  \" JSON   schema   was   not   loaded   from    '  % s '  .    File   is   empty .  \"  ,    fileName )  ;", "}", "try    {", ". readFromFile ( project ,    file )  ;", "}    catch    ( Exception   e )     {", "final   String   message    =    String . format (  \" JSON   Schema   not   found   or   contain   error   in    '  % s '  :     % s \"  ,    fileName ,    e . getMessage (  )  )  ;", ". LOG . info ( message )  ;", "return   message ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["checkIfValidJsonSchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "return    (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonBooleanLiteral )     {", "object . setAdditionalItemsAllowed (  (  ( JsonBooleanLiteral )     ( element )  )  . getValue (  )  )  ;", "} else", "if    ( element   instanceof   com . intellij . json . psi . JsonObject )     {", "final   Object   additionalItemsSchema    =    new   Object (  (  ( com . intellij . json . psi . JsonObject )     ( element )  )  )  ;", "queue . add ( additionalItemsSchema )  ;", "object . setAdditionalItemsSchema ( additionalItemsSchema )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createAdditionalItems"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "return    (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonBooleanLiteral )     {", "object . setAdditionalPropertiesAllowed (  (  ( JsonBooleanLiteral )     ( element )  )  . getValue (  )  )  ;", "} else", "if    ( element   instanceof   com . intellij . json . psi . JsonObject )     {", "final   Object   schema    =    new   Object (  (  ( com . intellij . json . psi . JsonObject )     ( element )  )  )  ;", "queue . add ( schema )  ;", "object . setAdditionalPropertiesSchema ( schema )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createAdditionalProperties"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "return    (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonArray )     {", "final   List < JsonValue >    list    =     (  ( JsonArray )     ( element )  )  . getValueList (  )  ;", "final   List < Object >    members    =    list . stream (  )  . filter (  (    el )     -  >    el   instanceof   JsonObject )  . map (  (    el )     -  >     {", "final   Object   child    =    new   Object (  (  ( JsonObject )     ( el )  )  )  ;", "queue . add ( child )  ;", "return   child ;", "}  )  . collect ( Collectors . toList (  )  )  ;", "delegate . consume ( object ,    members )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createContainer"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "return    (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonObject )     {", "final   Object   schema    =    new   Object (  (  ( JsonObject )     ( element )  )  )  ;", "queue . add ( schema )  ;", "object . setContainsSchema ( schema )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createContains"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "return    (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonObject )     {", "final   JsonSchemaObject   schemaObject    =    new   JsonSchemaObject (  (  ( JsonObject )     ( element )  )  )  ;", "queue . add ( schemaObject )  ;", "object . setDefault ( schemaObject )  ;", "} else", "if    ( element   instanceof   com . intellij . json . psi . JsonStringLiteral )     {", "object . setDefault ( com . intellij . openapi . util . text . StringUtil . unquoteString (  (  ( com . intellij . json . psi . JsonStringLiteral )     ( element )  )  . getValue (  )  )  )  ;", "} else", "if    ( element   instanceof   com . intellij . json . psi . JsonNumberLiteral )     {", "object . setDefault (  . getNumber (  (  ( com . intellij . json . psi . JsonNumberLiteral )     ( element )  )  )  )  ;", "} else", "if    ( element   instanceof   com . intellij . json . psi . JsonBooleanLiteral )     {", "object . setDefault (  (  ( com . intellij . json . psi . JsonBooleanLiteral )     ( element )  )  . getValue (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createDefault"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "return    (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonObject )     {", "final   JsonObject   definitions    =     (  ( JsonObject )     ( element )  )  ;", "object . setDefinitionsMap (  . readInnerObject ( definitions ,    queue )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createDefinitionsConsumer"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "return    (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonObject )     {", "final   HashMap < String ,    List < String >  >    propertyDependencies    =    new   HashMap <  >  (  )  ;", "final   HashMap < String ,    JsonSchemaObject >    schemaDependencies    =    new   HashMap <  >  (  )  ;", "final   List < JsonProperty >    list    =     (  ( JsonObject )     ( element )  )  . getPropertyList (  )  ;", "for    ( JsonProperty   property    :    list )     {", "if    (  ( StringUtil . isEmptyOrSpaces ( property . getName (  )  )  )     |  |     (  ( property . getValue (  )  )     =  =    null )  )", "continue ;", "if    (  ( property . getValue (  )  )    instanceof   JsonArray )     {", "final   List < String >    dependencies    =     (  ( JsonArray )     ( property . getValue (  )  )  )  . getValueList (  )  . stream (  )  . filter (  . notEmptyString (  )  )  . map (  (    el )     -  >    StringUtil . unquoteString ( el . getText (  )  )  )  . collect ( Collectors . toList (  )  )  ;", "if    (  !  ( dependencies . isEmpty (  )  )  )", "propertyDependencies . put ( property . getName (  )  ,    dependencies )  ;", "} else", "if    (  ( property . getValue (  )  )    instanceof   JsonObject )     {", "final   JsonSchemaObject   child    =    new   JsonSchemaObject (  (  ( JsonObject )     ( property . getValue (  )  )  )  )  ;", "queue . add ( child )  ;", "schemaDependencies . put ( property . getName (  )  ,    child )  ;", "}", "}", "object . setPropertyDependencies ( propertyDependencies )  ;", "object . setSchemaDependencies ( schemaDependencies )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createDependencies"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "return    (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonObject )     {", "final   Object   ifSchema    =    new   Object (  (  ( JsonObject )     ( element )  )  )  ;", "queue . add ( ifSchema )  ;", "object . setElse ( ifSchema )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createElse"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "return    (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonArray )     {", "final   List < Object >    objects    =    new   ArrayList <  >  (  )  ;", "final   List < JsonValue >    list    =     (  ( JsonArray )     ( element )  )  . getValueList (  )  ;", "for    ( JsonValue   value    :    list )     {", "Object   enumValue    =     . readEnumValue ( value )  ;", "if    ( enumValue    !  =    null )", "objects . add ( enumValue )  ;", "}", "object . setEnum ( objects )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createEnum"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "return    (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonObject )     {", "final   Object   ifSchema    =    new   Object (  (  ( JsonObject )     ( element )  )  )  ;", "queue . add ( ifSchema )  ;", "object . setIf ( ifSchema )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createIf"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "return    (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonObject )     {", "final   Object   schema    =    new   Object (  (  ( JsonObject )     ( element )  )  )  ;", "queue . add ( schema )  ;", "object . setItemsSchema ( schema )  ;", "} else", "if    ( element   instanceof   com . intellij . json . psi . JsonArray )     {", "final   List < Object >    list    =    new   ArrayList <  >  (  )  ;", "final   List < com . intellij . json . psi . JsonValue >    values    =     (  ( com . intellij . json . psi . JsonArray )     ( element )  )  . getValueList (  )  ;", "for    ( com . intellij . json . psi . JsonValue   value    :    values )     {", "if    ( value   instanceof   JsonObject )     {", "final   Object   child    =    new   Object (  (  ( JsonObject )     ( value )  )  )  ;", "queue . add ( child )  ;", "list . add ( child )  ;", "}", "}", "object . setItemsSchemaList ( list )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createItems"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "return    (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonObject )     {", "final   Object   not    =    new   Object (  (  ( JsonObject )     ( element )  )  )  ;", "queue . add ( not )  ;", "object . setNot ( not )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createNot"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "return    (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonObject )     {", "object . setPatternProperties (  . readInnerObject (  (  ( JsonObject )     ( element )  )  ,    queue )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createPatternProperties"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "return    (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonObject )     {", "object . setProperties (  . readInnerObject (  (  ( JsonObject )     ( element )  )  ,    queue )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createPropertiesConsumer"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "return    (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonObject )     {", "final   Object   schema    =    new   Object (  (  ( JsonObject )     ( element )  )  )  ;", "queue . add ( schema )  ;", "object . setPropertyNamesSchema ( schema )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createPropertyNames"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "return    (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonArray )     {", "object . setRequired (  (  ( JsonArray )     ( element )  )  . getValueList (  )  . stream (  )  . filter (  . notEmptyString (  )  )  . map (  (    el )     -  >    StringUtil . unquoteString ( el . getText (  )  )  )  . collect ( Collectors . toList (  )  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createRequired"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "return    (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonObject )     {", "final   Object   ifSchema    =    new   Object (  (  ( JsonObject )     ( element )  )  )  ;", "queue . add ( ifSchema )  ;", "object . setThen ( ifSchema )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createThen"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "return    (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonStringLiteral )     {", "final   JsonSchemaType   type    =     . parseType ( StringUtil . unquoteString ( element . getText (  )  )  )  ;", "if    ( type    !  =    null )", "object . setType ( type )  ;", "} else", "if    ( element   instanceof   com . intellij . json . psi . JsonArray )     {", "final   List < JsonSchemaType >    typeList    =     (  ( com . intellij . json . psi . JsonArray )     ( element )  )  . getValueList (  )  . stream (  )  . filter (  . notEmptyString (  )  )  . map (  (    el )     -  >     . parseType ( StringUtil . unquoteString ( el . getText (  )  )  )  )  . filter (  (    el )     -  >    el    !  =    null )  . collect ( toList (  )  )  ;", "if    (  !  ( typeList . isEmpty (  )  )  )", "object . setTypeVariants ( typeList )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createType"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "JsonSchemaReader . READERS _ MAP . put (  \"  $ id \"  ,     (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonStringLiteral )", "object . setId ( com . intellij . openapi . util . text . StringUtil . unquoteString ( element . getText (  )  )  )  ;", "}  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" id \"  ,     (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonStringLiteral )", "object . setId ( com . intellij . openapi . util . text . StringUtil . unquoteString ( element . getText (  )  )  )  ;", "}  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \"  $ schema \"  ,     (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonStringLiteral )", "object . setSchema ( com . intellij . openapi . util . text . StringUtil . unquoteString ( element . getText (  )  )  )  ;", "}  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" description \"  ,     (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonStringLiteral )", "object . setDescription ( com . intellij . openapi . util . text . StringUtil . unquoteString ( element . getText (  )  )  )  ;", "}  )  ;", "JsonSchemaReader . READERS _ MAP . put ( JsonSchemaObject . X _ INTELLIJ _ HTML _ DESCRIPTION ,     (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonStringLiteral )", "object . setHtmlDescription ( com . intellij . openapi . util . text . StringUtil . unquoteString ( element . getText (  )  )  )  ;", "}  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" title \"  ,     (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonStringLiteral )", "object . setTitle ( com . intellij . openapi . util . text . StringUtil . unquoteString ( element . getText (  )  )  )  ;", "}  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \"  $ ref \"  ,     (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonStringLiteral )", "object . setRef ( com . intellij . openapi . util . text . StringUtil . unquoteString ( element . getText (  )  )  )  ;", "}  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" default \"  ,    JsonSchemaReader . createDefault (  )  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" format \"  ,     (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonStringLiteral )", "object . setFormat ( com . intellij . openapi . util . text . StringUtil . unquoteString ( element . getText (  )  )  )  ;", "}  )  ;", "JsonSchemaReader . READERS _ MAP . put ( JsonSchemaObject . DEFINITIONS ,    JsonSchemaReader . createDefinitionsConsumer (  )  )  ;", "JsonSchemaReader . READERS _ MAP . put ( JsonSchemaObject . PROPERTIES ,    JsonSchemaReader . createPropertiesConsumer (  )  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" multipleOf \"  ,     (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonNumberLiteral )", "object . setMultipleOf (  (  ( JsonNumberLiteral )     ( element )  )  . getValue (  )  )  ;", "}  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" maximum \"  ,     (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonNumberLiteral )", "object . setMaximum (  (  ( JsonNumberLiteral )     ( element )  )  . getValue (  )  )  ;", "}  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" minimum \"  ,     (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonNumberLiteral )", "object . setMinimum (  (  ( JsonNumberLiteral )     ( element )  )  . getValue (  )  )  ;", "}  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" exclusiveMaximum \"  ,     (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonBooleanLiteral )", "object . setExclusiveMaximum (  (  ( JsonBooleanLiteral )     ( element )  )  . getValue (  )  )  ;", "if    ( element   instanceof   JsonNumberLiteral )", "object . setExclusiveMaximumNumber (  (  ( JsonNumberLiteral )     ( element )  )  . getValue (  )  )  ;", "}  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" exclusiveMinimum \"  ,     (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonBooleanLiteral )", "object . setExclusiveMinimum (  (  ( JsonBooleanLiteral )     ( element )  )  . getValue (  )  )  ;", "if    ( element   instanceof   JsonNumberLiteral )", "object . setExclusiveMinimumNumber (  (  ( JsonNumberLiteral )     ( element )  )  . getValue (  )  )  ;", "}  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" maxLength \"  ,     (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonNumberLiteral )", "object . setMaxLength (  (  (  )     (  (  ( JsonNumberLiteral )     ( element )  )  . getValue (  )  )  )  )  ;", "}  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" minLength \"  ,     (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonNumberLiteral )", "object . setMinLength (  (  (  )     (  (  ( JsonNumberLiteral )     ( element )  )  . getValue (  )  )  )  )  ;", "}  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" pattern \"  ,     (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonStringLiteral )", "object . setPattern ( com . intellij . openapi . util . text . StringUtil . unquoteString ( element . getText (  )  )  )  ;", "}  )  ;", "JsonSchemaReader . READERS _ MAP . put ( JsonSchemaObject . ADDITIONAL _ ITEMS ,    JsonSchemaReader . createAdditionalItems (  )  )  ;", "JsonSchemaReader . READERS _ MAP . put ( JsonSchemaObject . ITEMS ,    JsonSchemaReader . createItems (  )  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" contains \"  ,    JsonSchemaReader . createContains (  )  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" maxItems \"  ,     (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonNumberLiteral )", "object . setMaxItems (  (  (  )     (  (  ( JsonNumberLiteral )     ( element )  )  . getValue (  )  )  )  )  ;", "}  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" minItems \"  ,     (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonNumberLiteral )", "object . setMinItems (  (  (  )     (  (  ( JsonNumberLiteral )     ( element )  )  . getValue (  )  )  )  )  ;", "}  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" uniqueItems \"  ,     (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonBooleanLiteral )", "object . setUniqueItems (  (  ( JsonBooleanLiteral )     ( element )  )  . getValue (  )  )  ;", "}  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" maxProperties \"  ,     (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonNumberLiteral )", "object . setMaxProperties (  (  (  )     (  (  ( JsonNumberLiteral )     ( element )  )  . getValue (  )  )  )  )  ;", "}  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" minProperties \"  ,     (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonNumberLiteral )", "object . setMinProperties (  (  (  )     (  (  ( JsonNumberLiteral )     ( element )  )  . getValue (  )  )  )  )  ;", "}  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" required \"  ,    JsonSchemaReader . createRequired (  )  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" additionalProperties \"  ,    JsonSchemaReader . createAdditionalProperties (  )  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" propertyNames \"  ,    JsonSchemaReader . createPropertyNames (  )  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" patternProperties \"  ,    JsonSchemaReader . createPatternProperties (  )  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" dependencies \"  ,    JsonSchemaReader . createDependencies (  )  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" enum \"  ,    JsonSchemaReader . createEnum (  )  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" const \"  ,     (    element ,    object ,    queue )     -  >     {", "if    ( element   instanceof   JsonValue )", "object . setEnum ( com . intellij . util . containers . ContainerUtil . createMaybeSingletonList ( JsonSchemaReader . readEnumValue (  (  ( JsonValue )     ( element )  )  )  )  )  ;", "}  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" type \"  ,    JsonSchemaReader . createType (  )  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" allOf \"  ,    JsonSchemaReader . createContainer (  (    object ,    members )     -  >    object . setAllOf ( members )  )  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" anyOf \"  ,    JsonSchemaReader . createContainer (  (    object ,    members )     -  >    object . setAnyOf ( members )  )  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" oneOf \"  ,    JsonSchemaReader . createContainer (  (    object ,    members )     -  >    object . setOneOf ( members )  )  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" not \"  ,    JsonSchemaReader . createNot (  )  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" if \"  ,    JsonSchemaReader . createIf (  )  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" then \"  ,    JsonSchemaReader . createThen (  )  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" else \"  ,    JsonSchemaReader . createElse (  )  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" instanceof \"  ,     (    element ,    object ,    queue )     -  >    object . shouldValidateAgainstJSType (  )  )  ;", "JsonSchemaReader . READERS _ MAP . put (  \" typeof \"  ,     (    element ,    object ,    queue )     -  >    object . shouldValidateAgainstJSType (  )  )  ;", "}", "METHOD_END"], "methodName": ["fillMap"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "return   myIds ;", "}", "METHOD_END"], "methodName": ["getIds"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "Number   numberValue ;", "try    {", "numberValue    =    Integer . parseInt ( value . getText (  )  )  ;", "}    catch    ( NumberFormatException   e )     {", "numberValue    =    value . getValue (  )  ;", "}", "return   numberValue ;", "}", "METHOD_END"], "methodName": ["getNumber"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "return    (    el )     -  >     ( el   instanceof   JsonStringLiteral )     &  &     (  !  ( StringUtil . isEmptyOrSpaces ( el . getText (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["notEmptyString"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   Type . valueOf (  (  \"  _  \"     +    typeString )  )  ;", "}    catch    ( IllegalArgumentException   e )     {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["parseType"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "final   JsonSchemaObject   root    =    new   JsonSchemaObject ( object )  ;", "myQueue . add ( root )  ;", "while    (  !  ( myQueue . isEmpty (  )  )  )     {", "final   JsonSchemaObject   currentSchema    =    myQueue . removeFirst (  )  ;", "final   JsonContainer   jsonObject    =    currentSchema . getJsonObject (  )  ;", "if    ( jsonObject   instanceof   JsonObject )     {", "final   List < JsonProperty >    list    =     (  ( JsonObject )     ( jsonObject )  )  . getPropertyList (  )  ;", "for    ( JsonProperty   property    :    list )     {", "if    (  ( StringUtil . isEmptyOrSpaces ( property . getName (  )  )  )     |  |     (  ( property . getValue (  )  )     =  =    null )  )", "continue ;", "final    . MyReader   reader    =     . READERS _ MAP . get ( property . getName (  )  )  ;", "if    ( reader    !  =    null )     {", "reader . read ( property . getValue (  )  ,    currentSchema ,    myQueue )  ;", "} else    {", "readSingleDefinition ( property . getName (  )  ,    property . getValue (  )  ,    currentSchema )  ;", "}", "}", "} else", "if    ( jsonObject   instanceof   com . intellij . json . psi . JsonArray )     {", "List < com . intellij . json . psi . JsonValue >    values    =     (  ( com . intellij . json . psi . JsonArray )     ( jsonObject )  )  . getValueList (  )  ;", "for    (    i    =     0  ;    i    <     ( values . size (  )  )  ;    i +  +  )     {", "readSingleDefinition ( String . valueOf ( i )  ,    values . get ( i )  ,    currentSchema )  ;", "}", "}", "if    (  ( currentSchema . getId (  )  )     !  =    null )", "myIds . put ( currentSchema . getId (  )  ,    currentSchema )  ;", "}", "return   root ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "if    ( value   instanceof   JsonStringLiteral )     {", "return    (  \"  \\  \"  \"     +     ( StringUtil . unquoteString (  (  ( JsonStringLiteral )     ( value )  )  . getValue (  )  )  )  )     +     \"  \\  \"  \"  ;", "} else", "if    ( value   instanceof   com . intellij . json . psi . JsonNumberLiteral )     {", "return    . getNumber (  (  ( com . intellij . json . psi . JsonNumberLiteral )     ( value )  )  )  ;", "} else", "if    ( value   instanceof   com . intellij . json . psi . JsonBooleanLiteral )     {", "return    (  ( com . intellij . json . psi . JsonBooleanLiteral )     ( value )  )  . getValue (  )  ;", "} else", "if    ( value   instanceof   com . intellij . json . psi . JsonNullLiteral )     {", "return    \" null \"  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["readEnumValue"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( key . isValid (  )  )  )", "throw   new   Exception ( String . format (  \" Can   not   load   JSON   Schema   file    '  % s '  \"  ,    key . getName (  )  )  )  ;", "final   PsiFile   psiFile    =    PsiManager . getInstance ( project )  . findFile ( key )  ;", "if    (  !  ( psiFile   instanceof   JsonFile )  )", "throw   new   Exception ( String . format (  \" Can   not   load   PSI   for   JSON   Schema   file    '  % s '  \"  ,    key . getName (  )  )  )  ;", "final   JsonObject   value    =    ObjectUtils . tryCast (  (  ( JsonFile )     ( psiFile )  )  . getTopLevelValue (  )  ,    JsonObject . class )  ;", "if    ( value    =  =    null )", "throw   new   Exception ( String . format (  \" JSON   Schema   file    '  % s '    must   contain   only   one   top - level   object \"  ,    key . getName (  )  )  )  ;", "return   new    (  )  . read ( value )  ;", "}", "METHOD_END"], "methodName": ["readFromFile"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "final   List < JsonProperty >    properties    =    element . getPropertyList (  )  ;", "final   Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "for    ( JsonProperty   property    :    properties )     {", "if    (  ( StringUtil . isEmptyOrSpaces ( property . getName (  )  )  )     |  |     (  !  (  ( property . getValue (  )  )    instanceof   JsonObject )  )  )", "continue ;", "final   Object   child    =    new   Object (  (  ( JsonObject )     ( property . getValue (  )  )  )  )  ;", "queue . add ( child )  ;", "map . put ( property . getName (  )  ,    child )  ;", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["readInnerObject"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "if    ( value   instanceof   JsonContainer )     {", "final   Object   defined    =    new   Object (  (  ( JsonContainer )     ( value )  )  )  ;", "myQueue . add ( defined )  ;", "Map < String ,    Object >    definitions    =    schema . getDefinitionsMap (  )  ;", "if    ( definitions    =  =    null )", "schema . setDefinitionsMap (  ( definitions    =    new   HashMap <  >  (  )  )  )  ;", "definitions . put ( name ,    defined )  ;", "}", "}", "METHOD_END"], "methodName": ["readSingleDefinition"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReader"}, {"methodBody": ["METHOD_START", "{", "return   PlatformPatterns . psiElement ( JsonStringLiteral . class )  . and ( new   FilterPattern ( new   ElementFilter (  )     {", "@ Override", "public   boolean   isAcceptable ( Object   element ,     @ Nullable", "PsiElement   context )     {", "if    ( element   instanceof   JsonStringLiteral )     {", "final   PsiElement   parent    =     (  ( JsonStringLiteral )     ( element )  )  . getParent (  )  ;", "return    ( parent   instanceof   JsonProperty )     &  &     (  (  (  ( JsonProperty )     ( parent )  )  . getNameElement (  )  )     =  =    element )  ;", "}", "return   false ;", "}", "@ Override", "public   boolean   isClassAcceptable ( Class   hintClass )     {", "return   true ;", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["createPropertyNamePattern"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReferenceContributor"}, {"methodBody": ["METHOD_START", "{", "return   PlatformPatterns . psiElement ( JsonValue . class )  . and ( new   FilterPattern ( new   ElementFilter (  )     {", "@ Override", "public   boolean   isAcceptable ( Object   element ,     @ Nullable", "PsiElement   context )     {", "if    ( element   instanceof   JsonValue )     {", "final   JsonValue   value    =     (  ( JsonValue )     ( element )  )  ;", "if    (  !  ( Service . isSchemaFile ( value . getContainingFile (  )  )  )  )", "return   false ;", "if    (  (  ( value . getParent (  )  )    instanceof   JsonProperty )     &  &     (  (  (  ( JsonProperty )     ( value . getParent (  )  )  )  . getValue (  )  )     =  =    element )  )     {", "return   propertyName . equals (  (  ( JsonProperty )     ( value . getParent (  )  )  )  . getName (  )  )  ;", "}", "}", "return   false ;", "}", "@ Override", "public   boolean   isClassAcceptable ( Class   hintClass )     {", "return   true ;", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["createPropertyValuePattern"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaReferenceContributor"}, {"methodBody": ["METHOD_START", "{", "final   JsonSchemaTreeNode   node    =    JsonSchemaVariantsTreeBuilder . buildTree ( mySchema ,    myPosition ,    false ,    false ,     (  !  ( myIsName )  )  )  ;", "return   MatchResult . create ( node )  ;", "}", "METHOD_END"], "methodName": ["detailedResolve"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaResolver"}, {"methodBody": ["METHOD_START", "{", "final   JsonSchemaTreeNode   node    =    JsonSchemaVariantsTreeBuilder . buildTree ( mySchema ,    myPosition ,    true ,    literalResolve ,     ( acceptAdditionalPropertiesSchema    |  |     (  !  ( myIsName )  )  )  )  ;", "return    . getSchemaNavigationItem (  . selectSchema ( node ,    element ,    myPosition . isEmpty (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["findNavigationTarget"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaResolver"}, {"methodBody": ["METHOD_START", "{", "return   schemas . stream (  )  . filter (  (    schema )     -  >    schema . getJsonObject (  )  . isValid (  )  )  . findFirst (  )  . orElse ( null )  ;", "}", "METHOD_END"], "methodName": ["getFirstValidSchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( s =  =    null )", "return   null ;", "final   JsonContainer   jsonObject    =    sgetJsonObject (  )  ;", "if    (  ( jsonObject . getParent (  )  )    instanceof   JsonProperty )     {", "return    (  ( JsonProperty )     ( jsonObject . getParent (  )  )  )  . getNameElement (  )  ;", "}", "return   jsonObject ;", "}", "METHOD_END"], "methodName": ["getSchemaNavigationItem"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaResolver"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( schema . getJsonObject (  )  . isValid (  )  )  )", "return   false ;", "final   Type   type    =    Type . getType ( value )  ;", "if    ( type    =  =    null )", "return   true ;", "if    (  !  ( AnnotatorChecker . areSchemaTypesCompatible ( schema ,    type )  )  )", "return   false ;", "final   AnnotatorChecker   checker    =    new   AnnotatorChecker (  )  ;", "checker . checkByScheme ( value ,    schema )  ;", "return   checker . isCorrect (  )  ;", "}", "METHOD_END"], "methodName": ["isCorrect"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaResolver"}, {"methodBody": ["METHOD_START", "{", "final   MatchResult   result    =    detailedResolve (  )  ;", "final   List < Object >    list    =    new   ArrayList <  >  ( result . mySchemas )  ;", "list . addAll ( result . myExcludingSchemas . stream (  )  . flatMap ( Set :  : stream )  . collect ( Collectors . toSet (  )  )  )  ;", "return   list ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaResolver"}, {"methodBody": ["METHOD_START", "{", "final   MatchResult   matchResult    =    MatchResult . create ( resolveRoot )  ;", "List < JsonSchemaObject >    schemas    =    new   ArrayList <  >  ( matchResult . mySchemas )  ;", "schemas . addAll ( matchResult . myExcludingSchemas . stream (  )  . flatMap ( Set :  : stream )  . collect ( Collectors . toSet (  )  )  )  ;", "final   JsonSchemaObject   firstSchema    =     . getFirstValidSchema ( schemas )  ;", "if    (  (  ( element    =  =    null )     |  |     (  ( schemas . size (  )  )     =  =     1  )  )     |  |     ( firstSchema    =  =    null )  )     {", "return   firstSchema ;", "}", "final   JsonLikePsiWalker   walker    =    JsonLikePsiWalker . getWalker ( element ,    firstSchema )  ;", "JsonValueAdapter   adapter ;", "if    (  ( walker    =  =    null )     |  |     (  ( adapter    =    walker . createValueAdapter ( element )  )     =  =    null )  )", "return   null ;", "final   JsonValueAdapter   parentAdapter ;", "if    ( topLevelSchema )     {", "parentAdapter    =    null ;", "} else    {", "final   JsonValue   parentValue    =    PsiTreeUtil . getParentOfType ( PsiTreeUtil . getParentOfType ( element ,    JsonProperty . class )  ,    JsonObject . class ,    JsonArray . class )  ;", "if    (  ( parentValue    =  =    null )     |  |     (  ( parentAdapter    =    walker . createValueAdapter ( parentValue )  )     =  =    null )  )", "return   null ;", "}", "final   Ref < JsonSchemaObject >    schemaRef    =    new   Ref (  )  ;", "MatchResult . iterateTree ( resolveRoot ,     (    node )     -  >     {", "final   JsonSchemaTreeNode   parent    =    node . getParent (  )  ;", "if    (  (  ( node . getSchema (  )  )     =  =    null )     |  |     (  (  ( parentAdapter    !  =    null )     &  &     ( parent    !  =    null )  )     &  &     ( parent . isNothing (  )  )  )  )", "return   true ;", "if    (  !  ( isCorrect ( adapter ,    node . getSchema (  )  )  )  )", "return   true ;", "if    (  (  (  (  ( parentAdapter    =  =    null )     |  |     ( parent    =  =    null )  )     |  |     (  ( parent . getSchema (  )  )     =  =    null )  )     |  |     ( parent . isAny (  )  )  )     |  |     ( isCorrect ( parentAdapter ,    parent . getSchema (  )  )  )  )     {", "schemaRef . set ( node . getSchema (  )  )  ;", "return   false ;", "}", "return   true ;", "}  )  ;", "return   schemaRef . get (  )  ;", "}", "METHOD_END"], "methodName": ["selectSchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaResolver"}, {"methodBody": ["METHOD_START", "{", "return   myCatalogManager ;", "}", "METHOD_END"], "methodName": ["getCatalogManager"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   JsonSchemaProviderFactory . EP _ NAME . getExtensions (  )  ;", "}", "METHOD_END"], "methodName": ["getProviderFactories"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaServiceImpl"}, {"methodBody": ["METHOD_START", "{", "List < JsonSchemaFileProvider >    providers    =    new   ArrayList <  >  (  )  ;", "for    ( JsonSchemaProviderFactory   factory    :    getProviderFactories (  )  )     {", "try    {", "providers . addAll ( factory . getProviders ( myProject )  )  ;", "}    catch    ( Exception   e )     {", "Logger . getInstance (  . class )  . error ( e )  ;", "}", "}", "return   providers ;", "}", "METHOD_END"], "methodName": ["getProvidersFromFactories"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaServiceImpl"}, {"methodBody": ["METHOD_START", "{", "Ref < String >    res    =    Ref . create ( null )  ;", "ApplicationManager . getApplication (  )  . runReadAction (  (  )     -  >     {", "res . set ( JsonCachedValues . getSchemaUrlFromSchemaProperty ( file ,    myProject )  )  ;", "}  )  ;", "if    ( res . isNull (  )  )", "return   null ;", "return   Version . byId ( res . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["getSchemaVersionFromSchemaUrl"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return    ( getSchemaVersionFromSchemaUrl ( file )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasSchemaSchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaServiceImpl"}, {"methodBody": ["METHOD_START", "{", "final   FileType   type    =    file . getFileType (  )  ;", "final   boolean   isJson    =     ( type   instanceof   LanguageFileType )     &  &     (  (  ( LanguageFileType )     ( type )  )  . getLanguage (  )  . isKindOf ( JsonLanguage . INSTANCE )  )  ;", "return    ( isJson    |  |     (  !  ( ype . userequals ( provider . getype (  )  )  )  )  )     &  &     ( provider . isAvailable ( file )  )  ;", "}", "METHOD_END"], "methodName": ["isProviderAvailable"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaServiceImpl"}, {"methodBody": ["METHOD_START", "{", "VirtualFile   virtualFile    =    JsonCachedValues . getSchemaFileFromSchemaProperty ( file ,    myProject )  ;", "if    ( virtualFile    !  =    null )", "return   virtualFile ;", "return   myCatalogManager . getSchemaFileForFile ( file )  ;", "}", "METHOD_END"], "methodName": ["resolveSchemaFromOtherSources"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaServiceImpl"}, {"methodBody": ["METHOD_START", "{", "final   JsonSchemaTreeNode   node    =    new   JsonSchemaTreeNode ( this ,    null )  ;", "node . myAny    =    true ;", "myChildren . add ( node )  ;", "}", "METHOD_END"], "methodName": ["anyChild"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaTreeNode"}, {"methodBody": ["METHOD_START", "{", "List < JsonSchemaTreeNode >    nodes    =    ContainerUtil . newArrayListWithCapacity ( children . size (  )  )  ;", "for    ( JsonSchemaObject   child    :    children )     {", "nodes . add ( new   JsonSchemaTreeNode ( this ,    child )  )  ;", "}", "return   nodes ;", "}", "METHOD_END"], "methodName": ["convertToNodes"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaTreeNode"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( SchemaResolveState . normal . equals ( operation . myState )  )  )     {", "final      node    =    new    ( this ,    null )  ;", "node . myResolveState    =    operation . myState ;", "myChildren . add ( node )  ;", "return ;", "}", "if    (  !  ( operation . myAnyOfGroup . isEmpty (  )  )  )     {", "myChildren . addAll ( convertToNodes ( operation . myAnyOfGroup )  )  ;", "}", "if    (  !  ( operation . myOneOfGroup . isEmpty (  )  )  )     {", "for    (    i    =     0  ;    i    <     ( operation . myOneOfGroup . size (  )  )  ;    i +  +  )     {", "final   List < JsonSchemaObject >    group    =    operation . myOneOfGroup . get ( i )  ;", "final   List <  >    children    =    convertToNodes ( group )  ;", "final      number    =    i ;", "children . forEach (  (    c )     -  >    c . myExcludingGroupNumber    =    number )  ;", "myChildren . addAll ( children )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["createChildrenFromOperation"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaTreeNode"}, {"methodBody": ["METHOD_START", "{", "return   myChildren ;", "}", "METHOD_END"], "methodName": ["getChildren"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaTreeNode"}, {"methodBody": ["METHOD_START", "{", "return   myExcludingGroupNumber ;", "}", "METHOD_END"], "methodName": ["getExcludingGroupNumber"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaTreeNode"}, {"methodBody": ["METHOD_START", "{", "return   myParent ;", "}", "METHOD_END"], "methodName": ["getParent"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaTreeNode"}, {"methodBody": ["METHOD_START", "{", "return   myResolveState ;", "}", "METHOD_END"], "methodName": ["getResolveState"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaTreeNode"}, {"methodBody": ["METHOD_START", "{", "return   mySchema ;", "}", "METHOD_END"], "methodName": ["getSchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaTreeNode"}, {"methodBody": ["METHOD_START", "{", "return   mySteps ;", "}", "METHOD_END"], "methodName": ["getSteps"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaTreeNode"}, {"methodBody": ["METHOD_START", "{", "return   myAny ;", "}", "METHOD_END"], "methodName": ["isAny"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaTreeNode"}, {"methodBody": ["METHOD_START", "{", "return   myNothing ;", "}", "METHOD_END"], "methodName": ["isNothing"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaTreeNode"}, {"methodBody": ["METHOD_START", "{", "final   JsonSchemaTreeNode   node    =    new   JsonSchemaTreeNode ( this ,    null )  ;", "node . myNothing    =    true ;", "myChildren . add ( node )  ;", "}", "METHOD_END"], "methodName": ["nothingChild"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaTreeNode"}, {"methodBody": ["METHOD_START", "{", "myChildren . add ( new   JsonSchemaTreeNode ( this ,    schema )  )  ;", "}", "METHOD_END"], "methodName": ["setChild"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaTreeNode"}, {"methodBody": ["METHOD_START", "{", "mySteps . clear (  )  ;", "mySteps . addAll ( steps )  ;", "}", "METHOD_END"], "methodName": ["setSteps"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaTreeNode"}, {"methodBody": ["METHOD_START", "{", "return   name (  )  . substring (  1  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaType"}, {"methodBody": ["METHOD_START", "{", "if    ( value . isNull (  )  )", "return    .  _ null ;", "if    ( value . isBooleanLiteral (  )  )", "return    .  _ boolean ;", "if    ( value . isStringLiteral (  )  )", "return    .  _ string ;", "if    ( value . isArray (  )  )", "return    .  _ array ;", "if    ( value . isObject (  )  )", "return    .  _ object ;", "if    ( value . isNumberLiteral (  )  )     {", "return    . isInteger ( value . getDelegate (  )  . getText (  )  )     ?     .  _ integer    :     .  _ number ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaType"}, {"methodBody": ["METHOD_START", "{", "try    {", "Integer . parseInt ( text )  ;", "rurn   true ;", "}    catch    ( NumberFormatException   e )     {", "rurn   false ;", "}", "}", "METHOD_END"], "methodName": ["isInteger"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaType"}, {"methodBody": ["METHOD_START", "{", "List < JsonSchemaObject >    list    =    ContainerUtil . newArrayListWithCapacity ( group . size (  )  )  ;", "for    ( JsonSchemaObject   s    :    group )     {", "list . add (  . merge ( object ,    s ,    s )  )  ;", "}", "return   list ;", "}", "METHOD_END"], "methodName": ["andGroup"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaVariantsTreeBuilder"}, {"methodBody": ["METHOD_START", "{", "List < JsonSchemaObject >    result    =    ContainerUtil . newArrayListWithCapacity (  (  ( g 1  . size (  )  )     *     ( g 2  . size (  )  )  )  )  ;", "for    ( JsonSchemaObject   s    :    g 1  )     {", "result . addAll (  . andGroup ( s ,    g 2  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["andGroups"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaVariantsTreeBuilder"}, {"methodBody": ["METHOD_START", "{", "final   List < String >    chain    =    StringUtil . split ( JsonSchemaService . normalizeId ( nameInSchema )  . replace (  \"  \\  \\  \"  ,     \"  /  \"  )  ,     \"  /  \"  )  ;", "List <  . Step >    steps    =    ContainerUtil . newArrayListWithCapacity ( chain . size (  )  )  ;", "for    ( String   s    :    chain )     {", "if    (  !  ( StringUtil . isEmpty ( s )  )  )     {", "try    {", "steps . add (  . Step . createArrayElementStep ( Integer . parseInt ( s )  )  )  ;", "}    catch    ( NumberFormatException   e )     {", "steps . add (  . Step . createPropertyStep ( s )  )  ;", "}", "}", "}", "return   steps ;", "}", "METHOD_END"], "methodName": ["buildSteps"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaVariantsTreeBuilder"}, {"methodBody": ["METHOD_START", "{", "final   JsonSchemaTreeNode   root    =    new   JsonSchemaTreeNode ( null ,    schema )  ;", "JsonSchemaService   service    =    JsonSchemaService . Impl . get ( schema . getJsonObject (  )  . getProject (  )  )  ;", ". expandChildSchema ( root ,    schema ,    service )  ;", "for    ( JsonSchemaTreeNode   treeNode    :    root . getChildren (  )  )     {", "treeNode . setSteps ( ContainerUtil . notNullize ( position )  )  ;", "}", "final   ArrayDeque < JsonSchemaTreeNode >    queue    =    new   ArrayDeque <  >  ( root . getChildren (  )  )  ;", "while    (  !  ( queue . isEmpty (  )  )  )     {", "final   JsonSchemaTreeNode   node    =    queue . removeFirst (  )  ;", "if    (  (  (  ( node . isAny (  )  )     |  |     ( node . isNothing (  )  )  )     |  |     ( node . getSteps (  )  . isEmpty (  )  )  )     |  |     (  ( node . getSchema (  )  )     =  =    null )  )", "continue ;", "final    . Step   step    =    node . getSteps (  )  . get (  0  )  ;", "if    (  !  (  . typeMatches ( step . isFromObject (  )  ,    node . getSchema (  )  )  )  )     {", "node . nothingChild (  )  ;", "continue ;", "}", "if    ( literalResolve )", "step . myLiteralResolve    =    true ;", "final   Pair < ThreeState ,    JsonSchemaObject >    pair    =    step . step ( node . getSchema (  )  ,    acceptAdditional )  ;", "if    ( NO . equals ( pair . getFirst (  )  )  )", "node . nothingChild (  )  ;", "else", "if    ( ThreeState . YES . equals ( pair . getFirst (  )  )  )", "node . anyChild (  )  ;", "else    {", "assert    ( pair . getSecond (  )  )     !  =    null ;", "if    (  (  ( node . getSteps (  )  . size (  )  )     >     1  )     |  |     (  ! skipLastExpand )  )", ". expandChildSchema ( node ,    pair . getSecond (  )  ,    service )  ;", "else", "node . setChild ( pair . getSecond (  )  )  ;", "}", "queue . addAll ( node . getChildren (  )  )  ;", "}", "return   root ;", "}", "METHOD_END"], "methodName": ["buildTree"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaVariantsTreeBuilder"}, {"methodBody": ["METHOD_START", "{", "cnt    =     0  ;", "if    (  ( sgetAllOf (  )  )     !  =    null )", "+  + cnt ;", "if    (  ( sgetAnyOf (  )  )     !  =    null )", "+  + cnt ;", "if    (  ( sgetOneOf (  )  )     !  =    null )", "+  + cnt ;", "return   cnt    >     1  ;", "}", "METHOD_END"], "methodName": ["conflictingSchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaVariantsTreeBuilder"}, {"methodBody": ["METHOD_START", "{", "final   JsonContainer   element    =    childSchema . getJsonObject (  )  ;", "if    (  . interestingSchema ( childSchema )  )     {", "final    . Operation   operation    =    CachedValuesManager . getManager ( element . getProject (  )  )  . createParameterizedCachedValue (  ( JsonSchemaObject   param )     -  >     {", "final   Operation   expand    =    new   ProcessDefinitionsOperation ( param ,    service )  ;", "expand . doMap ( new   HashSet <  >  (  )  )  ;", "expand . doReduce (  )  ;", "return   CachedValueProvider . Result . create ( expand ,    element . getContainingFile (  )  ,    service . getAnySchemaChangeTracker (  )  )  ;", "}  ,    false )  . getValue ( childSchema )  ;", "node . createChildrenFromOperation ( operation )  ;", "} else    {", "node . setChild ( childSchema )  ;", "}", "}", "METHOD_END"], "methodName": ["expandChildSchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaVariantsTreeBuilder"}, {"methodBody": ["METHOD_START", "{", "final   String   path    =    splitter . getRelativePath (  )  ;", "if    ( StringUtil . isEmptyOrSpaces ( path )  )", "return   schema ;", "final   JsonSchemaObject   definition    =    schema . findRelativeDefinition ( path )  ;", "if    ( definition    =  =    null )     {", ". LOG . debug ( String . format (  \" Definition   not   found   by   reference :     '  % s '    in   file    % s \"  ,    path ,    schema . getSchemaFile (  )  . getPath (  )  )  )  ;", "}", "return   definition ;", "}", "METHOD_END"], "methodName": ["findRelativeDefinition"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaVariantsTreeBuilder"}, {"methodBody": ["METHOD_START", "{", "final   String   ref    =    schema . getRef (  )  ;", "assert    !  ( StringUtil . isEmptyOrSpaces ( ref )  )  ;", "final   VirtualFile   schemaFile    =    schema . getSchemaFile (  )  ;", "final    . SchemaUrlSplitter   splitter    =    new    . SchemaUrlSplitter ( ref )  ;", "if    (  ( splitter . getSchemaId (  )  )     !  =    null )     {", "final   VirtualFile   refFile    =    service . findSchemaFileByReference ( splitter . getSchemaId (  )  ,    schemaFile )  ;", "if    ( refFile    =  =    null )     {", ". LOG . debug ( String . format (  \" Schema   file   not   found   by   reference :     '  % s '    from    % s \"  ,    splitter . getSchemaId (  )  ,    schemaFile . getPath (  )  )  )  ;", "return   null ;", "}", "final   JsonSchemaObject   refSchema    =    service . getSchemaObjectForSchemaFile ( refFile )  ;", "if    ( refSchema    =  =    null )     {", ". LOG . debug ( String . format (  \" Schema   object   not   found   by   reference :     '  % s '    from    % s \"  ,    splitter . getSchemaId (  )  ,    schemaFile . getPath (  )  )  )  ;", "return   null ;", "}", "return    . findRelativeDefinition ( refSchema ,    splitter )  ;", "}", "final   JsonSchemaObject   rootSchema    =    service . getSchemaObjectForSchemaFile ( schemaFile )  ;", "if    ( rootSchema    =  =    null )     {", ". LOG . debug ( String . format (  \" Schema   object   not   found   for    % s \"  ,    schemaFile . getPath (  )  )  )  ;", "return   null ;", "}", "return    . findRelativeDefinition ( rootSchema ,    splitter )  ;", "}", "METHOD_END"], "methodName": ["getSchemaFromDefinition"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaVariantsTreeBuilder"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( schema . getAnyOf (  )  )     !  =    null )     |  |     (  ( schema . getOneOf (  )  )     !  =    null )  )     |  |     (  ( schema . getAllOf (  )  )     !  =    null )  )     |  |     (  ( schema . getRef (  )  )     !  =    null )  )     |  |     (  ( schema . getIf (  )  )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["interestingSchema"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaVariantsTreeBuilder"}, {"methodBody": ["METHOD_START", "{", "final   JsonSchemaObject   object    =    new   JsonSchemaObject ( pointTo . getJsonObject (  )  )  ;", "object . mergeValues ( other )  ;", "object . mergeValues ( base )  ;", "object . setRef ( other . getRef (  )  )  ;", "return   object ;", "}", "METHOD_END"], "methodName": ["merge"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaVariantsTreeBuilder"}, {"methodBody": ["METHOD_START", "{", "final   JsonSchemaType   requiredType    =     ( isObject )     ?    JsonSchemaType .  _ object    :    JsonSchemaType .  _ array ;", "if    (  ( schema . getType (  )  )     !  =    null )     {", "return   requiredType . equals ( schema . getType (  )  )  ;", "}", "if    (  ( schema . getTypeVariants (  )  )     !  =    null )     {", "for    ( JsonSchemaType   schemaType    :    schema . getTypeVariants (  )  )     {", "if    ( requiredType . equals ( schemaType )  )", "return   true ;", "}", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["typeMatches"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaVariantsTreeBuilder"}, {"methodBody": ["METHOD_START", "{", "switch    ( id )     {", "case    . ourSchemaV 4 Schema    :", "case    . ourSchemaV 4 SchemaTrim    :", "return    . SCHEMA _  4  ;", "case    . ourSchemaV 6 Schema    :", "case    . ourSchemaV 6 SchemaTrim    :", "return    . SCHEMA _  6  ;", "case    . ourSchemaV 7 Schema    :", "case    . ourSchemaV 7 SchemaTrim    :", "return    . SCHEMA _  7  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["byId"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaVersion"}, {"methodBody": ["METHOD_START", "{", "return    (  ( JsonSchemaVersion . ourSchemaV 4 Schema . equals ( id )  )     |  |     ( JsonSchemaVersion . ourSchemaV 6 Schema . equals ( id )  )  )     |  |     ( JsonSchemaVersion . ourSchemaV 7 Schema . equals ( id )  )  ;", "}", "METHOD_END"], "methodName": ["isSchemaSchemaId"], "fileName": "com.jetbrains.jsonSchema.impl.JsonSchemaVersion"}, {"methodBody": ["METHOD_START", "{", "List < JsonSchemaObject >    schemas    =    new   ArrayList <  >  (  )  ;", "Map < Integer ,    Set < JsonSchemaObject >  >    oneOfGroups    =    new   HashMap <  >  (  )  ;", ". iterateTree ( root ,     (    node )     -  >     {", "if    ( node . isAny (  )  )", "return   true ;", "int   groupNumber    =    node . getExcludingGroupNumber (  )  ;", "if    ( groupNumber    <     0  )     {", "schemas . add ( node . getSchema (  )  )  ;", "} else    {", "Set < JsonSchemaObject >    set    =    oneOfGroups . get ( groupNumber )  ;", "if    ( set    =  =    null )", "oneOfGroups . put ( groupNumber ,     ( set    =    new   HashSet <  >  (  )  )  )  ;", "set . add ( node . getSchema (  )  )  ;", "}", "return   true ;", "}  )  ;", "return   new    ( schemas ,    new   ArrayList <  >  ( oneOfGroups . values (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.jetbrains.jsonSchema.impl.MatchResult"}, {"methodBody": ["METHOD_START", "{", "final   ArrayDeque < JsonSchemaTreeNode >    queue    =    new   ArrayDeque <  >  ( root . getChildren (  )  )  ;", "while    (  !  ( queue . isEmpty (  )  )  )     {", "final   JsonSchemaTreeNode   node    =    queue . removeFirst (  )  ;", "if    ( node . getChildren (  )  . isEmpty (  )  )     {", "if    (  (  (  !  ( node . isNothing (  )  )  )     &  &     ( SchemaResolveState . normal . equals ( node . getResolveState (  )  )  )  )     &  &     (  !  ( processor . process ( node )  )  )  )     {", "break ;", "}", "} else    {", "queue . addAll ( node . getChildren (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["iterateTree"], "fileName": "com.jetbrains.jsonSchema.impl.MatchResult"}, {"methodBody": ["METHOD_START", "{", "if    ( value   instanceof   JsonObject )", "return   new   ObjectAdapter (  (  ( JsonObject )     ( value )  )  )  ;", "if    ( value   instanceof   JsonArray )", "return   new   ArrayAdapter (  (  ( JsonArray )     ( value )  )  )  ;", "return   new   GenericValueAdapter ( value )  ;", "}", "METHOD_END"], "methodName": ["createAdapterByType"], "fileName": "com.jetbrains.jsonSchema.impl.adapters.JsonJsonPropertyAdapter"}, {"methodBody": ["METHOD_START", "{", "testBySchema (  \"  {  \\  \" properties \\  \"  :     {  \\  \" prima \\  \"  :     {  }  ,     \\  \" proto \\  \"  :     {  }  ,     \\  \" primus \\  \"  :     {  }  }  }  \"  ,     \"  { prima :     1  ,    pri < caret >  }  \"  ,     \" json 5  \"  ,     \" primus \"  ,     \" proto \"  )  ;", "}", "METHOD_END"], "methodName": ["testAlreadyInsertedProperty"], "fileName": "com.jetbrains.jsonSchema.json5.Json5ByJsonSchemaCompletionTest"}, {"methodBody": ["METHOD_START", "{", "testBySchema (  \"  {  \\  \" properties \\  \"  :     {  \\  \" prima \\  \"  :     {  }  ,     \\  \" proto \\  \"  :     {  }  ,     \\  \" primus \\  \"  :     {  }  }  }  \"  ,     \"  { pri < caret >  }  \"  ,     \" json 5  \"  ,     \" prima \"  ,     \" primus \"  ,     \" proto \"  )  ;", "}", "METHOD_END"], "methodName": ["testTopLevel"], "fileName": "com.jetbrains.jsonSchema.json5.Json5ByJsonSchemaCompletionTest"}, {"methodBody": ["METHOD_START", "{", "if    ( schemaUrl    =  =    null )", "return   null ;", "boolean   isHttpPath    =    JsonSchemaConfigurable . isHttpPath ( schemaUrl )  ;", "if    ( isHttpPath    &  &     ( ApplicationManager . getApplication (  )  . isUnitTestMode (  )  )  )", "return   null ;", "if    (  ( StringUtil . startsWithChar ( schemaUrl ,     '  .  '  )  )     |  |     (  ! isHttpPath )  )     {", "VirtualFile   parent    =     ( currentFile    =  =    null )     ?    null    :    currentFile . getParent (  )  ;", "schemaUrl    =     ( parent    =  =    null )     ?    null    :    VfsUtilCore . pathToUrl (  (  (  ( parent . getPath (  )  )     +     ( File . separator )  )     +    schemaUrl )  )  ;", "}", "if    ( schemaUrl    !  =    null )     {", "VirtualFile   virtualFile    =     . urlToFile ( schemaUrl )  ;", "if    ( virtualFile    !  =    null )", "return   virtualFile ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["resolveSchemaByReference"], "fileName": "com.jetbrains.jsonSchema.remote.JsonFileResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( path   instanceof   HttpVirtualFile )     {", "RFileInfo   info    =     (  ( HttpVirtualFile )     ( path )  )  . getFileInfo (  )  ;", "if    (  ( info    =  =    null )     |  |     (  ( info . getState (  )  )     =  =     ( RFileState . DOWNLOADING _ NOT _ STARTED )  )  )     {", "path . refresh ( true ,    false )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["startFetchingHttpFileIfNeeded"], "fileName": "com.jetbrains.jsonSchema.remote.JsonFileResolver"}, {"methodBody": ["METHOD_START", "{", "return   VirtualFileManager . getInstance (  )  . findFileByUrl ( urlString )  ;", "}", "METHOD_END"], "methodName": ["urlToFile"], "fileName": "com.jetbrains.jsonSchema.remote.JsonFileResolver"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( JsonSchemaCatalogManager . myIsEnabled . get (  )  )  )", "return   null ;", "String   name    =    file . getName (  )  ;", "if    ( myResolvedMappings . containsKey ( name )  )     {", "String   urlString    =    myResolvedMappings . get ( name )  ;", "if    ( JsonSchemaCatalogManager . EMPTY . equals ( urlString )  )", "return   null ;", "return   JsonFileResolver . resolveSchemaByReference ( file ,    urlString )  ;", "}", "if    (  ( myCatalog )     !  =    null )     {", "String   urlString    =    JsonSchemaCatalogManager . resolveSchemaFile ( file ,    myCatalog ,    myProject )  ;", "if    ( JsonSchemaCatalogManager . NO _ CACHE . equals ( urlString )  )", "return   null ;", "myResolvedMappings . put ( name ,     ( urlString    =  =    null    ?    JsonSchemaCatalogManager . EMPTY    :    urlString )  )  ;", "return   JsonFileResolver . resolveSchemaByReference ( file ,    urlString )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getSchemaFileForFile"], "fileName": "com.jetbrains.jsonSchema.remote.JsonSchemaCatalogManager"}, {"methodBody": ["METHOD_START", "{", "if    ( mask . equals ( fileName )  )", "return   true ;", "star    =    mask . indexOf (  '  *  '  )  ;", "if    ( star    =  =     (  -  1  )  )", "return   false ;", "if    (  ( star    =  =     0  )     &  &     ( fileName . startsWith ( mask . substring (  1  )  )  )  )     {", "return   true ;", "}", "if    (  ( star    =  =     (  ( mask . length (  )  )     -     1  )  )     &  &     ( fileName . endsWith ( mask . substring (  0  ,     (  ( mask . length (  )  )     -     1  )  )  )  )  )     {", "return   true ;", "}", "String   beforeStar    =    mask . substring (  0  ,    star )  ;", "String   afterStar    =    mask . substring (  ( star    +     1  )  )  ;", "if    (  ( fileName . startsWith ( beforeStar )  )     &  &     ( fileName . endsWith ( afterStar )  )  )     {", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["matches"], "fileName": "com.jetbrains.jsonSchema.remote.JsonSchemaCatalogManager"}, {"methodBody": ["METHOD_START", "{", "for    ( String   mask    :    masks )     {", "if    (  . matches ( fileName ,    mask )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["matches"], "fileName": "com.jetbrains.jsonSchema.remote.JsonSchemaCatalogManager"}, {"methodBody": ["METHOD_START", "{", "JsonFileResolver . startFetchingHttpFileIfNeeded ( catalogFile )  ;", "List < Pair < Collection < String >  ,    String >  >    schemaCatalog    =    JsonCachedValues . getSchemaCatalog ( catalogFile ,    project )  ;", "if    ( schemaCatalog    =  =    null )", "return   catalogFile   instanceof   com . intellij . openapi . vfs . impl . http . HttpVirtualFile    ?     . NO _ CACHE    :    null ;", "String   fileName    =    file . getName (  )  ;", "for    ( Pair < Collection < String >  ,    String >    maskAndPath    :    schemaCatalog )     {", "if    (  . matches ( fileName ,    maskAndPath . first )  )     {", "return   maskAndPath . second ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["resolveSchemaFile"], "fileName": "com.jetbrains.jsonSchema.remote.JsonSchemaCatalogManager"}, {"methodBody": ["METHOD_START", "{", "JsonSchemaCatalogManager . myIsEnabled . set ( enabled )  ;", "}", "METHOD_END"], "methodName": ["setEnabled"], "fileName": "com.jetbrains.jsonSchema.remote.JsonSchemaCatalogManager"}, {"methodBody": ["METHOD_START", "{", "if    ( ApplicationManager . getApplication (  )  . isUnitTestMode (  )  )", "return ;", "RemoteFileManager   instance    =    RemoteFileManager . getInstance (  )  ;", "instance . addRemoteContentProvider ( myRemoteContentProvider )  ;", "myCatalog    =    JsonFileResolver . urlToFile (  . DEFAULT _ CATALOG )  ;", "}", "METHOD_END"], "methodName": ["startUpdates"], "fileName": "com.jetbrains.jsonSchema.remote.JsonSchemaCatalogManager"}, {"methodBody": ["METHOD_START", "{", "File   file    =    new   File (  (  ( path    +     \"  .  \"  )     +    header )  )  ;", "try    {", "return   isUpToDate ( url ,    file ,    header )  ;", "}    catch    ( IOException   e )     {", "new   File ( path )  . setLastModified ( System . currentTimeMillis (  )  )  ;", "return   true ;", "}", "}", "METHOD_END"], "methodName": ["checkUpToDate"], "fileName": "com.jetbrains.jsonSchema.remote.JsonSchemaRemoteContentProvider"}, {"methodBody": ["METHOD_START", "{", "long   now    =    System . currentTimeMillis (  )  ;", "if    (  ( now    -     ( myLastUpdateTime )  )     <     (  . UPDATE _ DELAY )  )     {", "return   true ;", "}", "myLastUpdateTime    =    now ;", "String   path    =    local . getPath (  )  ;", "if    (  ( now    -     ( new   File ( path )  . lastModified (  )  )  )     <     (  . UPDATE _ DELAY )  )     {", "return   true ;", "}", "if    ( checkUpToDate ( url ,    path ,     . ETAG _ HEADER )  )", "return   true ;", "if    ( checkUpToDate ( url ,    path ,     . LAST _ MODIFIED _ HEADER )  )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["isUpToDate"], "fileName": "com.jetbrains.jsonSchema.remote.JsonSchemaRemoteContentProvider"}, {"methodBody": ["METHOD_START", "{", "List < String >    strings    =     ( file . exists (  )  )     ?    Files . readAllLines ( file . toPath (  )  )     :    ContainerUtil . emptyList (  )  ;", "String   currentTag    =     (  ( strings . size (  )  )     >     0  )     ?    strings . get (  0  )     :    null ;", "if    ( currentTag    =  =    null )", "return   false ;", "String   Tag    =    connect ( url ,    HttpRequests . head ( url . toExternalForm (  )  )  ,     (    r )     -  >    r . getConnection (  )  . getHeaderField ( header )  )  ;", "return   currentTag . equals ( Tag )  ;", "}", "METHOD_END"], "methodName": ["isUpToDate"], "fileName": "com.jetbrains.jsonSchema.remote.JsonSchemaRemoteContentProvider"}, {"methodBody": ["METHOD_START", "{", "String   tag    =    connection . getHeaderField ( header )  ;", "if    ( tag    !  =    null )     {", "String   path    =    file . getAbsolutePath (  )  ;", "if    (  !  ( path . endsWith (  \"  . json \"  )  )  )", "path    +  =     \"  . json \"  ;", "File   tagFile    =    new   File (  (  ( path    +     \"  .  \"  )     +    header )  )  ;", ". saveToFile ( tagFile ,    tag )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["saveTag"], "fileName": "com.jetbrains.jsonSchema.remote.JsonSchemaRemoteContentProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( tagFile . exists (  )  )  )", "if    (  !  ( tagFile . createNewFile (  )  )  )", "return ;", "Files . write ( tagFile . toPath (  )  ,    ainerUtil . createMaybeSingletonList ( headerValue )  )  ;", "}", "METHOD_END"], "methodName": ["saveToFile"], "fileName": "com.jetbrains.jsonSchema.remote.JsonSchemaRemoteContentProvider"}, {"methodBody": ["METHOD_START", "{", "skeleton ( new   JsonSchemaHeavyAbstractTest . Callback (  )     {", "@ Override", "public   void   doCheck (  )     {", "final      offset    =    getEditor (  )  . getCaretModel (  )  . getCurrentCaret (  )  . getOffset (  )  ;", "final   PsiElement   atOffset    =    PsiTreeUtil . findElementOfClassAtOffset ( myFile ,    offset ,    PsiElement . class ,    false )  ;", "Assert . assertNotNull ( atOffset )  ;", "PsiReference   position    =    myFile . findReferenceAt ( offset )  ;", "Assert . assertNotNull ( position )  ;", "PsiElement   resolve    =    position . resolve (  )  ;", "Assert . assertNotNull ( resolve )  ;", "Assert . assertEquals (  \"  \\  \" baseEnum \\  \"  \"  ,    resolve . getText (  )  )  ;", "}", "@ Override", "public   void   configureFiles (  )    throws   Exception    {", "configureByFile (  \" localRefSchema . json \"  )  ;", "}", "@ Override", "public   void   registerSchemes (  )     {", "final   String   path    =    VfsUtilCore . getRelativePath ( myFile . getVirtualFile (  )  ,    myProject . getBaseDir (  )  )  ;", "final   UserDefinedJsonSchemaConfiguration   info    =    new   UserDefinedJsonSchemaConfiguration (  \" test \"  ,    JsonSchemaVersion . SCHEMA _  4  ,    path ,    false ,    Collections . emptyList (  )  )  ;", ". this . addSchema ( info )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testResolveLocalRef"], "fileName": "com.jetbrains.jsonSchema.schemaFile.JsonSchemaFileResolveTest"}, {"methodBody": ["METHOD_START", "{", "final   TestSuite   suite    =    new   TestSuite ( JsonSchemaTestSuite . class . getSimpleName (  )  )  ;", "suite . addTestSuite ( JsonSchemaCrossReferencesTest . class )  ;", "suite . addTestSuite ( JsonSchemaDocumentationTest . class )  ;", "suite . addTestSuite ( JsonSchemaHighlightingTest . class )  ;", "suite . addTestSuite ( JsonSchemaPatternComparatorTest . class )  ;", "suite . addTestSuite ( JsonSchemaSelfHighligthingTest . class )  ;", "suite . addTestSuite ( JsonBySchemaCompletionTest . class )  ;", "suite . addTestSuite ( JsonBySchemaHeavyCompletionTest . class )  ;", "suite . addTestSuite ( JsonSchemaReadTest . class )  ;", "suite . addTestSuite ( JsonSchemaFileResolveTest . class )  ;", "suite . addTestSuite ( JsonSchemaPerformanceTest . class )  ;", "return   suite ;", "}", "METHOD_END"], "methodName": ["suite"], "fileName": "com.jetbrains.jsonSchema.schemaFile.JsonSchemaTestSuite"}]