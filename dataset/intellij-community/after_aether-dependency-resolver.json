[{"methodBody": ["METHOD_START", "{", "return   myClassifier ;", "}", "METHOD_END"], "methodName": ["getClassifier"], "fileName": "org.jetbrains.idea.maven.aether.ArtifactKind"}, {"methodBody": ["METHOD_START", "{", "return   myExtension ;", "}", "METHOD_END"], "methodName": ["getExtension"], "fileName": "org.jetbrains.idea.maven.aether.ArtifactKind"}, {"methodBody": ["METHOD_START", "{", "myRemoteRepositories . add ( ArtifactRepositoryManager . createRemoteRepository ( id ,    url )  )  ;", "}", "METHOD_END"], "methodName": ["addRemoteRepository"], "fileName": "org.jetbrains.idea.maven.aether.ArtifactRepositoryManager"}, {"methodBody": ["METHOD_START", "{", "return   ArtifactRepositoryManager . ourVersioning . parseVersion (  ( str    =  =    null    ?     \"  \"     :    str )  )  ;", "}", "METHOD_END"], "methodName": ["asVersion"], "fileName": "org.jetbrains.idea.maven.aether.ArtifactRepositoryManager"}, {"methodBody": ["METHOD_START", "{", "return   ArtifactRepositoryManager . ourVersioning . parseVersionConstraint (  ( str    =  =    null    ?     \"  \"     :    str )  )  ;", "}", "METHOD_END"], "methodName": ["asVersionConstraint"], "fileName": "org.jetbrains.idea.maven.aether.ArtifactRepositoryManager"}, {"methodBody": ["METHOD_START", "{", "return   ArtifactRepositoryManager . ourVersioning . parseVersionRange (  ( str    =  =    null    ?     \"  \"     :    str )  )  ;", "}", "METHOD_END"], "methodName": ["asVersionRange"], "fileName": "org.jetbrains.idea.maven.aether.ArtifactRepositoryManager"}, {"methodBody": ["METHOD_START", "{", "final   CollectRequest   request    =    new   CollectRequest (  )  ;", "for    ( Artifact   artifact    :     . toArtifacts ( groupId ,    artifactId ,    versions ,    kinds )  )     {", "request . addDependency ( new   Dependency ( artifact ,    JavaScopes . COMPILE )  )  ;", "}", "return   request . setRepositories ( Collections . unmodifiableList ( myRemoteRepositories )  )  ;", "}", "METHOD_END"], "methodName": ["createCollectRequest"], "fileName": "org.jetbrains.idea.maven.aether.ArtifactRepositoryManager"}, {"methodBody": ["METHOD_START", "{", "return   new   RemoteRepository . Builder ( id ,     \" default \"  ,    url )  . setProxy ( ArtifactRepositoryManager . ourProxySelector . getProxy ( url )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["createRemoteRepository"], "fileName": "org.jetbrains.idea.maven.aether.ArtifactRepositoryManager"}, {"methodBody": ["METHOD_START", "{", "final   String   url    =    prototype . getUrl (  )  ;", "return   new   RemoteRepository . Builder ( prototype . getId (  )  ,    prototype . getContentType (  )  ,    url )  . setProxy (  . ourProxySelector . getProxy ( url )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["createRemoteRepository"], "fileName": "org.jetbrains.idea.maven.aether.ArtifactRepositoryManager"}, {"methodBody": ["METHOD_START", "{", "final   VersionRangeRequest   request    =    new   VersionRangeRequest (  )  ;", "for    ( Artifact   artifact    :     . toArtifacts ( groupId ,    artifactId ,    Collections . singleton ( versioning )  ,    EnumSet . of ( artifactKind )  )  )     {", "request . setArtifact ( artifact )  ;", "}", "return   request . setRepositories ( Collections . unmodifiableList ( myRemoteRepositories )  )  ;", "}", "METHOD_END"], "methodName": ["createVersionRangeRequest"], "fileName": "org.jetbrains.idea.maven.aether.ArtifactRepositoryManager"}, {"methodBody": ["METHOD_START", "{", "final   VersionRangeResult   result    =    ArtifactRepositoryManager . ourSystem . resolveVersionRange ( mySession ,    createVersionRangeRequest ( groupId ,    artifactId ,    ArtifactRepositoryManager . asVersionConstraint ( versionConstraint )  ,    artifactKind )  )  ;", "return   result . getVersions (  )  ;", "}", "METHOD_END"], "methodName": ["getAvailableVersions"], "fileName": "org.jetbrains.idea.maven.aether.ArtifactRepositoryManager"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . asList ( ArtifactRepositoryManager . class ,    VersionsMetadataGeneratorFactory . class ,    Artifact . class ,    StringUtils . class ,    Base 6  4  . class ,    Problem . class ,    Model . class ,    ModelBuilder . class ,    Metadata . class ,    Component . class ,    Interpolator . class ,    RepositorySystem . class ,    BasicRepositoryConnectorFactory . class ,    RepositoryConnector . class ,    class ,    ArtifactResolver . class ,    FileTransporterFactory . class ,    HttpTransporterFactory . class ,    Predicate . class ,    HttpConnection . class ,    HttpClient . class ,    class ,    LogFactory . class ,    Marker . class )  ;", "}", "METHOD_END"], "methodName": ["getClassesFromDependencies"], "fileName": "org.jetbrains.idea.maven.aether.ArtifactRepositoryManager"}, {"methodBody": ["METHOD_START", "{", "final   List < File >    files    =    new   ArrayList <  >  (  )  ;", "for    (    artifact    :    resolveDependencyAs ( groupId ,    artifactId ,    version ,    EnumSet . of ( Kind . ARTIFACT )  ,    includeTransitiveDependencies )  )     {", "files . add ( artifact . getFile (  )  )  ;", "}", "return   files ;", "}", "METHOD_END"], "methodName": ["resolveDependency"], "fileName": "org.jetbrains.idea.maven.aether.ArtifactRepositoryManager"}, {"methodBody": ["METHOD_START", "{", "final   List < Artifact >    artifacts    =    new   ArrayList <  >  (  )  ;", "final   Set < VersionConstraint >    constraints    =    Collections . singleton (  . asVersionConstraint ( versionConstraint )  )  ;", "for    ( ArtifactKind   kind    :    artifactKinds )     {", "try    {", "final   List < ArtifactRequest >    requests ;", "if    ( includeTransitiveDependencies )     {", "final   CollectResult   collectResult    =     . ourSystem . collectDependencies ( mySession ,    createCollectRequest ( groupId ,    artifactId ,    constraints ,    EnumSet . of ( kind )  )  )  ;", "final    . ArtifactRequestBuilder   builder    =    new    . ArtifactRequestBuilder ( kind )  ;", "collectResult . getRoot (  )  . accept ( new   TreeDependencyVisitor ( new   FilteringDependencyVisitor ( builder ,    DependencyFilterUtils . classpathFilter ( COMPILE )  )  )  )  ;", "requests    =    builder . getRequests (  )  ;", "} else    {", "requests    =    new   ArrayList (  )  ;", "for    ( Artifact   artifact    :     . toArtifacts ( groupId ,    artifactId ,    constraints ,    Collections . singleton ( kind )  )  )     {", "requests . add ( new   ArtifactRequest ( artifact ,    Collections . unmodifiableList ( myRemoteRepositories )  ,    null )  )  ;", "}", "}", "if    (  !  ( requests . isEmpty (  )  )  )     {", "try    {", "for    ( ArtifactResult   result    :     . ourSystem . resolveArtifacts ( mySession ,    requests )  )     {", "artifacts . add ( result . getArtifact (  )  )  ;", "}", "}    catch    ( ArtifactResolutionException   e )     {", "if    ( kind    !  =     ( ArtifactKind . ARTIFACT )  )     {", "if    (  ( requests . size (  )  )     >     1  )     {", "for    ( ArtifactRequest   request    :    requests )     {", "try    {", "final   ArtifactResult   result    =     . ourSystem . resolveArtifact ( mySession ,    request )  ;", "artifacts . add ( result . getArtifact (  )  )  ;", "}    catch    ( ArtifactResolutionException   ignored )     {", "}", "}", "}", "} else    {", "throw   e ;", "}", "}", "}", "}    catch    ( DependencyCollectionException   e )     {", "if    ( kind    =  =     ( ArtifactKind . ARTIFACT )  )     {", "throw   e ;", "}", "}", "}", "return   artifacts ;", "}", "METHOD_END"], "methodName": ["resolveDependencyAsArtifact"], "fileName": "org.jetbrains.idea.maven.aether.ArtifactRepositoryManager"}, {"methodBody": ["METHOD_START", "{", "if    (  ( constraints . isEmpty (  )  )     |  |     ( kinds . isEmpty (  )  )  )     {", "return   Collections . emptyList (  )  ;", "}", "final   List <  >    result    =    new   ArrayList (  (  ( kinds . size (  )  )     *     ( constraints . size (  )  )  )  )  ;", "for    ( Kind   kind    :    kinds )     {", "for    ( VersionConstraint   constr    :    constraints )     {", "result . add ( new   Default ( groupId ,    artifactId ,    kind . getClassifier (  )  ,    kind . getExtension (  )  ,    constr . toString (  )  )  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["toArtifacts"], "fileName": "org.jetbrains.idea.maven.aether.ArtifactRepositoryManager"}, {"methodBody": ["METHOD_START", "{", "Collection < File >    files    =    myRepositoryManager . resolveDependency (  \" junit \"  ,     \" junit \"  ,     \"  4  .  1  2  \"  ,    false )  ;", "assertSameElements ( ContainerUtil . map ( files ,    File :  : getName )  ,     \" junit -  4  .  1  2  . jar \"  )  ;", "}", "METHOD_END"], "methodName": ["testResolveNonTransitively"], "fileName": "org.jetbrains.idea.maven.aether.ArtifactRepositoryManagerTest"}, {"methodBody": ["METHOD_START", "{", "Collection < File >    files    =    myRepositoryManager . resolveDependency (  \" junit \"  ,     \" junit \"  ,     \"  4  .  1  2  \"  ,    true )  ;", "assertSameElements ( ContainerUtil . map ( files ,    File :  : getName )  ,     \" junit -  4  .  1  2  . jar \"  ,     \" hamcrest - core -  1  .  3  . jar \"  )  ;", "}", "METHOD_END"], "methodName": ["testResolveTransitively"], "fileName": "org.jetbrains.idea.maven.aether.ArtifactRepositoryManagerTest"}, {"methodBody": ["METHOD_START", "{", "if    ( TYPE _ HTTP . equals ( protocol )  )     {", "return   TYPE _ HTTP ;", "}", "if    ( TYPE _ HTTPS . equals ( protocol )  )     {", "return   TYPE _ HTTPS ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["chooseProxyType"], "fileName": "org.jetbrains.idea.maven.aether.JreProxySelector"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   ProxySelector   systemSelector    =    ProxySelector . getDefault (  )  ;", "if    ( systemSelector    =  =    null )     {", "return   null ;", "}", "final   URI   uri    =    new   URI ( url )  . parseServerAuthority (  )  ;", "final   List < Proxy >    selected    =    systemSelector . select ( uri )  ;", "if    (  ( selected    =  =    null )     |  |     ( selected . isEmpty (  )  )  )     {", "return   null ;", "}", "for    ( Proxy   proxy    :    selected )     {", "if    (  (  ( proxy . type (  )  )     =  =     ( Proxy . Type . HTTP )  )     &  &     (  . isValid ( proxy . address (  )  )  )  )     {", "final   String   proxyType    =     . chooseProxyType ( uri . getScheme (  )  )  ;", "if    ( proxyType    !  =    null )     {", "final   InetSocketAddress   addr    =     (  ( InetSocketAddress )     ( proxy . address (  )  )  )  ;", "return   new   Proxy ( proxyType ,    addr . getHostName (  )  ,    addr . getPort (  )  ,     . JreProxyAuthentication . INSTANCE )  ;", "}", "}", "}", "}    catch    ( Throwable   e )     {", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getProxy"], "fileName": "org.jetbrains.idea.maven.aether.JreProxySelector"}, {"methodBody": ["METHOD_START", "{", "return   getProxy ( repository . getUrl (  )  )  ;", "}", "METHOD_END"], "methodName": ["getProxy"], "fileName": "org.jetbrains.idea.maven.aether.JreProxySelector"}, {"methodBody": ["METHOD_START", "{", "if    ( address   instanceof   InetSocketAddress )     {", "final   InetSocketAddress   addr    =     (  ( InetSocketAddress )     ( address )  )  ;", "return    (  (  ( addr . getPort (  )  )     >     0  )     &  &     (  ( addr . getHostName (  )  )     !  =    null )  )     &  &     (  !  ( addr . getHostName (  )  . isEmpty (  )  )  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isValid"], "fileName": "org.jetbrains.idea.maven.aether.JreProxySelector"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isCanceled"], "fileName": "org.jetbrains.idea.maven.aether.ProgressConsumer"}]