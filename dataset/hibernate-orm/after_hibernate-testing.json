[{"methodBody": ["METHOD_START", "{", "return   ServiceRegistryBuilder . buildServiceRegistry ( Environment . getProperties (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildServiceRegistry"], "fileName": "org.hibernate.testing.ServiceRegistryBuilder"}, {"methodBody": ["METHOD_START", "{", "return    (  ( StandardServiceRegistryImpl )     ( new   StandardServiceRegistryBuilder (  )  . applySettings ( serviceRegistryConfig )  . build (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["buildServiceRegistry"], "fileName": "org.hibernate.testing.ServiceRegistryBuilder"}, {"methodBody": ["METHOD_START", "{", "(  ( StandardServiceRegistryImpl )     ( serviceRegistry )  )  . destroy (  )  ;", "}", "METHOD_END"], "methodName": ["destroy"], "fileName": "org.hibernate.testing.ServiceRegistryBuilder"}, {"methodBody": ["METHOD_START", "{", "SkipLog . log . info (  (  \"  *  *  *    skipping   test    -     \"     +    message )  ,    new   Exception (  )  )  ;", "}", "METHOD_END"], "methodName": ["reportSkip"], "fileName": "org.hibernate.testing.SkipLog"}, {"methodBody": ["METHOD_START", "{", "SkipLog . reportSkip (  (  ( testDescription    +     \"     :     \"  )     +    reason )  )  ;", "}", "METHOD_END"], "methodName": ["reportSkip"], "fileName": "org.hibernate.testing.SkipLog"}, {"methodBody": ["METHOD_START", "{", "return   isDone ;", "}", "METHOD_END"], "methodName": ["isDone"], "fileName": "org.hibernate.testing.async.ExecutableAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( error )     !  =    null )     {", "if    ( RuntimeException . class . isInstance ( error )  )     {", "throw   RuntimeException . class . cast ( error )  ;", "} else", "if    ( Error . class . isInstance ( error )  )     {", "throw   Error . class . cast ( error )  ;", "} else    {", "throw   new    . ExceptionWrapper ( error )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["reThrowAnyErrors"], "fileName": "org.hibernate.testing.async.ExecutableAdapter"}, {"methodBody": ["METHOD_START", "{", "final   ExecutableAdapter   adapter    =    new   ExecutableAdapter ( executable )  ;", "final   Thread   separateThread    =    new   Thread ( adapter )  ;", "separateThread . start (  )  ;", "int   runningTime    =     0  ;", "do    {", "if    ( runningTime    >     ( timeOut )  )     {", "try    {", "executable . timedOut (  )  ;", "}    catch    ( Exception   ignore )     {", "}", "throw   new   TimeoutException (  )  ;", "}", "try    {", "Thread . sleep ( checkMilliSeconds )  ;", "runningTime    +  =    checkMilliSeconds ;", "}    catch    ( InterruptedException   ignore )     {", "}", "}    while    (  !  ( adapter . isDone (  )  )     )  ;", "adapter . reThrowAnyErrors (  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.hibernate.testing.async.TimedExecutor"}, {"methodBody": ["METHOD_START", "{", "return   dialect ;", "}", "METHOD_END"], "methodName": ["getDialect"], "fileName": "org.hibernate.testing.boot.BasicTestingJdbcServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   jdbcEnvironment . getExtractedDatabaseMetaData (  )  ;", "}", "METHOD_END"], "methodName": ["getExtractedMetaDataSupport"], "fileName": "org.hibernate.testing.boot.BasicTestingJdbcServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   jdbcEnvironment . getLobCreatorBuilder (  )  . buildLobCreator ( lobCreationContext )  ;", "}", "METHOD_END"], "methodName": ["getLobCreator"], "fileName": "org.hibernate.testing.boot.BasicTestingJdbcServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   new   ResultSetWrapperImpl ( serviceRegistry )  ;", "}", "METHOD_END"], "methodName": ["getResultSetWrapper"], "fileName": "org.hibernate.testing.boot.BasicTestingJdbcServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   jdbcEnvironment . getSqlExceptionHelper (  )  ;", "}", "METHOD_END"], "methodName": ["getSqlExceptionHelper"], "fileName": "org.hibernate.testing.boot.BasicTestingJdbcServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   sqlStatementLogger ;", "}", "METHOD_END"], "methodName": ["getSqlStatementLogger"], "fileName": "org.hibernate.testing.boot.BasicTestingJdbcServiceImpl"}, {"methodBody": ["METHOD_START", "{", "dialect    =    ConnectionProviderBuilder . getCorrespondingDialect (  )  ;", "connectionProvider    =    ConnectionProviderBuilder . buildConnectionProvider ( allowAggressiveRelease )  ;", "sqlStatementLogger    =    new   SqlStatementLogger ( true ,    false )  ;", "Connection   jdbcConnection    =    connectionProvider . getConnection (  )  ;", "try    {", "jdbcEnvironment    =    new   engine . jdbc . env . internal . JdbcEnvironmentImpl ( jdbcConnection . getMetaData (  )  ,    dialect )  ;", "}    finally    {", "try    {", "connectionProvider . closeConnection ( jdbcConnection )  ;", "}    catch    ( SQLException   ignore )     {", "}", "}", "this . jdbcConnectionAccess    =    new   JdbcConnectionAccessImpl ( connectionProvider )  ;", "}", "METHOD_END"], "methodName": ["prepare"], "fileName": "org.hibernate.testing.boot.BasicTestingJdbcServiceImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( connectionProvider )    instanceof   Stoppable )     {", "(  ( Stoppable )     ( connectionProvider )  )  . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["release"], "fileName": "org.hibernate.testing.boot.BasicTestingJdbcServiceImpl"}, {"methodBody": ["METHOD_START", "{", "release (  )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.hibernate.testing.boot.BasicTestingJdbcServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   new   ProvidedService < ConnectionProvider >  ( ConnectionProvider . class ,    ConnectionProviderBuilder . buildConnectionProvider ( true )  )  ;", "}", "METHOD_END"], "methodName": ["connectionProviderService"], "fileName": "org.hibernate.testing.boot.ServiceRegistryTestingImpl"}, {"methodBody": ["METHOD_START", "{", "return   new   ProvidedService < DialectFactory >  ( DialectFactory . class ,    new   DialectFactoryTestingImpl (  )  )  ;", "}", "METHOD_END"], "methodName": ["dialectFactoryService"], "fileName": "org.hibernate.testing.boot.ServiceRegistryTestingImpl"}, {"methodBody": ["METHOD_START", "{", "return   new   ServiceRegistryTestingImpl ( true ,    new   BootstrapServiceRegistryBuilder (  )  . build (  )  ,    StandardServiceInitiators . LIST ,    Arrays . asList ( ServiceRegistryTestingImpl . dialectFactoryService (  )  ,    ServiceRegistryTestingImpl . connectionProviderService (  )  )  ,    Environment . getProperties (  )  )  ;", "}", "METHOD_END"], "methodName": ["forUnitTesting"], "fileName": "org.hibernate.testing.boot.ServiceRegistryTestingImpl"}, {"methodBody": ["METHOD_START", "{", "return   new   ServiceRegistryTestingImpl ( true ,    new   BootstrapServiceRegistryBuilder (  )  . build (  )  ,    StandardServiceInitiators . LIST ,    Arrays . asList ( ServiceRegistryTestingImpl . dialectFactoryService (  )  ,    ServiceRegistryTestingImpl . connectionProviderService (  )  )  ,    settings )  ;", "}", "METHOD_END"], "methodName": ["forUnitTesting"], "fileName": "org.hibernate.testing.boot.ServiceRegistryTestingImpl"}, {"methodBody": ["METHOD_START", "{", "String   packageName    =    klass . getPackage (  )  . getName (  )  ;", "List < Class <  ?  >  >    classList    =    new   ArrayList <  >  (  )  ;", "try    {", "if    ( klass . isAnnotationPresent ( CustomEnhancementContext . class )  )     {", "for    ( Class <  ?    extends   EnhancementContext >    contextClass    :    klass . getAnnotation ( CustomEnhancementContext . class )  . value (  )  )     {", "EnhancementContext   enhancementContextInstance    =    contextClass . getConstructor (  )  . newInstance (  )  ;", "classList . add (  . getEnhancerClassLoader ( enhancementContextInstance ,    packageName )  . loadClass ( klass . getName (  )  )  )  ;", "}", "} else    {", "classList . add (  . getEnhancerClassLoader ( new   EnhancerTestContext (  )  ,    packageName )  . loadClass ( klass . getName (  )  )  )  ;", "}", "}    catch    ( IllegalAccessException    |    InstantiationException    |    NoSuchMethodException    |    InvocationTargetException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "return   classList . toArray ( new   Class <  ?  >  [  ]  {        }  )  ;", "}", "METHOD_END"], "methodName": ["enhanceTestClass"], "fileName": "org.hibernate.testing.bytecode.enhancement.BytecodeEnhancerRunner"}, {"methodBody": ["METHOD_START", "{", "return   new   ClassLoader (  )     {", "private   final   String   debugOutputDir    =    System . getProperty (  \" tmpdir \"  )  ;", "private   final   Enhancer   enhancer    =    Environment . getProvider (  )  . getEnhancer ( context )  ;", "@ SuppressWarnings (  \" ResultOfMethodCallIgnored \"  )", "@ Override", "public   Class <  ?  >    loadClass ( String   name )    throws   ClassNotFoundException    {", "if    (  !  ( name . startsWith ( packageName )  )  )     {", "return   getParent (  )  . loadClass ( name )  ;", "}", "Class   c    =    findLoadedClass ( name )  ;", "if    ( c    !  =    null )     {", "return   c ;", "}", "try    ( InputStream   is    =    getResourceAsStream (  (  ( name . replace (  '  .  '  ,     '  /  '  )  )     +     \"  . class \"  )  )  )     {", "if    ( is    =  =    null )     {", "throw   new   ClassNotFoundException (  ( name    +     \"    not   found \"  )  )  ;", "}", "byte [  ]    original    =    new   byte [ is . available (  )  ]  ;", "try    ( BufferedInputStream   bis    =    new   BufferedInputStream ( is )  )     {", "bis . read ( original )  ;", "}", "byte [  ]    enhanced    =    enhancer . enhance ( name ,    original )  ;", "if    ( enhanced    =  =    null )     {", "return   defineClass ( name ,    original ,     0  ,    original . length )  ;", "}", "File   f    =    new   File (  (  (  (  ( debugOutputDir )     +     ( File . separator )  )     +     ( name . replace (  \"  .  \"  ,    File . separator )  )  )     +     \"  . class \"  )  )  ;", "f . getParentFile (  )  . mkdirs (  )  ;", "f . createNewFile (  )  ;", "try    ( FileOutputStream   out    =    new   FileOutputStream ( f )  )     {", "out . write ( enhanced )  ;", "}", "return   defineClass ( name ,    enhanced ,     0  ,    enhanced . length )  ;", "}    catch    ( Throwable   t )     {", "throw   new   ClassNotFoundException (  ( name    +     \"    not   found \"  )  ,    t )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getEnhancerClassLoader"], "fileName": "org.hibernate.testing.bytecode.enhancement.BytecodeEnhancerRunner"}, {"methodBody": ["METHOD_START", "{", "SelfDirtinessTracker   selfDirtinessTracker    =     (  ( SelfDirtinessTracker )     ( entityInstance )  )  ;", "Assert . assertEquals (  (  ( dirtyFields . length )     >     0  )  ,    selfDirtinessTracker .  $  $  _  _ hasDirtyAttributes (  )  )  ;", "String [  ]    tracked    =    selfDirtinessTracker .  $  $  _  _ getDirtyAttributes (  )  ;", "Assert . assertEquals ( dirtyFields . length ,    tracked . length )  ;", "Assert . assertTrue ( Arrays . asList ( tracked )  . containsAll ( Arrays . asList ( dirtyFields )  )  )  ;", "}", "METHOD_END"], "methodName": ["checkDirtyTracking"], "fileName": "org.hibernate.testing.bytecode.enhancement.EnhancerTestUtils"}, {"methodBody": ["METHOD_START", "{", "(  ( SelfDirtinessTracker )     ( entityInstance )  )  .  $  $  _ hibernate _ clearDirtyAttributes (  )  ;", "}", "METHOD_END"], "methodName": ["clearDirtyTracking"], "fileName": "org.hibernate.testing.bytecode.enhancement.EnhancerTestUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "Field   field    =    ity . getClass (  )  . getDeclaredField ( fieldName )  ;", "ReflectHelper . ensureAccessibility ( field )  ;", "return   field . get ( ity )  ;", "}    catch    ( NoSuchFieldException    |    IllegalAccessException   e )     {", "Assert . fail (  (  (  (  (  (  \" Fail   to   get   field    '  \"     +    fieldName )     +     \"  '    in   ity    \"  )     +    ity )     +     \"  :     \"  )     +     ( e . getMessage (  )  )  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getFieldByReflection"], "fileName": "org.hibernate.testing.bytecode.enhancement.EnhancerTestUtils"}, {"methodBody": ["METHOD_START", "{", "return   INSTANCE . createEntityEntry ( MANAGED ,    null ,    null ,     1  ,    null ,    NONE ,    false ,    null ,    false ,    null )  ;", "}", "METHOD_END"], "methodName": ["makeEntityEntry"], "fileName": "org.hibernate.testing.bytecode.enhancement.EnhancerTestUtils"}, {"methodBody": ["METHOD_START", "{", "BytemanHelper . log . debug (  \" Increment   call   count \"  )  ;", "BytemanHelper . COUNTER . incrementAndGet (  )  ;", "}", "METHOD_END"], "methodName": ["countInvocation"], "fileName": "org.hibernate.testing.byteman.BytemanHelper"}, {"methodBody": ["METHOD_START", "{", "return   BytemanHelper . COUNTER . getAndSet (  0  )  ;", "}", "METHOD_END"], "methodName": ["getAndResetInvocationCount"], "fileName": "org.hibernate.testing.byteman.BytemanHelper"}, {"methodBody": ["METHOD_START", "{", "try    {", ". log . info (  \" Byteman   rule   triggered :    sleeping   a   second \"  )  ;", "Thread . sleep (  1  0  0  0  )  ;", "}    catch    ( InterruptedException   e )     {", "Thread . currentThread (  )  . interrupt (  )  ;", ". log . error (  \" unexpected   interruption \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["sleepASecond"], "fileName": "org.hibernate.testing.byteman.BytemanHelper"}, {"methodBody": ["METHOD_START", "{", "throw   new   NullPointerException ( message )  ;", "}", "METHOD_END"], "methodName": ["throwNPE"], "fileName": "org.hibernate.testing.byteman.BytemanHelper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( data )     =  =    null )     {", "data    =    new   ConcurrentHash (  )  ;", "}", "return   data ;", "}", "METHOD_END"], "methodName": ["getOrMakeDataMap"], "fileName": "org.hibernate.testing.cache.MapStorageAccessImpl"}, {"methodBody": ["METHOD_START", "{", "Properties   properties    =    Environment . getProperties (  )  ;", "augmentConfigurationSettings ( properties )  ;", "properties . put ( ISOLATION ,     \" TRANSACTION _ SERIALIZABLE \"  )  ;", "ConnectionProvider   provider    =    getConnectionProviderUnderTest (  )  ;", "try    {", "(  ( Configurable )     ( provider )  )  . configure ( properties )  ;", "if    ( Startable . class . isInstance ( provider )  )     {", "(  ( Startable )     ( provider )  )  . start (  )  ;", "}", "Connection   connection    =    provider . getConnection (  )  ;", "Assert . assertEquals ( Connection . TRANSACTION _ SERIALIZABLE ,    connection . get (  )  )  ;", "provider . closeConnection ( connection )  ;", "}    finally    {", "(  ( Stoppable )     ( provider )  )  . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSettingIsolationAsName"], "fileName": "org.hibernate.testing.common.connections.BaseTransactionIsolationConfigTest"}, {"methodBody": ["METHOD_START", "{", "Properties   properties    =    Environment . getProperties (  )  ;", "augmentConfigurationSettings ( properties )  ;", "properties . put ( ISOLATION ,     \" SERIALIZABLE \"  )  ;", "ConnectionProvider   provider    =    getConnectionProviderUnderTest (  )  ;", "try    {", "(  ( Configurable )     ( provider )  )  . configure ( properties )  ;", "if    ( Startable . class . isInstance ( provider )  )     {", "(  ( Startable )     ( provider )  )  . start (  )  ;", "}", "Connection   connection    =    provider . getConnection (  )  ;", "Assert . assertEquals ( Connection . TRANSACTION _ SERIALIZABLE ,    connection . get (  )  )  ;", "provider . closeConnection ( connection )  ;", "}    finally    {", "(  ( Stoppable )     ( provider )  )  . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSettingIsolationAsNameAlt"], "fileName": "org.hibernate.testing.common.connections.BaseTransactionIsolationConfigTest"}, {"methodBody": ["METHOD_START", "{", "Properties   properties    =    Environment . getProperties (  )  ;", "augmentConfigurationSettings ( properties )  ;", "properties . put ( ISOLATION ,    Connection . TRANSACTION _ SERIALIZABLE )  ;", "ConnectionProvider   provider    =    getConnectionProviderUnderTest (  )  ;", "try    {", "(  ( Configurable )     ( provider )  )  . configure ( properties )  ;", "if    ( Startable . class . isInstance ( provider )  )     {", "(  ( Startable )     ( provider )  )  . start (  )  ;", "}", "Connection   connection    =    provider . getConnection (  )  ;", "Assert . assertEquals ( Connection . TRANSACTION _ SERIALIZABLE ,    connection . get (  )  )  ;", "provider . closeConnection ( connection )  ;", "}    finally    {", "(  ( Stoppable )     ( provider )  )  . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSettingIsolationAsNumeric"], "fileName": "org.hibernate.testing.common.connections.BaseTransactionIsolationConfigTest"}, {"methodBody": ["METHOD_START", "{", "Properties   properties    =    Environment . getProperties (  )  ;", "augmentConfigurationSettings ( properties )  ;", "properties . put ( ISOLATION ,    Integer . toString ( Connection . TRANSACTION _ SERIALIZABLE )  )  ;", "ConnectionProvider   provider    =    getConnectionProviderUnderTest (  )  ;", "try    {", "(  ( Configurable )     ( provider )  )  . configure ( properties )  ;", "if    ( Startable . class . isInstance ( provider )  )     {", "(  ( Startable )     ( provider )  )  . start (  )  ;", "}", "Connection   connection    =    provider . getConnection (  )  ;", "Assert . assertEquals ( Connection . TRANSACTION _ SERIALIZABLE ,    connection . get (  )  )  ;", "provider . closeConnection ( connection )  ;", "}    finally    {", "(  ( Stoppable )     ( provider )  )  . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSettingIsolationAsNumericString"], "fileName": "org.hibernate.testing.common.connections.BaseTransactionIsolationConfigTest"}, {"methodBody": ["METHOD_START", "{", "return   ConnectionProviderBuilder . buildConnectionProvider ( false )  ;", "}", "METHOD_END"], "methodName": ["buildConnectionProvider"], "fileName": "org.hibernate.testing.env.ConnectionProviderBuilder"}, {"methodBody": ["METHOD_START", "{", "return   ConnectionProviderBuilder . buildConnectionProvider ( ConnectionProviderBuilder . getConnectionProviderProperties (  \" db 1  \"  )  ,    allowAggressiveRelease )  ;", "}", "METHOD_END"], "methodName": ["buildConnectionProvider"], "fileName": "org.hibernate.testing.env.ConnectionProviderBuilder"}, {"methodBody": ["METHOD_START", "{", "return   ConnectionProviderBuilder . buildConnectionProvider ( ConnectionProviderBuilder . getConnectionProviderProperties ( dbName )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["buildConnectionProvider"], "fileName": "org.hibernate.testing.env.ConnectionProviderBuilder"}, {"methodBody": ["METHOD_START", "{", "DriverManagerConnectionProviderImpl   connectionProvider    =    new   DriverManagerConnectionProviderImpl (  )     {", "public   boolean   supportsAggressiveRelease (  )     {", "return   allowAggressiveRelease ;", "}", "}  ;", "connectionProvider . configure ( props )  ;", "return   connectionProvider ;", "}", "METHOD_END"], "methodName": ["buildConnectionProvider"], "fileName": "org.hibernate.testing.env.ConnectionProviderBuilder"}, {"methodBody": ["METHOD_START", "{", "try    {", "Class   dataSourceClass    =    ReflectHelper . classForName (  . DATA _ SOURCE ,     . class )  ;", "DataSource   actualDataSource    =     (  ( DataSource )     ( dataSourceClass . newInstance (  )  )  )  ;", "ReflectHelper . findSetterMethod ( dataSourceClass ,     \" URL \"  ,    String . class )  . invoke ( actualDataSource ,    String . format (  . URL ,    dbName )  )  ;", "ReflectHelper . findSetterMethod ( dataSourceClass ,     \" user \"  ,    String . class )  . invoke ( actualDataSource ,     . USER )  ;", "ReflectHelper . findSetterMethod ( dataSourceClass ,     \" password \"  ,    String . class )  . invoke ( actualDataSource ,     . PASS )  ;", "final    . DataSourceInvocationHandler   dataSourceInvocationHandler    =    new    . DataSourceInvocationHandler ( actualDataSource )  ;", "DatasourceConnectionProviderImpl   connectionProvider    =    new   DatasourceConnectionProviderImpl (  )     {", "@ Override", "public   void   stop (  )     {", "dataSourceInvocationHandler . stop (  )  ;", "}", "}  ;", "connectionProvider . configure ( Collections . singletonMap ( DATASOURCE ,    Proxy . newProxyInstance ( Thread . currentThread (  )  . getContextClassLoader (  )  ,    new   Class [  ]  {    DataSource . class    }  ,    dataSourceInvocationHandler )  )  )  ;", "return   connectionProvider ;", "}    catch    ( Exception   e )     {", "throw   new   IllegalArgumentException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["buildDataSourceConnectionProvider"], "fileName": "org.hibernate.testing.env.ConnectionProviderBuilder"}, {"methodBody": ["METHOD_START", "{", "return   ConnectionProviderBuilder . getConnectionProviderProperties (  \" db 1  \"  )  ;", "}", "METHOD_END"], "methodName": ["getConnectionProviderProperties"], "fileName": "org.hibernate.testing.env.ConnectionProviderBuilder"}, {"methodBody": ["METHOD_START", "{", "Properties   props    =    new   Properties ( null )  ;", "props . put ( DRIVER ,     . DRIVER )  ;", "props . put ( URL ,    String . format (  . URL ,    dbName )  )  ;", "props . put ( USER ,     . USER )  ;", "props . put ( PASS ,     . PASS )  ;", "return   props ;", "}", "METHOD_END"], "methodName": ["getConnectionProviderProperties"], "fileName": "org.hibernate.testing.env.ConnectionProviderBuilder"}, {"methodBody": ["METHOD_START", "{", "return   TestingDatabaseInfo . DIALECT ;", "}", "METHOD_END"], "methodName": ["getCorrespondingDialect"], "fileName": "org.hibernate.testing.env.ConnectionProviderBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   Configuration (  )  . setProperty ( DRIVER ,    TestingDatabaseInfo . DRIVER )  . setProperty ( URL ,    TestingDatabaseInfo . URL )  . setProperty ( USER ,    TestingDatabaseInfo . USER )  . setProperty ( PASS ,    TestingDatabaseInfo . PASS )  . setProperty ( DIALECT ,    TestingDatabaseInfo . DIALECT . getClass (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildBaseConfiguration"], "fileName": "org.hibernate.testing.env.TestingDatabaseInfo"}, {"methodBody": ["METHOD_START", "{", "final   Class [  ]    exceptions    =    method . getExceptionTypes (  )  ;", "for    ( Class   exceptionType    :    exceptions )     {", "if    ( SQLException . class . isAssignableFrom ( exceptionType )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["canThrowSQLException"], "fileName": "org.hibernate.testing.jdbc.JdbcMocks"}, {"methodBody": ["METHOD_START", "{", "return   new   JdbcMocks . ConnectionBuilder (  )  . setDatabaseProductName ( databaseName )  . setDatabaseMajorVersion ( majorVersion )  . buildConnection (  )  ;", "}", "METHOD_END"], "methodName": ["createConnection"], "fileName": "org.hibernate.testing.jdbc.JdbcMocks"}, {"methodBody": ["METHOD_START", "{", "return   new   JdbcMocks . ConnectionBuilder (  )  . setDatabaseProductName ( databaseName )  . setDatabaseMajorVersion ( majorVersion )  . setDatabaseMinorVersion ( minorVersion )  . buildConnection (  )  ;", "}", "METHOD_END"], "methodName": ["createConnection"], "fileName": "org.hibernate.testing.jdbc.JdbcMocks"}, {"methodBody": ["METHOD_START", "{", "return   password ;", "}", "METHOD_END"], "methodName": ["getPassword"], "fileName": "org.hibernate.testing.jdbc.JdbcProperties"}, {"methodBody": ["METHOD_START", "{", "return   url ;", "}", "METHOD_END"], "methodName": ["getUrl"], "fileName": "org.hibernate.testing.jdbc.JdbcProperties"}, {"methodBody": ["METHOD_START", "{", "return   user ;", "}", "METHOD_END"], "methodName": ["getUser"], "fileName": "org.hibernate.testing.jdbc.JdbcProperties"}, {"methodBody": ["METHOD_START", "{", "List < Map < String ,     ?  >  >    results    =    new   ArrayList < Map < String ,     ?  >  >  (  )  ;", "while    ( r . next (  )  )     {", "Map < String ,    Object >    row    =    new   HashMap < String ,    Object >  (  )  ;", "for    ( int   i    =     1  ;    i    <  =     ( r . getMetaData (  )  . getColumnCount (  )  )  ;    i +  +  )     {", "row . put ( r . getMetaData (  )  . getColumnLabel ( i )  ,    r . getObject ( i )  )  ;", "results . add ( row )  ;", "}", "}", "return   results ;", "}", "METHOD_END"], "methodName": ["extractResults"], "fileName": "org.hibernate.testing.jdbc.ResultSetUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  ( connectionCounter )     !  =    null )     {", "int   currentCount    =    counts (  )  ;", "int   diff    =    currentCount    -     ( connectionLeakCount )  ;", "if    ( diff    >     0  )     {", "throw   new   Exception ( String . format (  \"  % d   connection ( s )    have   been   leaked !    Previous   leak   count :     % d ,    Current   leak   count :     % d \"  ,    diff ,    connectionLeakCount ,    currentCount )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["assertNoLeaks"], "fileName": "org.hibernate.testing.jdbc.leak.ConnectionLeakUtil"}, {"methodBody": ["METHOD_START", "{", "try    ( Connection   connection    =    newConnection (  )  )     {", "return   connectionCounter . count ( connection )  ;", "}    catch    ( SQLException   e )     {", "throw   new   IllegalStateException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["countConnectionLeaks"], "fileName": "org.hibernate.testing.jdbc.leak.ConnectionLeakUtil"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   DriverManager . get ( jdbcProperties . getUrl (  )  ,    jdbcProperties . getUser (  )  ,    jdbcProperties . getPassword (  )  )  ;", "}    catch    ( SQLException   e )     {", "throw   new   IllegalStateException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["newConnection"], "fileName": "org.hibernate.testing.jdbc.leak.ConnectionLeakUtil"}, {"methodBody": ["METHOD_START", "{", "try    {", "TestingJtaPlatformImpl . synchronizationRegistry (  )  . putResource (  . CONNECTION _ KEY ,    null )  ;", "}    catch    ( Exception   e )     {", "System . err . println (  \"  !  !  ! Error   trying   to   reset   synchronization   registry !  !  !  \"  )  ;", "}", "try    {", "delegate . closeConnection ( connection )  ;", "}    catch    ( SQLException   e )     {", "System . err . println (  \"  !  !  ! Error   trying   to   close   JDBC   connection   from   delist   callbacks !  !  !  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["delist"], "fileName": "org.hibernate.testing.jta.JtaAwareConnectionProviderImpl"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   TJtaPlatformImpl . transactionManager (  )  . getTransaction (  )  ;", "}    catch    ( SystemException   e )     {", "throw   new   IllegalStateException (  \" Could   not   locate   current   transaction \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["findCurrentTransaction"], "fileName": "org.hibernate.testing.jta.JtaAwareConnectionProviderImpl"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    source . get ( settingName )  ;", "if    ( value    !  =    null )     {", "target . put ( settingName ,    value )  ;", "}", "}", "METHOD_END"], "methodName": ["transferSetting"], "fileName": "org.hibernate.testing.jta.JtaAwareConnectionProviderImpl"}, {"methodBody": ["METHOD_START", "{", "final   StandardServiceRegistryBuilder   registryBuilder    =    new   StandardServiceRegistryBuilder (  )  ;", ". prepare ( registryBuilder )  ;", "return   registryBuilder ;", "}", "METHOD_END"], "methodName": ["prepare"], "fileName": "org.hibernate.testing.jta.TestingJtaBootstrap"}, {"methodBody": ["METHOD_START", "{", "configValues . put ( JTA _ PLATFORM ,    TestingJtaPlatformImpl . INSTANCE )  ;", "configValues . put ( CONNECTION _ PROVIDER ,    JtaAwareConnectionProviderImpl . class . getName (  )  )  ;", "configValues . put (  \" transactionType \"  ,     \" JTA \"  )  ;", "}", "METHOD_END"], "methodName": ["prepare"], "fileName": "org.hibernate.testing.jta.TestingJtaBootstrap"}, {"methodBody": ["METHOD_START", "{", "registryBuilder . applySetting ( TRANSACTION _ COORDINATOR _ STRATEGY ,     \" jta \"  )  ;", "registryBuilder . applySetting ( JTA _ PLATFORM ,    PlatformImpl . INSTANCE )  ;", "registryBuilder . applySetting ( CONNECTION _ PROVIDER ,    JtaAwareConnectionProviderImpl . class . getName (  )  )  ;", "registryBuilder . applySetting (  \" transactionType \"  ,     \" JTA \"  )  ;", "}", "METHOD_END"], "methodName": ["prepare"], "fileName": "org.hibernate.testing.jta.TestingJtaBootstrap"}, {"methodBody": ["METHOD_START", "{", "return   TestingJtaPlatformImpl . INSTANCE . synchronizationRegistry ;", "}", "METHOD_END"], "methodName": ["synchronizationRegistry"], "fileName": "org.hibernate.testing.jta.TestingJtaPlatformImpl"}, {"methodBody": ["METHOD_START", "{", "return   TestingJtaPlatformImpl . INSTANCE . retrieveTransactionManager (  )  ;", "}", "METHOD_END"], "methodName": ["transactionManager"], "fileName": "org.hibernate.testing.jta.TestingJtaPlatformImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( TestingJtaPlatformImpl . transactionManager (  )  . getStatus (  )  )     =  =     ( Status . STATUS _ MARKED _ ROLLBACK )  )     {", "TestingJtaPlatformImpl . transactionManager (  )  . rollback (  )  ;", "} else    {", "TestingJtaPlatformImpl . transactionManager (  )  . commit (  )  ;", "}", "}", "METHOD_END"], "methodName": ["tryCommit"], "fileName": "org.hibernate.testing.jta.TestingJtaPlatformImpl"}, {"methodBody": ["METHOD_START", "{", "return   TestingJtaPlatformImpl . INSTANCE . retrieveUserTransaction (  )  ;", "}", "METHOD_END"], "methodName": ["userTransaction"], "fileName": "org.hibernate.testing.jta.TestingJtaPlatformImpl"}, {"methodBody": ["METHOD_START", "{", "String [  ]    mappings    =    getMappings (  )  ;", "if    ( mappings    !  =    null )     {", "for    ( String   mapping    :    mappings )     {", "configuration . addResource (  (  ( getForMappings (  )  )     +    mapping )  ,    getClass (  )  . getClassLoader (  )  )  ;", "}", "}", "Class <  ?  >  [  ]    annotatedClasses    =    getAnnotatedClasses (  )  ;", "if    ( annotatedClasses    !  =    null )     {", "for    ( Class <  ?  >    annotatedClass    :    annotatedClasses )     {", "configuration . addAnnotatedClass ( annotatedClass )  ;", "}", "}", "String [  ]    annotatedPackages    =    getAnnotatedPackages (  )  ;", "if    ( annotatedPackages    !  =    null )     {", "for    ( String   annotatedPackage    :    annotatedPackages )     {", "configuration . addPackage ( annotatedPackage )  ;", "}", "}", "String [  ]    xmlFiles    =    getXmlFiles (  )  ;", "if    ( xmlFiles    !  =    null )     {", "for    ( String   xmlFile    :    xmlFiles )     {", "InputStream   is    =    Thread . currentThread (  )  . getContextClassLoader (  )  . getResourceAsStream ( xmlFile )  ;", "configuration . addInputStream ( is )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addMappings"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "addMappings ( cfg )  ;", "applyCacheSets ( cfg )  ;", "afterConfigurationBuilt ( cfg )  ;", "}", "METHOD_END"], "methodName": ["afterConstructAndConfigureConfiguration"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "completeStrayTransaction (  )  ;", "if    ( isCleanupTestDataRequired (  )  )     {", "cleanupTestData (  )  ;", "}", "cleanupTest (  )  ;", "cleanupSession (  )  ;", "assertAllDataRemoved (  )  ;", "}", "METHOD_END"], "methodName": ["afterTest"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getCacheConcurrencyStrategy (  )  )     !  =    null )     {", "configura . setProperty ( DEFAULT _ CACHE _ CONCURRENCY _ STRATEGY ,    getCacheConcurrencyStrategy (  )  )  ;", "configura . setSharedCacheMode ( ALL )  ;", "}", "}", "METHOD_END"], "methodName": ["applyCacheSettings"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( createSchema (  )  )  )     {", "return ;", "}", "if    (  !  ( Boolean . getBoolean (  . VALIDATE _ DATA _ CLEANUP )  )  )     {", "return ;", "}", "Session   tmpSession    =    sessionFactory . openSession (  )  ;", "Transaction   transaction    =    tmpSession . beginTransaction (  )  ;", "try    {", "List   list    =    tmpSession . createQuery (  \" select   o   from   Object   o \"  )  . list (  )  ;", "Map < String ,    Integer >    items    =    new   HashMap < String ,    Integer >  (  )  ;", "if    (  !  ( list . isEmpty (  )  )  )     {", "for    ( Object   element    :    list )     {", "Integer   l    =    items . get ( tmpSession . getEntityName ( element )  )  ;", "if    ( l    =  =    null )     {", "l    =     0  ;", "}", "l    =    l    +     1  ;", "items . put ( tmpSession . getEntityName ( element )  ,    l )  ;", "System . out . println (  (  \" Data   left :     \"     +    element )  )  ;", "}", "transaction . rollback (  )  ;", "Assert . fail (  (  \" Data   is   left   in   the   database :     \"     +     ( items . toString (  )  )  )  )  ;", "}", "transaction . rollback (  )  ;", "}    finally    {", "try    {", "if    ( transaction . getStatus (  )  . canRollback (  )  )     {", "transaction . rollback (  )  ;", "}", "tmpSession . close (  )  ;", "}    catch    ( Throwable   t )     {", "}", "}", "}", "METHOD_END"], "methodName": ["assertAllDataRemoved"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "prepareTest (  )  ;", "}", "METHOD_END"], "methodName": ["beforeTest"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "final   BootstrapServiceRegistryBuilder   builder    =    new   BootstrapServiceRegistryBuilder (  )  ;", "builder . applyClassLoader ( getClass (  )  . getClassLoader (  )  )  ;", "prepareBootstrapRegistryBuilder ( builder )  ;", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["buildBootstrapServiceRegistry"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "Configuration   cfg    =    constructAndConfigureConfiguration (  )  ;", "afterConstructAndConfigureConfiguration ( cfg )  ;", "return   cfg ;", "}", "METHOD_END"], "methodName": ["buildConfiguration"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "Properties   properties    =    new   Properties (  )  ;", "properties . putAll ( configura . getProperties (  )  )  ;", "Environment . verifyProperties ( properties )  ;", "ConfiguraHelper . resolvePlaceHolders ( properties )  ;", "StandardServiceRegistryBuilder   cfgRegistryBuilder    =    configura . getStandardServiceRegistryBuilder (  )  ;", "StandardServiceRegistryBuilder   registryBuilder    =    new   StandardServiceRegistryBuilder ( bootRegistry ,    cfgRegistryBuilder . getAggregatedCfgXml (  )  )  . applySettings ( properties )  ;", "prepareBasicRegistryBuilder ( registryBuilder )  ;", "return    (  ( StandardServiceRegistryImpl )     ( registryBuilder . build (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["buildServiceRegistry"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "buildSessionFactory ( null )  ;", "}", "METHOD_END"], "methodName": ["buildSessionFactory"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "configuration    =    constructAndConfigureConfiguration (  )  ;", "if    ( configurationAdapter    !  =    null )     {", "configurationAdapter . accept ( configuration )  ;", "}", "BootstrapServiceRegistry   bootRegistry    =    buildBootstrapServiceRegistry (  )  ;", "serviceRegistry    =    buildServiceRegistry ( bootRegistry ,    configuration )  ;", "afterConstructAndConfigureConfiguration ( configuration )  ;", "sessionFactory    =     (  ( SessionFactoryImplementor )     ( configuration . buildSessionFactory ( serviceRegistry )  )  )  ;", "afterSessionFactoryBuilt (  )  ;", "}", "METHOD_END"], "methodName": ["buildSessionFactory"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  ( sessionFactory )     !  =    null )     {", "sessionFactory . getCache (  )  . evictAllRegions (  )  ;", "}", "}", "METHOD_END"], "methodName": ["cleanupCache"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( session )     !  =    null )     &  &     (  !  (  (  ( SessionImplementor )     ( session )  )  . isClosed (  )  )  )  )     {", "session . close (  )  ;", "}", "session    =    null ;", "}", "METHOD_END"], "methodName": ["cleanupSession"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "if    ( isCleanupTestDataUsingBulkDelete (  )  )     {", "TransactionUtil . doInH ( this :  : sessionFactory ,     (    s )     -  >     {", "s . createQuery (  \" delete   from   Object \"  )  . executeUpdate (  )  ;", "}  )  ;", "} else    {", "TransactionUtil . doInH ( this :  : sessionFactory ,     (    s )     -  >     {", "s . createQuery (  \" from   Object \"  )  . list (  )  . forEach ( s :  : remove )  ;", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["cleanupTestData"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  ( session )     =  =    null )     {", "return ;", "}", "if    (  (  ( SessionImplementor )     ( session )  )  . isClosed (  )  )     {", "return ;", "}", "if    (  !  ( session . isConnected (  )  )  )     {", "return ;", "}", "final   TransaCoordinator . TransaDriver   tdc    =     (  ( SessionImplementor )     ( session )  )  . getTransaCoordinator (  )  . getTransaDriverControl (  )  ;", "if    ( tdc . getStatus (  )  . canRollback (  )  )     {", "session . getTransa (  )  . rollback (  )  ;", "}", "session . close (  )  ;", "}", "METHOD_END"], "methodName": ["completeStrayTransaction"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   configuration ;", "}", "METHOD_END"], "methodName": ["configuration"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "Configuration   cfg    =    constructConfiguration (  )  ;", "configure ( cfg )  ;", "return   cfg ;", "}", "METHOD_END"], "methodName": ["constructAndConfigureConfiguration"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "Configuration   configuration    =    new   Configuration (  )  ;", "configuration . setProperty ( CACHE _ REGION _ FACTORY ,    CachingRegionFactory . class . getName (  )  )  ;", "configuration . setProperty ( USE _ NEW _ ID _ GENERATOR _ MAPPINGS ,     \" true \"  )  ;", "if    ( createSchema (  )  )     {", "configuration . setProperty ( HBM 2 DDL _ AUTO ,     \" create - drop \"  )  ;", "final   String   secondSchemaName    =    createSecondSchema (  )  ;", "if    ( StringHelper . isNotEmpty ( secondSchemaName )  )     {", "if    (  !  (  (  . getDialect (  )  )    instanceof   H 2 Dialect )  )     {", "throw   new   UnsupportedOperationException (  \" Only   H 2    dialect   supports   creation   of   second   schema .  \"  )  ;", "}", "Helper . createH 2 Schema ( secondSchemaName ,    configuration )  ;", "}", "}", "configuration . setImplicitNamingStrategy ( INSTANCE )  ;", "configuration . setProperty ( DIALECT ,     . getDialect (  )  . getClass (  )  . getName (  )  )  ;", "return   configuration ;", "}", "METHOD_END"], "methodName": ["constructConfiguration"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["createSchema"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["createSecondSchema"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   BaseCoreFunctionalTestCase . NO _ CLASSES ;", "}", "METHOD_END"], "methodName": ["getAnnotatedClasses"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   BaseCoreFunctionalTestCase . NO _ MAPPINGS ;", "}", "METHOD_END"], "methodName": ["getAnnotatedPackages"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return    \" org / hibernate / test /  \"  ;", "}", "METHOD_END"], "methodName": ["getBaseForMappings"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getCacheConcurrencyStrategy"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   BaseCoreFunctionalTestCase . DIALECT ;", "}", "METHOD_END"], "methodName": ["getDialect"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   BaseCoreFunctionalTestCase . NO _ MAPPINGS ;", "}", "METHOD_END"], "methodName": ["getMappings"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   BaseCoreFunctionalTestCase . NO _ MAPPINGS ;", "}", "METHOD_END"], "methodName": ["getXmlFiles"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "TransactionUtil 2  . inSession ( sessionFactory (  )  ,    action )  ;", "}", "METHOD_END"], "methodName": ["inSession"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "TransactionUtil 2  . inTransaction ( sessionFactory (  )  ,    action )  ;", "}", "METHOD_END"], "methodName": ["inTransaction"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "TransactionUtil 2  . inTransaction ( session ,    action )  ;", "}", "METHOD_END"], "methodName": ["inTransaction"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isCleanupTestDataRequired"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isCleanupTestDataUsingBulkDelete"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "if    ( rebuildSessionFactoryOnError (  )  )     {", "rebuildSessionFactory (  )  ;", "}", "}", "METHOD_END"], "methodName": ["onFailure"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "session    =    sessionFactory (  )  . openSession (  )  ;", "return   session ;", "}", "METHOD_END"], "methodName": ["openSession"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "session    =    sessionFactory (  )  . withOptions (  )  . interceptor ( interceptor )  . openSession (  )  ;", "return   session ;", "}", "METHOD_END"], "methodName": ["openSession"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "int   isolation    =    Connection . TRANSACTION _ READ _ UNCOMMITTED ;", "Session   testSession    =    null ;", "try    {", "testSession    =    openSession (  )  ;", "isolation    =    testSession . doReturningWork ( new   jdbc . AbstractReturningWork < Integer >  (  )     {", "@ Override", "public   Integer   execute ( Connection   connection )    throws   SQLException    {", "return   connection . getTransactionIsolation (  )  ;", "}", "}  )  ;", "}    catch    ( Throwable   ignore )     {", "}    finally    {", "if    ( testSession    !  =    null )     {", "try    {", "testSession . close (  )  ;", "}    catch    ( Throwable   ignore )     {", "}", "}", "}", "if    ( isolation    <     ( Connection . TRANSACTION _ READ _ COMMITTED )  )     {", "SkipLog . reportSkip (  \" environment   does   not   support   at   least   read   committed   isolation \"  ,    scenario )  ;", "return   false ;", "} else    {", "return   true ;", "}", "}", "METHOD_END"], "methodName": ["readCommittedIsolationMaintained"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "rebuildSessionFactory ( null )  ;", "}", "METHOD_END"], "methodName": ["rebuildSessionFactory"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  ( sessionFactory )     =  =    null )     {", "return ;", "}", "try    {", "sessionFactory . close (  )  ;", "sessionFactory    =    null ;", "configura    =    null ;", "serviceRegistry . destroy (  )  ;", "serviceRegistry    =    null ;", "}    catch    ( Excep   ignore )     {", "}", "buildSessionFactory ( configuraAdapter )  ;", "}", "METHOD_END"], "methodName": ["rebuildSessionFactory"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["rebuildSessionFactoryOnError"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  ( sessionFactory )     =  =    null )     {", "return ;", "}", "sessionFactory . close (  )  ;", "sessionFactory    =    null ;", "configura    =    null ;", "if    (  ( serviceRegistry )     !  =    null )     {", "if    ( serviceRegistry . isActive (  )  )     {", "try    {", "serviceRegistry . destroy (  )  ;", "}    catch    ( Excep   ignore )     {", "}", "Assert . fail (  \" StandardServiceRegistry   was   not   closed   down   as   expected \"  )  ;", "}", "}", "serviceRegistry    =    null ;", "}", "METHOD_END"], "methodName": ["releaseSessionFactory"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   serviceRegistry ;", "}", "METHOD_END"], "methodName": ["serviceRegistry"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   sessionFactory ;", "}", "METHOD_END"], "methodName": ["sessionFactory"], "fileName": "org.hibernate.testing.junit4.BaseCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "completeStrayTransaction (  )  ;", "if    ( isCleanupTestDataRequired (  )  )     {", "cleanupTestData (  )  ;", "}", "cleanupTest (  )  ;", "cleanupSession (  )  ;", "assertAllDataRemoved (  )  ;", "}", "METHOD_END"], "methodName": ["afterTest"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( overrideCacheStrategy (  )  )  )     {", "return ;", "}", "if    (  ( getCacheConcurrencyStrategy (  )  )     =  =    null )     {", "return ;", "}", "for    ( PersistentClass   entityBinding    :    metadata . getEntityBindings (  )  )     {", "if    ( entityBinding . isInherited (  )  )     {", "continue ;", "}", "boolean   hasLob    =    false ;", "final   Iterator   props    =    entityBinding . getPropertyClosureIterator (  )  ;", "while    ( props . hasNext (  )  )     {", "final   Property   prop    =     (  ( Property )     ( props . next (  )  )  )  ;", "if    ( prop . getValue (  )  . isSimpleValue (  )  )     {", "if    ( isLob (  (  ( SimpleValue )     ( prop . getValue (  )  )  )  . getTypeName (  )  )  )     {", "hasLob    =    true ;", "break ;", "}", "}", "}", "if    (  ! hasLob )     {", "(  ( RootClass )     ( entityBinding )  )  . setCacheConcurrencyStrategy ( getCacheConcurrencyStrategy (  )  )  ;", "entityBinding . setCached ( true )  ;", "}", "}", "for    ( Colle   colleBinding    :    metadata . getColleBindings (  )  )     {", "boolean   isLob    =    false ;", "if    ( colleBinding . getElement (  )  . isSimpleValue (  )  )     {", "isLob    =    isLob (  (  ( SimpleValue )     ( colleBinding . getElement (  )  )  )  . getTypeName (  )  )  ;", "}", "if    (  ! isLob )     {", "colleBinding . setCacheConcurrencyStrategy ( getCacheConcurrencyStrategy (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["applyCacheSettings"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "for    ( String   mapping    :    getMappings (  )  )     {", "sources . addResource (  (  ( getForMappings (  )  )     +    mapping )  )  ;", "}", "for    ( Class   annotatedClass    :    getAnnotatedClasses (  )  )     {", "sources . addAnnotatedClass ( annotatedClass )  ;", "}", "for    ( String   annotatedPackage    :    getAnnotatedPackages (  )  )     {", "sources . addPackage ( annotatedPackage )  ;", "}", "for    ( String   ormXmlFile    :    getXmlFiles (  )  )     {", "sources . addInputStream ( Thread . currentThread (  )  . getContextClassLoader (  )  . getResourceAsStream ( ormXmlFile )  )  ;", "}", "}", "METHOD_END"], "methodName": ["applyMetadataSources"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( createSchema (  )  )  )     {", "return ;", "}", "if    (  !  ( Boolean . getBoolean (  . VALIDATE _ DATA _ CLEANUP )  )  )     {", "return ;", "}", "Session   tmpSession    =    sessionFactory . openSession (  )  ;", "try    {", "List   list    =    tmpSession . createQuery (  \" select   o   from   Object   o \"  )  . list (  )  ;", "Map < String ,    Integer >    items    =    new   HashMap < String ,    Integer >  (  )  ;", "if    (  !  ( list . isEmpty (  )  )  )     {", "for    ( Object   element    :    list )     {", "Integer   l    =    items . get ( tmpSession . getEntityName ( element )  )  ;", "if    ( l    =  =    null )     {", "l    =     0  ;", "}", "l    =    l    +     1  ;", "items . put ( tmpSession . getEntityName ( element )  ,    l )  ;", "System . out . println (  (  \" Data   left :     \"     +    element )  )  ;", "}", "Assert . fail (  (  \" Data   is   left   in   the   database :     \"     +     ( items . toString (  )  )  )  )  ;", "}", "}    finally    {", "try    {", "tmpSession . close (  )  ;", "}    catch    ( Throwable   t )     {", "}", "}", "}", "METHOD_END"], "methodName": ["assertAllDataRemoved"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "prepareTest (  )  ;", "}", "METHOD_END"], "methodName": ["beforeTest"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "final   StandardServiceRegistryBuilder   ssrb    =    constructStandardServiceRegistryBuilder (  )  ;", "serviceRegistry    =    ssrb . build (  )  ;", "afterStandardServiceRegistryBuilt ( serviceRegistry )  ;", "final   MetadataSources   metadataSources    =    new   MetadataSources ( serviceRegistry )  ;", "applyMetadataSources ( metadataSources )  ;", "afterMetadataSourcesApplied ( metadataSources )  ;", "final   MetadataBuilder   metadataBuilder    =    metadataSources . getMetadataBuilder (  )  ;", "initialize ( metadataBuilder )  ;", "cureMetadataBuilder ( metadataBuilder )  ;", "metadata    =     (  ( MetadataImplementor )     ( metadataBuilder . build (  )  )  )  ;", "applyCacheSettings ( metadata )  ;", "afterMetadataBuilt ( metadata )  ;", "final   SessionFactoryBuilder   sfb    =    metadata . getSessionFactoryBuilder (  )  ;", "initialize ( sfb ,    metadata )  ;", "cureSessionFactoryBuilder ( sfb )  ;", "sessionFactory    =     (  ( SessionFactoryImplementor )     ( sfb . build (  )  )  )  ;", "afterSessionFactoryBuilt ( sessionFactory )  ;", "}", "METHOD_END"], "methodName": ["buildResources"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  ( sessionFactory )     !  =    null )     {", "sessionFactory . getCache (  )  . evictAllRegions (  )  ;", "}", "}", "METHOD_END"], "methodName": ["cleanupCache"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( session )     !  =    null )     &  &     (  !  (  (  ( SessionImplementor )     ( session )  )  . isClosed (  )  )  )  )     {", "session . close (  )  ;", "}", "session    =    null ;", "}", "METHOD_END"], "methodName": ["cleanupSession"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "TransactionUtil . doInHibernate ( this :  : sessionFactory ,     (    s )     -  >     {", "s . createQuery (  \" delete   from   Object \"  )  . executeUpdate (  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["cleanupTestData"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  ( session )     =  =    null )     {", "return ;", "}", "if    (  (  ( SessionImplementor )     ( session )  )  . isClosed (  )  )     {", "return ;", "}", "if    (  !  ( session . isConnected (  )  )  )     {", "return ;", "}", "final   TransaCoordinator . TransaDriver   tdc    =     (  ( SessionImplementor )     ( session )  )  . getTransaCoordinator (  )  . getTransaDriverControl (  )  ;", "if    ( tdc . getStatus (  )  . canRollback (  )  )     {", "session . getTransa (  )  . rollback (  )  ;", "}", "}", "METHOD_END"], "methodName": ["completeStrayTransaction"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "final   BootstrapServiceRegistryBuilder   bsrb    =    new   BootstrapServiceRegistryBuilder (  )  ;", "bsrb . applyClassLoader ( getClass (  )  . getClassLoader (  )  )  ;", "bsrb . enableAutoClose (  )  ;", "cureBootstrapServiceRegistryBuilder ( bsrb )  ;", "final   BootstrapServiceRegistry   bsr    =    bsrb . build (  )  ;", "afterBootstrapServiceRegistryBuilt ( bsr )  ;", "final   Map   settings    =    new   HashMap (  )  ;", "addSettings ( settings )  ;", "final   StandardServiceRegistryBuilder   ssrb    =    new   StandardServiceRegistryBuilder ( bsr )  ;", "initialize ( ssrb )  ;", "ssrb . applySettings ( settings )  ;", "cureStandardServiceRegistryBuilder ( ssrb )  ;", "return   ssrb ;", "}", "METHOD_END"], "methodName": ["constructStandardServiceRegistryBuilder"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["createSchema"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["createSecondSchema"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   BaseNonConfigCoreFunctionalTestCase . NO _ CLASSES ;", "}", "METHOD_END"], "methodName": ["getAnnotatedClasses"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   BaseNonConfigCoreFunctionalTestCase . NO _ MAPPINGS ;", "}", "METHOD_END"], "methodName": ["getAnnotatedPackages"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return    \" org / hibernate / test /  \"  ;", "}", "METHOD_END"], "methodName": ["getBaseForMappings"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getCacheConcurrencyStrategy"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  ( serviceRegistry )     !  =    null )     {", "return   serviceRegistry . getService ( JdbcEnvironment . class )  . getDialect (  )  ;", "} else    {", "return   Base . getDialect (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getDialect"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   BaseNonConfigCoreFunctionalTestCase . NO _ MAPPINGS ;", "}", "METHOD_END"], "methodName": ["getMappings"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   session ;", "}", "METHOD_END"], "methodName": ["getSession"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   BaseNonConfigCoreFunctionalTestCase . NO _ MAPPINGS ;", "}", "METHOD_END"], "methodName": ["getXmlFiles"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "log . trace (  \"  # inSession ( action )  \"  )  ;", "TransactionUtil 2  . inSession ( sessionFactory (  )  ,    action )  ;", "}", "METHOD_END"], "methodName": ["inSession"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "log . trace (  \"  # inTransaction ( action )  \"  )  ;", "TransactionUtil 2  . inTransaction ( sessionFactory (  )  ,    action )  ;", "}", "METHOD_END"], "methodName": ["inTransaction"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "metadataBuilder . enableNewIdentifierGeneratorSupport ( true )  ;", "metadataBuilder . applyImplicitNamStrategy ( INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Dialect   dialect    =    BaseCoreFunctionalTestCase . getDialect (  )  ;", "ssrb . applySetting ( CACHE _ REGION _ FACTORY ,    CachingRegionFactory . class . getName (  )  )  ;", "ssrb . applySetting ( USE _ NEW _ ID _ GENERATOR _ MAPPINGS ,     \" true \"  )  ;", "if    ( createSchema (  )  )     {", "ssrb . applySetting ( HBM 2 DDL _ AUTO ,     \" create - drop \"  )  ;", "final   String   secondSchemaName    =    createSecondSchema (  )  ;", "if    ( StringHelper . isNotEmpty ( secondSchemaName )  )     {", "if    (  !  ( H 2 Dialect . class . isInstance ( dialect )  )  )     {", "throw   new   UnsupportedOperationException (  \" Only   H 2    dialect   supports   creation   of   second   schema .  \"  )  ;", "}", "Helper . createH 2 Schema ( secondSchemaName ,    ssrb . getSettings (  )  )  ;", "}", "}", "ssrb . applySetting ( DIALECT ,    dialect . getClass (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isCleanupTestDataRequired"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  (  (  (  \" blob \"  . equals ( typeName )  )     |  |     (  \" clob \"  . equals ( typeName )  )  )     |  |     (  \" nclob \"  . equals ( typeName )  )  )     |  |     ( Blob . class . getName (  )  . equals ( typeName )  )  )     |  |     ( Clob . class . getName (  )  . equals ( typeName )  )  )     |  |     ( NClob . class . getName (  )  . equals ( typeName )  )  )     |  |     ( BlobType . class . getName (  )  . equals ( typeName )  )  )     |  |     ( ClobType . class . getName (  )  . equals ( typeName )  )  )     |  |     ( NClobType . class . getName (  )  . equals ( typeName )  )  ;", "}", "METHOD_END"], "methodName": ["isLob"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   metadata ;", "}", "METHOD_END"], "methodName": ["metadata"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "if    ( rebuildSessionFactoryOnError (  )  )     {", "rebuildSessionFactory (  )  ;", "}", "}", "METHOD_END"], "methodName": ["onFailure"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "session    =    sessionFactory (  )  . openSession (  )  ;", "return   session ;", "}", "METHOD_END"], "methodName": ["openSession"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "session    =    sessionFactory (  )  . withOptions (  )  . interceptor ( interceptor )  . openSession (  )  ;", "return   session ;", "}", "METHOD_END"], "methodName": ["openSession"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["overrideCacheStrategy"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "releaseResources (  )  ;", "buildResources (  )  ;", "}", "METHOD_END"], "methodName": ["rebuildSessionFactory"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["rebuildSessionFactoryOnError"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  ( sessionFactory )     !  =    null )     {", "try    {", "sessionFactory . close (  )  ;", "}    catch    ( Excep   e )     {", "System . err . println (  (  \" Unable   to   release   SessionFactory    :     \"     +     ( e . getMessage (  )  )  )  )  ;", "e . printStackTrace (  )  ;", "}", "}", "sessionFactory    =    null ;", "if    (  ( serviceRegistry )     !  =    null )     {", "try    {", "StandardServiceRegistryBuilder . destroy ( serviceRegistry )  ;", "}    catch    ( Excep   e )     {", "System . err . println (  (  \" Unable   to   release   StandardServiceRegistry    :     \"     +     ( e . getMessage (  )  )  )  )  ;", "e . printStackTrace (  )  ;", "}", "}", "serviceRegistry    =    null ;", "}", "METHOD_END"], "methodName": ["releaseResources"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   serviceRegistry ;", "}", "METHOD_END"], "methodName": ["serviceRegistry"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "return   sessionFactory ;", "}", "METHOD_END"], "methodName": ["sessionFactory"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "releaseResources (  )  ;", "}", "METHOD_END"], "methodName": ["shutDown"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "buildResources (  )  ;", "}", "METHOD_END"], "methodName": ["startUp"], "fileName": "org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase"}, {"methodBody": ["METHOD_START", "{", "if    ( BaseUnitTestCase . enableConnectionLeakDetection )     {", "connectionLeakUtil . assertNoLeaks (  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertNoLeaks"], "fileName": "org.hibernate.testing.junit4.BaseUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "return   executorService . submit ( callable )  ;", "}", "METHOD_END"], "methodName": ["executeAsync"], "fileName": "org.hibernate.testing.junit4.BaseUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "executeAsync ( callable )  . get (  )  ;", "}    catch    ( InterruptedException   e )     {", "Thread . currentThread (  )  . interrupt (  )  ;", "}    catch    ( ExecutionException   e )     {", "throw   new   RuntimeException ( e . geuse (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["executeSync"], "fileName": "org.hibernate.testing.junit4.BaseUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "if    ( JtaStatusHelper . isActive ( TestingJtaPlatformImpl . INSTANCE . getTransactionManager (  )  )  )     {", "log . warn (  \" Cleaning   up   unfinished   transaction \"  )  ;", "try    {", "TestingJtaPlatformImpl . INSTANCE . getTransactionManager (  )  . rollback (  )  ;", "}    catch    ( SystemException   ignored )     {", "}", "}", "}", "METHOD_END"], "methodName": ["releaseTransactions"], "fileName": "org.hibernate.testing.junit4.BaseUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "Thread . sleep ( millis )  ;", "}    cch    ( InterruptedException   e )     {", "Thread . interrupted (  )  ;", "}", "}", "METHOD_END"], "methodName": ["sleep"], "fileName": "org.hibernate.testing.junit4.BaseUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "ArrayList < Iterable < Object [  ]  >  >    returnedParameters    =    new   ArrayList < Iterable < Object [  ]  >  >  (  )  ;", "ArrayList < Object [  ]  >    allParameters    =    new   ArrayList < Object [  ]  >  (  )  ;", "Object   cachedInstance    =    null ;", "for    ( FrameworkMethod   method    :    parametersMethods )     {", "Object   parameters ;", "if    ( method . isStatic (  )  )     {", "parameters    =    method . invokeExplosively ( null )  ;", "} else    {", "if    ( cachedInstance    =  =    null )     {", "cachedInstance    =    getTestClass (  )  . getOnlyConstructor (  )  . newInstance (  )  ;", "}", "parameters    =    method . invokeExplosively ( cachedInstance )  ;", "}", "if    ( parameters   instanceof   Iterable )     {", "returnedParameters . add (  (  ( Iterable < Object [  ]  >  )     ( parameters )  )  )  ;", "} else    {", "throw   parametersMethodReturnedWrongType ( method )  ;", "}", "}", "for    ( Iterable < Object [  ]  >    parameters    :    returnedParameters )     {", "if    ( allParameters . isEmpty (  )  )     {", "for    ( Object [  ]    array    :    parameters )     {", "allParameters . add ( array )  ;", "}", "} else    {", "ArrayList < Object [  ]  >    newAllParameters    =    new   ArrayList < Object [  ]  >  (  )  ;", "for    ( Object [  ]    prev    :    allParameters )     {", "for    ( Object [  ]    array    :    parameters )     {", "Object [  ]    next    =    Arrays . copyOf ( prev ,     (  ( prev . length )     +     ( array . length )  )  )  ;", "System . arraycopy ( array ,     0  ,    next ,    prev . length ,    array . length )  ;", "newAllParameters . add ( next )  ;", "}", "}", "allParameters    =    newAllParameters ;", "}", "}", "return   allParameters ;", "}", "METHOD_END"], "methodName": ["allParameters"], "fileName": "org.hibernate.testing.junit4.CustomParameterized"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( FrameworkMethod   method    :    parametersMethods )     {", ". Parameters   parameters    =    method . getAnnotation ( Parameters . class )  ;", "if    (  ( sb . length (  )  )     !  =     0  )     {", "sb . append (  \"  ,     \"  )  ;", "}", "sb . append ( parameters . name (  )  )  ;", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["concatNames"], "fileName": "org.hibernate.testing.junit4.CustomParameterized"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "for    ( Object [  ]    parametersOfSingleTest    :    allParameters )     {", "String   name    =    nameFor ( namePattern ,    i ,    parametersOfSingleTest )  ;", ". CustomRunnerForParameters   runner    =    new    . CustomRunnerForParameters ( getTestClass (  )  . getJavaClass (  )  ,    parametersOfSingleTest ,    name )  ;", "runners . add ( runner )  ;", "+  + i ;", "}", "}", "METHOD_END"], "methodName": ["createRunnersForParameters"], "fileName": "org.hibernate.testing.junit4.CustomParameterized"}, {"methodBody": ["METHOD_START", "{", "return    !  ( getAnnotatedFieldsByParameter (  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["fieldsAreAnnotated"], "fileName": "org.hibernate.testing.junit4.CustomParameterized"}, {"methodBody": ["METHOD_START", "{", "return   getTestClass (  )  . getAnnotatedFields ( Parameter . class )  ;", "}", "METHOD_END"], "methodName": ["getAnnotatedFieldsByParameter"], "fileName": "org.hibernate.testing.junit4.CustomParameterized"}, {"methodBody": ["METHOD_START", "{", "List < FrameworkMethod >    methods    =    getTestClass (  )  . getAnnotatedMethods ( Parameters . class )  ;", "SortedMap < Integer ,    FrameworkMethod >    sortedMethods    =    new   TreeMap < Integer ,    FrameworkMethod >  (  )  ;", "for    ( FrameworkMethod   each    :    methods )     {", "if    ( each . isPublic (  )  )     {", "if    (  !  ( each . isStatic (  )  )  )     {", "if    (  ( getTestClass (  )  . getOnlyConstructor (  )  . getParameterCount (  )  )     !  =     0  )     {", "throw   new   Exception (  (  (  \" Method    \"     +     ( each . getMethod (  )  )  )     +     \"    is   annotated   with    @ Parameters ,    it   is   not   static   and   there   is   no   parameter - less   constructor !  \"  )  )  ;", "}", "}", ". Order   order    =    each . getAnnotation (  . Order . class )  ;", "int   value    =     ( order    =  =    null )     ?     0     :    order . value (  )  ;", "FrameworkMethod   prev    =    sortedMethods . put ( value ,    each )  ;", "if    ( prev    !  =    null )     {", "throw   new   Exception ( String . format (  \" There   are   more   methods   annotated   with    @ Parameters   and    @ Order ( value =  % d )  :     % s    (  % s )    and    % s    (  % s )  \"  ,    value ,    prev . getMethod (  )  ,    prev . getAnnotation (  . Order . class )  ,    each . getMethod (  )  ,    order )  )  ;", "}", "} else    {", "throw   new   Exception (  (  (  \" Method    \"     +     ( each . getMethod (  )  )  )     +     \"    is   annotated   with    @ Parameters   but   it   is   not   public !  \"  )  )  ;", "}", "}", "if    ( sortedMethods . isEmpty (  )  )     {", "throw   new   Exception (  (  \" No   public   static   parameters   method   on   class    \"     +     ( getTestClass (  )  . getName (  )  )  )  )  ;", "}", "return   new   ArrayList < FrameworkMethod >  ( sortedMethods . values (  )  )  ;", "}", "METHOD_END"], "methodName": ["getParametersMethods"], "fileName": "org.hibernate.testing.junit4.CustomParameterized"}, {"methodBody": ["METHOD_START", "{", "String   finalPattern    =    namePattern . replaceAll (  \"  \\  \\  { index \\  \\  }  \"  ,    Integer . toString ( index )  )  ;", "String   name    =    MessageFormat . format ( finalPattern ,    ps )  ;", "return    (  \"  [  \"     +    name )     +     \"  ]  \"  ;", "}", "METHOD_END"], "methodName": ["nameFor"], "fileName": "org.hibernate.testing.junit4.CustomParameterized"}, {"methodBody": ["METHOD_START", "{", "String   className    =    getTestClass (  )  . getName (  )  ;", "String   methodName    =    method . getName (  )  ;", "String   message    =    MessageFormat . format (  \"  {  0  }  .  {  1  }  (  )    must   return   an   Iterable   of   arrays .  \"  ,    className ,    methodName )  ;", "return   new   Exception ( message )  ;", "}", "METHOD_END"], "methodName": ["parametersMethodReturnedWrongType"], "fileName": "org.hibernate.testing.junit4.CustomParameterized"}, {"methodBody": ["METHOD_START", "{", "return   new   CustomRunner . IgnoreImpl ( getIgnoreMessage ( reason ,    comment ,    jiraKey )  )  ;", "}", "METHOD_END"], "methodName": ["buildIgnore"], "fileName": "org.hibernate.testing.junit4.CustomRunner"}, {"methodBody": ["METHOD_START", "{", "String   ignoreMessage    =     \"  \"  ;", "for    ( RequiresDialect   requiresDialect    :    requiresDialects )     {", "ignoreMessage    +  =    getIgnoreMessage (  \"  @ RequiresDialect   non - match \"  ,    requiresDialect . comment (  )  ,    requiresDialect . jiraKey (  )  )  ;", "ignoreMessage    +  =    System . lineSeparator (  )  ;", "}", "return   new    . IgnoreImpl ( ignoreMessage )  ;", "}", "METHOD_END"], "methodName": ["buildIgnore"], "fileName": "org.hibernate.testing.junit4.CustomRunner"}, {"methodBody": ["METHOD_START", "{", "return   buildIgnore (  \"  @ RequiresDialect   non - match \"  ,    requiresDialect . comment (  )  ,    requiresDialect . jiraKey (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildIgnore"], "fileName": "org.hibernate.testing.junit4.CustomRunner"}, {"methodBody": ["METHOD_START", "{", "return   buildIgnore (  \"  @ RequiresDialectFeature   non - match \"  ,    requiresDialectFeature . comment (  )  ,    requiresDialectFeature . jiraKey (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildIgnore"], "fileName": "org.hibernate.testing.junit4.CustomRunner"}, {"methodBody": ["METHOD_START", "{", "return   new   CustomRunner . IgnoreImpl (  (  \"  @ Skip    :     \"     +     ( skip . message (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["buildIgnore"], "fileName": "org.hibernate.testing.junit4.CustomRunner"}, {"methodBody": ["METHOD_START", "{", "return   buildIgnore (  \"  @ SkipForDialect   match \"  ,    skip . comment (  )  ,    skip . jiraKey (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildIgnore"], "fileName": "org.hibernate.testing.junit4.CustomRunner"}, {"methodBody": ["METHOD_START", "{", "Skip   skip    =    Helper . locateAnnotation ( Skip . class ,    frameworkMethod ,    getTestClass (  )  )  ;", "if    ( skip    !  =    null )     {", "if    ( isMatch ( skip . condition (  )  )  )     {", "return   buildIgnore ( skip )  ;", "}", "}", "for    ( SkipForDialect   skipForDialectAnn    :    Helper . collectAnnotations ( SkipForDialect . class ,    SkipForDialects . class ,    frameworkMethod ,    getTestClass (  )  )  )     {", "for    ( Class <  ?    extends   Dialect >    dialectClass    :    skipForDialectAnn . value (  )  )     {", "if    ( skipForDialectAnn . strictMatching (  )  )     {", "if    ( dialectClass . equals (  . dialect . getClass (  )  )  )     {", "return   buildIgnore ( skipForDialectAnn )  ;", "}", "} else    {", "if    ( dialectClass . isInstance (  . dialect )  )     {", "return   buildIgnore ( skipForDialectAnn )  ;", "}", "}", "}", "}", "final   List < RequiresDialect >    requiresDialects    =    Helper . collectAnnotations ( RequiresDialect . class ,    RequiresDialects . class ,    frameworkMethod ,    getTestClass (  )  )  ;", "if    (  (  !  ( requiresDialects . isEmpty (  )  )  )     &  &     (  !  ( isDialectMatchingRequired ( requiresDialects )  )  )  )     {", "return   buildIgnore ( requiresDialects )  ;", "}", "RequiresDialectFeature   requiresDialectFeatureAnn    =    Helper . locateAnnotation ( RequiresDialectFeature . class ,    frameworkMethod ,    getTestClass (  )  )  ;", "if    ( requiresDialectFeatureAnn    !  =    null )     {", "try    {", "for    ( Class <  ?    extends   DialectCheck >    checkClass    :    requiresDialectFeatureAnn . value (  )  )     {", "if    (  !  ( checkClass . newInstance (  )  . isMatch (  . dialect )  )  )     {", "return   buildIgnore ( requiresDialectFeatureAnn )  ;", "}", "}", "}    catch    ( RuntimeException   e )     {", "throw   e ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException (  \" Unable   to   instantiate   DialectCheck \"  ,    e )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["convertSkipToIgnore"], "fileName": "org.hibernate.testing.junit4.CustomRunner"}, {"methodBody": ["METHOD_START", "{", "try    {", "retu   Dialect . getDialect (  )  ;", "}    catch    ( Exception   e )     {", "retu   new   Dialect (  )     {  }  ;", "}", "}", "METHOD_END"], "methodName": ["determineDialect"], "fileName": "org.hibernate.testing.junit4.CustomRunner"}, {"methodBody": ["METHOD_START", "{", "final   List < FrameworkMethod >    methods    =    super . computeTestMethods (  )  ;", "final   List < FrameworkMethod >    result    =    new   ArrayList < FrameworkMethod >  (  )  ;", "final   boolean   doValidation    =    Boolean . getBoolean ( Helper . VALIDATE _ FAILURE _ EXPECTED )  ;", "int   testCount    =     0  ;", "Ignore   virtualIgnore ;", "for    ( FrameworkMethod   frameworkMethod    :    methods )     {", "final   FailureExpected   failureExpected    =    Helper . locateAnnotation ( FailureExpected . class ,    frameworkMethod ,    getTestClass (  )  )  ;", "if    (  ( failureExpected    !  =    null )     &  &     (  ! doValidation )  )     {", "virtualIgnore    =    new    . IgnoreImpl ( Helper . extractIgnoreMessage ( failureExpected ,    frameworkMethod )  )  ;", "} else    {", "virtualIgnore    =    convertSkipToIgnore ( frameworkMethod )  ;", "}", "testCount +  +  ;", ". log . trace (  (  (  (  (  \" adding   test    \"     +     ( Helper . extractTestName ( frameworkMethod )  )  )     +     \"     [  #  \"  )     +    testCount )     +     \"  ]  \"  )  )  ;", "result . add ( new   ExtendedFrameworkMethod ( frameworkMethod ,    virtualIgnore ,    failureExpected )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["doComputation"], "fileName": "org.hibernate.testing.junit4.CustomRunner"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   buffer    =    new   StringBuilder ( reason )  ;", "if    ( StringHelper . isNotEmpty ( comment )  )     {", "buffer . append (  \"  ;     \"  )  . append ( comment )  ;", "}", "if    ( StringHelper . isNotEmpty ( jiraKey )  )     {", "buffer . append (  \"     (  \"  )  . append ( jiraKey )  . append (  '  )  '  )  ;", "}", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getIgnoreMessage"], "fileName": "org.hibernate.testing.junit4.CustomRunner"}, {"methodBody": ["METHOD_START", "{", "return   testClassMetadata ;", "}", "METHOD_END"], "methodName": ["getTestClassMetadata"], "fileName": "org.hibernate.testing.junit4.CustomRunner"}, {"methodBody": ["METHOD_START", "{", "if    (  ( testInstance )     =  =    null )     {", "testInstance    =    super . createTest (  )  ;", "}", "return   testInstance ;", "}", "METHOD_END"], "methodName": ["getTestInstance"], "fileName": "org.hibernate.testing.junit4.CustomRunner"}, {"methodBody": ["METHOD_START", "{", "if    (  ( isAllTestsIgnored )     =  =    null )     {", "if    ( computeTestMethods (  )  . isEmpty (  )  )     {", "isAllTestsIgnored    =    true ;", "} else    {", "isAllTestsIgnored    =    true ;", "for    ( FrameworkMethod   method    :    computeTestMethods (  )  )     {", "Ignore   ignore    =    method . getAnnotation ( Ignore . class )  ;", "if    ( ignore    =  =    null )     {", "isAllTestsIgnored    =    false ;", "break ;", "}", "}", "}", "}", "return   isAllTestsIgnored ;", "}", "METHOD_END"], "methodName": ["isAllTestsIgnored"], "fileName": "org.hibernate.testing.junit4.CustomRunner"}, {"methodBody": ["METHOD_START", "{", "boolean   foundMatch    =    false ;", "for    ( RequiresDialect   requiresDialectAnn    :    requiresDialects )     {", "for    ( Class <  ?    extends   Dialect >    dialectClass    :    requiresDialectAnn . value (  )  )     {", "foundMatch    =     ( requiresDialectAnn . strictMatching (  )  )     ?    dialectClass . equals (  . dialect . getClass (  )  )     :    dialectClass . isInstance (  . dialect )  ;", "if    ( foundMatch )     {", "break ;", "}", "}", "if    ( foundMatch )     {", "break ;", "}", "}", "return   foundMatch ;", "}", "METHOD_END"], "methodName": ["isDialectMatchingRequired"], "fileName": "org.hibernate.testing.junit4.CustomRunner"}, {"methodBody": ["METHOD_START", "{", "try    {", "Skip . Matcher   matcher    =    condition . newInstance (  )  ;", "return   matcher . isMatch (  )  ;", "}    catch    ( Exception   e )     {", "throw   new    . MatcherInstantiationException ( condition ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["isMatch"], "fileName": "org.hibernate.testing.junit4.CustomRunner"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionHelper . isEmpty ( computedTestMethods )  )     {", "return ;", "}", "Collections . sort ( computedTestMethods ,    new   Comparator < FrameworkMethod >  (  )     {", "@ Override", "public   int   compare ( FrameworkMethod   o 1  ,    FrameworkMethod   o 2  )     {", "return   o 1  . getName (  )  . compareTo ( o 2  . getName (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["sortMethods"], "fileName": "org.hibernate.testing.junit4.CustomRunner"}, {"methodBody": ["METHOD_START", "{", "return   failureExpectedAnnotation ;", "}", "METHOD_END"], "methodName": ["getFailureExpectedAnnotation"], "fileName": "org.hibernate.testing.junit4.ExtendedFrameworkMethod"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( expected . isAssignableFrom ( actual )  )  )     {", ". fail (  (  (  (  (  \" Expected   class    [  \"     +     ( expected . getName (  )  )  )     +     \"  ]    was   not   assignable   from   actual    [  \"  )     +     ( actual . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertClassAssignability"], "fileName": "org.hibernate.testing.junit4.ExtraAssertions"}, {"methodBody": ["METHOD_START", "{", "if    ( expected    !  =    actual )     {", "final   String   message    =    String . format (  (  \" JDBC   type   codes   did   not   match .  .  .  \\ n \"     +     (  \" Expected :     % s    (  % s )  \\ n \"     +     \" Actual       :     % s    (  % s )  \"  )  )  ,     . jdbcTypeCodeMap (  )  . get ( expected )  ,    expected ,     . jdbcTypeCodeMap (  )  . get ( actual )  ,    actual )  ;", "Assert . fail ( message )  ;", "}", "}", "METHOD_END"], "methodName": ["assertJdbcTypeCode"], "fileName": "org.hibernate.testing.junit4.ExtraAssertions"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( expectedType . isInstance ( value )  )  )     {", ". fail ( String . format (  \" Expecting   value   of   type    [  % s ]  ,    but   found    [  % s ]  \"  ,    expectedType . getName (  )  ,     ( value    =  =    null    ?     \"  < null >  \"     :    value )  )  )  ;", "}", "return    (  ( T )     ( value )  )  ;", "}", "METHOD_END"], "methodName": ["assertTyping"], "fileName": "org.hibernate.testing.junit4.ExtraAssertions"}, {"methodBody": ["METHOD_START", "{", "final   Field [  ]    fields    =    Types . class . getFields (  )  ;", "Map   cache    =    new   HashMap (  (  (  ( int )     (  ( fields . length )     *     0  .  7  5  )  )     +     1  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( fields . length )  ;    i +  +  )     {", "final   Field   field    =    fields [ i ]  ;", "if    ( Modifier . isStatic ( field . getModifiers (  )  )  )     {", "try    {", "cache . put ( field . get ( null )  ,    field . getName (  )  )  ;", "}    catch    ( Throwable   ignore )     {", "}", "}", "}", "return   cache ;", "}", "METHOD_END"], "methodName": ["generateJdbcTypeCache"], "fileName": "org.hibernate.testing.junit4.ExtraAssertions"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ExtraAssertions . jdbcTypeCodeMap )     =  =    null )     {", "ExtraAssertions . jdbcTypeCodeMap    =    ExtraAssertions . generateJdbcTypeCache (  )  ;", "}", "return   ExtraAssertions . jdbcTypeCodeMap ;", "}", "METHOD_END"], "methodName": ["jdbcTypeCodeMap"], "fileName": "org.hibernate.testing.junit4.ExtraAssertions"}, {"methodBody": ["METHOD_START", "{", "final   List < S >    collection    =    new   LinkedList < S >  (  )  ;", "final   S   singularAnn    =     . locateAnnotation ( singularAnnotationClass ,    frameworkMethod ,    testClass )  ;", "if    ( singularAnn    !  =    null )     {", "collection . add ( singularAnn )  ;", "}", "final   P   pluralAnn    =     . locateAnnotation ( pluralAnnotationClass ,    frameworkMethod ,    testClass )  ;", "if    ( pluralAnn    !  =    null )     {", "try    {", "collection . addAll ( Arrays . asList (  (  ( S [  ]  )     ( pluralAnnotationClass . getDeclaredMethods (  )  [  0  ]  . invoke ( pluralAnn )  )  )  )  )  ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "return   collection ;", "}", "METHOD_END"], "methodName": ["collectAnnotations"], "fileName": "org.hibernate.testing.junit4.Helper"}, {"methodBody": ["METHOD_START", "{", "settings . put ( URL ,     (  (  ( settings . get ( URL )  )     +     \"  ; INIT = CREATE   SCHEMA   IF   NOT   EXISTS    \"  )     +    schemaName )  )  ;", "}", "METHOD_END"], "methodName": ["createH2Schema"], "fileName": "org.hibernate.testing.junit4.Helper"}, {"methodBody": ["METHOD_START", "{", "Helper . createH 2 Schema ( schemaName ,    cfg . getProperties (  )  )  ;", "}", "METHOD_END"], "methodName": ["createH2Schema"], "fileName": "org.hibernate.testing.junit4.Helper"}, {"methodBody": ["METHOD_START", "{", "return   new   StringBuilder (  \" Ignoring   test    [  \"  )  . append ( Helper . extractTestName ( frameworkMethod )  )  . append (  \"  ]    due   to    @ FailureExpected    -     \"  )  . append ( Helper . extractMessage ( failureExpected )  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["extractIgnoreMessage"], "fileName": "org.hibernate.testing.junit4.Helper"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   buffer    =    new   StringBuilder (  )  ;", "buffer . append (  '  (  '  )  . append ( failureExpected . jiraKey (  )  )  . append (  '  )  '  )  ;", "if    (  . isNotEmpty ( failureExpected . message (  )  )  )     {", "buffer . append (  \"     :     \"  )  . append ( failureExpected . message (  )  )  ;", "}", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["extractMessage"], "fileName": "org.hibernate.testing.junit4.Helper"}, {"methodBody": ["METHOD_START", "{", "return    (  ( method . getDeclaringClass (  )  . getName (  )  )     +     \"  #  \"  )     +     ( method . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["extractMethodName"], "fileName": "org.hibernate.testing.junit4.Helper"}, {"methodBody": ["METHOD_START", "{", "return    (  ( frameworkMethod . getMethod (  )  . getDeclaringClass (  )  . getName (  )  )     +     '  #  '  )     +     ( frameworkMethod . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["extractTestName"], "fileName": "org.hibernate.testing.junit4.Helper"}, {"methodBody": ["METHOD_START", "{", "return    ( string    !  =    null )     &  &     (  ( string . length (  )  )     >     0  )  ;", "}", "METHOD_END"], "methodName": ["isNotEmpty"], "fileName": "org.hibernate.testing.junit4.Helper"}, {"methodBody": ["METHOD_START", "{", "T   annotation    =    frameworkMethod . getAnnotation ( annotationClass )  ;", "if    ( annotation    =  =    null )     {", "annotation    =    Class . getJavaClass (  )  . getAnnotation ( annotationClass )  ;", "}", "return   annotation ;", "}", "METHOD_END"], "methodName": ["locateAnnotation"], "fileName": "org.hibernate.testing.junit4.Helper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( afterClassOnceMethods )     =  =    null )     {", "afterClassOnceMethods    =    new   LinkedHashSet < Method >  (  )  ;", "}", "ensureAccessibility ( method )  ;", "afterClassOnceMethods . add ( method )  ;", "}", "METHOD_END"], "methodName": ["addAfterClassOnceCallback"], "fileName": "org.hibernate.testing.junit4.TestClassMetadata"}, {"methodBody": ["METHOD_START", "{", "if    (  ( beforeClassOnceMethods )     =  =    null )     {", "beforeClassOnceMethods    =    new   LinkedHashSet < Method >  (  )  ;", "}", "ensureAccessibility ( method )  ;", "beforeClassOnceMethods . add ( method )  ;", "}", "METHOD_END"], "methodName": ["addBeforeClassOnceCallback"], "fileName": "org.hibernate.testing.junit4.TestClassMetadata"}, {"methodBody": ["METHOD_START", "{", "if    (  ( onExpectedFailureCallbacks )     =  =    null )     {", "onExpectedFailureCallbacks    =    new   LinkedHashSet < hod >  (  )  ;", "}", "ensureAccessibility ( method )  ;", "onExpectedFailureCallbacks . add ( method )  ;", "}", "METHOD_END"], "methodName": ["addOnExpectedFailureCallback"], "fileName": "org.hibernate.testing.junit4.TestClassMetadata"}, {"methodBody": ["METHOD_START", "{", "if    (  ( onFailureCallbacks )     =  =    null )     {", "onFailureCallbacks    =    new   LinkedHashSet < hod >  (  )  ;", "}", "ensureAccessibility ( method )  ;", "onFailureCallbacks . add ( method )  ;", "}", "METHOD_END"], "methodName": ["addOnFailureCallback"], "fileName": "org.hibernate.testing.junit4.TestClassMetadata"}, {"methodBody": ["METHOD_START", "{", "try    {", "mhod . sAccessible ( true )  ;", "}    catch    ( Exception   ignored )     {", "}", "}", "METHOD_END"], "methodName": ["ensureAccessibility"], "fileName": "org.hibernate.testing.junit4.TestClassMetadata"}, {"methodBody": ["METHOD_START", "{", "try    {", "performCallbackInvocation ( callback ,    target )  ;", "}    catch    ( CallbackException   e )     {", "System . out . println (  (  \" Error   perform   callback   invocation    :     \"     +     ( e . getLocalizedMessage (  )  )  )  )  ;", "e . printStackTrace (  )  ;", "throw   e ;", "}", "}", "METHOD_END"], "methodName": ["invokeCallback"], "fileName": "org.hibernate.testing.junit4.TestClassMetadata"}, {"methodBody": ["METHOD_START", "{", "performCallbacks ( afterClassOnceMethods ,    target )  ;", "if    ( INSTANCE . hasRegistrations (  )  )     {", ". log . warnf (  \" Open   SessionFactory   instances   found   after   completion   of   test   class    [  % s ]  ;    closing   them \"  ,    testClass . getName (  )  )  ;", "INSTANCE . clearRegistrations (  )  ;", "}", "}", "METHOD_END"], "methodName": ["performAfterClassCallbacks"], "fileName": "org.hibernate.testing.junit4.TestClassMetadata"}, {"methodBody": ["METHOD_START", "{", "if    ( INSTANCE . hasRegistrations (  )  )     {", ". log . warnf (  \" Open   SessionFactory   instances   found   prior   to   start   of   test   class    [  % s ]  \"  ,    testClass . getName (  )  )  ;", "}", "performCallbacks ( beforeClassOnceMethods ,    target )  ;", "}", "METHOD_END"], "methodName": ["performBeforeClassCallbacks"], "fileName": "org.hibernate.testing.junit4.TestClassMetadata"}, {"methodBody": ["METHOD_START", "{", "try    {", "callback . invoke ( target ,     . NO _ ARGS )  ;", "}    catch    ( InvocationTargetException   e )     {", "throw   new   CallbackException ( callback ,    e . getTargetException (  )  )  ;", "}    catch    ( IllegalAccessException   e )     {", "throw   new   CallbackException ( callback ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["performCallbackInvocation"], "fileName": "org.hibernate.testing.junit4.TestClassMetadata"}, {"methodBody": ["METHOD_START", "{", "if    ( callbackMethods    =  =    null )     {", "return ;", "}", "for    ( Method   callbackMethod    :    callbackMethods )     {", "invokeCallback ( callbackMethod ,    target )  ;", "}", "}", "METHOD_END"], "methodName": ["performCallbacks"], "fileName": "org.hibernate.testing.junit4.TestClassMetadata"}, {"methodBody": ["METHOD_START", "{", "performCallbacks ( onExpectedFailureCallbacks ,    target )  ;", "}", "METHOD_END"], "methodName": ["performOnExpectedFailureCallback"], "fileName": "org.hibernate.testing.junit4.TestClassMetadata"}, {"methodBody": ["METHOD_START", "{", "performCallbacks ( onFailureCallbacks ,    target )  ;", "}", "METHOD_END"], "methodName": ["performOnFailureCallback"], "fileName": "org.hibernate.testing.junit4.TestClassMetadata"}, {"methodBody": ["METHOD_START", "{", "for    ( Method   method    :    testClass . getDeclaredMethods (  )  )     {", "if    (  ( method . getAnnotation (  . CallbackType . BEFORE _ CLASS _ ONCE . annotationClass )  )     !  =    null )     {", "addBeforeClassOnceCallback ( method )  ;", "}", "if    (  ( method . getAnnotation (  . CallbackType . AFTER _ CLASS _ ONCE . annotationClass )  )     !  =    null )     {", "addAfterClassOnceCallback ( method )  ;", "}", "if    (  ( method . getAnnotation (  . CallbackType . ON _ FAILURE . annotationClass )  )     !  =    null )     {", "addOnFailureCallback ( method )  ;", "}", "if    (  ( method . getAnnotation (  . CallbackType . ON _ EXPECTED _ FAILURE . annotationClass )  )     !  =    null )     {", "addOnExpectedFailureCallback ( method )  ;", "}", "}", "Class   superClass    =    testClass . getSuperclass (  )  ;", "if    ( superClass    !  =    null )     {", "processClassHierarchy ( superClass )  ;", "}", "}", "METHOD_END"], "methodName": ["processClassHierarchy"], "fileName": "org.hibernate.testing.junit4.TestClassMetadata"}, {"methodBody": ["METHOD_START", "{", "if    ( callbackMethods    !  =    null )     {", "for    ( Method   method    :    callbackMethods )     {", "validateCallbackMethod ( method ,    callbackType ,    errors )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.hibernate.testing.junit4.TestClassMetadata"}, {"methodBody": ["METHOD_START", "{", "validate ( beforeClassOnceMethods ,    TestClassMetadata . CallbackType . BEFORE _ CLASS _ ONCE ,    errors )  ;", "validate ( afterClassOnceMethods ,    TestClassMetadata . CallbackType . AFTER _ CLASS _ ONCE ,    errors )  ;", "validate ( onFailureCallbacks ,    TestClassMetadata . CallbackType . ON _ FAILURE ,    errors )  ;", "validate ( onExpectedFailureCallbacks ,    TestClassMetadata . CallbackType . ON _ EXPECTED _ FAILURE ,    errors )  ;", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.hibernate.testing.junit4.TestClassMetadata"}, {"methodBody": ["METHOD_START", "{", "if    (  ( method . getParameterCount (  )  )     >     0  )     {", "errors . add ( new   InvalidhodForAnnotationException (  (  (  ( type . buildTypeMarker (  )  )     +     \"    callback   only   valid   on   no - arg   methods    :     \"  )     +     ( Helper . extracthodName ( method )  )  )  )  )  ;", "}", "try    {", "method . setAccessible ( true )  ;", "}    catch    ( Exception   e )     {", "errors . add ( new   InvalidhodForAnnotationException (  (  ( type . buildTypeMarker (  )  )     +     \"    attached   to   inaccessible   method   and   unable   to   make   accessible \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateCallbackMethod"], "fileName": "org.hibernate.testing.junit4.TestClassMetadata"}, {"methodBody": ["METHOD_START", "{", "synchronized ( enabledListeners )     {", "enabledListeners . clear (  )  ;", "interceptEnabled . set ( false )  ;", "}", "}", "METHOD_END"], "methodName": ["clearAllListeners"], "fileName": "org.hibernate.testing.logger.Log4DelegatingLogger"}, {"methodBody": ["METHOD_START", "{", "final   Level   translatedLevel    =    Log 4 DelegatingLogger . translate ( level )  ;", "if    ( interceptEnabled . get (  )  )     {", "intercept ( level ,     (  ( parameters    =  =    null )     |  |     (  ( parameters . length )     =  =     0  )     ?    String . valueOf ( message )     :    MessageFormat . format ( String . valueOf ( message )  ,    parameters )  )  ,    thrown )  ;", "}", "if    (  !  ( logger . isEnabledFor ( translatedLevel )  )  )     {", "return ;", "}", "try    {", "logger . log ( loggerClassName ,    translatedLevel ,     (  ( parameters    =  =    null )     |  |     (  ( parameters . length )     =  =     0  )     ?    String . valueOf ( message )     :    MessageFormat . format ( String . valueOf ( message )  ,    parameters )  )  ,    thrown )  ;", "}    catch    ( Throwable   ignored )     {", "}", "}", "METHOD_END"], "methodName": ["doLog"], "fileName": "org.hibernate.testing.logger.Log4DelegatingLogger"}, {"methodBody": ["METHOD_START", "{", "final   Level   translatedLevel    =    Log 4 DelegatingLogger . translate ( level )  ;", "if    ( interceptEnabled . get (  )  )     {", "intercept ( level ,     ( parameters    =  =    null    ?    format    :    String . format ( format ,    parameters )  )  ,    thrown )  ;", "}", "if    (  !  ( logger . isEnabledFor ( translatedLevel )  )  )     {", "return ;", "}", "try    {", "logger . log ( loggerClassName ,    translatedLevel ,     ( parameters    =  =    null    ?    format    :    String . format ( format ,    parameters )  )  ,    thrown )  ;", "}    catch    ( Throwable   ignored )     {", "}", "}", "METHOD_END"], "methodName": ["doLogf"], "fileName": "org.hibernate.testing.logger.Log4DelegatingLogger"}, {"methodBody": ["METHOD_START", "{", "synchronized ( enabledListeners )     {", "for    ( LogListener   listener    :    enabledListeners )     {", "listenerdEvent ( level ,    renderedMessage ,    thrown )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["intercept"], "fileName": "org.hibernate.testing.logger.Log4DelegatingLogger"}, {"methodBody": ["METHOD_START", "{", "final   Level   l    =    Log 4 DelegatingLogger . translate ( level )  ;", "return    ( logger . isEnabledFor ( l )  )     &  &     ( l . isGreaterOrEqual ( logger . getEffectiveLevel (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isEnabled"], "fileName": "org.hibernate.testing.logger.Log4DelegatingLogger"}, {"methodBody": ["METHOD_START", "{", "synchronized ( enabledListeners )     {", "if    ( newListener    !  =    null )     {", "enabledListeners . add ( newListener )  ;", "interceptEnabled . set ( true )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["registerListener"], "fileName": "org.hibernate.testing.logger.Log4DelegatingLogger"}, {"methodBody": ["METHOD_START", "{", "if    ( level    =  =    null )     {", "return   apache . log 4 j . Level . ALL ;", "}", "switch    ( level )     {", "case   FATAL    :", "return   apache . log 4 j . Level . FATAL ;", "case   ERROR    :", "return   apache . log 4 j . Level . ERROR ;", "case   WARN    :", "return   apache . log 4 j . Level . WARN ;", "case   INFO    :", "return   apache . log 4 j . Level . INFO ;", "case   DEBUG    :", "return   apache . log 4 j . Level . DEBUG ;", "case   TRACE    :", "return   apache . log 4 j . Level . TRACE ;", "}", "return   apache . log 4 j . Level . ALL ;", "}", "METHOD_END"], "methodName": ["translate"], "fileName": "org.hibernate.testing.logger.Log4DelegatingLogger"}, {"methodBody": ["METHOD_START", "{", "LogDelegationTest . TestListener   listener    =    new   LogDelegationTest . TestListener (  )  ;", "LogInspectionHelper . registerListener ( listener ,    LogDelegationTest . LOG )  ;", "LogInspectionHelper . clearAllListeners ( LogDelegationTest . LOG )  ;", "LogDelegationTest . LOG . debug (  \" Hey   coffee   is   ready !  \"  )  ;", "Assert . assertThat ( listener . isCAlled ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["testClearListeners"], "fileName": "org.hibernate.testing.logger.LogDelegationTest"}, {"methodBody": ["METHOD_START", "{", "Assert . assertThat ( LogDelegationTest . LOG ,    instanceOf ( Log 4 DelegatingLogger . class )  )  ;", "}", "METHOD_END"], "methodName": ["testLogDelegationIsActivated"], "fileName": "org.hibernate.testing.logger.LogDelegationTest"}, {"methodBody": ["METHOD_START", "{", "LogDelegationTest . TestListener   listener    =    new   LogDelegationTest . TestListener (  )  ;", "LogInspectionHelper . registerListener ( listener ,    LogDelegationTest . LOG )  ;", "LogDelegationTest . LOG . debug (  \" Hey   coffee   is   ready !  \"  )  ;", "Assert . assertThat ( listener . isCAlled ,    is ( true )  )  ;", "Assert . assertThat ( listener . level ,    is ( DEBUG )  )  ;", "Assert . assertThat (  (  ( String )     ( listener . renderedMessage )  )  ,    is (  \" Hey   coffee   is   ready !  \"  )  )  ;", "Assert . assertThat ( listener . thrown ,    nullValue (  )  )  ;", "LogInspectionHelper . clearAllListeners ( LogDelegationTest . LOG )  ;", "}", "METHOD_END"], "methodName": ["testRecording"], "fileName": "org.hibernate.testing.logger.LogDelegationTest"}, {"methodBody": ["METHOD_START", "{", "LogInspectionHelper . convertType ( log )  . clearAllListeners (  )  ;", "}", "METHOD_END"], "methodName": ["clearAllListeners"], "fileName": "org.hibernate.testing.logger.LogInspectionHelper"}, {"methodBody": ["METHOD_START", "{", "if    ( log   instanceof   DelegatingBasicLogger )     {", "DelegatingBasicLogger   wrapper    =     (  ( DelegatingBasicLogger )     ( log )  )  ;", "try    {", "return    . extractFromWrapper ( wrapper )  ;", "}    catch    ( Exception   cause )     {", "throw   new   RuntimeException ( cause )  ;", "}", "}", "if    (  !  ( log   instanceof   Log 4 DelegatingLogger )  )     {", "throw   new   AssertionFailure (  \" Unexpected   log   type :    JBoss   Logger   didn ' t   register   the   custom   TestableLoggerProvider   as   logger   provider \"  )  ;", "}", "return    (  ( Log 4 DelegatingLogger )     ( log )  )  ;", "}", "METHOD_END"], "methodName": ["convertType"], "fileName": "org.hibernate.testing.logger.LogInspectionHelper"}, {"methodBody": ["METHOD_START", "{", "Field   field    =    DelegatingBasicLogger . class . getDeclaredField (  \" log \"  )  ;", "field . setAccessible ( true )  ;", "Object   object    =    field . get ( wrapper )  ;", "return    . convertType (  (  ( BasicLogger )     ( object )  )  )  ;", "}", "METHOD_END"], "methodName": ["extractFromWrapper"], "fileName": "org.hibernate.testing.logger.LogInspectionHelper"}, {"methodBody": ["METHOD_START", "{", "LogInspectionHelper . convertType ( log )  . registerListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["registerListener"], "fileName": "org.hibernate.testing.logger.LogInspectionHelper"}, {"methodBody": ["METHOD_START", "{", "LogInspectionHelper . registerListener ( listener ,    log )  ;", "}", "METHOD_END"], "methodName": ["registerListener"], "fileName": "org.hibernate.testing.logger.LoggerInspectionRule"}, {"methodBody": ["METHOD_START", "{", "TriggerOnPrefixLogListener   listener    =    new   TriggerOnPrefixLogListener ( prefix )  ;", "registerListener ( listener )  ;", "return   listener ;", "}", "METHOD_END"], "methodName": ["watchForLogMessages"], "fileName": "org.hibernate.testing.logger.LoggerInspectionRule"}, {"methodBody": ["METHOD_START", "{", "TriggerOnPrefixLogListener   listener    =    new   TriggerOnPrefixLogListener ( prefixes )  ;", "registerListener ( listener )  ;", "return   listener ;", "}", "METHOD_END"], "methodName": ["watchForLogMessages"], "fileName": "org.hibernate.testing.logger.LoggerInspectionRule"}, {"methodBody": ["METHOD_START", "{", "Triggerable   triggerable    =    logInspection . watchForLogMessages (  \" HHH 0  0  0  0  0  8  :  \"  )  ;", "Assert . assertFalse ( triggerable . wasTriggered (  )  )  ;", ". LOG . autoFlushWillNotWork (  )  ;", "Assert . assertTrue ( triggerable . wasTriggered (  )  )  ;", "triggerable . reset (  )  ;", "Assert . assertFalse ( triggerable . wasTriggered (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRule"], "fileName": "org.hibernate.testing.logger.LoggingRuleTest"}, {"methodBody": ["METHOD_START", "{", "NDC . remove (  )  ;", "}", "METHOD_END"], "methodName": ["clearNdc"], "fileName": "org.hibernate.testing.logger.TestableLoggerProvider"}, {"methodBody": ["METHOD_START", "{", "Logger   logger    =    TestableLoggerProvider . reuseLoggerInstances . get ( name )  ;", "if    ( logger    =  =    null )     {", "logger    =    new   Log 4 DelegatingLogger (  (  \"  \"  . equals ( name )     ?     \" ROOT \"     :    name )  )  ;", "Logger   previous    =    TestableLoggerProvider . reuseLoggerInstances . putIfAbsent ( name ,    logger )  ;", "if    ( previous    !  =    null )     {", "return   previous ;", "}", "}", "return   logger ;", "}", "METHOD_END"], "methodName": ["getLogger"], "fileName": "org.hibernate.testing.logger.TestableLoggerProvider"}, {"methodBody": ["METHOD_START", "{", "return   MDC . get ( key )  ;", "}", "METHOD_END"], "methodName": ["getMdc"], "fileName": "org.hibernate.testing.logger.TestableLoggerProvider"}, {"methodBody": ["METHOD_START", "{", "return   MDC . getContext (  )  ;", "}", "METHOD_END"], "methodName": ["getMdcMap"], "fileName": "org.hibernate.testing.logger.TestableLoggerProvider"}, {"methodBody": ["METHOD_START", "{", "return   NDC . get (  )  ;", "}", "METHOD_END"], "methodName": ["getNdc"], "fileName": "org.hibernate.testing.logger.TestableLoggerProvider"}, {"methodBody": ["METHOD_START", "{", "return   NDC . getDepth (  )  ;", "}", "METHOD_END"], "methodName": ["getNdcDepth"], "fileName": "org.hibernate.testing.logger.TestableLoggerProvider"}, {"methodBody": ["METHOD_START", "{", "return   NDC . peek (  )  ;", "}", "METHOD_END"], "methodName": ["peekNdc"], "fileName": "org.hibernate.testing.logger.TestableLoggerProvider"}, {"methodBody": ["METHOD_START", "{", "return   NDC . pop (  )  ;", "}", "METHOD_END"], "methodName": ["popNdc"], "fileName": "org.hibernate.testing.logger.TestableLoggerProvider"}, {"methodBody": ["METHOD_START", "{", "NDC . push ( message )  ;", "}", "METHOD_END"], "methodName": ["pushNdc"], "fileName": "org.hibernate.testing.logger.TestableLoggerProvider"}, {"methodBody": ["METHOD_START", "{", "try    {", "retu   MDC . get ( key )  ;", "}    finally    {", "MDC . put ( key ,    val )  ;", "}", "}", "METHOD_END"], "methodName": ["putMdc"], "fileName": "org.hibernate.testing.logger.TestableLoggerProvider"}, {"methodBody": ["METHOD_START", "{", "MDC . remove ( key )  ;", "}", "METHOD_END"], "methodName": ["removeMdc"], "fileName": "org.hibernate.testing.logger.TestableLoggerProvider"}, {"methodBody": ["METHOD_START", "{", "NDC . setMaxDepth ( maxDepth )  ;", "}", "METHOD_END"], "methodName": ["setNdcMaxDepth"], "fileName": "org.hibernate.testing.logger.TestableLoggerProvider"}, {"methodBody": ["METHOD_START", "{", "SchemaCreateHelper . create ( metadata ,     (  ( MetadataImplementor )     ( metadata )  )  . getMetadataBuildingOptions (  )  . getServiceRegistry (  )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.hibernate.testing.schema.SchemaCreateHelper"}, {"methodBody": ["METHOD_START", "{", "final   Map   settings    =    serviceRegistry . getService ( ConfigurationService . class )  . getSettings (  )  ;", "settings . put ( HBM 2 DDL _ DATABASE _ ACTION ,    CREATE )  ;", "settings . put ( HBM 2 DDL _ CONNECTION ,    connection )  ;", "ManagementToolCoordinator . process ( metadata ,    serviceRegistry ,    settings ,    INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.hibernate.testing.schema.SchemaCreateHelper"}, {"methodBody": ["METHOD_START", "{", "final   Map   settings    =    serviceRegistry . getService ( ConfigurationService . class )  . getSettings (  )  ;", "settings . put ( HBM 2 DDL _ DATABASE _ ACTION ,    CREATE )  ;", "ManagementToolCoordinator . process ( metadata ,    serviceRegistry ,    settings ,    INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.hibernate.testing.schema.SchemaCreateHelper"}, {"methodBody": ["METHOD_START", "{", "final   Map   settings    =    serviceRegistry . getService ( ConfigurationService . class )  . getSettings (  )  ;", "settings . put ( HBM 2 DDL _ DATABASE _ ACTION ,    CREATE _ ONLY )  ;", "ManagementToolCoordinator . process ( metadata ,    serviceRegistry ,    settings ,    INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["createOnly"], "fileName": "org.hibernate.testing.schema.SchemaCreateHelper"}, {"methodBody": ["METHOD_START", "{", "SchemaCreateHelper . toWriter ( metadata ,    new   OutputStreamWriter ( System . out )  )  ;", "}", "METHOD_END"], "methodName": ["toStdOut"], "fileName": "org.hibernate.testing.schema.SchemaCreateHelper"}, {"methodBody": ["METHOD_START", "{", "final   ServiceRegistry   serviceRegistry    =     (  ( MetadataImplementor )     ( metadata )  )  . getMetadataBuildingOptions (  )  . getServiceRegistry (  )  ;", "final   Map   settings    =    serviceRegistry . getService ( ConfigurationService . class )  . getSettings (  )  ;", "settings . put ( HBM 2 DDL _ SCRIPTS _ ACTION ,    CREATE )  ;", "settings . put ( HBM 2 DDL _ SCRIPTS _ CREATE _ TARGET ,    writer )  ;", "ManagementToolCoordinator . process ( metadata ,    serviceRegistry ,    settings ,    INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["toWriter"], "fileName": "org.hibernate.testing.schema.SchemaCreateHelper"}, {"methodBody": ["METHOD_START", "{", "SchemaDropHelper . drop ( metadata ,     (  ( MetadataImplementor )     ( metadata )  )  . getMetadataBuildingOptions (  )  . getServiceRegistry (  )  )  ;", "}", "METHOD_END"], "methodName": ["drop"], "fileName": "org.hibernate.testing.schema.SchemaDropHelper"}, {"methodBody": ["METHOD_START", "{", "final   Map   settings    =    serviceRegistry . getService ( ConfigurationService . class )  . getSettings (  )  ;", "settings . put ( HBM 2 DDL _ DATABASE _ ACTION ,    DROP )  ;", "ManagementToolCoordinator . process ( metadata ,    serviceRegistry ,    settings ,    INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["drop"], "fileName": "org.hibernate.testing.schema.SchemaDropHelper"}, {"methodBody": ["METHOD_START", "{", "final   Map   settings    =    serviceRegistry . getService ( ConfigurationService . class )  . getSettings (  )  ;", "settings . put ( HBM 2 DDL _ DATABASE _ ACTION ,    DROP )  ;", "settings . put ( HBM 2 DDL _ CONNECTION ,    connection )  ;", "ManagementToolCoordinator . process ( metadata ,    serviceRegistry ,    settings ,    INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["drop"], "fileName": "org.hibernate.testing.schema.SchemaDropHelper"}, {"methodBody": ["METHOD_START", "{", "SchemaUpdateHelper . toWriter ( metadata ,    new   OutputStreamWriter ( System . out )  )  ;", "}", "METHOD_END"], "methodName": ["toStdout"], "fileName": "org.hibernate.testing.schema.SchemaUpdateHelper"}, {"methodBody": ["METHOD_START", "{", "final   ServiceRegistry   serviceRegistry    =     (  ( MetadataImplementor )     ( metadata )  )  . getMetadataBuildingOptions (  )  . getServiceRegistry (  )  ;", "final   Map   settings    =    serviceRegistry . getService ( ConfigurationService . class )  . getSettings (  )  ;", "settings . put ( HBM 2 DDL _ SCRIPTS _ ACTION ,    UPDATE )  ;", "settings . put ( HBM 2 DDL _ SCRIPTS _ CREATE _ TARGET ,    writer )  ;", "ManagementToolCoordinator . process ( metadata ,    serviceRegistry ,    settings ,    INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["toWriter"], "fileName": "org.hibernate.testing.schema.SchemaUpdateHelper"}, {"methodBody": ["METHOD_START", "{", "SchemaUpdateHelper . update ( metadata ,     (  ( MetadataImplementor )     ( metadata )  )  . getMetadataBuildingOptions (  )  . getServiceRegistry (  )  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.hibernate.testing.schema.SchemaUpdateHelper"}, {"methodBody": ["METHOD_START", "{", "final   Map   settings    =    serviceRegistry . getService ( ConfigurationService . class )  . getSettings (  )  ;", "settings . put ( HBM 2 DDL _ DATABASE _ ACTION ,    UPDATE )  ;", "ManagementToolCoordinator . process ( metadata ,    serviceRegistry ,    settings ,    INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.hibernate.testing.schema.SchemaUpdateHelper"}, {"methodBody": ["METHOD_START", "{", "SchemaValidateHelper . validate ( metadata ,     (  ( MetadataImplementor )     ( metadata )  )  . getMetadataBuildingOptions (  )  . getServiceRegistry (  )  )  ;", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.hibernate.testing.schema.SchemaValidateHelper"}, {"methodBody": ["METHOD_START", "{", "Session   session    =    null ;", "txn    =    null ;", "try    {", "session    =    factorySupplier . get (  )  . withOptions (  )  . tenantIdentifier ( tenant )  . openSession (  )  ;", "txn    =    session . get (  )  ;", "txn . begin (  )  ;", "function . accept ( session )  ;", "txn . commit (  )  ;", "}    catch    ( Throwable   e )     {", "if    ( txn    !  =    null )     {", "txn . rollback (  )  ;", "}", "throw   e ;", "}    finally    {", "if    ( session    !  =    null )     {", "session . close (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doInHibernate"], "fileName": "org.hibernate.testing.transaction.TransactionUtil"}, {"methodBody": ["METHOD_START", "{", "Session   session    =    null ;", "txn    =    null ;", "try    {", "session    =    factorySupplier . get (  )  . withOptions (  )  . tenantIdentifier ( tenant )  . openSession (  )  ;", "txn    =    session . get (  )  ;", "txn . begin (  )  ;", "R   returnValue    =    function . apply ( session )  ;", "txn . commit (  )  ;", "return   returnValue ;", "}    catch    ( Throwable   e )     {", "if    ( txn    !  =    null )     {", "txn . rollback (  )  ;", "}", "throw   e ;", "}    finally    {", "if    ( session    !  =    null )     {", "session . close (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doInHibernate"], "fileName": "org.hibernate.testing.transaction.TransactionUtil"}, {"methodBody": ["METHOD_START", "{", "Session   session    =    null ;", "Transaction   txn    =    null ;", "try    {", "session    =    factorySupplier . get (  )  . openSession (  )  ;", "function . beforeTransactionCompletion (  )  ;", "txn    =    session . beginTransaction (  )  ;", "function . accept ( session )  ;", "if    (  !  ( txn . getRollbackOnly (  )  )  )     {", "txn . commit (  )  ;", "} else    {", "try    {", "txn . rollback (  )  ;", "}    catch    ( Exception   e )     {", ". log . error (  \" Rollback   failure \"  ,    e )  ;", "}", "}", "}    catch    ( Throwable   t )     {", "if    (  ( txn    !  =    null )     &  &     ( txn . isActive (  )  )  )     {", "try    {", "txn . rollback (  )  ;", "}    catch    ( Exception   e )     {", ". log . error (  \" Rollback   failure \"  ,    e )  ;", "}", "}", "throw   t ;", "}    finally    {", "function . afterTransactionCompletion (  )  ;", "if    ( session    !  =    null )     {", "session . close (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doInHibernate"], "fileName": "org.hibernate.testing.transaction.TransactionUtil"}, {"methodBody": ["METHOD_START", "{", "T   result    =    null ;", "Session   session    =    null ;", "Transaction   txn    =    null ;", "try    {", "session    =    factorySupplier . get (  )  . openSession (  )  ;", "function . beforeTransactionCompletion (  )  ;", "txn    =    session . beginTransaction (  )  ;", "result    =    function . apply ( session )  ;", "if    (  !  ( txn . getRollbackOnly (  )  )  )     {", "txn . commit (  )  ;", "} else    {", "try    {", "txn . rollback (  )  ;", "}    catch    ( Exception   e )     {", ". log . error (  \" Rollback   failure \"  ,    e )  ;", "}", "}", "}    catch    ( Throwable   t )     {", "if    (  ( txn    !  =    null )     &  &     ( txn . isActive (  )  )  )     {", "try    {", "txn . rollback (  )  ;", "}    catch    ( Exception   e )     {", ". log . error (  \" Rollback   failure \"  ,    e )  ;", "}", "}", "throw   t ;", "}    finally    {", "function . afterTransactionCompletion (  )  ;", "if    ( session    !  =    null )     {", "session . close (  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["doInHibernate"], "fileName": "org.hibernate.testing.transaction.TransactionUtil"}, {"methodBody": ["METHOD_START", "{", "Session   session    =    null ;", "Transaction   txn    =    null ;", "try    {", "session    =    sessionBuilderSupplier . get (  )  . openSession (  )  ;", "function . beforeTransactionCompletion (  )  ;", "txn    =    session . beginTransaction (  )  ;", "function . accept ( session )  ;", "if    (  !  ( txn . getRollbackOnly (  )  )  )     {", "txn . commit (  )  ;", "} else    {", "try    {", "txn . rollback (  )  ;", "}    catch    ( Exception   e )     {", ". log . error (  \" Rollback   failure \"  ,    e )  ;", "}", "}", "}    catch    ( Throwable   t )     {", "if    (  ( txn    !  =    null )     &  &     ( txn . isActive (  )  )  )     {", "try    {", "txn . rollback (  )  ;", "}    catch    ( Exception   e )     {", ". log . error (  \" Rollback   failure \"  ,    e )  ;", "}", "}", "throw   t ;", "}    finally    {", "function . afterTransactionCompletion (  )  ;", "if    ( session    !  =    null )     {", "session . close (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doInHibernateSessionBuilder"], "fileName": "org.hibernate.testing.transaction.TransactionUtil"}, {"methodBody": ["METHOD_START", "{", "T   result    =    null ;", "Session   session    =    null ;", "Transaction   txn    =    null ;", "try    {", "session    =    sessionBuilderSupplier . get (  )  . openSession (  )  ;", "function . beforeTransactionCompletion (  )  ;", "txn    =    session . beginTransaction (  )  ;", "result    =    function . apply ( session )  ;", "if    (  !  ( txn . getRollbackOnly (  )  )  )     {", "txn . commit (  )  ;", "} else    {", "try    {", "txn . rollback (  )  ;", "}    catch    ( Exception   e )     {", ". log . error (  \" Rollback   failure \"  ,    e )  ;", "}", "}", "}    catch    ( Throwable   t )     {", "if    (  ( txn    !  =    null )     &  &     ( txn . isActive (  )  )  )     {", "try    {", "txn . rollback (  )  ;", "}    catch    ( Exception   e )     {", ". log . error (  \" Rollback   failure \"  ,    e )  ;", "}", "}", "throw   t ;", "}    finally    {", "function . afterTransactionCompletion (  )  ;", "if    ( session    !  =    null )     {", "session . close (  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["doInHibernateSessionBuilder"], "fileName": "org.hibernate.testing.transaction.TransactionUtil"}, {"methodBody": ["METHOD_START", "{", "return   TransactionUtil . doInJPA ( factorySupplier ,    function ,    null )  ;", "}", "METHOD_END"], "methodName": ["doInJPA"], "fileName": "org.hibernate.testing.transaction.TransactionUtil"}, {"methodBody": ["METHOD_START", "{", "T   result    =    null ;", "EntityManager   entityManager    =    null ;", "Entity   txn    =    null ;", "try    {", "entityManager    =     ( properties    =  =    null )     ?    factorySupplier . get (  )  . createEntityManager (  )     :    factorySupplier . get (  )  . createEntityManager ( properties )  ;", "function . beforeCompletion (  )  ;", "txn    =    entityManager . get (  )  ;", "txn . begin (  )  ;", "result    =    function . apply ( entityManager )  ;", "txn . commit (  )  ;", "}    catch    ( Throwable   e )     {", "if    (  ( txn    !  =    null )     &  &     ( txn . isActive (  )  )  )     {", "txn . rollback (  )  ;", "}", "throw   e ;", "}    finally    {", "function . afterCompletion (  )  ;", "if    ( entityManager    !  =    null )     {", "entityManager . close (  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["doInJPA"], "fileName": "org.hibernate.testing.transaction.TransactionUtil"}, {"methodBody": ["METHOD_START", "{", "TransactionUtil . doInJPA ( factorySupplier ,    function ,    null )  ;", "}", "METHOD_END"], "methodName": ["doInJPA"], "fileName": "org.hibernate.testing.transaction.TransactionUtil"}, {"methodBody": ["METHOD_START", "{", "EntityManager   entityManager    =    null ;", "EntityTransaction   txn    =    null ;", "try    {", "entityManager    =     ( properties    =  =    null )     ?    factorySupplier . get (  )  . createEntityManager (  )     :    factorySupplier . get (  )  . createEntityManager ( properties )  ;", "function . beforeTransactionCompletion (  )  ;", "txn    =    entityManager . getTransaction (  )  ;", "txn . begin (  )  ;", "function . accept ( entityManager )  ;", "if    (  !  ( txn . getRollbackOnly (  )  )  )     {", "txn . commit (  )  ;", "} else    {", "try    {", "txn . rollback (  )  ;", "}    catch    ( Exception   e )     {", ". log . error (  \" Rollback   failure \"  ,    e )  ;", "}", "}", "}    catch    ( Throwable   t )     {", "if    (  ( txn    !  =    null )     &  &     ( txn . isActive (  )  )  )     {", "try    {", "txn . rollback (  )  ;", "}    catch    ( Exception   e )     {", ". log . error (  \" Rollback   failure \"  ,    e )  ;", "}", "}", "throw   t ;", "}    finally    {", "function . afterTransactionCompletion (  )  ;", "if    ( entityManager    !  =    null )     {", "entityManager . close (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doInJPA"], "fileName": "org.hibernate.testing.transaction.TransactionUtil"}, {"methodBody": ["METHOD_START", "{", "TransactionUtil . setJdbcTimeout ( session ,    TimeUnit . SECONDS . toMillis (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["setJdbcTimeout"], "fileName": "org.hibernate.testing.transaction.TransactionUtil"}, {"methodBody": ["METHOD_START", "{", "session . doWork (  (    connection )     -  >     {", "if    (  ( Dialect . getDialect (  )  )    instanceof   PostgreSQL 8  1 Dialect )     {", "try    ( Statement   st    =    connection . createStatement (  )  )     {", "st . execute ( String . format (  \" SET   statement _ timeout   TO    % d \"  ,     ( millis    /     1  0  )  )  )  ;", "}", "} else", "if    (  ( Dialect . getDialect (  )  )    instanceof   dialect . MySQLDialect )     {", "try    ( PreparedStatement   st    =    connection . prepareStatement (  \" SET   SESSION   innodb _ lock _ wait _ timeout    =     ?  \"  )  )     {", "st . setLong (  1  ,    TimeUnit . MILLISECONDS . toSeconds ( millis )  )  ;", "st . execute (  )  ;", "}", "} else", "if    (  ( Dialect . getDialect (  )  )    instanceof   dialect . H 2 Dialect )     {", "try    ( PreparedStatement   st    =    connection . prepareStatement (  \" SET   LOCK _ TIMEOUT    ?  \"  )  )     {", "st . setLong (  1  ,     ( millis    /     1  0  )  )  ;", "st . execute (  )  ;", "}", "} else", "if    (  ( Dialect . getDialect (  )  )    instanceof   dialect . SQLServerDialect )     {", "try    ( Statement   st    =    connection . createStatement (  )  )     {", "st . execute ( String . format (  \" SET   LOCK _ TIMEOUT    % d \"  ,     ( millis    /     1  0  )  )  )  ;", "}", "} else", "if    (  ( Dialect . getDialect (  )  )    instanceof   dialect . AbstractHANADialect )     {", "try    ( Statement   st    =    connection . createStatement (  )  )     {", "st . execute ( String . format (  \" SET   TRANSACTION   LOCK   WAIT   TIMEOUT    % d \"  ,    millis )  )  ;", "}", "} else    {", "try    {", "connection . setNetworkTimeout ( newSingleThreadExecutor (  )  ,     (  ( int )     ( millis )  )  )  ;", "}    catch    (    ignore )     {", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["setJdbcTimeout"], "fileName": "org.hibernate.testing.transaction.TransactionUtil"}, {"methodBody": ["METHOD_START", "{", "TransactionUtil 2  . log . trace (  \"  # inSession ( SF , action )  \"  )  ;", "try    ( SessionImplementor   session    =     (  ( SessionImplementor )     ( sfi . openSession (  )  )  )  )     {", "TransactionUtil 2  . log . trace (  \" Session   opened ,    calling   action \"  )  ;", "action . accept ( session )  ;", "TransactionUtil 2  . log . trace (  \" called   action \"  )  ;", "}    finally    {", "TransactionUtil 2  . log . trace (  \" Session   closed    ( AutoCloseable )  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["inSession"], "fileName": "org.hibernate.testing.transaction.TransactionUtil2"}, {"methodBody": ["METHOD_START", "{", "TransactionUtil 2  . log . trace (  \"  # inTransaction ( factory ,    action )  \"  )  ;", "TransactionUtil 2  . inSession ( factory ,     (    session )     -  >     {", "inTransaction ( session ,    action )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["inTransaction"], "fileName": "org.hibernate.testing.transaction.TransactionUtil2"}, {"methodBody": ["METHOD_START", "{", "TransactionUtil 2  . log . trace (  \" inTransaction ( session , action )  \"  )  ;", "final   Transaction   txn    =    session . beginTransaction (  )  ;", "TransactionUtil 2  . log . trace (  \" Started   transaction \"  )  ;", "try    {", "TransactionUtil 2  . log . trace (  \" Calling   action   in   txn \"  )  ;", "action . accept ( session )  ;", "TransactionUtil 2  . log . trace (  \" Called   action    -    in   txn \"  )  ;", "if    (  !  ( txn . isActive (  )  )  )     {", "throw   new   TransactionUtil 2  . TransactionManagementException ( TransactionUtil 2  . ACTION _ COMPLETED _ TXN )  ;", "}", "}    catch    ( Exception   e )     {", "if    (  !  ( txn . isActive (  )  )  )     {", "TransactionUtil 2  . log . warn ( TransactionUtil 2  . ACTION _ COMPLETED _ TXN ,    e )  ;", "} else    {", "TransactionUtil 2  . log . trace (  \" Rolling   back   transaction   due   to   action   error \"  )  ;", "try    {", "txn . rollback (  )  ;", "TransactionUtil 2  . log . trace (  \" Rolled   back   transaction   due   to   action   error \"  )  ;", "}    catch    ( Exception   inner )     {", "TransactionUtil 2  . log . trace (  \" Rolling   back   transaction   due   to   action   error   failed ;    throwing   original   error \"  )  ;", "}", "}", "throw   e ;", "}", "TransactionUtil 2  . log . trace (  \" Committing   transaction   after   successful   action   execution \"  )  ;", "try    {", "txn . commit (  )  ;", "TransactionUtil 2  . log . trace (  \" Committing   transaction   after   successful   action   execution    -    success \"  )  ;", "}    catch    ( Exception   e )     {", "TransactionUtil 2  . log . trace (  \" Committing   transaction   after   successful   action   execution    -    failure \"  )  ;", "throw   e ;", "}", "}", "METHOD_END"], "methodName": ["inTransaction"], "fileName": "org.hibernate.testing.transaction.TransactionUtil2"}, {"methodBody": ["METHOD_START", "{", "Throwable   cause    =    t . getCause (  )  ;", "if    (  ( cause    !  =    null )     &  &     (  !  ( causeClass . equals ( cause . getClass (  )  )  )  )  )     {", "return   cause    !  =    t    ?     . findCause ( cause ,    causeClass )     :    null ;", "}", "return   cause ;", "}", "METHOD_END"], "methodName": ["findCause"], "fileName": "org.hibernate.testing.util.ExceptionUtil"}, {"methodBody": ["METHOD_START", "{", "return   ExceptionUtil . INSTANCE ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.hibernate.testing.util.ExceptionUtil"}, {"methodBody": ["METHOD_START", "{", "Throwable   rootCause    =    ExceptionUtil . rootCause ( e )  ;", "if    (  ( rootCause    !  =    null )     &  &     (  ( rootCause . getMessage (  )  . toLowerCase (  )  . contains (  \" connection   is   close \"  )  )     |  |     ( rootCause . getMessage (  )  . toLowerCase (  )  . contains (  \" closed   connection \"  )  )  )  )     {", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isConnectionClose"], "fileName": "org.hibernate.testing.util.ExceptionUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  (  (  ( LockAcquisitionException . class . isInstance ( e )  )     |  |     ( LockTimeoutException . class . isInstance ( e )  )  )     |  |     ( GenericJDBCException . class . isInstance ( e )  )  )     |  |     ( PessimisticLockException . class . isInstance ( e )  )  )     |  |     ( PessimisticLockException . class . isInstance ( e )  )  )     |  |     ( JDBCConnectionException . class . isInstance ( e )  )  )     {", "return   true ;", "} else    {", "Throwable   rootCause    =     . rootCause ( e )  ;", "if    (  ( rootCause    !  =    null )     &  &     (  ( rootCause . getMessage (  )  . contains (  \" timeout \"  )  )     |  |     ( rootCause . getMessage (  )  . contains (  \" timed   out \"  )  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isSqlLockTimeout"], "fileName": "org.hibernate.testing.util.ExceptionUtil"}, {"methodBody": ["METHOD_START", "{", "Throwable   cause    =    t . getCause (  )  ;", "if    (  ( cause    !  =    null )     &  &     ( cause    !  =    t )  )     {", "return    . rootCause ( cause )  ;", "}", "return   t ;", "}", "METHOD_END"], "methodName": ["rootCause"], "fileName": "org.hibernate.testing.util.ExceptionUtil"}, {"methodBody": ["METHOD_START", "{", "final   String   knownClassFileName    =     (  '  /  '     +     ( knownClass . getName (  )  . replace (  '  .  '  ,    File . separatorChar )  )  )     +     \"  . class \"  ;", "final   URL   knownClassFileUrl    =    knownClass . getResource ( knownClassFileName )  ;", "try    {", "return   new   File ( knownClassFileUrl . toURI (  )  )  ;", "}    catch    ( URISyntaxException   e )     {", "throw   new   RuntimeException (  \" Could   not   convert   class   root   URL   to   a   URI \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveClassFile"], "fileName": "org.hibernate.testing.util.TestPathHelper"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   File (  . resolveRootUrl ( knownClass )  . toURI (  )  )  ;", "}    catch    ( URISyntaxException   e )     {", "throw   new   RuntimeException (  \" Could   not   convert   class   root   URL   to   a   URI \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveRootDirectory"], "fileName": "org.hibernate.testing.util.TestPathHelper"}, {"methodBody": ["METHOD_START", "{", "final   String   knownClassFileName    =     (  '  /  '     +     ( knownClass . getName (  )  . replace (  '  .  '  ,    File . separatorChar )  )  )     +     \"  . class \"  ;", "final   URL   knownClassFileUrl    =    knownClass . getResource ( knownClassFileName )  ;", "final   String   knownClassFileUrlString    =    knownClassFileUrl . toExtlForm (  )  ;", "String   rootUrlString    =    knownClassFileUrlString . substring (  0  ,    knownClassFileUrlString . lastIndexOf ( File . separatorChar )  )  ;", "final   String   packageName    =    knownClass . getPackage (  )  . getName (  )  ;", "for    ( String   packageNamePart    :    packageName . split (  \"  \\  \\  .  \"  )  )     {", "rootUrlString    =    rootUrlString . substring (  0  ,    rootUrlString . lastIndexOf ( File . separatorChar )  )  ;", "}", "try    {", "return   new   URL ( rootUrlString )  ;", "}    catch    ( MalformedURLException   e )     {", "throw   new   RuntimeException (  \" Could   not   convert   class   base   url   as   string   to   URL   ref \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveRootUrl"], "fileName": "org.hibernate.testing.util.TestPathHelper"}]