[{"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( DefaultPackageEntity . class )  ;", "}", "METHOD_END"], "methodName": ["testMetaModelGeneratedForEntitiesInDefaultPackage"], "fileName": "DefaultPackageTest"}, {"methodBody": ["METHOD_START", "{", "String   superClassName    =     (  ( TypeElement )     ( superClassElement )  )  . getQualifiedName (  )  . toString (  )  ;", "if    (  ( context . containsMetaEntity ( superClassName )  )     |  |     ( context . containsMetaEmbeddable ( superClassName )  )  )     {", "return   true ;", "}", "if    (  (  ! entityMetaComplete )     &  &     (  ( TypeUtils . containsAnnotation ( superClassElement ,    Constants . ENTITY )  )     |  |     ( TypeUtils . containsAnnotation ( superClassElement ,    Constants . MAPPED _ SUPERCLASS )  )  )  )     {", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["extendsSuperMetaModel"], "fileName": "org.hibernate.jpamodelgen.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "TypeMirror   superClass    =    entity . getTypeElement (  )  . getSuperclass (  )  ;", "while    (  ( superClass . getKind (  )  )     =  =     ( TypeKind . DECLARED )  )     {", "final   Element   superClassElement    =     (  ( DeclaredType )     ( superClass )  )  . asElement (  )  ;", "String   superClassName    =     (  ( TypeElement )     ( superClassElement )  )  . getQualifiedName (  )  . toString (  )  ;", "if    (  . extendsSuperMetaModel ( superClassElement ,    entity . isMetaComplete (  )  ,    context )  )     {", "return   superClassName ;", "}", "superClass    =     (  ( TypeElement )     ( superClassElement )  )  . getSuperclass (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findMappedSuperClass"], "fileName": "org.hibernate.jpamodelgen.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "StringWriter   sw    =    new   StringWriter (  )  ;", "PrintWriter   pw    =    null ;", "try    {", "pw    =    new   PrintWriter ( sw )  ;", "if    ( context . addGeneratedAnnotation (  )  )     {", "pw . println (  . writeGeneratedAnnotation ( entity ,    context )  )  ;", "}", "if    ( context . isAddSuppressWarningsAnnotation (  )  )     {", "pw . println (  . writeSuppressWarnings (  )  )  ;", "}", "pw . println (  . writeStaticMetaModelAnnotation ( entity )  )  ;", ". printClassDeclaration ( entity ,    pw ,    context )  ;", "pw . println (  )  ;", "List < MetaAttribute >    members    =    entity . getMembers (  )  ;", "for    ( MetaAttribute   metaMember    :    members )     {", "pw . println (  (  \"  \t  \"     +     ( metaMember . getAttributeDeclarationString (  )  )  )  )  ;", "}", "pw . println (  )  ;", "for    ( MetaAttribute   metaMember    :    members )     {", "pw . println (  (  \"  \t  \"     +     ( metaMember . getAttributeNameDeclarationString (  )  )  )  )  ;", "}", "pw . println (  )  ;", "pw . println (  \"  }  \"  )  ;", "return   sw . getBuffer (  )  ;", "}    finally    {", "if    ( pw    !  =    null )     {", "pw . close (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["generateBody"], "fileName": "org.hibernate.jpamodelgen.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "String   fullyQualifiedClassName    =     \"  \"  ;", "if    (  !  ( metaModelPackage . isEmpty (  )  )  )     {", "fullyQualifiedClassName    =     ( fullyQualifiedClassName    +    metaModelPackage )     +     \"  .  \"  ;", "}", "fullyQualifiedClassName    =     ( fullyQualifiedClassName    +     ( entity . getSimpleName (  )  )  )     +     (  . META _ MODEL _ CLASS _ NAME _ SUFFIX )  ;", "return   fullyQualifiedClassName ;", "}", "METHOD_END"], "methodName": ["getFullyQualifiedClassName"], "fileName": "org.hibernate.jpamodelgen.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "pw . print (  (  (  \" public   abstract   class    \"     +     ( entity . getSimpleName (  )  )  )     +     ( ClassWriter . META _ MODEL _ CLASS _ NAME _ SUFFIX )  )  )  ;", "String   superClassName    =    ClassWriter . findMappedSuperClass ( entity ,    context )  ;", "if    ( superClassName    !  =    null )     {", "pw . print (  (  (  \"    extends    \"     +    superClassName )     +     ( ClassWriter . META _ MODEL _ CLASS _ NAME _ SUFFIX )  )  )  ;", "}", "pw . println (  \"     {  \"  )  ;", "}", "METHOD_END"], "methodName": ["printClassDeclaration"], "fileName": "org.hibernate.jpamodelgen.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "try    {", "String   metaModelPackage    =    entity . getPackageName (  )  ;", "String   body    =     . generateBody ( entity ,    context )  . toString (  )  ;", "FileObject   fo    =    context . getProcessingEnvironment (  )  . getFiler (  )  . createSourceFile (  . getFullyQualifiedClassName ( entity ,    metaModelPackage )  )  ;", "OutputStream   os    =    fo . openOutputStream (  )  ;", "PrintWriter   pw    =    new   PrintWriter ( os )  ;", "if    (  !  ( metaModelPackage . isEmpty (  )  )  )     {", "pw . println (  (  (  \" package    \"     +    metaModelPackage )     +     \"  ;  \"  )  )  ;", "pw . println (  )  ;", "}", "pw . println ( entity . generateImports (  )  )  ;", "pw . println ( body )  ;", "pw . flush (  )  ;", "pw . close (  )  ;", "}    catch    ( FilerException   filerEx )     {", "context . logMessage ( Diagnostic . Kind . ERROR ,     (  \" Problem   with   Filer :     \"     +     ( filerEx . getMessage (  )  )  )  )  ;", "}    catch    ( IOException   ioEx )     {", "context . logMessage ( Diagnostic . Kind . ERROR ,     (  (  \" Problem   opening   file   to   write   MetaModel   for    \"     +     ( entity . getSimpleName (  )  )  )     +     ( ioEx . getMessage (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeFile"], "fileName": "org.hibernate.jpamodelgen.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   generatedAnnotation    =    new   StringBuilder (  )  ;", "generatedAnnotation . append (  \"  @  \"  )  . append ( entity . importType (  \" Generated \"  )  )  . append (  \"  ( value    =     \\  \"  \"  )  . append ( JPAMetaModelEntityProcessor . class . getName (  )  )  ;", "if    ( context . addGeneratedDate (  )  )     {", "generatedAnnotation . append (  \"  \\  \"  ,    date    =     \\  \"  \"  )  . append (  . SIMPLE _ DATE _ FORMAT . get (  )  . format ( new   Date (  )  )  )  . append (  \"  \\  \"  )  \"  )  ;", "} else    {", "generatedAnnotation . append (  \"  \\  \"  )  \"  )  ;", "}", "return   generatedAnnotation . toString (  )  ;", "}", "METHOD_END"], "methodName": ["writeGeneratedAnnotation"], "fileName": "org.hibernate.jpamodelgen.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  \"  @  \"     +     ( entity . importType (  \" StaticMetamodel \"  )  )  )     +     \"  (  \"  )     +     ( entity . getSimpleName (  )  )  )     +     \"  . class )  \"  ;", "}", "METHOD_END"], "methodName": ["writeStaticMetaModelAnnotation"], "fileName": "org.hibernate.jpamodelgen.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "return    \"  @ SuppressWarnings (  {     \\  \" deprecation \\  \"  ,     \\  \" rawtypes \\  \"     }  )  \"  ;", "}", "METHOD_END"], "methodName": ["writeSuppressWarnings"], "fileName": "org.hibernate.jpamodelgen.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "accessTypeInformation . put ( fqcn ,    info )  ;", "}", "METHOD_END"], "methodName": ["addAccessTypeInformation"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "return   addGeneratedAnnotation ;", "}", "METHOD_END"], "methodName": ["addGeneratedAnnotation"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "return   addGenerationDate ;", "}", "METHOD_END"], "methodName": ["addGeneratedDate"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "metaEmbeddables . put ( fqcn ,    metaEntity )  ;", "}", "METHOD_END"], "methodName": ["addMetaEmbeddable"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "metaEntities . put ( fqcn ,    metaEntity )  ;", "}", "METHOD_END"], "methodName": ["addMetaEntity"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "return   metaEmbeddables . containsKey ( fqcn )  ;", "}", "METHOD_END"], "methodName": ["containsMetaEmbeddable"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "return   metaEntities . containsKey ( fqcn )  ;", "}", "METHOD_END"], "methodName": ["containsMetaEntity"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "return   lazyXmlParsing ;", "}", "METHOD_END"], "methodName": ["doLazyXmlParsing"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "return   accessTypeInformation . get ( fqcn )  ;", "}", "METHOD_END"], "methodName": ["getAccessTypeInfo"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "return   pe . getElementUtils (  )  ;", "}", "METHOD_END"], "methodName": ["getElementUtils"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "return   metaEmbeddables . get ( fqcn )  ;", "}", "METHOD_END"], "methodName": ["getMetaEmbeddable"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "return   metaEmbeddables . values (  )  ;", "}", "METHOD_END"], "methodName": ["getMetaEmbeddables"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "return   metaEntities . values (  )  ;", "}", "METHOD_END"], "methodName": ["getMetaEntities"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "return   metaEntities . get ( fqcn )  ;", "}", "METHOD_END"], "methodName": ["getMetaEntity"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "return   ormXmlFiles ;", "}", "METHOD_END"], "methodName": ["getOrmXmlFiles"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "return   persistenceUnitDefaultAccessType ;", "}", "METHOD_END"], "methodName": ["getPersistenceUnitDefaultAccessType"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "return   persistenceXmlLocation ;", "}", "METHOD_END"], "methodName": ["getPersistenceXmlLocation"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "return   pe ;", "}", "METHOD_END"], "methodName": ["getProcessingEnvironment"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "Elements   elementUtils    =    pe . getElementUtils (  )  ;", "return   elementUtils . getTypeElement ( fqcn )  ;", "}", "METHOD_END"], "methodName": ["getTypeElementForFullyQualifiedName"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "return   pe . getTypeUtils (  )  ;", "}", "METHOD_END"], "methodName": ["getTypeUtils"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "return   addSuppressWarningsAnnotation ;", "}", "METHOD_END"], "methodName": ["isAddSuppressWarningsAnnotation"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "return   generatedModelClasses . contains ( name )  ;", "}", "METHOD_END"], "methodName": ["isAlreadyGenerated"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "return    ( Boolean . TRUE )     =  =     ( fullyXmlConfigured )  ;", "}", "METHOD_END"], "methodName": ["isFullyXmlConfigured"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( logDebug )  )     &  &     ( type . equals ( Diagnostic . Kind . OTHER )  )  )     {", "return ;", "}", "pe . getMessager (  )  . printMessage ( type ,    message )  ;", "}", "METHOD_END"], "methodName": ["logMessage"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . fullyXmlConfigured )     =  =    null )     {", "this . fullyXmlConfigured    =    fullyXmlConfigured ;", "} else    {", "this . fullyXmlConfigured    =     ( this . fullyXmlConfigured )     &  &    fullyXmlConfigured ;", "}", "}", "METHOD_END"], "methodName": ["mappingDocumentFullyXmlConfigured"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "generatedModelClasses . add ( name )  ;", "}", "METHOD_END"], "methodName": ["markGenerated"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "this . addGeneratedAnnotation    =    addGeneratedAnnotation ;", "}", "METHOD_END"], "methodName": ["setAddGeneratedAnnotation"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "this . addGenerationDate    =    addGenerationDate ;", "}", "METHOD_END"], "methodName": ["setAddGenerationDate"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "this . addSuppressWarningsAnnotation    =    addSuppressWarningsAnnotation ;", "}", "METHOD_END"], "methodName": ["setAddSuppressWarningsAnnotation"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "this . persistenceUnitDefaultAccessType    =    persistenceUnitDefaultAccessType ;", "}", "METHOD_END"], "methodName": ["setPersistenceUnitDefaultAccessType"], "fileName": "org.hibernate.jpamodelgen.Context"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "for    ( String   next    :    imports )     {", "if    (  !  ( isAutoed ( next )  )  )     {", "if    ( statics . contains ( next )  )     {", "builder . append (  \" import   static    \"  )  . append ( next )  . append (  \"  ;  \"  )  . append ( System . lineSeparator (  )  )  ;", "} else    {", "builder . append (  \" import    \"  )  . append ( next )  . append (  \"  ;  \"  )  . append ( System . lineSeparator (  )  )  ;", "}", "}", "}", "if    (  ( builder . indexOf (  \"  $  \"  )  )     >  =     0  )     {", "return   builder . toString (  )  ;", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["generateImports"], "fileName": "org.hibernate.jpamodelgen.ImportContextImpl"}, {"methodBody": ["METHOD_START", "{", "String   result    =    fqcn ;", "String   additionalTypePart    =    null ;", "if    (  ( fqcn . indexOf (  '  <  '  )  )     >  =     0  )     {", "additionalTypePart    =    result . substring ( fqcn . indexOf (  '  <  '  )  )  ;", "result    =    result . substring (  0  ,    fqcn . indexOf (  '  <  '  )  )  ;", "fqcn    =    result ;", "} else", "if    (  ( fqcn . indexOf (  '  [  '  )  )     >  =     0  )     {", "additionalTypePart    =    result . substring ( fqcn . indexOf (  '  [  '  )  )  ;", "result    =    result . substring (  0  ,    fqcn . indexOf (  '  [  '  )  )  ;", "fqcn    =    result ;", "}", "String   pureFqcn    =    fqcn . replace (  '  $  '  ,     '  .  '  )  ;", "boolean   canBeSimple ;", "String   simpleName    =     . unqualify ( fqcn )  ;", "if    ( simpleNames . containsKey ( simpleName )  )     {", "String   existingFqcn    =    simpleNames . get ( simpleName )  ;", "if    ( existingFqcn . equals ( pureFqcn )  )     {", "canBeSimple    =    true ;", "} else    {", "canBeSimple    =    false ;", "}", "} else    {", "canBeSimple    =    true ;", "simpleNames . put ( simpleName ,    pureFqcn )  ;", "imports . add ( pureFqcn )  ;", "}", "if    (  ( inSamePackage ( fqcn )  )     |  |     (  ( imports . contains ( pureFqcn )  )     &  &    canBeSimple )  )     {", "result    =     . unqualify ( result )  ;", "} else", "if    ( inJavaLang ( fqcn )  )     {", "result    =    result . substring (  \" \"  . length (  )  )  ;", "}", "if    ( additionalTypePart    !  =    null )     {", "result    =    result    +    additionalTypePart ;", "}", "result    =    result . replace (  '  $  '  ,     '  .  '  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["importType"], "fileName": "org.hibernate.jpamodelgen.ImportContextImpl"}, {"methodBody": ["METHOD_START", "{", "return    ( className . indexOf (  \"  .  \"  )  )     <     0  ;", "}", "METHOD_END"], "methodName": ["inDefaultPackage"], "fileName": "org.hibernate.jpamodelgen.ImportContextImpl"}, {"methodBody": ["METHOD_START", "{", "return    \" lang \"  . equals ( ImportContextImpl . qualifier ( className )  )  ;", "}", "METHOD_END"], "methodName": ["inJavaLang"], "fileName": "org.hibernate.jpamodelgen.ImportContextImpl"}, {"methodBody": ["METHOD_START", "{", "String   other    =    ImportContextImpl . qualifier ( className )  ;", "return    ( other    =  =     ( basePackage )  )     |  |     (  ( other    !  =    null )     &  &     ( other . equals ( basePackage )  )  )  ;", "}", "METHOD_END"], "methodName": ["inSamePackage"], "fileName": "org.hibernate.jpamodelgen.ImportContextImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( isPrimitive ( next )  )     |  |     ( inDefaultPackage ( next )  )  )     |  |     ( inJavaLang ( next )  )  )     |  |     ( inSamePackage ( next )  )  ;", "}", "METHOD_END"], "methodName": ["isAutoImported"], "fileName": "org.hibernate.jpamodelgen.ImportContextImpl"}, {"methodBody": ["METHOD_START", "{", "return   ImportContextImpl . PRIMITIVES . containsKey ( className )  ;", "}", "METHOD_END"], "methodName": ["isPrimitive"], "fileName": "org.hibernate.jpamodelgen.ImportContextImpl"}, {"methodBody": ["METHOD_START", "{", "int   loc    =    qualifiedName . lastIndexOf (  \"  .  \"  )  ;", "return   loc    <     0     ?     \"  \"     :    qualifiedName . substring (  0  ,    loc )  ;", "}", "METHOD_END"], "methodName": ["qualifier"], "fileName": "org.hibernate.jpamodelgen.ImportContextImpl"}, {"methodBody": ["METHOD_START", "{", "String   local    =     ( fqcn    +     \"  .  \"  )     +    member ;", "imports . add ( local )  ;", "statics . add ( local )  ;", "if    ( member . equals (  \"  *  \"  )  )     {", "return    \"  \"  ;", "} else    {", "return   member ;", "}", "}", "METHOD_END"], "methodName": ["staticImport"], "fileName": "org.hibernate.jpamodelgen.ImportContextImpl"}, {"methodBody": ["METHOD_START", "{", "int   loc    =    qualifiedName . lastIndexOf (  '  .  '  )  ;", "return   loc    <     0     ?    qualifiedName    :    qualifiedName . substring (  (  ( qualifiedName . lastIndexOf (  '  .  '  )  )     +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["unqualify"], "fileName": "org.hibernate.jpamodelgen.ImportContextImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( TypeUtils . isAnnotationMirrorOfType ( mirror ,    Constants . ENTITY )  )     {", "context . addMeta ( meta . getQualifiedName (  )  ,    meta )  ;", "} else", "if    ( TypeUtils . isAnnotationMirrorOfType ( mirror ,    Constants . MAPPED _ SUPERCLASS )  )     {", "context . addMeta ( meta . getQualifiedName (  )  ,    meta )  ;", "} else", "if    ( TypeUtils . isAnnotationMirrorOfType ( mirror ,    Constants . EMBEDDABLE )  )     {", "context . addMetaEmbeddable ( meta . getQualifiedName (  )  ,    meta )  ;", "}", "}", "METHOD_END"], "methodName": ["addMetaEntityToContext"], "fileName": "org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor"}, {"methodBody": ["METHOD_START", "{", "for    ( MetaEntity   entity    :    context . getMetaEntities (  )  )     {", "if    ( context . isAlreadyGenerated ( entity . getQualifiedName (  )  )  )     {", "continue ;", "}", "context . logMessage ( Diagnostic . Kind . OTHER ,     (  \" Writing   meta   model   for   entity    \"     +    entity )  )  ;", "ClassWriter . writeFile ( entity ,    context )  ;", "context . markGenerated ( entity . getQualifiedName (  )  )  ;", "}", "Collection < MetaEntity >    toEntities    =    context . getMetaEmbeddables (  )  ;", "while    (  !  ( toEntities . isEmpty (  )  )  )     {", "Set < MetaEntity >    processedEntities    =    new   HashSet < MetaEntity >  (  )  ;", "int   toCountBeforeLoop    =    toEntities . size (  )  ;", "for    ( MetaEntity   entity    :    toEntities )     {", "if    ( context . isAlreadyGenerated ( entity . getQualifiedName (  )  )  )     {", "processedEntities . add ( entity )  ;", "continue ;", "}", "if    ( modelGenerationNeedsToBeDeferred ( toEntities ,    entity )  )     {", "continue ;", "}", "context . logMessage ( Diagnostic . Kind . OTHER ,     (  \" Writing   meta   model   for   embeddable / mapped   superclass \"     +    entity )  )  ;", "ClassWriter . writeFile ( entity ,    context )  ;", "context . markGenerated ( entity . getQualifiedName (  )  )  ;", "processedEntities . add ( entity )  ;", "}", "toEntities . removeAll ( processedEntities )  ;", "if    (  ( toEntities . size (  )  )     >  =    toCountBeforeLoop )     {", "context . logMessage ( Diagnostic . Kind . ERROR ,     \" Potential   endless   loop   in   generation   of   entities .  \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["createMetaModelClasses"], "fileName": "org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor"}, {"methodBody": ["METHOD_START", "{", "List <  ?    extends   AnnotationMirror >    annotationMirrors    =    element . getAnnotationMirrors (  )  ;", "for    ( AnnotationMirror   mirror    :    annotationMirrors )     {", "if    (  !  ( ElementKind . CLASS . equals ( element . getKind (  )  )  )  )     {", "continue ;", "}", "String   fqn    =     (  ( TypeElement )     ( element )  )  . getQualifiedName (  )  . toString (  )  ;", "Meta   alreadyExistingMeta    =    tryGettingExistingFromContext ( mirror ,    fqn )  ;", "if    (  ( alreadyExistingMeta    !  =    null )     &  &     ( alreadyExistingMeta . isMetaComplete (  )  )  )     {", "String   msg    =     (  \" Skipping   processing   of   annotations   for    \"     +    fqn )     +     \"    since   xml   configuration   is   metadata   complete .  \"  ;", "context . logMessage ( Diagnostic . Kind . OTHER ,    msg )  ;", "continue ;", "}", "boolean   requiresLazyMemberInitialization    =    false ;", "AnnotationMeta   meta ;", "if    (  ( TypeUtils . containsAnnotation ( element ,    Constants . EMBEDDABLE )  )     |  |     ( TypeUtils . containsAnnotation ( element ,    Constants . MAPPED _ SUPERCLASS )  )  )     {", "requiresLazyMemberInitialization    =    true ;", "}", "meta    =    new   AnnotationMeta (  (  ( TypeElement )     ( element )  )  ,    context ,    requiresLazyMemberInitialization )  ;", "if    ( alreadyExistingMeta    !  =    null )     {", "meta . mergeInMembers ( alreadyExistingMeta )  ;", "}", "addMetaToContext ( mirror ,    meta )  ;", "}", "}", "METHOD_END"], "methodName": ["handleRootElementAnnotationMirrors"], "fileName": "org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor"}, {"methodBody": ["METHOD_START", "{", "return   TypeUtils . containsAnnotation ( element ,    Constants . ENTITY ,    Constants . MAPPED _ SUPERCLASS ,    Constants . EMBEDDABLE )  ;", "}", "METHOD_END"], "methodName": ["isJPAEntity"], "fileName": "org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor"}, {"methodBody": ["METHOD_START", "{", "JPAMetaModelEntityProcessor . ContainsAttributeTypeVisitor   visitor    =    new   JPAMetaModelEntityProcessor . ContainsAttributeTypeVisitor ( containedEntity . getTypeElement (  )  ,    context )  ;", "for    ( MetaEntity   entity    :    entities )     {", "if    ( entity . equals ( containedEntity )  )     {", "continue ;", "}", "for    ( Element   subElement    :    ElementFilter . fieldsIn ( entity . getTypeElement (  )  . getEnclosedElements (  )  )  )     {", "TypeMirror   mirror    =    subElement . asType (  )  ;", "if    (  !  ( TypeKind . DECLARED . equals ( mirror . getKind (  )  )  )  )     {", "continue ;", "}", "boolean   contains    =    mirror . accept ( visitor ,    subElement )  ;", "if    ( contains )     {", "return   true ;", "}", "}", "for    ( Element   subElement    :    ElementFilter . methodsIn ( entity . getTypeElement (  )  . getEnclosedElements (  )  )  )     {", "TypeMirror   mirror    =    subElement . asType (  )  ;", "if    (  !  ( TypeKind . DECLARED . equals ( mirror . getKind (  )  )  )  )     {", "continue ;", "}", "boolean   contains    =    mirror . accept ( visitor ,    subElement )  ;", "if    ( contains )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["modelGenerationNeedsToBeDeferred"], "fileName": "org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor"}, {"methodBody": ["METHOD_START", "{", "MetaEntity   alreadyExistingMetaEntity    =    null ;", "if    (  ( TypeUtils . isAnnotationMirrorOfType ( mirror ,    Constants . ENTITY )  )     |  |     ( TypeUtils . isAnnotationMirrorOfType ( mirror ,    Constants . MAPPED _ SUPERCLASS )  )  )     {", "alreadyExistingMetaEntity    =    context . getMetaEntity ( fqn )  ;", "} else", "if    ( TypeUtils . isAnnotationMirrorOfType ( mirror ,    Constants . EMBEDDABLE )  )     {", "alreadyExistingMetaEntity    =    context . getMetaEmbeddable ( fqn )  ;", "}", "return   alreadyExistingMetaEntity ;", "}", "METHOD_END"], "methodName": ["tryGettingExistingEntityFromContext"], "fileName": "org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Version . version )     =  =    null )     {", "Version . version    =    Version . class . getPackage (  )  . getImplementationVersion (  )  ;", "if    (  ( Version . version )     =  =    null )     {", "Version . version    =     \"  [ WORKING ]  \"  ;", "}", "}", "return   Version . version ;", "}", "METHOD_END"], "methodName": ["getVersionString"], "fileName": "org.hibernate.jpamodelgen.Version"}, {"methodBody": ["METHOD_START", "{", "return   parent ;", "}", "METHOD_END"], "methodName": ["getHostingEntity"], "fileName": "org.hibernate.jpamodelgen.annotation.AnnotationMetaAttribute"}, {"methodBody": ["METHOD_START", "{", "Elements   elementsUtil    =    parent . getContext (  )  . getElementUtils (  )  ;", "if    (  ( element . getKind (  )  )     =  =     ( ElementKind . FIELD )  )     {", "return   element . getSimpleName (  )  . toSng (  )  ;", "} else", "if    (  ( element . getKind (  )  )     =  =     ( ElementKind . METHOD )  )     {", "Sng   name    =    element . getSimpleName (  )  . toSng (  )  ;", "if    ( name . startsWith (  \" get \"  )  )     {", "return   elementsUtil . getName ( decapitalize ( name . subsng (  \" get \"  . length (  )  )  )  )  . toSng (  )  ;", "} else", "if    ( name . startsWith (  \" is \"  )  )     {", "return   elementsUtil . getName ( decapitalize ( name . subsng (  \" is \"  . length (  )  )  )  )  . toSng (  )  ;", "}", "return   elementsUtil . getName ( decapitalize ( name )  )  . toSng (  )  ;", "} else    {", "return   elementsUtil . getName (  (  (  (  ( element . getSimpleName (  )  )     +     \"  /  *     \"  )     +     ( element . getKind (  )  )  )     +     \"     *  /  \"  )  )  . toSng (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getPropertyName"], "fileName": "org.hibernate.jpamodelgen.annotation.AnnotationMetaAttribute"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getTypeDeclaration"], "fileName": "org.hibernate.jpamodelgen.annotation.AnnotationMetaAttribute"}, {"methodBody": ["METHOD_START", "{", "for    ( Element   memberOfClass    :    membersOfClass )     {", "AccessType   forcedAccessType    =    TypeUtils . determineAnnotationSpecifiedAccessType ( memberOfClass )  ;", "if    (  (  ( entityAccessTypeInfo . getAccessType (  )  )     !  =    membersKind )     &  &     ( forcedAccessType    =  =    null )  )     {", "continue ;", "}", "if    (  (  ( TypeUtils . containsAnnotation ( memberOfClass ,    Constants . TRANSIENT )  )     |  |     ( memberOfClass . getModifiers (  )  . contains ( Modifier . TRANSIENT )  )  )     |  |     ( memberOfClass . getModifiers (  )  . contains ( Modifier . STATIC )  )  )     {", "continue ;", "}", "MetaAttributeGenerationVisitor   visitor    =    new   MetaAttributeGenerationVisitor ( this ,    context )  ;", "Attribute   result    =    memberOfClass . asType (  )  . accept ( visitor ,    memberOfClass )  ;", "if    ( result    !  =    null )     {", "members . put ( result . getPropertyName (  )  ,    result )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addPersistentMembers"], "fileName": "org.hibernate.jpamodelgen.annotation.AnnotationMetaEntity"}, {"methodBody": ["METHOD_START", "{", "return   importContext . generateImports (  )  ;", "}", "METHOD_END"], "methodName": ["generateImports"], "fileName": "org.hibernate.jpamodelgen.annotation.AnnotationMetaEntity"}, {"methodBody": ["METHOD_START", "{", "return   context ;", "}", "METHOD_END"], "methodName": ["getContext"], "fileName": "org.hibernate.jpamodelgen.annotation.AnnotationMetaEntity"}, {"methodBody": ["METHOD_START", "{", "return   element ;", "}", "METHOD_END"], "methodName": ["getElement"], "fileName": "org.hibernate.jpamodelgen.annotation.AnnotationMetaEntity"}, {"methodBody": ["METHOD_START", "{", "return   entityAccessTypeInfo ;", "}", "METHOD_END"], "methodName": ["getEntityAccessTypeInfo"], "fileName": "org.hibernate.jpamodelgen.annotation.AnnotationMetaEntity"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( initialized )  )     {", "init (  )  ;", "if    (  ( entityToMerge )     !  =    null )     {", "mergeInMembers ( entityToMerge . getMembers (  )  )  ;", "}", "}", "return   new   ArrayList < model . MetaAttribute >  ( members . values (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMembers"], "fileName": "org.hibernate.jpamodelgen.annotation.AnnotationMetaEntity"}, {"methodBody": ["METHOD_START", "{", "PackageElement   packageOf    =    context . getElementUtils (  )  . getPackageOf ( element )  ;", "return   context . getElementUtils (  )  . getName ( packageOf . getQualifiedName (  )  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getPackageName"], "fileName": "org.hibernate.jpamodelgen.annotation.AnnotationMetaEntity"}, {"methodBody": ["METHOD_START", "{", "return   element . getQualifiedName (  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getQualifiedName"], "fileName": "org.hibernate.jpamodelgen.annotation.AnnotationMetaEntity"}, {"methodBody": ["METHOD_START", "{", "return   element . getSimpleName (  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getSimpleName"], "fileName": "org.hibernate.jpamodelgen.annotation.AnnotationMetaEntity"}, {"methodBody": ["METHOD_START", "{", "return   element ;", "}", "METHOD_END"], "methodName": ["getTypeElement"], "fileName": "org.hibernate.jpamodelgen.annotation.AnnotationMetaEntity"}, {"methodBody": ["METHOD_START", "{", "return   importContext . importType ( fqcn )  ;", "}", "METHOD_END"], "methodName": ["importType"], "fileName": "org.hibernate.jpamodelgen.annotation.AnnotationMetaEntity"}, {"methodBody": ["METHOD_START", "{", "getContext (  )  . logMessage ( Diagnostic . Kind . OTHER ,     (  (  \" Initializing   type    \"     +     ( getQualifiedName (  )  )  )     +     \"  .  \"  )  )  ;", "TypeUtils . determineAccessTypeForHierarchy ( element ,    context )  ;", "eAccessTypeInfo    =    context . getAccessTypeInfo ( getQualifiedName (  )  )  ;", "List <  ?    extends   Element >    fieldsOfClass    =    ElementFilter . fieldsIn ( element . getEnclosedElements (  )  )  ;", "addPersistentMembers ( fieldsOfClass ,    AccessType . FIELD )  ;", "List <  ?    extends   Element >    methodsOfClass    =    ElementFilter . methodsIn ( element . getEnclosedElements (  )  )  ;", "List < Element >    gettersAndSettersOfClass    =    new   ArrayList <  >  (  )  ;", "for    ( Element   rawMethodOfClass    :    methodsOfClass )     {", "if    ( isGetterOrSetter ( rawMethodOfClass )  )     {", "gettersAndSettersOfClass . add ( rawMethodOfClass )  ;", "}", "}", "addPersistentMembers ( gettersAndSettersOfClass ,    AccessType . PROPERTY )  ;", "initialized    =    true ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.hibernate.jpamodelgen.annotation.AnnotationMetaEntity"}, {"methodBody": ["METHOD_START", "{", "ExecutableType   methodType    =     (  ( ExecutableType )     ( methodOfClass . asType (  )  )  )  ;", "String   methodSimpleName    =    methodOfClass . getSimpleName (  )  . toString (  )  ;", "List <  ?    extends   TypeMirror >    methodParameterTypes    =    methodType . getParameterTypes (  )  ;", "TypeMirror   returnType    =    methodType . getReturnType (  )  ;", "if    (  (  ( methodSimpleName . startsWith (  \" set \"  )  )     &  &     (  ( methodParameterTypes . size (  )  )     =  =     1  )  )     &  &     (  \" void \"  . equalsIgnoreCase ( returnType . toString (  )  )  )  )     {", "return   true ;", "} else", "if    (  (  (  ( methodSimpleName . startsWith (  \" get \"  )  )     |  |     ( methodSimpleName . startsWith (  \" is \"  )  )  )     &  &     ( methodParameterTypes . isEmpty (  )  )  )     &  &     (  !  (  \" void \"  . equalsIgnoreCase ( returnType . toString (  )  )  )  )  )     {", "return   true ;", "} else    {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isGetterOrSetter"], "fileName": "org.hibernate.jpamodelgen.annotation.AnnotationMetaEntity"}, {"methodBody": ["METHOD_START", "{", "for    ( MetaAttribute   attribute    :    attributes )     {", "importType ( attribute . getMetaType (  )  )  ;", "importType ( attribute . getTypeDeclar (  )  )  ;", "members . put ( attribute . getPropertyName (  )  ,    attribute )  ;", "}", "}", "METHOD_END"], "methodName": ["mergeInMembers"], "fileName": "org.hibernate.jpamodelgen.annotation.AnnotationMetaEntity"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( initialized )  )     {", "this . eToMerge    =    other ;", "} else    {", "mergeInMembers ( other . getMembers (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["mergeInMembers"], "fileName": "org.hibernate.jpamodelgen.annotation.AnnotationMetaEntity"}, {"methodBody": ["METHOD_START", "{", "return   importContext . staticImport ( fqcn ,    member )  ;", "}", "METHOD_END"], "methodName": ["staticImport"], "fileName": "org.hibernate.jpamodelgen.annotation.AnnotationMetaEntity"}, {"methodBody": ["METHOD_START", "{", "String   keyType ;", "if    ( TypeUtils . containsA ( element ,    Constants . MAP _ KEY _ CLASS )  )     {", "TypeMirror   typeMirror    =     (  ( TypeMirror )     ( TypeUtils . getAValue ( TypeUtils . getAMirror ( element ,    Constants . MAP _ KEY _ CLASS )  ,    TypeUtils . DEFAULT _ ANNOTATION _ PARAMETER _ NAME )  )  )  ;", "keyType    =    typeMirror . toString (  )  ;", "} else    {", "keyType    =    TypeUtils . getKeyType ( declaredType ,    context )  ;", "}", "return   new   AMetaMap ( entity ,    element ,    collection ,    keyType ,    getElementType ( declaredType ,    targetEntity )  )  ;", "}", "METHOD_END"], "methodName": ["createAnnotationMetaAttributeForMap"], "fileName": "org.hibernate.jpamodelgen.annotation.MetaAttributeGenerationVisitor"}, {"methodBody": ["METHOD_START", "{", "if    ( TypeUtils . containsAnnotation ( element ,    Constants . ELEMENT _ COLLECTION )  )     {", "String   explicitTargetEntity    =    getTargetEntity ( element . getAnnotationMirrors (  )  )  ;", "TypeMirror   collectionElementType    =    TypeUtils . getCollectionElementType ( declaredType ,    fqNameOfReturnType ,    explicitTargetEntity ,    context )  ;", "final   TypeElement   collectionElement    =     (  ( TypeElement )     ( context . getTypeUtils (  )  . asElement ( collectionElementType )  )  )  ;", "AccessTypeInformation   accessTypeInfo    =    context . getAccessTypeInfo ( collectionElementType . toString (  )  )  ;", "if    ( accessTypeInfo    =  =    null )     {", "AccessType   explicitAccessType    =    null ;", "if    ( collectionElement    !  =    null )     {", "explicitAccessType    =    TypeUtils . determineAnnotationSpecifiedAccessType ( collectionElement )  ;", "}", "accessTypeInfo    =    new   AccessTypeInformation ( collectionElementType . toString (  )  ,    explicitAccessType ,    entity . getEntityAccessTypeInfo (  )  . getAccessType (  )  )  ;", "context . addAccessTypeInformation ( collectionElementType . toString (  )  ,    accessTypeInfo )  ;", "} else    {", "accessTypeInfo . setDefaultAccessType ( entity . getEntityAccessTypeInfo (  )  . getAccessType (  )  )  ;", "}", "}", "if    (  ( TypeUtils . containsAnnotation ( element ,    Constants . CONVERT )  )     |  |     ( TypeUtils . containsAnnotation ( element ,    Constants . HIBERNATE _ TYPE )  )  )     {", "return   new   AnnotationMetaSingleAttribute ( entity ,    element ,    TypeUtils . toTypeString ( declaredType )  )  ;", "}", "if    ( collection . equals ( Constants . MAP _ ATTRIBUTE )  )     {", "return   createAnnotationForMap ( declaredType ,    element ,    collection ,    targetEntity )  ;", "}", "return   new   AnnotationMetaCollection ( entity ,    element ,    collection ,    getElementType ( declaredType ,    targetEntity )  )  ;", "}", "METHOD_END"], "methodName": ["createMetaCollectionAttribute"], "fileName": "org.hibernate.jpamodelgen.annotation.MetaAttributeGenerationVisitor"}, {"methodBody": ["METHOD_START", "{", "if    ( targetEntity    !  =    null )     {", "return   targetEntity ;", "}", "final   List <  ?    extends   TypeMirror >    mirrors    =    declaredType . getTypeArguments (  )  ;", "if    (  ( mirrors . size (  )  )     =  =     1  )     {", "final   TypeMirror   type    =    mirrors . get (  0  )  ;", "return   TypeUtils . extractClosestRealTypeAsSng ( type ,    context )  ;", "} else", "if    (  ( mirrors . size (  )  )     =  =     2  )     {", "return   TypeUtils . extractClosestRealTypeAsSng ( mirrors . get (  1  )  ,    context )  ;", "} else    {", "if    (  ( mirrors . size (  )  )     >     2  )     {", "context . logMessage ( WARNING ,     (  \" Unable   to   find   the   closest   solid   type \"     +    declaredType )  )  ;", "}", "return    \"  ?  \"  ;", "}", "}", "METHOD_END"], "methodName": ["getElementType"], "fileName": "org.hibernate.jpamodelgen.annotation.MetaAttributeGenerationVisitor"}, {"methodBody": ["METHOD_START", "{", "assert   mirror    !  =    null ;", "assert   parameterName    !  =    null ;", "String   targetEntityName    =    null ;", "Object   parameterValue    =    TypeUtils . getAValue ( mirror ,    parameterName )  ;", "if    ( parameterValue    !  =    null )     {", "TypeMirror   parameterType    =     (  ( TypeMirror )     ( parameterValue )  )  ;", "if    (  !  ( parameterType . getKind (  )  . equals ( TypeKind . VOID )  )  )     {", "targetEntityName    =    parameterType . toString (  )  ;", "}", "}", "return   targetEntityName ;", "}", "METHOD_END"], "methodName": ["getFullyQualifiedClassNameOfTargetEntity"], "fileName": "org.hibernate.jpamodelgen.annotation.MetaAttributeGenerationVisitor"}, {"methodBody": ["METHOD_START", "{", "String   fullyQualifiedTargetEntityName    =    null ;", "for    ( AnnotationMirror   mirror    :    annotations )     {", "if    ( TypeUtils . isAnnotationMirrorOfType ( mirror ,    Constants . ELEMENT _ COLLECTION )  )     {", "fullyQualifiedTargetEntityName    =    getFullyQualifiedClassNameOfTargetEntity ( mirror ,     \" targetClass \"  )  ;", "} else", "if    (  (  (  ( TypeUtils . isAnnotationMirrorOfType ( mirror ,    Constants . ONE _ TO _ MANY )  )     |  |     ( TypeUtils . isAnnotationMirrorOfType ( mirror ,    Constants . MANY _ TO _ MANY )  )  )     |  |     ( TypeUtils . isAnnotationMirrorOfType ( mirror ,    Constants . MANY _ TO _ ONE )  )  )     |  |     ( TypeUtils . isAnnotationMirrorOfType ( mirror ,    Constants . ONE _ TO _ ONE )  )  )     {", "fullyQualifiedTargetEntityName    =    getFullyQualifiedClassNameOfTargetEntity ( mirror ,     \" targetEntity \"  )  ;", "} else", "if    ( TypeUtils . isAnnotationMirrorOfType ( mirror ,     . ORG _ HIBERNATE _ ANNOTATIONS _ TARGET )  )     {", "fullyQualifiedTargetEntityName    =    getFullyQualifiedClassNameOfTargetEntity ( mirror ,     \" value \"  )  ;", "}", "}", "return   fullyQualifiedTargetEntityName ;", "}", "METHOD_END"], "methodName": ["getTargetEntity"], "fileName": "org.hibernate.jpamodelgen.annotation.MetaAttributeGenerationVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  (  ( TypeUtils . containsAnnotation ( element ,    Constants . BASIC )  )     |  |     ( TypeUtils . containsAnnotation ( element ,    Constants . ONE _ TO _ ONE )  )  )     |  |     ( TypeUtils . containsAnnotation ( element ,    Constants . MANY _ TO _ ONE )  )  )     |  |     ( TypeUtils . containsAnnotation ( element ,    Constants . EMBEDDED _ ID )  )  )     |  |     ( TypeUtils . containsAnnotation ( element ,    Constants . ID )  )  )     {", "return   true ;", "}", "if    (  ( TypeUtils . getAnnotationMirror ( element ,     . ORG _ HIBERNATE _ ANNOTATIONS _ TYPE )  )     !  =    null )     {", "return   true ;", "}", "BasicAttributeVisitor   basicVisitor    =    new   BasicAttributeVisitor ( context )  ;", "return   returnedElement . asType (  )  . accept ( basicVisitor ,    returnedElement )  ;", "}", "METHOD_END"], "methodName": ["isBasicAttribute"], "fileName": "org.hibernate.jpamodelgen.annotation.MetaAttributeGenerationVisitor"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" USER _ PARENT _ NAME \"  ,    StringUtil . getUpperUnderscoreCaseFromLowerCamelCase (  \" userParentName \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetUpperUnderscoreCaseFromLowerCamelCase"], "fileName": "org.hibernate.jpamodelgen.test.StringUtilTest"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( StringUtil . isProperty (  \" hashCode \"  ,     \" Integer \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testHashCodeNotAProperty"], "fileName": "org.hibernate.jpamodelgen.test.StringUtilTest"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( StringUtil . isProperty (  \" getFoo \"  ,     \" Object \"  )  )  ;", "assertTrue ( StringUtil . isProperty (  \" isFoo \"  ,     \" Boolean \"  )  )  ;", "assertTrue ( StringUtil . isProperty (  \" hasFoo \"  ,     \" Boolean \"  )  )  ;", "assertFalse ( StringUtil . isProperty (  \" isfoo \"  ,     \" void \"  )  )  ;", "assertFalse ( StringUtil . isProperty (  \" hasfoo \"  ,     \" Object \"  )  )  ;", "assertFalse ( StringUtil . isProperty (  \"  \"  ,     \" Object \"  )  )  ;", "assertFalse ( StringUtil . isProperty ( null ,     \" Object \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testIsPropertyName"], "fileName": "org.hibernate.jpamodelgen.test.StringUtilTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertPresenceOfFieldInMetamodelFor ( Hotel . class ,     \" webmaster \"  ,     \" Access   type   should   be   inherited   position   of   the    @ Id   field   annotation   in   the   root   entity \"  )  ;", "}", "METHOD_END"], "methodName": ["testAccessTypeForEmbeddableDeterminedByIdAnnotationInRootEntity"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.AccessTypeTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertAbsenceOfFieldInMetamodelFor ( Detail . class ,     \" nonPersistent \"  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultAccessTypeForEmbeddable"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.AccessTypeTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertAbsenceOfFieldInMetamodelFor ( Detail . class ,     \" volume \"  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultAccessTypeForMappedSuperclass"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.AccessTypeTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertAbsenceOfFieldInMetamodelFor ( Customer . class ,     \" nonPersistent \"  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultAccessTypeForSubclassOfEntity"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.AccessTypeTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertAbsenceOfFieldInMetamodelFor ( User . class ,     \" nonPersistent \"  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultAccessTypeOnEntity"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.AccessTypeTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertAbsenceOfFieldInMetamodelFor ( Product . class ,     \" nonPersistent \"  )  ;", "TestUtil . assertAbsenceOfFieldInMetamodelFor ( Product . class ,     \" nonPersistent 2  \"  )  ;", "}", "METHOD_END"], "methodName": ["testExcludeTransientFieldAndStatic"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.AccessTypeTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertAbsenceOfFieldInMetamodelFor ( LivingBeing . class ,     \" nonPersistent \"  ,     \" explicit   access   type   on   mapped   superclass \"  )  ;", "TestUtil . assertAbsenceOfFieldInMetamodelFor ( Hominidae . class ,     \" nonPersistent \"  ,     \" explicit   access   type   on   entity \"  )  ;", "TestUtil . assertAbsenceOfFieldInMetamodelFor ( Human . class ,     \" nonPersistent \"  ,     \" proper   inheritance   from   root   entity   access   type \"  )  ;", "}", "METHOD_END"], "methodName": ["testExplicitAccessTypeAndDefaultFromRootEntity"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.AccessTypeTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertAbsenceOfFieldInMetamodelFor ( Country . class ,     \" nonPersistent \"  )  ;", "TestUtil . assertAbsenceOfFieldInMetamodelFor ( Pet . class ,     \" nonPersistent \"  ,     \" Collection   of   embeddable   not   taken   care   of \"  )  ;", "}", "METHOD_END"], "methodName": ["testInheritedAccessTypeForEmbeddable"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.AccessTypeTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertPresenceOfFieldInMetamodelFor ( Customer . class ,     \" goodPayer \"  ,     \" access   type   overriding \"  )  ;", "TestUtil . assertAttributeTypeInMetaModelFor ( Customer . class ,     \" goodPayer \"  ,    Boolean . class ,     \" access   type   overriding \"  )  ;", "}", "METHOD_END"], "methodName": ["testMemberAccessType"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.AccessTypeTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Order . class )  ;", "}", "METHOD_END"], "methodName": ["testXmlConfiguredEntityGenerated"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.AccessTypeTest"}, {"methodBody": ["METHOD_START", "{", "return   city ;", "}", "METHOD_END"], "methodName": ["getCity"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Address"}, {"methodBody": ["METHOD_START", "{", "return   country ;", "}", "METHOD_END"], "methodName": ["getCountry"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Address"}, {"methodBody": ["METHOD_START", "{", "return   inhabitants ;", "}", "METHOD_END"], "methodName": ["getInhabitants"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Address"}, {"methodBody": ["METHOD_START", "{", "return   street 1  ;", "}", "METHOD_END"], "methodName": ["getStreet1"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Address"}, {"methodBody": ["METHOD_START", "{", "this . city    =    city ;", "}", "METHOD_END"], "methodName": ["setCity"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Address"}, {"methodBody": ["METHOD_START", "{", "this . country    =    country ;", "}", "METHOD_END"], "methodName": ["setCountry"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Address"}, {"methodBody": ["METHOD_START", "{", "this . inhabitants    =    inhabitants ;", "}", "METHOD_END"], "methodName": ["setInhabitants"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Address"}, {"methodBody": ["METHOD_START", "{", "this . street 1     =    street 1  ;", "}", "METHOD_END"], "methodName": ["setStreet1"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Address"}, {"methodBody": ["METHOD_START", "{", "return   height ;", "}", "METHOD_END"], "methodName": ["getHeight"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Area"}, {"methodBody": ["METHOD_START", "{", "return   length ;", "}", "METHOD_END"], "methodName": ["getLength"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Area"}, {"methodBody": ["METHOD_START", "{", "return    (  ( length )     *     ( width )  )     *     ( height )  ;", "}", "METHOD_END"], "methodName": ["getVolume"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Area"}, {"methodBody": ["METHOD_START", "{", "return   width ;", "}", "METHOD_END"], "methodName": ["getWidth"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Area"}, {"methodBody": ["METHOD_START", "{", "this . height    =    height ;", "}", "METHOD_END"], "methodName": ["setHeight"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Area"}, {"methodBody": ["METHOD_START", "{", "this . length    =    length ;", "}", "METHOD_END"], "methodName": ["setLength"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Area"}, {"methodBody": ["METHOD_START", "{", "this . width    =    width ;", "}", "METHOD_END"], "methodName": ["setWidth"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Area"}, {"methodBody": ["METHOD_START", "{", "return   address ;", "}", "METHOD_END"], "methodName": ["getAddress"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Building"}, {"methodBody": ["METHOD_START", "{", "this . address    =    address ;", "}", "METHOD_END"], "methodName": ["setAddress"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Building"}, {"methodBody": ["METHOD_START", "{", "return   iso 2 Code ;", "}", "METHOD_END"], "methodName": ["getIso2Code"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Country"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Country"}, {"methodBody": ["METHOD_START", "{", "this . iso 2 Code    =    iso 2 Code ;", "}", "METHOD_END"], "methodName": ["setIso2Code"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Country"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Country"}, {"methodBody": ["METHOD_START", "{", "return   orders ;", "}", "METHOD_END"], "methodName": ["getOrders"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Customer"}, {"methodBody": ["METHOD_START", "{", "this . orders    =    orders ;", "}", "METHOD_END"], "methodName": ["setOrders"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Customer"}, {"methodBody": ["METHOD_START", "{", "return   height ;", "}", "METHOD_END"], "methodName": ["getHeight"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Detail"}, {"methodBody": ["METHOD_START", "{", "return   length ;", "}", "METHOD_END"], "methodName": ["getLength"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Detail"}, {"methodBody": ["METHOD_START", "{", "return   width ;", "}", "METHOD_END"], "methodName": ["getWidth"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Detail"}, {"methodBody": ["METHOD_START", "{", "this . height    =    height ;", "}", "METHOD_END"], "methodName": ["setHeight"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Detail"}, {"methodBody": ["METHOD_START", "{", "this . length    =    length ;", "}", "METHOD_END"], "methodName": ["setLength"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Detail"}, {"methodBody": ["METHOD_START", "{", "this . width    =    width ;", "}", "METHOD_END"], "methodName": ["setWidth"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Detail"}, {"methodBody": ["METHOD_START", "{", "return   intelligence ;", "}", "METHOD_END"], "methodName": ["getIntelligence"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Hominidae"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getNonPersistent"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Hominidae"}, {"methodBody": ["METHOD_START", "{", "this . intelligence    =    intelligence ;", "}", "METHOD_END"], "methodName": ["setIntelligence"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Hominidae"}, {"methodBody": ["METHOD_START", "{", "return   webmaster ;", "}", "METHOD_END"], "methodName": ["getWebmaster"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Hotel"}, {"methodBody": ["METHOD_START", "{", "this . webmaster    =    webmaster ;", "}", "METHOD_END"], "methodName": ["setWebmaster"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Hotel"}, {"methodBody": ["METHOD_START", "{", "return   hotel ;", "}", "METHOD_END"], "methodName": ["getHotel"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.HotelRoom"}, {"methodBody": ["METHOD_START", "{", "this . hotel    =    hotel ;", "}", "METHOD_END"], "methodName": ["setHotel"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.HotelRoom"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.House"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.House"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Human"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Human"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Inhabitant"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Inhabitant"}, {"methodBody": ["METHOD_START", "{", "return   detail ;", "}", "METHOD_END"], "methodName": ["getDetail"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Item"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Item"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getNamedOrders"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Item"}, {"methodBody": ["METHOD_START", "{", "return   order ;", "}", "METHOD_END"], "methodName": ["getOrder"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Item"}, {"methodBody": ["METHOD_START", "{", "return   product ;", "}", "METHOD_END"], "methodName": ["getProduct"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Item"}, {"methodBody": ["METHOD_START", "{", "return   quantity ;", "}", "METHOD_END"], "methodName": ["getQuantity"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Item"}, {"methodBody": ["METHOD_START", "{", "this . detail    =    detail ;", "}", "METHOD_END"], "methodName": ["setDetail"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Item"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Item"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Item"}, {"methodBody": ["METHOD_START", "{", "this . product    =    product ;", "}", "METHOD_END"], "methodName": ["setProduct"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Item"}, {"methodBody": ["METHOD_START", "{", "this . quantity    =    quantity ;", "}", "METHOD_END"], "methodName": ["setQuantity"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Item"}, {"methodBody": ["METHOD_START", "{", "return   isReallyAlive ;", "}", "METHOD_END"], "methodName": ["isReallyAlive"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.LivingBeing"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["nonPersistent"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.LivingBeing"}, {"methodBody": ["METHOD_START", "{", "isReallyAlive    =    reallyAlive ;", "}", "METHOD_END"], "methodName": ["setReallyAlive"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.LivingBeing"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Mammals"}, {"methodBody": ["METHOD_START", "{", "return   nbrOfMammals ;", "}", "METHOD_END"], "methodName": ["getNbrOfMammals"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Mammals"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Mammals"}, {"methodBody": ["METHOD_START", "{", "this . nbrOfMammals    =    nbrOfMammals ;", "}", "METHOD_END"], "methodName": ["setNbrOfMammals"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Mammals"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Pet"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getNonPersistent"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Pet"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Pet"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Room"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.Room"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.User"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.User"}, {"methodBody": ["METHOD_START", "{", "return   nonPersistent ;", "}", "METHOD_END"], "methodName": ["getNonPersistent"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.User"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.User"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.User"}, {"methodBody": ["METHOD_START", "{", "this . nonPersistent    =    nonPersistent ;", "}", "METHOD_END"], "methodName": ["setNonPersistent"], "fileName": "org.hibernate.jpamodelgen.test.accesstype.User"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertAttributeTypeInMetaModelFor ( TemperatureSamples . class ,     \" samples \"  ,    Integer [  ]  . class ,     \" Wrong   type   for   field .  \"  )  ;", "}", "METHOD_END"], "methodName": ["testIntegerArray"], "fileName": "org.hibernate.jpamodelgen.test.arraytype.ArrayTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertAttributeTypeInMetaModelFor ( Image . class ,     \" data \"  ,    byte [  ]  . class ,     \" Wrong   type   for   field .  \"  )  ;", "}", "METHOD_END"], "methodName": ["testPrimitiveArray"], "fileName": "org.hibernate.jpamodelgen.test.arraytype.ArrayTest"}, {"methodBody": ["METHOD_START", "{", "return   data ;", "}", "METHOD_END"], "methodName": ["getData"], "fileName": "org.hibernate.jpamodelgen.test.arraytype.Image"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.hibernate.jpamodelgen.test.arraytype.Image"}, {"methodBody": ["METHOD_START", "{", "this . data    =    data ;", "}", "METHOD_END"], "methodName": ["setData"], "fileName": "org.hibernate.jpamodelgen.test.arraytype.Image"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.hibernate.jpamodelgen.test.arraytype.Image"}, {"methodBody": ["METHOD_START", "{", "return   samples ;", "}", "METHOD_END"], "methodName": ["getSamples"], "fileName": "org.hibernate.jpamodelgen.test.arraytype.TemperatureSamples"}, {"methodBody": ["METHOD_START", "{", "this . samples    =    samples ;", "}", "METHOD_END"], "methodName": ["setSamples"], "fileName": "org.hibernate.jpamodelgen.test.arraytype.TemperatureSamples"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( BlobEntity . class )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( BlobEntity . class ,     \" blob \"  ,     \" the   metamodel   should   have   a   member    ' blob '  \"  )  ;", "}", "METHOD_END"], "methodName": ["testBlobField"], "fileName": "org.hibernate.jpamodelgen.test.blob.BlobTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Product . class )  ;", "TestUtil . assertMetamodelClassGeneratedFor ( Goods . class )  ;", "TestUtil . assertListAttributeTypeInMetaModelFor ( Goods . class ,     \" productList \"  ,    Product . class ,     \" ListAttribute   generic   type   should   be   Product \"  )  ;", "TestUtil . assertAttributeTypeInMetaModelFor ( Goods . class ,     \" tags \"  ,    Goods . class . getDeclaredField (  \" tags \"  )  . getGenericType (  )  ,     \" Wrong   meta   model   type \"  )  ;", "}", "METHOD_END"], "methodName": ["testConvert"], "fileName": "org.hibernate.jpamodelgen.test.collectionbasictype.CollectionAsBasicTypeTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Person . class )  ;", "TestUtil . assertAttributeTypeInMetaModelFor ( Person . class ,     \" phones \"  ,    Person . class . getDeclaredField (  \" phones \"  )  . getGenericType (  )  ,     \" Wrong   meta   model   type \"  )  ;", "}", "METHOD_END"], "methodName": ["testListType"], "fileName": "org.hibernate.jpamodelgen.test.collectionbasictype.CollectionAsBasicTypeTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( PersonPhone . class )  ;", "TestUtil . assertAttributeTypeInMetaModelFor ( PersonPhone . class ,     \" phones \"  ,    PersonPhone . class . getDeclaredField (  \" phones \"  )  . getGenericType (  )  ,     \" Wrong   meta   model   type \"  )  ;", "}", "METHOD_END"], "methodName": ["testListTypeWithImport"], "fileName": "org.hibernate.jpamodelgen.test.collectionbasictype.CollectionAsBasicTypeTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( PhoneBook . class )  ;", "TestUtil . assertAttributeTypeInMetaModelFor ( PhoneBook . class ,     \" phones \"  ,    PhoneBook . class . getDeclaredField (  \" phones \"  )  . getGenericType (  )  ,     \" Wrong   meta   model   type \"  )  ;", "}", "METHOD_END"], "methodName": ["testMapType"], "fileName": "org.hibernate.jpamodelgen.test.collectionbasictype.CollectionAsBasicTypeTest"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.collectionbasictype.Goods"}, {"methodBody": ["METHOD_START", "{", "return   productList ;", "}", "METHOD_END"], "methodName": ["getProductList"], "fileName": "org.hibernate.jpamodelgen.test.collectionbasictype.Goods"}, {"methodBody": ["METHOD_START", "{", "return   tags ;", "}", "METHOD_END"], "methodName": ["getTags"], "fileName": "org.hibernate.jpamodelgen.test.collectionbasictype.Goods"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.collectionbasictype.Goods"}, {"methodBody": ["METHOD_START", "{", "this . productList    =    productList ;", "}", "METHOD_END"], "methodName": ["setProductList"], "fileName": "org.hibernate.jpamodelgen.test.collectionbasictype.Goods"}, {"methodBody": ["METHOD_START", "{", "this . tags    =    tags ;", "}", "METHOD_END"], "methodName": ["setTags"], "fileName": "org.hibernate.jpamodelgen.test.collectionbasictype.Goods"}, {"methodBody": ["METHOD_START", "{", "return   phones ;", "}", "METHOD_END"], "methodName": ["getPhones"], "fileName": "org.hibernate.jpamodelgen.test.collectionbasictype.Person"}, {"methodBody": ["METHOD_START", "{", "return   phones ;", "}", "METHOD_END"], "methodName": ["getPhones"], "fileName": "org.hibernate.jpamodelgen.test.collectionbasictype.PersonPhone"}, {"methodBody": ["METHOD_START", "{", "return   phones ;", "}", "METHOD_END"], "methodName": ["getPhones"], "fileName": "org.hibernate.jpamodelgen.test.collectionbasictype.PhoneBook"}, {"methodBody": ["METHOD_START", "{", "return   proId ;", "}", "METHOD_END"], "methodName": ["getProId"], "fileName": "org.hibernate.jpamodelgen.test.collectionbasictype.Product"}, {"methodBody": ["METHOD_START", "{", "return   proName ;", "}", "METHOD_END"], "methodName": ["getProName"], "fileName": "org.hibernate.jpamodelgen.test.collectionbasictype.Product"}, {"methodBody": ["METHOD_START", "{", "this . proId    =    proId ;", "}", "METHOD_END"], "methodName": ["setProId"], "fileName": "org.hibernate.jpamodelgen.test.collectionbasictype.Product"}, {"methodBody": ["METHOD_START", "{", "this . proName    =    proName ;", "}", "METHOD_END"], "methodName": ["setProName"], "fileName": "org.hibernate.jpamodelgen.test.collectionbasictype.Product"}, {"methodBody": ["METHOD_START", "{", "return   phoneNumber ;", "}", "METHOD_END"], "methodName": ["getPhoneNumber"], "fileName": "org.hibernate.jpamodelgen.test.collectionbasictype.extras.Phone"}, {"methodBody": ["METHOD_START", "{", "this . phoneNumber    =    phoneNumber ;", "}", "METHOD_END"], "methodName": ["setPhoneNumber"], "fileName": "org.hibernate.jpamodelgen.test.collectionbasictype.extras.Phone"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.Cleaner"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.Cleaner"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.Cleaner"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.Cleaner"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( OfficeBuilding . class )  ;", "TestUtil . assertMapAttributesInMetaModelFor ( OfficeBuilding . class ,     \" doorCodes \"  ,    Integer . class ,    byte [  ]  . class ,     \" Wrong   type   in   map   attribute .  \"  )  ;", "}", "METHOD_END"], "methodName": ["testArrayValueElementCollection"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.ElementCollectionTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( House . class )  ;", "TestUtil . assertMetamodelClassGeneratedFor ( Room . class )  ;", "TestUtil . assertNoSourceFileGeneratedFor ( String . class )  ;", "}", "METHOD_END"], "methodName": ["testElementCollectionOnMap"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.ElementCollectionTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Homework . class )  ;", "TestUtil . assertListAttributeTypeInMetaModelFor ( Homework . class ,     \" paths \"  ,    String . class ,     \" ListAttribute   generic   type   should   be   String \"  )  ;", "}", "METHOD_END"], "methodName": ["testListAttributeWithGenericTypeForJavaBeanGetter"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.ElementCollectionTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Hotel . class )  ;", "TestUtil . assertMapAttributesInMetaModelFor ( Hotel . class ,     \" roomsByName \"  ,    String . class ,    Room . class ,     \" Wrong   type   in   map   attribute .  \"  )  ;", "TestUtil . assertMapAttributesInMetaModelFor ( Hotel . class ,     \" cleaners \"  ,    Room . class ,    Cleaner . class ,     \" Wrong   type   in   map   attribute .  \"  )  ;", "}", "METHOD_END"], "methodName": ["testMapKeyClass"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.ElementCollectionTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Hostel . class )  ;", "TestUtil . assertMapAttributesInMetaModelFor ( Hostel . class ,     \" roomsByName \"  ,    String . class ,    Room . class ,     \" Wrong   type   in   map   attribute .  \"  )  ;", "TestUtil . assertMapAttributesInMetaModelFor ( Hostel . class ,     \" cleaners \"  ,    Room . class ,    Cleaner . class ,     \" Wrong   type   in   map   attribute .  \"  )  ;", "}", "METHOD_END"], "methodName": ["testMapKeyClassXmlConfigured"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.ElementCollectionTest"}, {"methodBody": ["METHOD_START", "{", "return   paths ;", "}", "METHOD_END"], "methodName": ["getPaths"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.Homework"}, {"methodBody": ["METHOD_START", "{", "TreeSet < String >    result    =    new   TreeSet <  >  (  )  ;", "if    (  ( paths )     =  =    null )     {", "return   result ;", "}", "for    ( String   path    :    paths )     {", "if    ( path . startsWith ( startPath )  )     {", "result . add ( path )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getPaths"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.Homework"}, {"methodBody": ["METHOD_START", "{", "this . paths    =    paths ;", "}", "METHOD_END"], "methodName": ["setPaths"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.Homework"}, {"methodBody": ["METHOD_START", "{", "if    ( append )     {", "this . paths . addAll ( paths )  ;", "} else    {", "this . paths    =    paths ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["setPaths"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.Homework"}, {"methodBody": ["METHOD_START", "{", "return   cleaners ;", "}", "METHOD_END"], "methodName": ["getCleaners"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.Hostel"}, {"methodBody": ["METHOD_START", "{", "return   roomsByName ;", "}", "METHOD_END"], "methodName": ["getRoomsByName"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.Hostel"}, {"methodBody": ["METHOD_START", "{", "this . cleaners    =    cleaners ;", "}", "METHOD_END"], "methodName": ["setCleaners"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.Hostel"}, {"methodBody": ["METHOD_START", "{", "this . roomsByName    =    roomsByName ;", "}", "METHOD_END"], "methodName": ["setRoomsByName"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.Hostel"}, {"methodBody": ["METHOD_START", "{", "return   cleaners ;", "}", "METHOD_END"], "methodName": ["getCleaners"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.Hotel"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.Hotel"}, {"methodBody": ["METHOD_START", "{", "return   roomsByName ;", "}", "METHOD_END"], "methodName": ["getRoomsByName"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.Hotel"}, {"methodBody": ["METHOD_START", "{", "this . cleaners    =    cleaners ;", "}", "METHOD_END"], "methodName": ["setCleaners"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.Hotel"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.Hotel"}, {"methodBody": ["METHOD_START", "{", "this . roomsByName    =    roomsByName ;", "}", "METHOD_END"], "methodName": ["setRoomsByName"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.Hotel"}, {"methodBody": ["METHOD_START", "{", "return   roomsByName ;", "}", "METHOD_END"], "methodName": ["getRoomsByName"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.House"}, {"methodBody": ["METHOD_START", "{", "this . roomsByName    =    roomsByName ;", "}", "METHOD_END"], "methodName": ["setRoomsByName"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.House"}, {"methodBody": ["METHOD_START", "{", "return   doorCodes ;", "}", "METHOD_END"], "methodName": ["getDoorCodes"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.OfficeBuilding"}, {"methodBody": ["METHOD_START", "{", "this . doorCodes    =    doorCodes ;", "}", "METHOD_END"], "methodName": ["setDoorCodes"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.OfficeBuilding"}, {"methodBody": ["METHOD_START", "{", "return   length ;", "}", "METHOD_END"], "methodName": ["getLength"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.Room"}, {"methodBody": ["METHOD_START", "{", "return   width ;", "}", "METHOD_END"], "methodName": ["getWidth"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.Room"}, {"methodBody": ["METHOD_START", "{", "this . length    =    length ;", "}", "METHOD_END"], "methodName": ["setLength"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.Room"}, {"methodBody": ["METHOD_START", "{", "this . width    =    width ;", "}", "METHOD_END"], "methodName": ["setWidth"], "fileName": "org.hibernate.jpamodelgen.test.elementcollection.Room"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertAttributeTypeInMetaModelFor ( EmbeddableEntity . class ,     \" stuffs \"  ,    Stuff . class ,     \" The   target   annotation   set   the   type   to   Stuff \"  )  ;", "}", "METHOD_END"], "methodName": ["testCorrectAccessTypeUsedForEmbeddable"], "fileName": "org.hibernate.jpamodelgen.test.embeddable.EmbeddableAccessTypeTest"}, {"methodBody": ["METHOD_START", "{", "return   stuffs ;", "}", "METHOD_END"], "methodName": ["getStuffs"], "fileName": "org.hibernate.jpamodelgen.test.embeddable.EmbeddableEntity"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.embeddedid.withinheritance.AbstractRef"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( TestEntity . class )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( TestEntity . class ,     \" ref \"  ,     \" Property   ref   should   be   in   metamodel \"  )  ;", "}", "METHOD_END"], "methodName": ["testEntityContainsEmbeddedIdProperty"], "fileName": "org.hibernate.jpamodelgen.test.embeddedid.withinheritance.EmbeddedIdWithInheritanceTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Person . class )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( Person . class ,     \" id \"  ,     \" Property   id   should   be   in   metamodel \"  )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( Person . class ,     \" address \"  ,     \" Property   id   should   be   in   metamodel \"  )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( XmlPerson . class ,     \" id \"  ,     \" Property   id   should   be   in   metamodel \"  )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( XmlPerson . class ,     \" address \"  ,     \" Property   id   should   be   in   metamodel \"  )  ;", "}", "METHOD_END"], "methodName": ["testGeneratedAnnotationNotGenerated"], "fileName": "org.hibernate.jpamodelgen.test.embeddedid.withoutinheritance.EmbeddedIdNoInheritanceTest"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.hibernate.jpamodelgen.test.embeddedid.withoutinheritance.PersonId"}, {"methodBody": ["METHOD_START", "{", "return   snn ;", "}", "METHOD_END"], "methodName": ["getSnn"], "fileName": "org.hibernate.jpamodelgen.test.embeddedid.withoutinheritance.PersonId"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.hibernate.jpamodelgen.test.embeddedid.withoutinheritance.PersonId"}, {"methodBody": ["METHOD_START", "{", "this . snn    =    snn ;", "}", "METHOD_END"], "methodName": ["setSnn"], "fileName": "org.hibernate.jpamodelgen.test.embeddedid.withoutinheritance.PersonId"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( TestEntity . class )  ;", "String   metaModelSource    =    TestUtil . getMetaModelSourceAsString ( TestEntity . class )  ;", "String   generatedString    =     \"  @ Generated ( value    =     \\  \" JPAMetaModelEntityProcessor \\  \"  )  \"  ;", "assertTrue (  \"  @ Generated   should   be   added   to   the   metamodel .  \"  ,    metaModelSource . contains ( generatedString )  )  ;", "}", "METHOD_END"], "methodName": ["testGeneratedAnnotationNotGenerated"], "fileName": "org.hibernate.jpamodelgen.test.generatedannotation.GeneratedAnnotationTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( TestEntity . class )  ;", "String   metaModelSource    =    TestUtil . getMetaModelSourceAsString ( TestEntity . class )  ;", "TestUtil . dumpMetaModelSourceFor ( TestEntity . class )  ;", "String   generatedString    =     \"  @ Generated ( value    =     \\  \" JPAMetaModelEntityProcessor \\  \"  ,    date    =     \\  \"  \"  ;", "assertTrue (  \"  @ Generated   should   also   contain   the   date   parameter .  \"  ,    metaModelSource . contains ( generatedString )  )  ;", "}", "METHOD_END"], "methodName": ["testGeneratedAnnotationGenerated"], "fileName": "org.hibernate.jpamodelgen.test.generatedannotation.GenerationDateTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( TestEntity . class )  ;", "String   metaModelSource    =    TestUtil . getMetaModelSourceAsString ( TestEntity . class )  ;", "assertFalse (  \"  @ Generated   should   not   be   added   to   the   metamodel .  \"  ,    metaModelSource . contains (  \"  @ Generated \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGeneratedAnnotationGenerated"], "fileName": "org.hibernate.jpamodelgen.test.generatedannotation.SkipGeneratedAnnotationTest"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.generics.Child"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.hibernate.jpamodelgen.test.generics.Child"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.generics.Child"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.hibernate.jpamodelgen.test.generics.Child"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Parent . class )  ;", "TestUtil . assertMetamodelClassGeneratedFor ( Child . class )  ;", "}", "METHOD_END"], "methodName": ["testGenerics"], "fileName": "org.hibernate.jpamodelgen.test.generics.GenericsTest"}, {"methodBody": ["METHOD_START", "{", "return   children ;", "}", "METHOD_END"], "methodName": ["getChildren"], "fileName": "org.hibernate.jpamodelgen.test.generics.Parent"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.generics.Parent"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.hibernate.jpamodelgen.test.generics.Parent"}, {"methodBody": ["METHOD_START", "{", "return   siblings ;", "}", "METHOD_END"], "methodName": ["getSiblings"], "fileName": "org.hibernate.jpamodelgen.test.generics.Parent"}, {"methodBody": ["METHOD_START", "{", "this . children    =    children ;", "}", "METHOD_END"], "methodName": ["setChildren"], "fileName": "org.hibernate.jpamodelgen.test.generics.Parent"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.generics.Parent"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.hibernate.jpamodelgen.test.generics.Parent"}, {"methodBody": ["METHOD_START", "{", "this . siblings    =    siblings ;", "}", "METHOD_END"], "methodName": ["setSiblings"], "fileName": "org.hibernate.jpamodelgen.test.generics.Parent"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( HashEntity . class )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( HashEntity . class ,     \" id \"  )  ;", "TestUtil . assertAbsenceOfFieldInMetamodelFor ( HashEntity . class ,     \" h \"  ,     \" h   is   not   a   persistent   property \"  )  ;", "}", "METHOD_END"], "methodName": ["testHashCodeDoesNotCreateSingularAttribute"], "fileName": "org.hibernate.jpamodelgen.test.hashcode.HashCodeTest"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.hashcode.HashEntity"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["goo"], "fileName": "org.hibernate.jpamodelgen.test.hashcode.HashEntity"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.hashcode.HashEntity"}, {"methodBody": ["METHOD_START", "{", "return   height ;", "}", "METHOD_END"], "methodName": ["getHeight"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.basic.Area"}, {"methodBody": ["METHOD_START", "{", "return   length ;", "}", "METHOD_END"], "methodName": ["getLength"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.basic.Area"}, {"methodBody": ["METHOD_START", "{", "return    (  ( length )     *     ( width )  )     *     ( height )  ;", "}", "METHOD_END"], "methodName": ["getVolume"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.basic.Area"}, {"methodBody": ["METHOD_START", "{", "return   width ;", "}", "METHOD_END"], "methodName": ["getWidth"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.basic.Area"}, {"methodBody": ["METHOD_START", "{", "this . height    =    height ;", "}", "METHOD_END"], "methodName": ["setHeight"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.basic.Area"}, {"methodBody": ["METHOD_START", "{", "this . length    =    length ;", "}", "METHOD_END"], "methodName": ["setLength"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.basic.Area"}, {"methodBody": ["METHOD_START", "{", "this . width    =    width ;", "}", "METHOD_END"], "methodName": ["setWidth"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.basic.Area"}, {"methodBody": ["METHOD_START", "{", "return   builtIn ;", "}", "METHOD_END"], "methodName": ["getBuiltIn"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.basic.Building"}, {"methodBody": ["METHOD_START", "{", "this . builtIn    =    builtIn ;", "}", "METHOD_END"], "methodName": ["setBuiltIn"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.basic.Building"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.basic.House"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.basic.House"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertSuperClassRelationShipInMetamodel ( Customer . class ,    User . class )  ;", "TestUtil . assertSuperClassRelationShipInMetamodel ( House . class ,    Building . class )  ;", "TestUtil . assertSuperClassRelationShipInMetamodel ( Building . class ,    Area . class )  ;", "TestUtil . assertSuperClassRelationShipInMetamodel ( Person . class ,    AbstractEntity . class )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( AbstractEntity . class ,     \" id \"  ,     \" Property    ' id '    should   exist \"  )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( AbstractEntity . class ,     \" foo \"  ,     \" Property   should   exist    -    METAGEN -  2  9  \"  )  ;", "TestUtil . assertAttributeTypeInMetaModelFor ( AbstractEntity . class ,     \" foo \"  ,    Object . class ,     \" Object   is   the   upper   bound   of   foo    \"  )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( Person . class ,     \" name \"  ,     \" Property    ' name '    should   exist \"  )  ;", "}", "METHOD_END"], "methodName": ["testInheritance"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.basic.InheritanceTest"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.basic.Person"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.basic.Person"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.basic.User"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.basic.User"}, {"methodBody": ["METHOD_START", "{", "return   nonPersistent ;", "}", "METHOD_END"], "methodName": ["getNonPersistent"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.basic.User"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.basic.User"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.basic.User"}, {"methodBody": ["METHOD_START", "{", "this . nonPersistent    =    nonPersistent ;", "}", "METHOD_END"], "methodName": ["setNonPersistent"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.basic.User"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Plane . class )  ;", "TestUtil . assertMetamodelClassGeneratedFor ( JetPlane . class )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( JetPlane . class ,     \" jets \"  )  ;", "TestUtil . assertAttributeTypeInMetaModelFor ( JetPlane . class ,     \" jets \"  ,    Integer . class ,     \" jets   should   be   defined   in   JetPlane _  \"  )  ;", "}", "METHOD_END"], "methodName": ["testDeepInheritance"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.deep.DeepInheritanceTest"}, {"methodBody": ["METHOD_START", "{", "created    =    new   Date (  )  ;", "}", "METHOD_END"], "methodName": ["prePersist"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.deep.PersistenceBase"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.unmappedclassinhierarchy.BaseEntity"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.unmappedclassinhierarchy.BaseEntity"}, {"methodBody": ["METHOD_START", "{", "return   s    !  =    null    ?    s    :     \" empty \"  ;", "}", "METHOD_END"], "methodName": ["doSomething"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.unmappedclassinhierarchy.NormalExtendsEntity"}, {"methodBody": ["METHOD_START", "{", "return   s    !  =    null    ?    s    :     \" empty \"  ;", "}", "METHOD_END"], "methodName": ["doSomething"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.unmappedclassinhierarchy.NormalExtendsMapped"}, {"methodBody": ["METHOD_START", "{", "return   street ;", "}", "METHOD_END"], "methodName": ["getStreet"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.unmappedclassinhierarchy.SubA"}, {"methodBody": ["METHOD_START", "{", "return   street ;", "}", "METHOD_END"], "methodName": ["getStreet"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.unmappedclassinhierarchy.SubB"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertSuperClassRelationShipInMetamodel ( SubA . class ,    BaseEntity . class )  ;", "TestUtil . assertSuperClassRelationShipInMetamodel ( SubB . class ,    MappedBase . class )  ;", "}", "METHOD_END"], "methodName": ["testUnmappedClassInHierarchy"], "fileName": "org.hibernate.jpamodelgen.test.inheritance.unmappedclassinhierarchy.UnmappedClassInHierarchyTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( EmbeddableAndMappedSuperClass . class )  ;", "}", "METHOD_END"], "methodName": ["testMetaModelsGenerated"], "fileName": "org.hibernate.jpamodelgen.test.mappedsuperclass.embeddablemappedsuperclass.EmbeddableMappedSuperClassTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( ConcreteProduct . class )  ;", "TestUtil . assertMetamodelClassGeneratedFor ( Product . class )  ;", "TestUtil . assertMetamodelClassGeneratedFor ( Shop . class )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( Product . class ,     \" shop \"  ,     \" The   many   to   one   attribute   shop   is   missing \"  )  ;", "}", "METHOD_END"], "methodName": ["testRightAccessTypeForMappedSuperclass"], "fileName": "org.hibernate.jpamodelgen.test.mappedsuperclass.mappedsuperclasswithoutid.MappedSuperclassWithoutExplicitIdTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( AttachmentGroup . class )  ;", "}", "METHOD_END"], "methodName": ["testExtractClosestRealType"], "fileName": "org.hibernate.jpamodelgen.test.mappedsuperclass.typedmappedsuperclass.TypesMappedSuperclassTest"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getHorsePower"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Car"}, {"methodBody": ["METHOD_START", "{", "return   make ;", "}", "METHOD_END"], "methodName": ["getMake"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Car"}, {"methodBody": ["METHOD_START", "{", "this . make    =    make ;", "}", "METHOD_END"], "methodName": ["setMake"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Car"}, {"methodBody": ["METHOD_START", "{", "return   number ;", "}", "METHOD_END"], "methodName": ["getNumber"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Insurance"}, {"methodBody": ["METHOD_START", "{", "return   policyNumber ;", "}", "METHOD_END"], "methodName": ["getPolicyNumber"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Insurance"}, {"methodBody": ["METHOD_START", "{", "this . number    =    number ;", "}", "METHOD_END"], "methodName": ["setNumber"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Insurance"}, {"methodBody": ["METHOD_START", "{", "this . policyNumber    =    policyNumber ;", "}", "METHOD_END"], "methodName": ["setPolicyNumber"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Insurance"}, {"methodBody": ["METHOD_START", "{", "return   coordinates ;", "}", "METHOD_END"], "methodName": ["getCoordinates"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Location"}, {"methodBody": ["METHOD_START", "{", "return   description ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Location"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Location"}, {"methodBody": ["METHOD_START", "{", "return   zeroCoordinates ;", "}", "METHOD_END"], "methodName": ["getZeroCoordinates"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Location"}, {"methodBody": ["METHOD_START", "{", "this . coordinates    =    coordinates ;", "}", "METHOD_END"], "methodName": ["setCoordinates"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Location"}, {"methodBody": ["METHOD_START", "{", "this . description    =    description ;", "}", "METHOD_END"], "methodName": ["setDescription"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Location"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Location"}, {"methodBody": ["METHOD_START", "{", "this . zeroCoordinates    =    zeroCoordinates ;", "}", "METHOD_END"], "methodName": ["setZeroCoordinates"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Location"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Coordinates . class )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( Coordinates . class ,     \" longitude \"  ,     \" field   exists   and   should   be   in   metamodel \"  )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( Coordinates . class ,     \" latitude \"  ,     \" field   exists   and   should   be   in   metamodel \"  )  ;", "TestUtil . assertMetamodelClassGeneratedFor ( ZeroCoordinates . class )  ;", "TestUtil . assertAbsenceOfFieldInMetamodelFor ( ZeroCoordinates . class ,     \" longitude \"  ,     \" Field   access   should   be   used ,    but   ZeroCoordinates   does   not   define   fields \"  )  ;", "TestUtil . assertAbsenceOfFieldInMetamodelFor ( ZeroCoordinates . class ,     \" latitude \"  ,     \" Field   access   should   be   used ,    but   ZeroCoordinates   does   not   define   fields \"  )  ;", "}", "METHOD_END"], "methodName": ["testAccessTypeForXmlConfiguredEmbeddables"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.MixedConfigurationTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Vehicle . class )  ;", "TestUtil . assertMetamodelClassGeneratedFor ( Car . class )  ;", "TestUtil . assertAbsenceOfFieldInMetamodelFor ( Car . class ,     \" horsePower \"  ,     \"  ' horsePower '    should   not   appear   in   metamodel   since   it   does   have   no   field .  \"  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultAccessTypeApplied"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.MixedConfigurationTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Vehicle . class )  ;", "TestUtil . assertMetamodelClassGeneratedFor ( Truck . class )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( Truck . class ,     \" horsePower \"  ,     \" Property    ' horsePower '    has   explicit   access   type   and   should   be   in   metamodel \"  )  ;", "TestUtil . assertAttributeTypeInMetaModelFor ( Truck . class ,     \" horsePower \"  ,    Integer . class ,     \" Wrong   meta   model   type \"  )  ;", "}", "METHOD_END"], "methodName": ["testExplicitXmlConfiguredAccessTypeApplied"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.MixedConfigurationTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( RentalCar . class )  ;", "TestUtil . assertMetamodelClassGeneratedFor ( RentalCompany . class )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( RentalCar . class ,     \" company \"  ,     \" Property    ' company '    should   be   included   due   to   xml   c \"  )  ;", "TestUtil . assertAttributeTypeInMetaModelFor ( RentalCar . class ,     \" company \"  ,    RentalCompany . class ,     \" Wrong   meta   model   type \"  )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( RentalCar . class ,     \" insurance \"  ,     \" Property    ' insurance '    should   be   included   since   it   is   an   embeddable \"  )  ;", "TestUtil . assertAttributeTypeInMetaModelFor ( RentalCar . class ,     \" insurance \"  ,    Insurance . class ,     \" Wrong   meta   model   type \"  )  ;", "}", "METHOD_END"], "methodName": ["testMixedConfiguration"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.MixedConfigurationTest"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Person"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Person"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Person"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Person"}, {"methodBody": ["METHOD_START", "{", "return   chassisNumber ;", "}", "METHOD_END"], "methodName": ["getChassisNumber"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.RentalCar"}, {"methodBody": ["METHOD_START", "{", "return   company ;", "}", "METHOD_END"], "methodName": ["getCompany"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.RentalCar"}, {"methodBody": ["METHOD_START", "{", "return   hired ;", "}", "METHOD_END"], "methodName": ["getHired"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.RentalCar"}, {"methodBody": ["METHOD_START", "{", "return   insurance ;", "}", "METHOD_END"], "methodName": ["getInsurance"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.RentalCar"}, {"methodBody": ["METHOD_START", "{", "this . chassisNumber    =    chassisNumber ;", "}", "METHOD_END"], "methodName": ["setChassisNumber"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.RentalCar"}, {"methodBody": ["METHOD_START", "{", "this . company    =    company ;", "}", "METHOD_END"], "methodName": ["setCompany"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.RentalCar"}, {"methodBody": ["METHOD_START", "{", "this . hired    =    hired ;", "}", "METHOD_END"], "methodName": ["setHired"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.RentalCar"}, {"methodBody": ["METHOD_START", "{", "this . insurance    =    insurance ;", "}", "METHOD_END"], "methodName": ["setInsurance"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.RentalCar"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.RentalCompany"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.RentalCompany"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.RentalCompany"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.RentalCompany"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getHorsePower"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Truck"}, {"methodBody": ["METHOD_START", "{", "return   make ;", "}", "METHOD_END"], "methodName": ["getMake"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Truck"}, {"methodBody": ["METHOD_START", "{", "this . make    =    make ;", "}", "METHOD_END"], "methodName": ["setMake"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Truck"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Vehicle"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.Vehicle"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Person . class )  ;", "TestUtil . assertAbsenceOfFieldInMetamodelFor ( Person . class ,     \" name \"  )  ;", "}", "METHOD_END"], "methodName": ["testXmlConfiguredEmbeddedClassGenerated"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.XmlMetaCompleteTest"}, {"methodBody": ["METHOD_START", "{", "return    0  .  0 F ;", "}", "METHOD_END"], "methodName": ["getLatitude"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.ZeroCoordinates"}, {"methodBody": ["METHOD_START", "{", "return    0  .  0 F ;", "}", "METHOD_END"], "methodName": ["getLongitude"], "fileName": "org.hibernate.jpamodelgen.test.mixedmode.ZeroCoordinates"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Snafu . class )  ;", "}", "METHOD_END"], "methodName": ["testMetaModelGeneratedForXmlConfiguredEntity"], "fileName": "org.hibernate.jpamodelgen.test.persistence21.Jpa21DescriptorTest"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.persistence21.Snafu"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.persistence21.Snafu"}, {"methodBody": ["METHOD_START", "{", "return   employees ;", "}", "METHOD_END"], "methodName": ["getEmployees"], "fileName": "org.hibernate.jpamodelgen.test.rawtypes.DeskWithRawType"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.rawtypes.DeskWithRawType"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.hibernate.jpamodelgen.test.rawtypes.DeskWithRawType"}, {"methodBody": ["METHOD_START", "{", "this . employees    =    employees ;", "}", "METHOD_END"], "methodName": ["setEmployees"], "fileName": "org.hibernate.jpamodelgen.test.rawtypes.DeskWithRawType"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.rawtypes.DeskWithRawType"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.hibernate.jpamodelgen.test.rawtypes.DeskWithRawType"}, {"methodBody": ["METHOD_START", "{", "return   desks ;", "}", "METHOD_END"], "methodName": ["getDesks"], "fileName": "org.hibernate.jpamodelgen.test.rawtypes.EmployeeWithRawType"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.rawtypes.EmployeeWithRawType"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.hibernate.jpamodelgen.test.rawtypes.EmployeeWithRawType"}, {"methodBody": ["METHOD_START", "{", "this . desks    =    desks ;", "}", "METHOD_END"], "methodName": ["setDesks"], "fileName": "org.hibernate.jpamodelgen.test.rawtypes.EmployeeWithRawType"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.rawtypes.EmployeeWithRawType"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.hibernate.jpamodelgen.test.rawtypes.EmployeeWithRawType"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( DeskWithRawType . class )  ;", "TestUtil . assertMetamodelClassGeneratedFor ( EmployeeWithRawType . class )  ;", "}", "METHOD_END"], "methodName": ["testGenerics"], "fileName": "org.hibernate.jpamodelgen.test.rawtypes.RawTypesTest"}, {"methodBody": ["METHOD_START", "{", "String   entityMetaModel    =    TestUtil . getMetaModelSourceAsString ( Entity . class )  ;", "assertTrue ( entityMetaModel . contains (  \" extends   superclass . MappedSuperclass \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testInheritance"], "fileName": "org.hibernate.jpamodelgen.test.separatecompilationunits.SeparateCompilationUnitsTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Printer . class )  ;", "TestUtil . assertMetamodelClassGeneratedFor ( PrintJob . class )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( Printer . class ,     \" printQueue \"  ,     \" There   sorted   set   attribute   is   missing \"  )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( Printer . class ,     \" printedJobs \"  ,     \" There   sorted   map   attribute   is   missing \"  )  ;", "}", "METHOD_END"], "methodName": ["testGenerics"], "fileName": "org.hibernate.jpamodelgen.test.sortedcollection.SortedCollectionTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( TestEntity . class )  ;", "String   metaModelSource    =    TestUtil . getMetaModelSourceAsString ( TestEntity . class )  ;", "assertTrue (  \"  @    should   be   added   to   the   metamodel .  \"  ,    metaModelSource . contains (  \"  @  (  {     \\  \" deprecation \\  \"  ,     \\  \" rawtypes \\  \"     }  )  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSuppressedWarningsAnnotationGenerated"], "fileName": "org.hibernate.jpamodelgen.test.supresswarnings.SuppressWarningsAnnotationGeneratedTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( TestEntity . class )  ;", "String   metaModelSource    =    TestUtil . getMetaModelSourceAsString ( TestEntity . class )  ;", "assertFalse (  \"  @    should   not   be   added   to   the   metamodel .  \"  ,    metaModelSource . contains (  \"  @  (  \\  \" all \\  \"  )  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSuppressedWarningsAnnotationNotGenerated"], "fileName": "org.hibernate.jpamodelgen.test.supresswarnings.SuppressWarningsAnnotationNotGeneratedTest"}, {"methodBody": ["METHOD_START", "{", "return   address ;", "}", "METHOD_END"], "methodName": ["getAddress"], "fileName": "org.hibernate.jpamodelgen.test.targetannotation.House"}, {"methodBody": ["METHOD_START", "{", "this . address    =    address ;", "}", "METHOD_END"], "methodName": ["setAddress"], "fileName": "org.hibernate.jpamodelgen.test.targetannotation.House"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( House . class )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( House . class ,     \" address \"  ,     \" the   metamodel   should   have   a   member    ' address '  \"  )  ;", "TestUtil . assertAttributeTypeInMetaModelFor ( House . class ,     \" address \"  ,    AddressImpl . class ,     \" The   target      set   the   type   to   AddressImpl \"  )  ;", "}", "METHOD_END"], "methodName": ["testEmbeddableWithTargetAnnotation"], "fileName": "org.hibernate.jpamodelgen.test.targetannotation.TargetAnnotationTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( ContactDetails . class )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( ContactDetails . class ,     \" phoneNumber \"  ,     \"  @ Type   annotated   field   should   be   in   metamodel \"  )  ;", "}", "METHOD_END"], "methodName": ["testCustomUserTypeInMetaModel"], "fileName": "org.hibernate.jpamodelgen.test.usertype.UserTypeTest"}, {"methodBody": ["METHOD_START", "{", "if    ( withProcessorOptionsAnnotation    !  =    null )     {", "processorOptions . put ( withProcessorOptionsAnnotation . key (  )  ,    withProcessorOptionsAnnotation . value (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addOptions"], "fileName": "org.hibernate.jpamodelgen.test.util.CompilationRunner"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( testEntities . isEmpty (  )  )  )     |  |     (  !  ( mappingFiles . isEmpty (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["annotationProcessorNeedsToRun"], "fileName": "org.hibernate.jpamodelgen.test.util.CompilationRunner"}, {"methodBody": ["METHOD_START", "{", "processWithClasses ( method . getAnnotation ( WithClasses . class )  )  ;", "processWithMappingFiles ( method . getAnnotation ( WithMappingFiles . class )  )  ;", "processOptions ( method . getAnnotation ( WithProcessorOption . class )  ,    method . getAnnotation ( WithProcessorOption . List . class )  )  ;", "ignoreErrors    =     ( method . getAnnotation ( IgnoreErrors . class )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["processAnnotations"], "fileName": "org.hibernate.jpamodelgen.test.util.CompilationRunner"}, {"methodBody": ["METHOD_START", "{", "addOptions ( withProcessorOption )  ;", "if    ( withProcessorOptionsListAnnot    !  =    null )     {", "for    ( WithProcessorOption   option    :    withProcessorOptionsListAnnot . value (  )  )     {", "addOptions ( option )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processOptions"], "fileName": "org.hibernate.jpamodelgen.test.util.CompilationRunner"}, {"methodBody": ["METHOD_START", "{", "if    ( withClasses    !  =    null )     {", "Collections . addAll ( testEntities ,    withClasses . value (  )  )  ;", "Collections . addAll ( preeEntities ,    withClasses . pree (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["processWithClasses"], "fileName": "org.hibernate.jpamodelgen.test.util.CompilationRunner"}, {"methodBody": ["METHOD_START", "{", "if    ( withMappingFiles    !  =    null )     {", "String   packageNameAsPath    =    TestUfcnToPath ( packageName )  ;", "for    ( String   mappingFile    :    withMappingFiles . value (  )  )     {", "mappingFiles . add (  (  ( packageNameAsPath    +     ( TestURESOURCE _ SEPARATOR )  )     +    mappingFile )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processWithMappingFiles"], "fileName": "org.hibernate.jpamodelgen.test.util.CompilationRunner"}, {"methodBody": ["METHOD_START", "{", "List < String >    options    =    createJavaOptions (  )  ;", "JavaCompiler   compiler    =    ToolProvider . getSystemJavaCompiler (  )  ;", "DiagnosticCollector < JavaFileObject >    diagnostics    =    new   DiagnosticCollector < JavaFileObject >  (  )  ;", "StandardJavaFileManager   fileManager    =    compiler . getStandardFileManager ( diagnostics ,    null ,    null )  ;", "Iterable <  ?    extends   JavaFileObject >    cUnits    =    fileManager . getJavaFileObjectsFromFiles ( sourceFiles )  ;", "compileSources ( options ,    compiler ,    diagnostics ,    fileManager ,    cUnits )  ;", "cDiagnostics . addAll ( diagnostics . getDiagnostics (  )  )  ;", "fileManager . close (  )  ;", "}", "METHOD_END"], "methodName": ["compile"], "fileName": "org.hibernate.jpamodelgen.test.util.CompilationStatement"}, {"methodBody": ["METHOD_START", "{", "JavaCompiler . CompilationTask   task    =    compiler . getTask ( null ,    fileManager ,    diagnostics ,    options ,    null ,    compilationUnits )  ;", "task . call (  )  ;", "for    ( Diagnostic <  ?  >    diagnostic    :    diagnostics . getDiagnostics (  )  )     {", ". log . debug ( diagnostic . getMessage ( null )  )  ;", "}", "}", "METHOD_END"], "methodName": ["compileSources"], "fileName": "org.hibernate.jpamodelgen.test.util.CompilationStatement"}, {"methodBody": ["METHOD_START", "{", "List < String >    options    =    new   ArrayList < String >  (  )  ;", "options . add (  \"  - d \"  )  ;", "options . add ( TestUtil . getOutBaseDir (  )  . getAbsolutePath (  )  )  ;", "if    (  !  ( xmlMappingFiles . isEmpty (  )  )  )     {", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "builder . append (  . ANNOTATION _ PROCESSOR _ OPTION _ PREFIX )  ;", "builder . append ( JPAMetaModelEntityProcessor . ORM _ XML _ OPTION )  ;", "builder . append (  \"  =  \"  )  ;", "for    ( String   ormFile    :    xmlMappingFiles )     {", "builder . append ( ormFile )  ;", "builder . append (  \"  ,  \"  )  ;", "}", "builder . deleteCharAt (  (  ( builder . length (  )  )     -     1  )  )  ;", "options . add ( builder . toString (  )  )  ;", "}", "for    ( Map . Entry < String ,    String >    entry    :    processorOptions . entrySet (  )  )     {", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "builder . append (  . ANNOTATION _ PROCESSOR _ OPTION _ PREFIX )  ;", "builder . append ( entry . getKey (  )  )  ;", "builder . append (  \"  =  \"  )  ;", "builder . append ( entry . getValue (  )  )  ;", "options . add ( builder . toString (  )  )  ;", "}", "return   options ;", "}", "METHOD_END"], "methodName": ["createJavaOptions"], "fileName": "org.hibernate.jpamodelgen.test.util.CompilationStatement"}, {"methodBody": ["METHOD_START", "{", "List < File >    javaFiles    =    new   ArrayList < File >  (  )  ;", "for    ( Class <  ?  >    testClass    :    classesToe )     {", "String   pathToSource    =    getPathToSource ( testClass )  ;", "add ( new   File ( pathToSource )  )  ;", "}", "return   javaFiles ;", "}", "METHOD_END"], "methodName": ["getCompilationUnits"], "fileName": "org.hibernate.jpamodelgen.test.util.CompilationStatement"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( CompilationStatement . SOURCE _ BASE _ DIR )     +     ( File . separator )  )     +     ( testClass . getName (  )  . replace ( CompilationStatement . PACKAGE _ SEPARATOR ,    File . separator )  )  )     +     \"  . java \"  ;", "}", "METHOD_END"], "methodName": ["getPathToSource"], "fileName": "org.hibernate.jpamodelgen.test.util.CompilationStatement"}, {"methodBody": ["METHOD_START", "{", "TestUtil . deleteProcessorGeneratedFiles (  )  ;", "}", "METHOD_END"], "methodName": ["cleanup"], "fileName": "org.hibernate.jpamodelgen.test.util.CompilationTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertAbsenceOfFieldInMetamodelFor ( clazz ,    fieldName ,     (  (  \"  '  \"     +    fieldName )     +     \"  '    should   not   appear   in   metamodel   class \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertAbsenceOfFieldInMetamodelFor"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( TestUtil . buildErrorString ( errorString ,    clazz )  ,    TestUtil . hasFieldInMetamodelFor ( clazz ,    fieldName )  )  ;", "}", "METHOD_END"], "methodName": ["assertAbsenceOfFieldInMetamodelFor"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "Field   field    =    TestUtil . getFieldFromMetamodelFor ( clazz ,    fieldName )  ;", "assertNotNull (  (  (  (  \" Cannot   find   field    '  \"     +    fieldName )     +     \"  '    in    \"  )     +     ( clazz . getName (  )  )  )  ,    field )  ;", "ParameterizedType   type    =     (  ( ParameterizedType )     ( field . getGenericType (  )  )  )  ;", "Type   actualType    =    type . getActualTypeArguments (  )  [  1  ]  ;", "if    ( expectedType . isArray (  )  )     {", "expectedType    =    expectedType . getComponentType (  )  ;", "actualType    =    TestUtil . getComponentType ( actualType )  ;", "}", "assertEquals (  (  \" Types   do   not   match :     \"     +     ( TestUtil . buildErrorString ( errorString ,    clazz )  )  )  ,    expectedType ,    actualType )  ;", "}", "METHOD_END"], "methodName": ["assertAttributeTypeInMetaModelFor"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "Field   field    =    TestUtil . getFieldFromMetamodelFor ( clazz ,    fieldName )  ;", "assertNotNull (  (  (  (  \" Cannot   find   field    '  \"     +    fieldName )     +     \"  '    in    \"  )     +     ( clazz . getName (  )  )  )  ,    field )  ;", "ParameterizedType   type    =     (  ( ParameterizedType )     ( field . getGenericType (  )  )  )  ;", "Type   actualType    =    type . getActualTypeArguments (  )  [  1  ]  ;", "assertEquals (  (  \" Types   do   not   match :     \"     +     ( TestUtil . buildErrorString ( errorString ,    clazz )  )  )  ,    expectedType ,    actualType )  ;", "}", "METHOD_END"], "methodName": ["assertAttributeTypeInMetaModelFor"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "Field   field    =    TestUtil . getFieldFromMetamodelFor ( clazz ,    fieldName )  ;", "assertNotNull (  (  (  (  \" Cannot   find   field    '  \"     +    fieldName )     +     \"  '    in    \"  )     +     ( clazz . getName (  )  )  )  ,    field )  ;", "ParameterizedType   type    =     (  ( ParameterizedType )     ( field . getGenericType (  )  )  )  ;", "Type   rawType    =    type . getRawType (  )  ;", "assertEquals (  (  \" Types   do   not   match :     \"     +     ( TestUtil . buildErrorString ( errorString ,    clazz )  )  )  ,    ListAttribute . class ,    rawType )  ;", "Type   genericType    =    type . getActualTypeArguments (  )  [  1  ]  ;", "assertEquals (  (  \" Types   do   not   match :     \"     +     ( TestUtil . buildErrorString ( errorString ,    clazz )  )  )  ,    expectedType ,    genericType )  ;", "}", "METHOD_END"], "methodName": ["assertListAttributeTypeInMetaModelFor"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "Field   field    =    TestUtil . getFieldFromMetamodelFor ( clazz ,    fieldName )  ;", "assertNotNull ( field )  ;", "ParameterizedType   type    =     (  ( ParameterizedType )     ( field . getGenericType (  )  )  )  ;", "Type   actualMapKeyType    =    type . getActualTypeArguments (  )  [  1  ]  ;", "assertEquals ( TestUtil . buildErrorString ( errorString ,    clazz )  ,    expectedMapKey ,    actualMapKeyType )  ;", "Type   actualMapKeyValue    =    type . getActualTypeArguments (  )  [  2  ]  ;", "assertEquals ( TestUtil . buildErrorString ( errorString ,    clazz )  ,    expectedMapValue ,    actualMapKeyValue )  ;", "}", "METHOD_END"], "methodName": ["assertMapAttributesInMetaModelFor"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( TestUtil . getMetamodelClassFor ( clazz )  )  ;", "}", "METHOD_END"], "methodName": ["assertMetamodelClassGeneratedFor"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "for    ( Diagnostic <  ?  >    diagnostic    :    diagnostics )     {", "if    ( diagnostic . getKind (  )  . equals ( Diagnostic . Kind . ERROR )  )     {", "fail (  (  \" There   was   a   compilation   error   during   annotation   processing :  \\ n \"     +     ( diagnostic . getMessage ( null )  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["assertNoCompilationError"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" Class   parameter   cannot   be   null \"  ,    clazz )  ;", "File   sourceFile    =     . getMetaModelSourceFileFor ( clazz )  ;", "assertFalse (  (  \" There   should   be   no   source   file :     \"     +     ( sourceFile . getName (  )  )  )  ,    sourceFile . exists (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNoSourceFileGeneratedFor"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertPresenceOfFieldInMetamodelFor ( clazz ,    fieldName ,     (  (  \"  '  \"     +    fieldName )     +     \"  '    should   appear   in   metamodel   class \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertPresenceOfFieldInMetamodelFor"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( TestUtil . buildErrorString ( errorString ,    clazz )  ,    TestUtil . hasFieldInMetamodelFor ( clazz ,    fieldName )  )  ;", "}", "METHOD_END"], "methodName": ["assertPresenceOfFieldInMetamodelFor"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    TestUtil . getMetamodelClassFor ( entityClass )  ;", "Class <  ?  >    superClazz    =    TestUtil . getMetamodelClassFor ( superEntityClass )  ;", "assertEquals (  (  (  (  \" Entity    \"     +     ( superClazz . getName (  )  )  )     +     \"    should   be   the   superclass   of    \"  )     +     ( clazz . getName (  )  )  )  ,    superClazz . getName (  )  ,    clazz . getSuperclass (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertSuperClassRelationShipInMetamodel"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "builder . append ( baseError )  ;", "builder . append (  \"  .  \\ n \\ n \"  )  ;", "builder . append (  \" Source   code   for    \"  )  ;", "builder . append ( clazz . getName (  )  )  ;", "builder . append (  \"  _  . java :  \"  )  ;", "builder . append (  \"  \\ n \"  )  ;", "builder . append (  . getMetaModelSourceAsString ( clazz )  )  ;", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["buildErrorString"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( file . isDirectory (  )  )     {", "for    ( File   c    :    file . listFiles (  )  )     {", ". deleteFilesRecursive ( c )  ;", "}", "}", "if    (  !  ( file . delete (  )  )  )     {", "fail (  (  \" Unable   to   delete   file :     \"     +    file )  )  ;", "}", "}", "METHOD_END"], "methodName": ["deleteFilesRecursive"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "for    ( File   file    :    TestUtil . OUT _ BASE _ DIR . listFiles (  )  )     {", "TestUtil . deleteFilesRecursive ( file )  ;", "}", "}", "METHOD_END"], "methodName": ["deleteProcessorGeneratedFiles"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "TestUtil . log . info (  (  (  \" Dumping   meta   model   source   for    \"     +     ( clazz . getName (  )  )  )     +     \"  :  \"  )  )  ;", "TestUtil . log . info ( TestUtil . getMetaModelSourceAsString ( clazz )  )  ;", "}", "METHOD_END"], "methodName": ["dumpMetaModelSourceFor"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "return   fcn . replace ( TestUtil . PACKAGE _ SEPARATOR ,    TestUtil . RESOURCE _ SEPARATOR )  ;", "}", "METHOD_END"], "methodName": ["fcnToPath"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( actualType   instanceof   Class )     {", "Class <  ?  >    clazz    =     (  ( Class <  ?  >  )     ( actualType )  )  ;", "if    ( clazz . isArray (  )  )     {", "return   clazz . getComponentType (  )  ;", "} else    {", "fail (  \" Unexpected   component   type \"  )  ;", "}", "}", "if    ( actualType   instanceof   GenericArrayType )     {", "return    (  ( GenericArrayType )     ( actualType )  )  . getGenericComponentType (  )  ;", "} else    {", "fail (  \" Unexpected   component   type \"  )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getComponentType"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    metaModelClass    =    TestUtil . getMetamodelClassFor ( entityClass )  ;", "Field   field ;", "try    {", "field    =    metaModelClass . getDeclaredField ( fieldName )  ;", "}    catch    ( NoSuchFieldException   e )     {", "field    =    null ;", "}", "return   field ;", "}", "METHOD_END"], "methodName": ["getFieldFromMetamodelFor"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "File   sourceFile    =    TestUtil . getMetaModelSourceFileFor ( clazz )  ;", "StringBuilder   contents    =    new   StringBuilder (  )  ;", "try    {", "BufferedReader   input    =    new   BufferedReader ( new   FileReader ( sourceFile )  )  ;", "try    {", "String   line ;", "while    (  ( line    =    input . readLine (  )  )     !  =    null )     {", "contents . append ( line )  ;", "contents . append ( System . lineSeparator (  )  )  ;", "}", "}    finally    {", "input . close (  )  ;", "}", "}    catch    ( IOException   ex )     {", "ex . printStackTrace (  )  ;", "}", "return   contents . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getMetaModelSourceAsString"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "String   metaModelClassName    =     ( clazz . getName (  )  )     +     ( TestUtil . META _ MODEL _ CLASS _ POSTFIX )  ;", "String   fileName    =    metaModelClassName . replace ( TestUtil . PACKAGE _ SEPARATOR ,    TestUtil . PATH _ SEPARATOR )  ;", "fileName    =    fileName . concat (  \"  . java \"  )  ;", "return   new   File (  (  (  ( TestUtil . OUT _ BASE _ DIR )     +     ( TestUtil . PATH _ SEPARATOR )  )     +    fileName )  )  ;", "}", "METHOD_END"], "methodName": ["getMetaModelSourceFileFor"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" Class   parameter   cannot   be   null \"  ,    entityClass )  ;", "String   metaModelClassName    =     ( entityClass . getName (  )  )     +     (  . META _ MODEL _ CLASS _ POSTFIX )  ;", "try    {", "URL   outDirUrl    =     . OUT _ BASE _ DIR . toURI (  )  . toURL (  )  ;", "URL [  ]    urls    =    new   URL [  1  ]  ;", "urls [  0  ]     =    outDirUrl ;", "URLClassLoader   classLoader    =    new   URLClassLoader ( urls ,     . class . getClassLoader (  )  )  ;", "return   classLoader . loadClass ( metaModelClassName )  ;", "}    catch    ( Exception   e )     {", "fail (  ( metaModelClassName    +     \"    was   not   generated .  \"  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getMetamodelClassFor"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "return   TestUtil . OUT _ BASE _ DIR ;", "}", "METHOD_END"], "methodName": ["getOutBaseDir"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   contextClassLoader    =    Thread . currentThread (  )  . getContextClassLoader (  )  ;", "String   currentTestClass    =     . class . getName (  )  ;", "int   hopsToCompileDirectory    =    currentTestClass . split (  \"  \\  \\  .  \"  )  . length ;", "int   hopsToTargetDirectory    =    hopsToCompileDirectory    +     2  ;", "URL   classURL    =    contextClassLoader . getResource (  (  ( currentTestClass . replace (  '  .  '  ,     '  /  '  )  )     +     \"  . class \"  )  )  ;", "File   targetDir    =    new   File ( classURL . getFile (  )  )  ;", "for    ( int   i    =     0  ;    i    <    hopsToTargetDirectory ;    i +  +  )     {", "targetDir    =    targetDir . getParentFile (  )  ;", "}", "return   targetDir ;", "}", "METHOD_END"], "methodName": ["getTargetDir"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "return    ( TestUtil . getFieldFromMetamodelFor ( clazz ,    fieldName )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasFieldInMetamodelFor"], "fileName": "org.hibernate.jpamodelgen.test.util.TestUtil"}, {"methodBody": ["METHOD_START", "{", "String   entityMetaModel    =    TestUtil . getMetaModelSourceAsString ( BusinessEntity . class )  ;", "assertTrue ( entityMetaModel . contains (  \" SingularAttribute < BusinessEntity ,    BusinessId < T >  >    businessId \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeForEmbeddableConfiguredInXmlExists"], "fileName": "org.hibernate.jpamodelgen.test.xmlembeddable.EmbeddableConfiguredInXmlTest"}, {"methodBody": ["METHOD_START", "{", "return   city ;", "}", "METHOD_END"], "methodName": ["getCity"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Address"}, {"methodBody": ["METHOD_START", "{", "return   country ;", "}", "METHOD_END"], "methodName": ["getCountry"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Address"}, {"methodBody": ["METHOD_START", "{", "return   street 1  ;", "}", "METHOD_END"], "methodName": ["getStreet1"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Address"}, {"methodBody": ["METHOD_START", "{", "this . city    =    city ;", "}", "METHOD_END"], "methodName": ["setCity"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Address"}, {"methodBody": ["METHOD_START", "{", "this . country    =    country ;", "}", "METHOD_END"], "methodName": ["setCountry"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Address"}, {"methodBody": ["METHOD_START", "{", "this . street 1     =    street 1  ;", "}", "METHOD_END"], "methodName": ["setStreet1"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Address"}, {"methodBody": ["METHOD_START", "{", "return   favoriteSuperhero ;", "}", "METHOD_END"], "methodName": ["getFavoriteSuperhero"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Boy"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Boy"}, {"methodBody": ["METHOD_START", "{", "return   knowsHeroes ;", "}", "METHOD_END"], "methodName": ["getKnowsHeroes"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Boy"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Boy"}, {"methodBody": ["METHOD_START", "{", "return   nickNames ;", "}", "METHOD_END"], "methodName": ["getNickNames"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Boy"}, {"methodBody": ["METHOD_START", "{", "return   savedBy ;", "}", "METHOD_END"], "methodName": ["getSavedBy"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Boy"}, {"methodBody": ["METHOD_START", "{", "this . favoriteSuperhero    =    favoriteSuperhero ;", "}", "METHOD_END"], "methodName": ["setFavoriteSuperhero"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Boy"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Boy"}, {"methodBody": ["METHOD_START", "{", "this . knowsHeroes    =    knowsHeroes ;", "}", "METHOD_END"], "methodName": ["setKnowsHeroes"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Boy"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Boy"}, {"methodBody": ["METHOD_START", "{", "this . nickNames    =    nickNames ;", "}", "METHOD_END"], "methodName": ["setNickNames"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Boy"}, {"methodBody": ["METHOD_START", "{", "this . savedBy    =    savedBy ;", "}", "METHOD_END"], "methodName": ["setSavedBy"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Boy"}, {"methodBody": ["METHOD_START", "{", "return   address ;", "}", "METHOD_END"], "methodName": ["getAddress"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Building"}, {"methodBody": ["METHOD_START", "{", "this . address    =    address ;", "}", "METHOD_END"], "methodName": ["setAddress"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Building"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Superhero . class )  ;", "}", "METHOD_END"], "methodName": ["testInvalidXmlFilesGetIgnored"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.IgnoreInvalidXmlTest"}, {"methodBody": ["METHOD_START", "{", "return   reallyAlive ;", "}", "METHOD_END"], "methodName": ["isReallyAlive"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.LivingBeing"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["nonPersistent"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.LivingBeing"}, {"methodBody": ["METHOD_START", "{", "this . reallyAlive    =    reallyAlive ;", "}", "METHOD_END"], "methodName": ["setReallyAlive"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.LivingBeing"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Mammal"}, {"methodBody": ["METHOD_START", "{", "return   subclass ;", "}", "METHOD_END"], "methodName": ["getSubclass"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Mammal"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Mammal"}, {"methodBody": ["METHOD_START", "{", "this . subclass    =    subclass ;", "}", "METHOD_END"], "methodName": ["setSubclass"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Mammal"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Superhero"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Superhero"}, {"methodBody": ["METHOD_START", "{", "return   superPower ;", "}", "METHOD_END"], "methodName": ["getSuperPower"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Superhero"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Superhero"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Superhero"}, {"methodBody": ["METHOD_START", "{", "this . superPower    =    superPower ;", "}", "METHOD_END"], "methodName": ["setSuperPower"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.Superhero"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Mammal . class )  ;", "TestUtil . assertMetamodelClassGeneratedFor ( LivingBeing . class )  ;", "TestUtil . assertSuperClassRelationShipInMetamodel ( Mammal . class ,    LivingBeing . class )  ;", "}", "METHOD_END"], "methodName": ["testClassHierarchy"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.XmlMappingTest"}, {"methodBody": ["METHOD_START", "{", "Class . forName (  \" Dummy _  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNonExistentMappedClassesGetIgnored"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.XmlMappingTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Boy . class )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( Boy . class ,     \" savedBy \"  ,     \" savedBy   field   should   exist \"  )  ;", "TestUtil . assertAttributeTypeInMetaModelFor ( Boy . class ,     \" savedBy \"  ,    FakeHero . class ,     \" target   entity   overridden   in   xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testTargetEntityOnManyToMany"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.XmlMappingTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Boy . class )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( Boy . class ,     \" knowsHeroes \"  ,     \" knowsHeroes   field   should   exist \"  )  ;", "TestUtil . assertAttributeTypeInMetaModelFor ( Boy . class ,     \" knowsHeroes \"  ,    FakeHero . class ,     \" target   entity   overridden   in   xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testTargetEntityOnOneToMany"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.XmlMappingTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Boy . class )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( Boy . class ,     \" favoriteSuperhero \"  ,     \" favoriteSuperhero   field   should   exist \"  )  ;", "TestUtil . assertAttributeTypeInMetaModelFor ( Boy . class ,     \" favoriteSuperhero \"  ,    FakeHero . class ,     \" target   entity   overridden   in   xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testTargetEntityOnOneToOne"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.XmlMappingTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Boy . class )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( Boy . class ,     \" nickNames \"  ,     \" nickNames   field   should   exist \"  )  ;", "TestUtil . assertAttributeTypeInMetaModelFor ( Boy . class ,     \" nickNames \"  ,    String . class ,     \" target   class   overridden   in   xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testXmlConfiguredElementCollection"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.XmlMappingTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Address . class )  ;", "}", "METHOD_END"], "methodName": ["testXmlConfiguredEmbeddedClassGenerated"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.XmlMappingTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Building . class )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( Building . class ,     \" address \"  ,     \" address   field   should   exist \"  )  ;", "}", "METHOD_END"], "methodName": ["testXmlConfiguredMappedSuperclassGenerated"], "fileName": "org.hibernate.jpamodelgen.test.xmlmapped.XmlMappingTest"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.xmlmetacomplete.multiplepus.Dummy"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.xmlmetacomplete.multiplepus.Dummy"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( Dummy . class )  ;", "}", "METHOD_END"], "methodName": ["testMetaModelGenerated"], "fileName": "org.hibernate.jpamodelgen.test.xmlmetacomplete.multiplepus.XmlMetaDataCompleteMultiplePersistenceUnitsTest"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.xmlmetacomplete.singlepu.Dummy"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.xmlmetacomplete.singlepu.Dummy"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertNoSourceFileGeneratedFor ( Dummy . class )  ;", "}", "METHOD_END"], "methodName": ["testNoMetaModelGenerated"], "fileName": "org.hibernate.jpamodelgen.test.xmlmetacomplete.singlepu.XmlMetaDataCompleteSinglePersistenceUnitTest"}, {"methodBody": ["METHOD_START", "{", "return    1 L ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.xmlonly.Car"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getTires"], "fileName": "org.hibernate.jpamodelgen.test.xmlonly.Car"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getCar"], "fileName": "org.hibernate.jpamodelgen.test.xmlonly.Tire"}, {"methodBody": ["METHOD_START", "{", "return    1 L ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.xmlonly.Tire"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.hibernate.jpamodelgen.test.xmlonly.XmlOnly"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.hibernate.jpamodelgen.test.xmlonly.XmlOnly"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertPresenceOfFieldInMetamodelFor ( Option . class ,     \" period \"  ,     \" Embedded   expected \"  )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( Period . class ,     \" start \"  ,     \" Embedded   expected \"  )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( Period . class ,     \" end \"  ,     \" Embedded   expected \"  )  ;", "}", "METHOD_END"], "methodName": ["testMetaModelGeneratedForEmbeddable"], "fileName": "org.hibernate.jpamodelgen.test.xmlonly.XmlOnlyTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertPresenceOfFieldInMetamodelFor ( Course . class ,     \" qualifiedTeachers \"  ,     \" Type   should   be   inferred   from   field \"  )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( Teacher . class ,     \" qualifiedFor \"  ,     \" Type   should   be   inferred   from   field \"  )  ;", "}", "METHOD_END"], "methodName": ["testMetaModelGeneratedForManyToManyFieldAccessWithoutTargetEntity"], "fileName": "org.hibernate.jpamodelgen.test.xmlonly.XmlOnlyTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertPresenceOfFieldInMetamodelFor ( Car . class ,     \" tires \"  ,     \" Type   should   be   inferred   from   field \"  )  ;", "TestUtil . assertPresenceOfFieldInMetamodelFor ( Tire . class ,     \" car \"  ,     \" Type   should   be   inferred   from   field \"  )  ;", "}", "METHOD_END"], "methodName": ["testMetaModelGeneratedForOneToManyPropertyAccessWithoutTargetEntity"], "fileName": "org.hibernate.jpamodelgen.test.xmlonly.XmlOnlyTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . assertMetamodelClassGeneratedFor ( XmlOnly . class )  ;", "}", "METHOD_END"], "methodName": ["testMetaModelGeneratedForXmlConfiguredEntity"], "fileName": "org.hibernate.jpamodelgen.test.xmlonly.XmlOnlyTest"}, {"methodBody": ["METHOD_START", "{", "if    (  ( explicitAccessType )     !  =    null )     {", "return   explicitAccessType ;", "} else", "if    (  ( defaultAccessType )     !  =    null )     {", "return   defaultAccessType ;", "} else    {", "return    . DEFAULT _ ACCESS _ TYPE ;", "}", "}", "METHOD_END"], "methodName": ["getAccessType"], "fileName": "org.hibernate.jpamodelgen.util.AccessTypeInformation"}, {"methodBody": ["METHOD_START", "{", "return   defaultAccessType ;", "}", "METHOD_END"], "methodName": ["getDefaultAccessType"], "fileName": "org.hibernate.jpamodelgen.util.AccessTypeInformation"}, {"methodBody": ["METHOD_START", "{", "return    (  ( explicitAccessType )     !  =    null )     |  |     (  ( defaultAccessType )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["isAccessTypeResolved"], "fileName": "org.hibernate.jpamodelgen.util.AccessTypeInformation"}, {"methodBody": ["METHOD_START", "{", "this . defaultAccessType    =    defaultAccessType ;", "}", "METHOD_END"], "methodName": ["setDefaultAccessType"], "fileName": "org.hibernate.jpamodelgen.util.AccessTypeInformation"}, {"methodBody": ["METHOD_START", "{", "this . explicitAccessType    =    explicitAccessType ;", "}", "METHOD_END"], "methodName": ["setExplicitAccessType"], "fileName": "org.hibernate.jpamodelgen.util.AccessTypeInformation"}, {"methodBody": ["METHOD_START", "{", "lastModifiedCache . put ( fileName ,    lastModified )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.hibernate.jpamodelgen.util.FileTimeStampChecker"}, {"methodBody": ["METHOD_START", "{", "return   fqcn . substring (  (  ( fqcn . lastIndexOf ( StringUtil . NAME _ SEPARATOR )  )     +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["classNameFromFqcn"], "fileName": "org.hibernate.jpamodelgen.util.StringUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( string    =  =    null )     |  |     ( string . isEmpty (  )  )  )     |  |     ( StringUtil . startsWithSeveralUpperCaseLetters ( string )  )  )     {", "return   string ;", "} else    {", "return    ( string . substring (  0  ,     1  )  . toLowerCase ( Locale . ROOT )  )     +     ( string . substring (  1  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["decapitalize"], "fileName": "org.hibernate.jpamodelgen.util.StringUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtil . isFullyQualified ( name )  )     {", "return   name ;", "} else    {", "return    ( defaultPackage    +     ( StringUtil . NAME _ SEPARATOR )  )     +    name ;", "}", "}", "METHOD_END"], "methodName": ["determineFullyQualifiedClassName"], "fileName": "org.hibernate.jpamodelgen.util.StringUtil"}, {"methodBody": ["METHOD_START", "{", "String   tmp    =    name ;", "if    ( name . startsWith (  . PROPERTY _ PREFIX _ GET )  )     {", "tmp    =    name . replaceFirst (  . PROPERTY _ PREFIX _ GET ,     \"  \"  )  ;", "} else", "if    ( name . startsWith (  . PROPERTY _ PREFIX _ IS )  )     {", "tmp    =    name . replaceFirst (  . PROPERTY _ PREFIX _ IS ,     \"  \"  )  ;", "} else", "if    ( name . startsWith (  . PROPERTY _ PREFIX _ HAS )  )     {", "tmp    =    name . replaceFirst (  . PROPERTY _ PREFIX _ HAS ,     \"  \"  )  ;", "}", "return    . decapitalize ( tmp )  ;", "}", "METHOD_END"], "methodName": ["getPropertyName"], "fileName": "org.hibernate.jpamodelgen.util.StringUtil"}, {"methodBody": ["METHOD_START", "{", "return   lowerCamelCaseString . replaceAll (  \"  (  .  )  (  \\  \\ p { Upper }  )  \"  ,     \"  $  1  _  $  2  \"  )  . toUpperCase (  )  ;", "}", "METHOD_END"], "methodName": ["getUpperUnderscoreCaseFromLowerCamelCase"], "fileName": "org.hibernate.jpamodelgen.util.StringUtil"}, {"methodBody": ["METHOD_START", "{", "return    (  \" Boolean \"  . equals ( type )  )     |  |     (  \" Boolean \"  . equals ( type )  )  ;", "}", "METHOD_END"], "methodName": ["isBooleanGetter"], "fileName": "org.hibernate.jpamodelgen.util.StringUtil"}, {"methodBody": ["METHOD_START", "{", "return   name . contains ( StringUtil . NAME _ SEPARATOR )  ;", "}", "METHOD_END"], "methodName": ["isFullyQualified"], "fileName": "org.hibernate.jpamodelgen.util.StringUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  ( methodName    =  =    null )     |  |     (  \" void \"  . equals ( returnTypeAsString )  )  )     {", "return   false ;", "}", "if    (  . isValidPropertyName ( methodName ,     . PROPERTY _ PREFIX _ GET )  )     {", "return   true ;", "}", "if    (  (  . isValidPropertyName ( methodName ,     . PROPERTY _ PREFIX _ IS )  )     |  |     (  . isValidPropertyName ( methodName ,     . PROPERTY _ PREFIX _ HAS )  )  )     {", "return    . isBooleanGetter ( returnTypeAsString )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isProperty"], "fileName": "org.hibernate.jpamodelgen.util.StringUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( name . startsWith ( prefix )  )  )     {", "return   false ;", "}", "return    ( name . length (  )  )     >  =     (  ( prefix . length (  )  )     +     1  )  ;", "}", "METHOD_END"], "methodName": ["isValidPropertyName"], "fileName": "org.hibernate.jpamodelgen.util.StringUtil"}, {"methodBody": ["METHOD_START", "{", "return   fqcn . substring (  0  ,    fqcn . lastIndexOf ( StringUtil . NAME _ SEPARATOR )  )  ;", "}", "METHOD_END"], "methodName": ["packageNameFromFqcn"], "fileName": "org.hibernate.jpamodelgen.util.StringUtil"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( string . length (  )  )     >     1  )     &  &     ( Character . isUpperCase ( string . charAt (  0  )  )  )  )     &  &     ( Character . isUpperCase ( string . charAt (  1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["startsWithSeveralUpperCaseLetters"], "fileName": "org.hibernate.jpamodelgen.util.StringUtil"}, {"methodBody": ["METHOD_START", "{", "assert   element    !  =    null ;", "assert   annotations    !  =    null ;", "List < String >    annotationClassNames    =    new   ArrayList < String >  (  )  ;", "Collections . addAll ( annotationClassNames ,    annotations )  ;", "List <  ?    extends   AnnotationMirror >    annotationMirrors    =    element . getAnnotationMirrors (  )  ;", "for    ( AnnotationMirror   mirror    :    annotationMirrors )     {", "if    ( annotationClassNames . contains ( mirror . getAnnotation (  )  . toString (  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsAnnotation"], "fileName": "org.hibernate.jpamodelgen.util.TypeUtils"}, {"methodBody": ["METHOD_START", "{", "String   fqcn    =    searchedElement . getQualifiedName (  )  . toString (  )  ;", "context . logMessage ( Diagnostic . Kind . OTHER ,     (  \" Determining   access   type   for    \"     +    fqcn )  )  ;", "AccessTypeInformation   accessTypeInfo    =    context . getAccessTypeInfo ( fqcn )  ;", "if    (  ( accessTypeInfo    !  =    null )     &  &     ( accessTypeInfo . isAccessTypeResolved (  )  )  )     {", "context . logMessage ( Diagnostic . Kind . OTHER ,     (  (  (  \" AccessType   for    \"     +     ( searchedElement . toString (  )  )  )     +     \"    found   in   cache :     \"  )     +    accessTypeInfo )  )  ;", "return ;", "}", "AccessType   forcedAccessType    =     . determineAnnotationSpecifiedAccessType ( searchedElement )  ;", "if    ( forcedAccessType    !  =    null )     {", "context . logMessage ( Diagnostic . Kind . OTHER ,     (  (  (  \" Explicit   access   type   on    \"     +    searchedElement )     +     \"  :  \"  )     +    forcedAccessType )  )  ;", "accessTypeInfo    =    new   AccessTypeInformation ( fqcn ,    forcedAccessType ,    null )  ;", "context . addAccessTypeInformation ( fqcn ,    accessTypeInfo )  ;", ". updateEmbeddableAccessType ( searchedElement ,    context ,    forcedAccessType )  ;", "return ;", "}", "AccessType   defaultAccessType    =     . getAccessTypeInCaseElementIsRoot ( searchedElement ,    context )  ;", "if    ( defaultAccessType    !  =    null )     {", "accessTypeInfo    =    new   AccessTypeInformation ( fqcn ,    null ,    defaultAccessType )  ;", "context . addAccessTypeInformation ( fqcn ,    accessTypeInfo )  ;", ". updateEmbeddableAccessType ( searchedElement ,    context ,    defaultAccessType )  ;", ". setDefaultAccessTypeForMappedSuperclassesInHierarchy ( searchedElement ,    defaultAccessType ,    context )  ;", "return ;", "}", "defaultAccessType    =     . getDefaultAccessForHierarchy ( searchedElement ,    context )  ;", "if    ( defaultAccessType    =  =    null )     {", "defaultAccessType    =    AccessType . PROPERTY ;", "}", "accessTypeInfo    =    new   AccessTypeInformation ( fqcn ,    null ,    defaultAccessType )  ;", "context . addAccessTypeInformation ( fqcn ,    accessTypeInfo )  ;", ". updateEmbeddableAccessType ( searchedElement ,    context ,    defaultAccessType )  ;", "}", "METHOD_END"], "methodName": ["determineAccessTypeForHierarchy"], "fileName": "org.hibernate.jpamodelgen.util.TypeUtils"}, {"methodBody": ["METHOD_START", "{", "final   AnnotationMirror   accessAnnotationMirror    =    TypeUtils . getAnnotationMirror ( element ,    Constants . ACCESS )  ;", "AccessType   forcedAccessType    =    null ;", "if    ( accessAnnotationMirror    !  =    null )     {", "Element   accessElement    =     (  ( Element )     ( TypeUtils . getAnnotationValue ( accessAnnotationMirror ,    TypeUtils . DEFAULT _ ANNOTATION _ PARAMETER _ NAME )  )  )  ;", "if    ( accessElement . getKind (  )  . equals ( ElementKind . ENUM _ CONSTANT )  )     {", "if    ( accessElement . getSimpleName (  )  . toString (  )  . equals ( AccessType . PROPERTY . toString (  )  )  )     {", "forcedAccessType    =    AccessType . PROPERTY ;", "} else", "if    ( accessElement . getSimpleName (  )  . toString (  )  . equals ( AccessType . FIELD . toString (  )  )  )     {", "forcedAccessType    =    AccessType . FIELD ;", "}", "}", "}", "return   forcedAccessType ;", "}", "METHOD_END"], "methodName": ["determineAnnotationSpecifiedAccessType"], "fileName": "org.hibernate.jpamodelgen.util.TypeUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( type   instanceof   TypeVariable )     {", "final   TypeMirror   compositeUpperBound    =     (  ( TypeVariable )     ( type )  )  . getUpperBound (  )  ;", "return    . extractClosestRealTypeAsString ( compositeUpperBound ,    context )  ;", "} else    {", "return   context . get (  )  . erasure ( type )  . toString (  )  ;", "}", "}", "METHOD_END"], "methodName": ["extractClosestRealTypeAsString"], "fileName": "org.hibernate.jpamodelgen.util.TypeUtils"}, {"methodBody": ["METHOD_START", "{", "List <  ?    extends   Element >    myMembers    =    searchedElement . getEnclosedElements (  )  ;", "for    ( Element   subElement    :    myMembers )     {", "List <  ?    extends   AnnotationMirror >    entityAnnotations    =    context . getElementUtils (  )  . getAllAnnotationMirrors ( subElement )  ;", "for    ( Object   entityAnnotation    :    entityAnnotations )     {", "AnnotationMirror   annotationMirror    =     (  ( AnnotationMirror )     ( entityAnnotation )  )  ;", "if    (  . isIdAnnotation ( annotationMirror )  )     {", "return    . getAccessTypeOfIdAnnotation ( subElement )  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAccessTypeInCaseElementIsRoot"], "fileName": "org.hibernate.jpamodelgen.util.TypeUtils"}, {"methodBody": ["METHOD_START", "{", "AccessType   accessType    =    null ;", "final   ElementKind   kind    =    element . getKind (  )  ;", "if    (  ( kind    =  =     ( ElementKind . FIELD )  )     |  |     ( kind    =  =     ( ElementKind . METHOD )  )  )     {", "accessType    =     ( kind    =  =     ( ElementKind . FIELD )  )     ?    AccessType . FIELD    :    AccessType . PROPERTY ;", "}", "return   accessType ;", "}", "METHOD_END"], "methodName": ["getAccessTypeOfIdAnnotation"], "fileName": "org.hibernate.jpamodelgen.util.TypeUtils"}, {"methodBody": ["METHOD_START", "{", "assert   element    !  =    null ;", "assert   fqcn    !  =    null ;", "AnnotationMirror   mirror    =    null ;", "for    ( AnnotationMirror   am    :    element . getAnnotationMirrors (  )  )     {", "if    (  . isAnnotationMirrorOfType ( am ,    fqcn )  )     {", "mirror    =    am ;", "break ;", "}", "}", "return   mirror ;", "}", "METHOD_END"], "methodName": ["getAnnotationMirror"], "fileName": "org.hibernate.jpamodelgen.util.TypeUtils"}, {"methodBody": ["METHOD_START", "{", "assert   annotationMirror    !  =    null ;", "assert   parameterValue    !  =    null ;", "Object   returnValue    =    null ;", "for    ( Map . Entry <  ?    extends   ExecutableElement ,     ?    extends   AnnotationValue >    entry    :    annotationMirror . getElementValues (  )  . entrySet (  )  )     {", "if    ( parameterValue . equals ( entry . getKey (  )  . getSimpleName (  )  . toString (  )  )  )     {", "returnValue    =    entry . getValue (  )  . getValue (  )  ;", "break ;", "}", "}", "return   returnValue ;", "}", "METHOD_END"], "methodName": ["getAnnotationValue"], "fileName": "org.hibernate.jpamodelgen.util.TypeUtils"}, {"methodBody": ["METHOD_START", "{", "TypeMirror   collectionElementType ;", "if    ( explicitTargetEntityName    !  =    null )     {", "Elements   elements    =    context . getElementUtils (  )  ;", "TypeElement   element    =    elements . getTypeElement ( explicitTargetEntityName )  ;", "collectionElementType    =    element . asType (  )  ;", "} else    {", "List <  ?    extends   TypeMirror >    typeArguments    =    t . getTypeArguments (  )  ;", "if    (  ( typeArguments . size (  )  )     =  =     0  )     {", "throw   new   MetaModelGenerationException (  \" Unable   to   determine   collection   type \"  )  ;", "} else", "if    ( getCanonicalName (  )  . equals ( fqNameOfReturnedType )  )     {", "collectionElementType    =    t . getTypeArguments (  )  . get (  1  )  ;", "} else    {", "collectionElementType    =    t . getTypeArguments (  )  . get (  0  )  ;", "}", "}", "return   collectionElementType ;", "}", "METHOD_END"], "methodName": ["getCollectionElementType"], "fileName": "org.hibernate.jpamodelgen.util.TypeUtils"}, {"methodBody": ["METHOD_START", "{", "AccessType   defaultAccessType    =    null ;", "TypeElement   superClass    =    element ;", "do    {", "superClass    =     . getSuperclassTypeElement ( superClass )  ;", "if    ( superClass    !  =    null )     {", "String   fqcn    =    superClass . getQualifiedName (  )  . toString (  )  ;", "AccessTypeInformation   accessTypeInfo    =    context . getAccessTypeInfo ( fqcn )  ;", "if    (  ( accessTypeInfo    !  =    null )     &  &     (  ( accessTypeInfo . getDefaultAccessType (  )  )     !  =    null )  )     {", "return   accessTypeInfo . getDefaultAccessType (  )  ;", "}", "if    (  . containsAnnotation ( superClass ,    Constants . ENTITY ,    Constants . MAPPED _ SUPERCLASS )  )     {", "defaultAccessType    =     . getAccessTypeInCaseElementIsRoot ( superClass ,    context )  ;", "if    ( defaultAccessType    !  =    null )     {", "accessTypeInfo    =    new   AccessTypeInformation ( fqcn ,    null ,    defaultAccessType )  ;", "context . addAccessTypeInformation ( fqcn ,    accessTypeInfo )  ;", ". setDefaultAccessTypeForMappedSuperclassesInHierarchy ( superClass ,    defaultAccessType ,    context )  ;", "break ;", "} else    {", "defaultAccessType    =     . getDefaultAccessForHierarchy ( superClass ,    context )  ;", "}", "}", "}", "}    while    ( superClass    !  =    null    )  ;", "return   defaultAccessType ;", "}", "METHOD_END"], "methodName": ["getDefaultAccessForHierarchy"], "fileName": "org.hibernate.jpamodelgen.util.TypeUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( AccessType . FIELD . equals ( accessType )  )     {", "return   ElementKind . FIELD ;", "} else    {", "return   ElementKind . METHOD ;", "}", "}", "METHOD_END"], "methodName": ["getElementKindForAccessType"], "fileName": "org.hibernate.jpamodelgen.util.TypeUtils"}, {"methodBody": ["METHOD_START", "{", "List <  ?    extends   TypeMirror >    typeArguments    =    t . getTypeArguments (  )  ;", "if    (  ( typeArguments . size (  )  )     =  =     0  )     {", "context . logMessage ( Diagnostic . Kind . ERROR ,     (  \" Unable   to   determine   type   argument   for    \"     +    t )  )  ;", "}", "return    . extractClosestRealTypeAsString ( typeArguments . get (  0  )  ,    context )  ;", "}", "METHOD_END"], "methodName": ["getKeyType"], "fileName": "org.hibernate.jpamodelgen.util.TypeUtils"}, {"methodBody": ["METHOD_START", "{", "final   TypeMirror   superClass    =    element . getSuperclass (  )  ;", "if    (  ( superClass . getKind (  )  )     =  =     ( TypeKind . DECLARED )  )     {", "final   Element   superClassElement    =     (  ( DeclaredType )     ( superClass )  )  . asElement (  )  ;", "return    (  ( TypeElement )     ( superClassElement )  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getSuperclassTypeElement"], "fileName": "org.hibernate.jpamodelgen.util.TypeUtils"}, {"methodBody": ["METHOD_START", "{", "assert   annotationMirror    !  =    null ;", "assert   fqcn    !  =    null ;", "String   annotationClassName    =    annotationMirror . getAnnotation (  )  . toString (  )  ;", "return   annotationClassName . equals ( fqcn )  ;", "}", "METHOD_END"], "methodName": ["isAnnotationMirrorOfType"], "fileName": "org.hibernate.jpamodelgen.util.TypeUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( TypeUtils . isAnnotationMirrorOfType ( annotationMirror ,    Constants . ID )  )     |  |     ( TypeUtils . isAnnotationMirrorOfType ( annotationMirror ,    Constants . EMBEDDED _ ID )  )  ;", "}", "METHOD_END"], "methodName": ["isIdAnnotation"], "fileName": "org.hibernate.jpamodelgen.util.TypeUtils"}, {"methodBody": ["METHOD_START", "{", "TypeElement   superClass    =    element ;", "do    {", "superClass    =     . getSuperclassTypeElement ( superClass )  ;", "if    ( superClass    !  =    null )     {", "String   fqcn    =    superClass . getQualifiedName (  )  . toString (  )  ;", "if    (  . containsAnnotation ( superClass ,    Constants . MAPPED _ SUPERCLASS )  )     {", "AccessTypeInformation   accessTypeInfo ;", "AccessType   forcedAccessType    =     . determineAnnotationSpecifiedAccessType ( superClass )  ;", "if    ( forcedAccessType    !  =    null )     {", "accessTypeInfo    =    new   AccessTypeInformation ( fqcn ,    null ,    forcedAccessType )  ;", "} else    {", "accessTypeInfo    =    new   AccessTypeInformation ( fqcn ,    null ,    defaultAccessType )  ;", "}", "context . addAccessTypeInformation ( fqcn ,    accessTypeInfo )  ;", "}", "}", "}    while    ( superClass    !  =    null    )  ;", "}", "METHOD_END"], "methodName": ["setDefaultAccessTypeForMappedSuperclassesInHierarchy"], "fileName": "org.hibernate.jpamodelgen.util.TypeUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( type . getKind (  )  . isPrimitive (  )  )     {", "return    . PRIMITIVES . get ( type . getKind (  )  )  ;", "}", "return   type . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toTypeString"], "fileName": "org.hibernate.jpamodelgen.util.TypeUtils"}, {"methodBody": ["METHOD_START", "{", "List <  ?    extends   Element >    fieldsOfClass    =    ElementFilter . fieldsIn ( element . getEnclosedElements (  )  )  ;", "for    ( Element   field    :    fieldsOfClass )     {", ". updateEmbeddableAccessTypeForMember ( context ,    defaultAccessType ,    field )  ;", "}", "List <  ?    extends   Element >    methodOfClass    =    ElementFilter . methodsIn ( element . getEnclosedElements (  )  )  ;", "for    ( Element   method    :    methodOfClass )     {", ". updateEmbeddableAccessTypeForMember ( context ,    defaultAccessType ,    method )  ;", "}", "}", "METHOD_END"], "methodName": ["updateEmbeddableAccessType"], "fileName": "org.hibernate.jpamodelgen.util.TypeUtils"}, {"methodBody": ["METHOD_START", "{", "TypeUtils . EmbeddedAttributeVisitor   visitor    =    new   TypeUtils . EmbeddedAttributeVisitor ( context )  ;", "String   embeddedClassName    =    member . asType (  )  . accept ( visitor ,    member )  ;", "if    ( embeddedClassName    !  =    null )     {", "AccessTypeInformation   accessTypeInfo    =    context . getAccessTypeInfo ( embeddedClassName )  ;", "if    ( accessTypeInfo    =  =    null )     {", "accessTypeInfo    =    new   AccessTypeInformation ( embeddedClassName ,    null ,    defaultAccessType )  ;", "context . addAccessTypeInformation ( embeddedClassName ,    accessTypeInfo )  ;", "} else    {", "accessTypeInfo . setDefaultAccessType ( defaultAccessType )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["updateEmbeddableAccessTypeForMember"], "fileName": "org.hibernate.jpamodelgen.util.TypeUtils"}, {"methodBody": ["METHOD_START", "{", "return   columnNumber ;", "}", "METHOD_END"], "methodName": ["getColumnNumber"], "fileName": "org.hibernate.jpamodelgen.util.xml.ContextProvidingValidationEventHandler"}, {"methodBody": ["METHOD_START", "{", "return   lineNumber ;", "}", "METHOD_END"], "methodName": ["getLineNumber"], "fileName": "org.hibernate.jpamodelgen.util.xml.ContextProvidingValidationEventHandler"}, {"methodBody": ["METHOD_START", "{", "return   message ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.hibernate.jpamodelgen.util.xml.ContextProvidingValidationEventHandler"}, {"methodBody": ["METHOD_START", "{", "String   elementName    =    startElement . getName (  )  . getLocalPart (  )  ;", "if    (  . START _ ELEMENT _ TO _ NAMESPACE _ URI . containsKey ( elementName )  )     {", "currentDocumentNamespaceUri    =     . START _ ELEMENT _ TO _ NAMESPACE _ URI . get ( elementName )  ;", "}", "List < Attribute >    newElementAttributeList    =    updateElementAttributes ( startElement )  ;", "List < Namespace >    newNamespaceList    =    updateElementNamespaces ( startElement )  ;", "return   xmlEventFactory . createStartElement ( new   QName ( currentDocumentNamespaceUri ,    startElement . getName (  )  . getLocalPart (  )  )  ,    newElementAttributeList . iterator (  )  ,    newNamespaceList . iterator (  )  )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.hibernate.jpamodelgen.util.xml.JpaNamespaceTransformingEventReader"}, {"methodBody": ["METHOD_START", "{", "List < Attribute >    newElementAttributeList    =    new   ArrayList < Attribute >  (  )  ;", "Iterator <  ?  >    existingAttributesIterator    =    startElement . getAttributes (  )  ;", "while    ( existingAttributesIterator . hasNext (  )  )     {", "Attribute   attribute    =     (  ( Attribute )     ( existingAttributesIterator . next (  )  )  )  ;", "if    (  . VERSION _ ATTRIBUTE _ NAME . equals ( attribute . getName (  )  . getLocalPart (  )  )  )     {", "if    (  !  (  . DEFAULT _ VERSION . equals ( attribute . getName (  )  . getPrefix (  )  )  )  )     {", "newElementAttributeList . add ( xmlEventFactory . createAttribute ( attribute . getName (  )  ,     . DEFAULT _ VERSION )  )  ;", "}", "} else    {", "newElementAttributeList . add ( attribute )  ;", "}", "}", "return   newElementAttributeList ;", "}", "METHOD_END"], "methodName": ["updateElementAttributes"], "fileName": "org.hibernate.jpamodelgen.util.xml.JpaNamespaceTransformingEventReader"}, {"methodBody": ["METHOD_START", "{", "List < Namespace >    newNamespaceList    =    new   ArrayList < Namespace >  (  )  ;", "Iterator <  ?  >    existingNamespaceIterator    =    startElement . getNamespaces (  )  ;", "while    ( existingNamespaceIterator . hasNext (  )  )     {", "Namespace   namespace    =     (  ( Namespace )     ( existingNamespaceIterator . next (  )  )  )  ;", "if    (  . NAMESPACE _ MAPPING . containsKey ( namespace . getNamespaceURI (  )  )  )     {", "newNamespaceList . add ( xmlEventFactory . createNamespace (  . EMPTY _ PREFIX ,    currentDocumentNamespaceUri )  )  ;", "} else    {", "newNamespaceList . add ( namespace )  ;", "}", "}", "if    ( newNamespaceList . isEmpty (  )  )     {", "newNamespaceList . add ( xmlEventFactory . createNamespace (  . EMPTY _ PREFIX ,    currentDocumentNamespaceUri )  )  ;", "}", "return   newNamespaceList ;", "}", "METHOD_END"], "methodName": ["updateElementNamespaces"], "fileName": "org.hibernate.jpamodelgen.util.xml.JpaNamespaceTransformingEventReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( event    !  =    null )     &  &     ( event . isStartElement (  )  )  )     {", "return   t ( event . asStartElement (  )  )  ;", "}", "return   event ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "org.hibernate.jpamodelgen.util.xml.JpaNamespaceTransformingEventReader"}, {"methodBody": ["METHOD_START", "{", "return   XmlParserHelper . XML _ INPUT _ FACTORY . createXMLEventReader ( xmlStream )  ;", "}", "METHOD_END"], "methodName": ["createXmlEventReader"], "fileName": "org.hibernate.jpamodelgen.util.xml.XmlParserHelper"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( resource . startsWith ( XmlParserHelper . RESOURCE _ PATH _ SEPARATOR )  )  )     {", "resource    =     ( XmlParserHelper . RESOURCE _ PATH _ SEPARATOR )     +    resource ;", "}", "String   pkg    =    getPackage ( resource )  ;", "String   name    =    getRelativeName ( resource )  ;", "InputStream   ormStream ;", "try    {", "FileObject   fileObject    =    context . getProcessingEnvironment (  )  . getFiler (  )  . getResource ( StandardLocation . CLASS _ OUTPUT ,    pkg ,    name )  ;", "ormStream    =    fileObject . openInputStream (  )  ;", "}    catch    ( IOException   e 1  )     {", "ormStream    =    this . getClass (  )  . getResourceAsStream ( resource )  ;", "}", "return   ormStream ;", "}", "METHOD_END"], "methodName": ["getInputStreamForResource"], "fileName": "org.hibernate.jpamodelgen.util.xml.XmlParserHelper"}, {"methodBody": ["METHOD_START", "{", "XMLEventReader   staxEventReader ;", "try    {", "staxEventReader    =    createXmlEventReader ( stream )  ;", "}    catch    ( XMLStreamException   e )     {", "throw   new   ingException (  \" Unable   to   create   stax   reader \"  ,    e )  ;", "}", "ContextProvidingValidationEventHandler   handler    =    new   ContextProvidingValidationEventHandler (  )  ;", "try    {", "staxEventReader    =    new   JpaNamespaceTransformingEventReader ( staxEventReader )  ;", "JAXBContext   jaxbContext    =    JAXBContext . newInstance ( ObjectFactory . class )  ;", "Unmarshaller   unmarshaller    =    jaxbContext . createUnmarshaller (  )  ;", "unmarshaller . setSchema ( schema )  ;", "unmarshaller . setEventHandler ( handler )  ;", "return   clazz . cast ( unmarshaller . unmarshal ( staxEventReader )  )  ;", "}    catch    ( JAXBException   e )     {", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "builder . append (  \" Unable   to   perform   unmarshalling   at   line   number    \"  )  ;", "builder . append ( handler . getLineNumber (  )  )  ;", "builder . append (  \"    and   column    \"  )  ;", "builder . append ( handler . getColumnNumber (  )  )  ;", "builder . append (  \"  .    Message :     \"  )  ;", "builder . append ( handler . getMessage (  )  )  ;", "throw   new   ingException ( builder . toString (  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getJaxbRoot"], "fileName": "org.hibernate.jpamodelgen.util.xml.XmlParserHelper"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( resourceName . contains ( Constants . PATH _ SEPARATOR )  )  )     {", "return    \"  \"  ;", "} else    {", "return   resourceName . substring (  0  ,    resourceName . lastIndexOf ( Constants . PATH _ SEPARATOR )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getPackage"], "fileName": "org.hibernate.jpamodelgen.util.xml.XmlParserHelper"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( resourceName . contains ( Constants . PATH _ SEPARATOR )  )  )     {", "return   resourceName ;", "} else    {", "return   resourceName . substring (  (  ( resourceName . lastIndexOf ( Constants . PATH _ SEPARATOR )  )     +     1  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getRelativeName"], "fileName": "org.hibernate.jpamodelgen.util.xml.XmlParserHelper"}, {"methodBody": ["METHOD_START", "{", "Schema   schema    =    XmlParserHelper . SCHEMA _ CACHE . get ( schemaResource )  ;", "if    ( schema    !  =    null )     {", "return   schema ;", "}", "schema    =    loadSchema ( schemaResource )  ;", "Schema   previous    =    XmlParserHelper . SCHEMA _ CACHE . putIfAbsent ( schemaResource ,    schema )  ;", "return   previous    !  =    null    ?    previous    :    schema ;", "}", "METHOD_END"], "methodName": ["getSchema"], "fileName": "org.hibernate.jpamodelgen.util.xml.XmlParserHelper"}, {"methodBody": ["METHOD_START", "{", "Schema   schema    =    null ;", "URL   schemaUrl    =    this . getClass (  )  . getClassLoader (  )  . getResource ( schemaName )  ;", "if    ( schemaUrl    =  =    null )     {", "return   schema ;", "}", "SchemaFactory   sf    =    SchemaFactory . newInstance ( XMLConstants . W 3 C _ XML _ SCHEMA _ NS _ URI )  ;", "try    {", "schema    =    sf . newSchema ( schemaUrl )  ;", "}    catch    ( SAXException   e )     {", "throw   new   ingException (  (  (  (  \" Unable   to   create   schema   for    \"     +    schemaName )     +     \"  :     \"  )     +     ( e . getMessage (  )  )  )  ,    e )  ;", "}", "return   schema ;", "}", "METHOD_END"], "methodName": ["loadSchema"], "fileName": "org.hibernate.jpamodelgen.util.xml.XmlParserHelper"}, {"methodBody": ["METHOD_START", "{", "for    ( EntityMappings   mappings    :    entityMappings )     {", "String   fqcn ;", "String   packageName    =    mappings . getPackage (  )  ;", "for    ( Entity   entity    :    mappings . getEntity (  )  )     {", "String   name    =    entity . getClazz (  )  ;", "fqcn    =    StringUtil . determineFullyQualifiedClassName ( packageName ,    name )  ;", "TypeElement   element    =    context . getTypeElementForFullyQualifiedName ( fqcn )  ;", "if    ( element    !  =    null )     {", "TypeUtils . determineAccessTypeForHierarchy ( element ,    context )  ;", "}", "}", "for    ( MappedSuperclass   mappedSuperClass    :    mappings . getMappedSuperclass (  )  )     {", "String   name    =    mappedSuperClass . getClazz (  )  ;", "fqcn    =    StringUtil . determineFullyQualifiedClassName ( packageName ,    name )  ;", "TypeElement   element    =    context . getTypeElementForFullyQualifiedName ( fqcn )  ;", "if    ( element    !  =    null )     {", "TypeUtils . determineAccessTypeForHierarchy ( element ,    context )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["determineAnnotationAccessTypes"], "fileName": "org.hibernate.jpamodelgen.xml.JpaDescriptorParser"}, {"methodBody": ["METHOD_START", "{", "for    ( EntityMappings   mappings    :    entityMappings )     {", "PersistenceUnitMetadata   meta    =    mappings . getPersistenceUnitMetadata (  )  ;", "if    ( meta    !  =    null )     {", "if    (  ( meta . getXmlMappingMetadataComplete (  )  )     !  =    null )     {", "context . mappingDocumentFullyXmlConfigured ( true )  ;", "} else    {", "context . mappingDocumentFullyXmlConfigured ( false )  ;", "}", "PersistenceUnitDefaults   persistenceUnitDefaults    =    meta . getPersistenceUnitDefaults (  )  ;", "if    ( persistenceUnitDefaults    !  =    null )     {", "AccessType   AccessType    =    persistenceUnitDefaults . getAccess (  )  ;", "if    ( AccessType    !  =    null )     {", "context . setPersistenceUnitDefaultAccessType ( mapXmlAccessTypeToJpaAccessType ( AccessType )  )  ;", "}", "}", "} else    {", "context . mappingDocumentFullyXmlConfigured ( false )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["determineDefaultAccessTypeAndMetaCompleteness"], "fileName": "org.hibernate.jpamodelgen.xml.JpaDescriptorParser"}, {"methodBody": ["METHOD_START", "{", "AccessType   accessType    =    context . getPersistenceUnitDefaultAccessType (  )  ;", "if    (  ( mappings . getAccess (  )  )     !  =    null )     {", "accessType    =    mapXmlAccessTypeToAccessType ( mappings . getAccess (  )  )  ;", "}", "return   accessType ;", "}", "METHOD_END"], "methodName": ["determineEntityAccessType"], "fileName": "org.hibernate.jpamodelgen.xml.JpaDescriptorParser"}, {"methodBody": ["METHOD_START", "{", "Collection < String >    mappingFileNames    =    new   ArrayList < String >  (  )  ;", "Persistence   persistence    =    getPersistence (  )  ;", "if    ( persistence    !  =    null )     {", "List < Persistence . PersistenceUnit >    persistenceUnits    =    persistence . getPersistenceUnit (  )  ;", "for    ( Persistence . PersistenceUnit   unit    :    persistenceUnits )     {", "mappingFileNames . addAll ( unit . getMappingFile (  )  )  ;", "}", "}", "mappingFileNames . add (  . DEFAULT _ ORM _ XML _ LOCATION )  ;", "mappingFileNames . addAll ( context . getOrmXmlFiles (  )  )  ;", "return   mappingFileNames ;", "}", "METHOD_END"], "methodName": ["determineMappingFileNames"], "fileName": "org.hibernate.jpamodelgen.xml.JpaDescriptorParser"}, {"methodBody": ["METHOD_START", "{", "for    ( EntityMappings   mappings    :    entityMappings )     {", "String   fqcn ;", "String   packageName    =    mappings . getPackage (  )  ;", "AccessType   defaultAccessType    =    determineEntityAccessType ( mappings )  ;", "for    ( Entity   entity    :    mappings . getEntity (  )  )     {", "String   name    =    entity . getClazz (  )  ;", "fqcn    =    StringUtil . determineFullyQualifiedClassName ( packageName ,    name )  ;", "AccessType   explicitAccessType    =    null ;", "jaxb . AccessType   type    =    entity . getAccess (  )  ;", "if    ( type    !  =    null )     {", "explicitAccessType    =    mapXmlAccessTypeToJpaAccessType ( type )  ;", "}", "AccessTypeInformation   accessInfo    =    new   AccessTypeInformation ( fqcn ,    explicitAccessType ,    defaultAccessType )  ;", "context . addAccessTypeInformation ( fqcn ,    accessInfo )  ;", "}", "for    ( MappedSuperclass   mappedSuperClass    :    mappings . getMappedSuperclass (  )  )     {", "String   name    =    mappedSuperClass . getClazz (  )  ;", "fqcn    =    StringUtil . determineFullyQualifiedClassName ( packageName ,    name )  ;", "AccessType   explicitAccessType    =    null ;", "jaxb . AccessType   type    =    mappedSuperClass . getAccess (  )  ;", "if    ( type    !  =    null )     {", "explicitAccessType    =    mapXmlAccessTypeToJpaAccessType ( type )  ;", "}", "AccessTypeInformation   accessInfo    =    new   AccessTypeInformation ( fqcn ,    explicitAccessType ,    defaultAccessType )  ;", "context . addAccessTypeInformation ( fqcn ,    accessInfo )  ;", "}", "for    ( Embeddable   embeddable    :    mappings . getEmbeddable (  )  )     {", "String   name    =    embeddable . getClazz (  )  ;", "fqcn    =    StringUtil . determineFullyQualifiedClassName ( packageName ,    name )  ;", "AccessType   explicitAccessType    =    null ;", "jaxb . AccessType   type    =    embeddable . getAccess (  )  ;", "if    ( type    !  =    null )     {", "explicitAccessType    =    mapXmlAccessTypeToJpaAccessType ( type )  ;", "}", "AccessTypeInformation   accessInfo    =    new   AccessTypeInformation ( fqcn ,    explicitAccessType ,    defaultAccessType )  ;", "context . addAccessTypeInformation ( fqcn ,    accessInfo )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["determineXmlAccessTypes"], "fileName": "org.hibernate.jpamodelgen.xml.JpaDescriptorParser"}, {"methodBody": ["METHOD_START", "{", "Persistence   persistence    =    null ;", "String   persistenceXmlLocation    =    context . getPersistenceXmlLocation (  )  ;", "InputStream   stream    =    xmlParserHelper . getInputStreamForResource ( persistenceXmlLocation )  ;", "if    ( stream    =  =    null )     {", "return   null ;", "}", "try    {", "Schema   schema    =    xmlParserHelper . getSchema (  . PERSISTENCE _ SCHEMA )  ;", "persistence    =    xmlParserHelper . getJaxbRoot ( stream ,    Persistence . class ,    schema )  ;", "}    catch    ( XmlParsingException   e )     {", "context . logMessage ( Diagnostic . Kind . WARNING ,     (  \" Unable   to   parse   persistence . xml :     \"     +     ( e . getMessage (  )  )  )  )  ;", "}", "try    {", "stream . close (  )  ;", "}    catch    ( IOException   e )     {", "}", "return   persistence ;", "}", "METHOD_END"], "methodName": ["getPersistence"], "fileName": "org.hibernate.jpamodelgen.xml.JpaDescriptorParser"}, {"methodBody": ["METHOD_START", "{", "File   tmpDir    =    new   File ( System . getProperty (  \" tmpdir \"  )  )  ;", "return   new   File ( tmpDir ,     . SERIALIZATION _ FILE _ NAME )  ;", "}", "METHOD_END"], "methodName": ["getSerializationTmpFile"], "fileName": "org.hibernate.jpamodelgen.xml.JpaDescriptorParser"}, {"methodBody": ["METHOD_START", "{", "Elements   utils    =    context . getElementUtils (  )  ;", "return   utils . getTypeElement ( fullyQualifiedClassName )  ;", "}", "METHOD_END"], "methodName": ["getXmlMappedType"], "fileName": "org.hibernate.jpamodelgen.xml.JpaDescriptorParser"}, {"methodBody": ["METHOD_START", "{", "for    ( String   mappingFile    :    mappingFileNames )     {", "InputStream   stream    =    xmlParserHelper . getInputStreamForResource ( mappingFile )  ;", "if    ( stream    =  =    null )     {", "continue ;", "}", "EntityMappings   mapping    =    null ;", "try    {", "Schema   schema    =    xmlParserHelper . getSchema (  . ORM _ SCHEMA )  ;", "mapping    =    xmlParserHelper . getJaxbRoot ( stream ,    EntityMappings . class ,    schema )  ;", "}    catch    ( XmlParsingException   e )     {", "context . logMessage ( Diagnostic . Kind . WARNING ,     (  (  (  \" Unable   to   parse    \"     +    mappingFile )     +     \"  :     \"  )     +     ( e . getMessage (  )  )  )  )  ;", "}", "if    ( mapping    !  =    null )     {", "entityMappings . add ( mapping )  ;", "}", "try    {", "stream . close (  )  ;", "}    catch    ( IOException   e )     {", "}", "}", "}", "METHOD_END"], "methodName": ["loadEntityMappings"], "fileName": "org.hibernate.jpamodelgen.xml.JpaDescriptorParser"}, {"methodBody": ["METHOD_START", "{", "FileTimeStampChecker   serializedTimeStampCheck    =    new   FileTimeStampChecker (  )  ;", "File   file    =    null ;", "try    {", "file    =    getSerializationTmpFile (  )  ;", "if    ( file . exists (  )  )     {", "ObjectInputStream   in    =    new   ObjectInputStream ( new   FileInputStream ( file )  )  ;", "serializedTimeStampCheck    =     (  ( FileTimeStampChecker )     ( in . readObject (  )  )  )  ;", "in . close (  )  ;", "}", "}    catch    ( Exception   e )     {", "context . logMessage ( Diagnostic . Kind . OTHER ,     (  \" Error   de - serializing       \"     +    file )  )  ;", "}", "return   serializedTimeStampCheck ;", "}", "METHOD_END"], "methodName": ["loadTimeStampCache"], "fileName": "org.hibernate.jpamodelgen.xml.JpaDescriptorParser"}, {"methodBody": ["METHOD_START", "{", "switch    ( xmlAccessType )     {", "case   FIELD    :", "{", "return   AccessType . FIELD ;", "}", "case   PROPERTY    :", "{", "return   AccessType . PROPERTY ;", "}", "default    :", "{", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["mapXmlAccessTypeToJpaAccessType"], "fileName": "org.hibernate.jpamodelgen.xml.JpaDescriptorParser"}, {"methodBody": ["METHOD_START", "{", "boolean   mappingFilesUnchanged    =    false ;", "FileTimeStampChecker   fileStampCheck    =    new   FileTimeStampChecker (  )  ;", "for    ( String   mappingFile    :    mappingFileNames )     {", "try    {", "URL   url    =    this . getClass (  )  . getResource ( mappingFile )  ;", "if    ( url    =  =    null )     {", "continue ;", "}", "File   file    =    new   File ( url . toURI (  )  )  ;", "context . logMessage ( Diagnostic . Kind . OTHER ,     (  \" Check   file       \"     +    mappingFile )  )  ;", "if    ( file . exists (  )  )     {", "fileStampCheck . add ( mappingFile ,    file . lastModified (  )  )  ;", "}", "}    catch    ( URISyntaxException   e )     {", "return   false ;", "}", "}", "FileTimeStampChecker   ializedTimeStampCheck    =    loadTimeStampCache (  )  ;", "if    ( ializedTimeStampCheck . equals ( fileStampCheck )  )     {", "context . logMessage ( Diagnostic . Kind . OTHER ,     \" XML   parsing   will   be   skipped   due   to   unchanged   xml   files \"  )  ;", "mappingFilesUnchanged    =    true ;", "} else    {", "saveTimeStampCache ( fileStampCheck )  ;", "}", "return   mappingFilesUnchanged ;", "}", "METHOD_END"], "methodName": ["mappingFilesUnchanged"], "fileName": "org.hibernate.jpamodelgen.xml.JpaDescriptorParser"}, {"methodBody": ["METHOD_START", "{", "for    ( Embeddable   embeddable    :    embeddables )     {", "String   fqcn    =    StringUtil . determineFullyQualifiedClassName ( defaultPackageName ,    embeddable . getClazz (  )  )  ;", "String   pkg    =    StringUtil . packageNameFromFqcn ( fqcn )  ;", "if    (  !  ( xmlMappedTypeExists ( fqcn )  )  )     {", "context . logMessage ( Diagnostic . Kind . WARNING ,     ( fqcn    +     \"    is   mapped   in   xml ,    but   class   does   not   exist .    Skipping   meta      generation .  \"  )  )  ;", "continue ;", "}", "XmlMetaEntity   metaEntity    =    new   XmlMetaEntity ( embeddable ,    pkg ,    getXmlMappedType ( fqcn )  ,    context )  ;", "if    ( context . containsMetaEmbeddable ( fqcn )  )     {", "context . logMessage ( Diagnostic . Kind . WARNING ,     ( fqcn    +     \"    was   already   processed   once .    Skipping   second   occurrence .  \"  )  )  ;", "}", "context . addMetaEmbeddable ( fqcn ,    metaEntity )  ;", "}", "}", "METHOD_END"], "methodName": ["parseEmbeddable"], "fileName": "org.hibernate.jpamodelgen.xml.JpaDescriptorParser"}, {"methodBody": ["METHOD_START", "{", "for    ( Entity   entity    :    entities )     {", "String   fqcn    =    StringUtil . determineFullyQualifiedClassName ( defaultPackageName ,    entity . getClazz (  )  )  ;", "if    (  !  ( xmlMappedTypeExists ( fqcn )  )  )     {", "context . logMessage ( Diagnostic . Kind . WARNING ,     ( fqcn    +     \"    is   mapped   in   xml ,    but   class   does   not   exist .    Skipping   meta      generation .  \"  )  )  ;", "continue ;", "}", "XmlMetaEntity   metaEntity    =    new   XmlMetaEntity ( entity ,    defaultPackageName ,    getXmlMappedType ( fqcn )  ,    context )  ;", "if    ( context . containsMetaEntity ( fqcn )  )     {", "context . logMessage ( Diagnostic . Kind . WARNING ,     ( fqcn    +     \"    was   already   processed   once .    Skipping   second   occurrence .  \"  )  )  ;", "}", "context . addMetaEntity ( fqcn ,    metaEntity )  ;", "}", "}", "METHOD_END"], "methodName": ["parseEntities"], "fileName": "org.hibernate.jpamodelgen.xml.JpaDescriptorParser"}, {"methodBody": ["METHOD_START", "{", "for    ( MappedSuperclass   mappedSuperClass    :    mappedSuperClasses )     {", "String   fqcn    =    StringUtil . determineFullyQualifiedClassName ( defaultPackageName ,    mappedSuperClass . getClazz (  )  )  ;", "String   pkg    =    StringUtil . packageNameFromFqcn ( fqcn )  ;", "if    (  !  ( xmlMappedTypeExists ( fqcn )  )  )     {", "context . logMessage ( Diagnostic . Kind . WARNING ,     ( fqcn    +     \"    is   mapped   in   xml ,    but   class   does   not   exist .    Skipping   meta      generation .  \"  )  )  ;", "continue ;", "}", "XmlMetaEntity   metaEntity    =    new   XmlMetaEntity ( mappedSuperClass ,    pkg ,    getXmlMappedType ( fqcn )  ,    context )  ;", "if    ( context . containsMetaEntity ( fqcn )  )     {", "context . logMessage ( Diagnostic . Kind . WARNING ,     ( fqcn    +     \"    was   already   processed   once .    Skipping   second   occurrence .  \"  )  )  ;", "}", "context . addMetaEntity ( fqcn ,    metaEntity )  ;", "}", "}", "METHOD_END"], "methodName": ["parseMappedSuperClass"], "fileName": "org.hibernate.jpamodelgen.xml.JpaDescriptorParser"}, {"methodBody": ["METHOD_START", "{", "Collection < String >    mappingFileNames    =    determineMappingFileNames (  )  ;", "if    (  ( context . doLazyXmling (  )  )     &  &     ( mappingFilesUnchanged ( mappingFileNames )  )  )     {", "return ;", "}", "loadEntityMappings ( mappingFileNames )  ;", "determineDefaultAccessTypeAndMetaCompleteness (  )  ;", "determineXmlAccessTypes (  )  ;", "if    (  !  ( context . isFullyXmlConfigured (  )  )  )     {", "determineAnnotationAccessTypes (  )  ;", "}", "for    ( EntityMappings   mappings    :    entityMappings )     {", "String   defaultPackageName    =    mappings . getPackage (  )  ;", "parseEntities ( mappings . getEntity (  )  ,    defaultPackageName )  ;", "parseEmbeddable ( mappings . getEmbeddable (  )  ,    defaultPackageName )  ;", "parseMappedSuperClass ( mappings . getMappedSuperclass (  )  ,    defaultPackageName )  ;", "}", "}", "METHOD_END"], "methodName": ["parseXml"], "fileName": "org.hibernate.jpamodelgen.xml.JpaDescriptorParser"}, {"methodBody": ["METHOD_START", "{", "try    {", "File   file    =    getSerializationTmpFile (  )  ;", "ObjectOutput   out    =    new   ObjectOutputStream ( new   FileOutputStream ( file )  )  ;", "out . writeObject ( fileStampCheck )  ;", "out . close (  )  ;", "context . logMessage ( Diagnostic . Kind . OTHER ,     (  (  (  \" Serialized    \"     +    fileStampCheck )     +     \"    into    \"  )     +     ( file . getAbsolutePath (  )  )  )  )  ;", "}    catch    ( IOException   e )     {", "context . logMessage ( Diagnostic . Kind . OTHER ,     (  \" Error   ializing       \"     +    fileStampCheck )  )  ;", "}", "}", "METHOD_END"], "methodName": ["saveTimeStampCache"], "fileName": "org.hibernate.jpamodelgen.xml.JpaDescriptorParser"}, {"methodBody": ["METHOD_START", "{", "Elements   utils    =    context . getElementUtils (  )  ;", "return    ( utils . getTypeElement ( fullyQualifiedClassName )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["xmlMappedTypeExists"], "fileName": "org.hibernate.jpamodelgen.xml.JpaDescriptorParser"}, {"methodBody": ["METHOD_START", "{", "return   hostingEntity ;", "}", "METHOD_END"], "methodName": ["getHostingEntity"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaAttribute"}, {"methodBody": ["METHOD_START", "{", "return   propertyName ;", "}", "METHOD_END"], "methodName": ["getPropertyName"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaAttribute"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getTypeDeclaration"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaAttribute"}, {"methodBody": ["METHOD_START", "{", "types [  1  ]     =    XmlMetaEntity . COLLECTIONS . get ( type . asElement (  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["determineCollectionType"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "DeclaredType   type    =    null ;", "if    (  ( elem . asType (  )  )    instanceof   DeclaredType )     {", "type    =     (  ( DeclaredType )     ( elem . asType (  )  )  )  ;", "} else", "if    (  ( elem . asType (  )  )    instanceof   ExecutableType )     {", "ExecutableType   executableType    =     (  ( ExecutableType )     ( elem . asType (  )  )  )  ;", "if    (  ( executableType . getReturnType (  )  )    instanceof   DeclaredType )     {", "type    =     (  ( DeclaredType )     ( executableType . getReturnType (  )  )  )  ;", "}", "}", "return   type ;", "}", "METHOD_END"], "methodName": ["determineDeclaredType"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "String   explicitMapKey    =    null ;", "if    ( mapKeyClass    !  =    null )     {", "explicitMapKey    =    StringUtil . determineFullyQualifiedClassName ( defaultPackageName ,    mapKeyClass . getClazz (  )  )  ;", "}", "return   explicitMapKey ;", "}", "METHOD_END"], "methodName": ["determineExplicitMapKeyClass"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "String   explicitTargetClass    =    targetClass ;", "if    ( explicitTargetClass    !  =    null )     {", "explicitTargetClass    =    StringUtil . determineFullyQualifiedClassName ( defaultPackageName ,    targetClass )  ;", "}", "return   explicitTargetClass ;", "}", "METHOD_END"], "methodName": ["determineExplicitTargetEntity"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "if    ( explicitMapKeyClass    !  =    null )     {", "types [  2  ]     =    explicitMapKeyClass ;", "} else    {", "types [  2  ]     =    TypeUtils . getKeyType ( type ,    context )  ;", "}", "}", "METHOD_END"], "methodName": ["determineMapType"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "List <  ?    extends   TypeMirror >    typeArguments    =    type . getTypeArguments (  )  ;", "if    (  (  ( typeArguments . size (  )  )     =  =     0  )     &  &     ( explicitTarget    =  =    null )  )     {", "throw   new   MetaModelGenerationException (  (  (  (  (  \" Unable   to   determine   target   entity   type   for    \"     +     ( clazzName )  )     +     \"  .  \"  )     +    propertyName )     +     \"  .  \"  )  )  ;", "}", "if    ( explicitTarget    =  =    null )     {", "types [  0  ]     =    TypeUtils . extractClosestRealTypeAsString ( typeArguments . get (  0  )  ,    context )  ;", "} else    {", "types [  0  ]     =    explicitTarget ;", "}", "}", "METHOD_END"], "methodName": ["determineTargetType"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "String [  ]    types    =    new   String [  3  ]  ;", "determineTargetType ( type ,    propertyName ,    explicitTarget ,    types )  ;", "determineCollectionType ( type ,    types )  ;", "if    ( types [  1  ]  . equals (  \" MapAttribute \"  )  )     {", "determineMapType ( type ,    explicitMapKeyClass ,    types )  ;", "}", "return   types ;", "}", "METHOD_END"], "methodName": ["determineTypes"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "return   importContext . generateImports (  )  ;", "}", "METHOD_END"], "methodName": ["generateImports"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "for    ( Element   elem    :    element . getEnclosedElements (  )  )     {", "if    (  !  ( expectedElementKind . equals ( elem . getKind (  )  )  )  )     {", "continue ;", "}", "String   elementPropertyName    =    elem . getSimpleName (  )  . toString (  )  ;", "if    ( elem . getKind (  )  . equals ( ElementKind . METHOD )  )     {", "elementPropertyName    =    StringUtil . getPropertyName ( elementPropertyName )  ;", "}", "if    (  !  ( propertyName . equals ( elementPropertyName )  )  )     {", "continue ;", "}", "DeclaredType   type    =    determineDeclaredType ( elem )  ;", "if    ( type    =  =    null )     {", "continue ;", "}", "return   determineTypes ( propertyName ,    explicitTarget ,    explicitMapKeyClass ,    type )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getCollectionTypes"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "if    ( accessType    =  =    null )     {", "return   TypeUtils . getElementKindForAccessType ( accessTypeInfo . getAccessType (  )  )  ;", "}", "if    ( jaxb . AccessType . equals ( accessType )  )     {", "return   ElementKind . FIELD ;", "} else    {", "return   ElementKind . METHOD ;", "}", "}", "METHOD_END"], "methodName": ["getElementKind"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( initialized )  )     {", "init (  )  ;", "}", "return   mems ;", "}", "METHOD_END"], "methodName": ["getMembers"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "return   packageName ;", "}", "METHOD_END"], "methodName": ["getPackageName"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "return    (  ( packageName )     +     \"  .  \"  )     +     ( getSimpleName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getQualifiedName"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "return   clazzName ;", "}", "METHOD_END"], "methodName": ["getSimpleName"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "for    ( Element   elem    :    element . getEnclosedElements (  )  )     {", "if    (  !  ( expectedElementKind . equals ( elem . getKind (  )  )  )  )     {", "continue ;", "}", "TypeMirror   mirror ;", "String   name    =    elem . getSimpleName (  )  . toString (  )  ;", "if    ( ElementKind . METHOD . equals ( elem . getKind (  )  )  )     {", "name    =    StringUtil . getPropertyName ( name )  ;", "mirror    =     (  ( ExecutableElement )     ( elem )  )  . getReturnType (  )  ;", "} else    {", "mirror    =    elem . asType (  )  ;", "}", "if    (  ( name    =  =    null )     |  |     (  !  ( name . equals ( propertyName )  )  )  )     {", "continue ;", "}", "if    ( explicitTarget    !  =    null )     {", "return   explicitTarget ;", "}", "switch    ( mirror . getKind (  )  )     {", "case   INT    :", "{", "return    \" Integer \"  ;", "}", "case   LONG    :", "{", "return    \" Long \"  ;", "}", "case   BOOLEAN    :", "{", "return    \" Boolean \"  ;", "}", "case   BYTE    :", "{", "return    \" Byte \"  ;", "}", "case   SHORT    :", "{", "return    \" Short \"  ;", "}", "case   CHAR    :", "{", "return    \" Char \"  ;", "}", "case   FLOAT    :", "{", "return    \" Float \"  ;", "}", "case   DOUBLE    :", "{", "return    \" Double \"  ;", "}", "case   DECLARED    :", "{", "return   mirror . toString (  )  ;", "}", "case   TYPEVAR    :", "{", "return   mirror . toString (  )  ;", "}", "default    :", "{", "}", "}", "}", "context . logMessage ( Diagnostic . Kind . WARNING ,     (  (  (  (  (  \" Unable   to   determine   type   for   property    \"     +    propertyName )     +     \"    of   class    \"  )     +     ( getQualifiedName (  )  )  )     +     \"    using   access   type    \"  )     +     ( accessTypeInfo . getDefaultAccessType (  )  )  )  )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "return   element ;", "}", "METHOD_END"], "methodName": ["getTypeElement"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "return   importContext . importType ( fqcn )  ;", "}", "METHOD_END"], "methodName": ["importType"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "context . logMessage ( Diagnostic . Kind . OTHER ,     (  (  \" Initializing   type    \"     +     ( getQualifiedName (  )  )  )     +     \"  .  \"  )  )  ;", "this . accessTypeInfo    =    context . getAccessTypeInfo ( getQualifiedName (  )  )  ;", "if    (  ( attributes )     !  =    null )     {", "parseAttributes ( attributes )  ;", "} else    {", "parseEmbeddableAttributes ( embeddableAttributes )  ;", "}", "initialized    =    true ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "return    ( context . isFullyXmlConfigured (  )  )     |  |     ( Boolean . TRUE . equals ( metadataComplete )  )  ;", "}", "METHOD_END"], "methodName": ["initIsMetaComplete"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "builder . append (  \" Error   processing      for    \"  )  ;", "builder . append ( clazzName )  ;", "builder . append (  \"  .  \"  )  ;", "builder . append ( name )  ;", "builder . append (  \"  .    Error   message :     \"  )  ;", "builder . append ( e . getMessage (  )  )  ;", "context . logMessage ( Diagnostic . Kind . WARNING ,    builder . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["logMetaModelException"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "XmlMetaSingleAttribute   attribute ;", "for    ( Id   id    :    attributes . getId (  )  )     {", "ElementKind   elementKind    =    getElementKind ( id . getAccess (  )  )  ;", "String   type    =    getType ( id . getName (  )  ,    null ,    elementKind )  ;", "if    ( type    !  =    null )     {", "attribute    =    new   XmlMetaSingleAttribute ( this ,    id . getName (  )  ,    type )  ;", "members . add ( attribute )  ;", "}", "}", "if    (  ( attributes . getEmbeddedId (  )  )     !  =    null )     {", "EmbeddedId   embeddedId    =    attributes . getEmbeddedId (  )  ;", "ElementKind   elementKind    =    getElementKind ( embeddedId . getAccess (  )  )  ;", "String   type    =    getType ( embeddedId . getName (  )  ,    null ,    elementKind )  ;", "if    ( type    !  =    null )     {", "attribute    =    new   XmlMetaSingleAttribute ( this ,    embeddedId . getName (  )  ,    type )  ;", "members . add ( attribute )  ;", "}", "}", "for    ( Basic   basic    :    attributes . getBasic (  )  )     {", "parseBasic ( basic )  ;", "}", "for    ( ManyToOne   manyToOne    :    attributes . getManyToOne (  )  )     {", "parseManyToOne ( manyToOne )  ;", "}", "for    ( OneToOne   oneToOne    :    attributes . getOneToOne (  )  )     {", "parseOneToOne ( oneToOne )  ;", "}", "for    ( ManyToMany   manyToMany    :    attributes . getManyToMany (  )  )     {", "if    ( parseManyToMany ( manyToMany )  )     {", "break ;", "}", "}", "for    ( OneToMany   oneToMany    :    attributes . getOneToMany (  )  )     {", "if    ( parseOneToMany ( oneToMany )  )     {", "break ;", "}", "}", "for    ( ElementCollection   collection    :    attributes . getElementCollection (  )  )     {", "if    ( parseElementCollection ( collection )  )     {", "break ;", "}", "}", "for    ( Embedded   embedded    :    attributes . getEmbedded (  )  )     {", "parseEmbedded ( embedded )  ;", "}", "}", "METHOD_END"], "methodName": ["parseAttributes"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "XmlMetaSingleAttribute   attribute ;", "ElementKind   elementKind    =    getElementKind ( basic . getAccess (  )  )  ;", "String   type    =    getType ( basic . getName (  )  ,    null ,    elementKind )  ;", "if    ( type    !  =    null )     {", "attribute    =    new   XmlMetaSingleAttribute ( this ,    basic . getName (  )  ,    type )  ;", "members . add ( attribute )  ;", "}", "}", "METHOD_END"], "methodName": ["parseBasic"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "String [  ]    types ;", "Collection   metaCollection ;", "ElementKind   elementKind    =    getElementKind ( collection . getAccess (  )  )  ;", "String   explicitTargetClass    =    determineExplicitTargetEntity ( collection . getTargetClass (  )  )  ;", "String   explicitMapKey    =    determineExplicitMapKeyClass ( collection . getMapKeyClass (  )  )  ;", "try    {", "types    =    getCollectionTypes ( collection . getName (  )  ,    explicitTargetClass ,    explicitMapKey ,    elementKind )  ;", "}    catch    ( MetaModelGenerationException   e )     {", "logMetaModelException ( collection . getName (  )  ,    e )  ;", "return   true ;", "}", "if    ( types    !  =    null )     {", "if    (  ( types [  2  ]  )     =  =    null )     {", "metaCollection    =    new   Collection ( this ,    collection . getName (  )  ,    types [  0  ]  ,    types [  1  ]  )  ;", "} else    {", "metaCollection    =    new   Map ( this ,    collection . getName (  )  ,    types [  0  ]  ,    types [  1  ]  ,    types [  2  ]  )  ;", "}", "members . add ( metaCollection )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["parseElementCollection"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "if    ( attributes    =  =    null )     {", "return ;", "}", "for    ( Basic   basic    :    attributes . getBasic (  )  )     {", "parseBasic ( basic )  ;", "}", "for    ( ManyToOne   manyToOne    :    attributes . getManyToOne (  )  )     {", "parseManyToOne ( manyToOne )  ;", "}", "for    ( OneToOne   oneToOne    :    attributes . getOneToOne (  )  )     {", "parseOneToOne ( oneToOne )  ;", "}", "for    ( ManyToMany   manyToMany    :    attributes . getManyToMany (  )  )     {", "if    ( parseManyToMany ( manyToMany )  )     {", "break ;", "}", "}", "for    ( OneToMany   oneToMany    :    attributes . getOneToMany (  )  )     {", "if    ( parseOneToMany ( oneToMany )  )     {", "break ;", "}", "}", "for    ( ElementCollection   collection    :    attributes . getElementCollection (  )  )     {", "if    ( parseElementCollection ( collection )  )     {", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseEmbeddableAttributes"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "XmlMetaSingleAttribute   attribute ;", "ElementKind   elementKind    =    getElementKind ( embedded . getAccess (  )  )  ;", "String   type    =    getType ( embedded . getName (  )  ,    null ,    elementKind )  ;", "if    ( type    !  =    null )     {", "attribute    =    new   XmlMetaSingleAttribute ( this ,    embedded . getName (  )  ,    type )  ;", "members . add ( attribute )  ;", "}", "}", "METHOD_END"], "methodName": ["parseEmbedded"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "String [  ]    types ;", "Collection   metaCollection ;", "ElementKind   elementKind    =    getElementKind ( manyToMany . getAccess (  )  )  ;", "String   explicitTargetClass    =    determineExplicitTargetEntity ( manyToMany . getTargetEntity (  )  )  ;", "String   explicitMapKey    =    determineExplicitMapKeyClass ( manyToMany . getMapKeyClass (  )  )  ;", "try    {", "types    =    getCollectionTypes ( manyToMany . getName (  )  ,    explicitTargetClass ,    explicitMapKey ,    elementKind )  ;", "}    catch    ( MetaModelGenerationException   e )     {", "logMetaModelException ( manyToMany . getName (  )  ,    e )  ;", "return   true ;", "}", "if    ( types    !  =    null )     {", "if    (  ( types [  2  ]  )     =  =    null )     {", "metaCollection    =    new   Collection ( this ,    manyToMany . getName (  )  ,    types [  0  ]  ,    types [  1  ]  )  ;", "} else    {", "metaCollection    =    new   Map ( this ,    manyToMany . getName (  )  ,    types [  0  ]  ,    types [  1  ]  ,    types [  2  ]  )  ;", "}", "members . add ( metaCollection )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["parseManyToMany"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "XmlMetaSingleAttribute   attribute ;", "ElementKind   elementKind    =    getElementKind ( manyToOne . getAccess (  )  )  ;", "String   type    =    getType ( manyToOne . getName (  )  ,    manyToOne . getTargetEntity (  )  ,    elementKind )  ;", "if    ( type    !  =    null )     {", "attribute    =    new   XmlMetaSingleAttribute ( this ,    manyToOne . getName (  )  ,    type )  ;", "members . add ( attribute )  ;", "}", "}", "METHOD_END"], "methodName": ["parseManyToOne"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "String [  ]    types ;", "Collection   metaCollection ;", "ElementKind   elementKind    =    getElementKind ( oneToMany . getAccess (  )  )  ;", "String   explicitTargetClass    =    determineExplicitTargetEntity ( oneToMany . getTargetEntity (  )  )  ;", "String   explicitMapKey    =    determineExplicitMapKeyClass ( oneToMany . getMapKeyClass (  )  )  ;", "try    {", "types    =    getCollectionTypes ( oneToMany . getName (  )  ,    explicitTargetClass ,    explicitMapKey ,    elementKind )  ;", "}    catch    ( MetaModelGenerationException   e )     {", "logMetaModelException ( oneToMany . getName (  )  ,    e )  ;", "return   true ;", "}", "if    ( types    !  =    null )     {", "if    (  ( types [  2  ]  )     =  =    null )     {", "metaCollection    =    new   Collection ( this ,    oneToMany . getName (  )  ,    types [  0  ]  ,    types [  1  ]  )  ;", "} else    {", "metaCollection    =    new   Map ( this ,    oneToMany . getName (  )  ,    types [  0  ]  ,    types [  1  ]  ,    types [  2  ]  )  ;", "}", "members . add ( metaCollection )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["parseOneToMany"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "XmlMetaSingleAttribute   attribute ;", "ElementKind   elementKind    =    getElementKind ( oneToOne . getAccess (  )  )  ;", "String   type    =    getType ( oneToOne . getName (  )  ,    oneToOne . getTargetEntity (  )  ,    elementKind )  ;", "if    ( type    !  =    null )     {", "attribute    =    new   XmlMetaSingleAttribute ( this ,    oneToOne . getName (  )  ,    type )  ;", "members . add ( attribute )  ;", "}", "}", "METHOD_END"], "methodName": ["parseOneToOne"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "return   importContext . staticImport ( fqcn ,    member )  ;", "}", "METHOD_END"], "methodName": ["staticImport"], "fileName": "org.hibernate.jpamodelgen.xml.XmlMetaEntity"}, {"methodBody": ["METHOD_START", "{", "project . getPlugins (  )  . apply (  \" java \"  )  ;", "final   HibernateExtension   Extension    =    new   HibernateExtension ( project )  ;", "project . getLogger (  )  . debug (  \" Adding   Hibernate   extensions   to   the   build    [  {  }  ]  \"  ,    project . getName (  )  )  ;", "project . getExtensions (  )  . add (  \"  \"  ,    Extension )  ;", "project . afterEvaluate ( new   Action < Project >  (  )     {", "@ Override", "public   void   execute ( Project   project )     {", "if    (  ( Extension . enhance )     !  =    null )     {", "applyEnhancement ( project ,    Extension )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.hibernate.orm.tooling.gradle.HibernatePlugin"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( hibernateExtension . enhance . shouldApply (  )  )  )     {", "project . getLogger (  )  . warn (  \" Skipping   Hibernate   bytecode   enhancement   since   no   feature   is   enabled \"  )  ;", "return ;", "}", "for    ( final   SourceSet   sourceSet    :    hibernateExtension . getSourceSets (  )  )     {", "project . getLogger (  )  . debug (  \" Applying   Hibernate   enhancement   action   to   SourceSet .  {  }  \"  ,    sourceSet . getName (  )  )  ;", "final   Task   compileTask    =    project . getTasks (  )  . findByName ( sourceSet . getCompileJavaTaskName (  )  )  ;", "compileTask . doLast ( new   Action < Task >  (  )     {", "@ Override", "public   void   execute ( Task   task )     {", "project . getLogger (  )  . debug (  \" Starting   Hibernate   enhancement   on   SourceSet .  {  }  \"  ,    sourceSet . getName (  )  )  ;", "final   ClassLoader   classLoader    =    toClassLoader ( sourceSet . getRuntimeClasspath (  )  )  ;", "EnhancementContext   enhancementContext    =    new   DefaultEnhancementContext (  )     {", "@ Override", "public   ClassLoader   getLoadingClassLoader (  )     {", "return   classLoader ;", "}", "@ Override", "public   boolean   doBiDirectionalAssociationManagement ( UnloadedField   field )     {", "return   hibernateExtension . enhance . getEnableAssociationManagement (  )  ;", "}", "@ Override", "public   boolean   doDirtyCheckingInline ( UnloadedClass   classDescriptor )     {", "return   hibernateExtension . enhance . getEnableDirtyTracking (  )  ;", "}", "@ Override", "public   boolean   hasLazyLoadableAttributes ( UnloadedClass   classDescriptor )     {", "return   hibernateExtension . enhance . getEnableLazyInitialization (  )  ;", "}", "@ Override", "public   boolean   isLazyLoadable ( UnloadedField   field )     {", "return   hibernateExtension . enhance . getEnableLazyInitialization (  )  ;", "}", "@ Override", "public   boolean   doExtendedEnhancement ( UnloadedClass   classDescriptor )     {", "return   hibernateExtension . enhance . getEnableExtendedEnhancement (  )  ;", "}", "}  ;", "if    ( hibernateExtension . enhance . getEnableExtendedEnhancement (  )  )     {", "logger . warn (  \" Extended   enhancement   is   enabled .    Classes   other   than   entities   may   be   modified .    You   should   consider   access   the   entities   using   getter / setter   methods   and   disable   this   property .    Use   at   your   own   risk .  \"  )  ;", "}", "final   Enhancer   enhancer    =    Environment . getBytecodeProvider (  )  . getEnhancer ( enhancementContext )  ;", "final   FileTree   fileTree    =    project . fileTree ( sourceSet . getOutput (  )  . getClassesDir (  )  )  ;", "for    ( File   file    :    fileTree )     {", "if    (  !  ( file . getName (  )  . endsWith (  \"  . class \"  )  )  )     {", "continue ;", "}", "final   byte [  ]    enhancedBytecode    =    doEnhancement ( sourceSet . getOutput (  )  . getClassesDir (  )  ,    file ,    enhancer )  ;", "if    ( enhancedBytecode    !  =    null )     {", "writeOutEnhancedClass ( enhancedBytecode ,    file )  ;", "logger . info (  (  (  \" Successfully   enhanced   class    [  \"     +    file )     +     \"  ]  \"  )  )  ;", "} else    {", "logger . info (  (  (  \" Skipping   class    [  \"     +     ( file . getAbsolutePath (  )  )  )     +     \"  ]  ,    not   an   entity   nor   embeddable \"  )  )  ;", "}", "}", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["applyEnhancement"], "fileName": "org.hibernate.orm.tooling.gradle.HibernatePlugin"}, {"methodBody": ["METHOD_START", "{", "try    {", "String   className    =    getAbsolutePath (  )  . substring (  (  ( root . getAbsolutePath (  )  . length (  )  )     +     1  )  ,     (  ( getAbsolutePath (  )  . length (  )  )     -     (  \"  . class \"  . length (  )  )  )  )  . replace ( File . separatorChar ,     '  .  '  )  ;", "ByteArrayOutputStream   originalBytes    =    new   ByteArrayOutputStream (  )  ;", "FileInputStream   fileInputStream    =    new   FileInputStream ( javaClassFile )  ;", "try    {", "byte [  ]    buffer    =    new   byte [  1  0  2  4  ]  ;", "int   length ;", "while    (  ( length    =    fileInputStream . read ( buffer )  )     !  =     (  -  1  )  )     {", "originalBytes . write ( buffer ,     0  ,    length )  ;", "}", "}    finally    {", "fileInputStream . close (  )  ;", "}", "return   enhancer . enhance ( className ,    originalBytes . toByteArray (  )  )  ;", "}    catch    ( Exception   e )     {", "throw   new   GException (  (  \" Unable   to   enhance   class    :     \"     +    javaClassFile )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["doEnhancement"], "fileName": "org.hibernate.orm.tooling.gradle.HibernatePlugin"}, {"methodBody": ["METHOD_START", "{", "List < URL >    urls    =    new   ArrayList < URL >  (  )  ;", "for    ( File   file    :    runtimeClasspath )     {", "try    {", "urls . add ( file . toURI (  )  . toURL (  )  )  ;", "logger . debug (  (  \" Adding   classpath   entry   for    \"     +     ( file . getAbsolutePath (  )  )  )  )  ;", "}    catch    ( MalformedURLException   e )     {", "throw   new   GException (  (  \" Unable   to   resolve   classpath   entry   to   URL    :     \"     +     ( file . getAbsolutePath (  )  )  )  ,    e )  ;", "}", "}", "return   new   URLClassLoader ( urls . toArray ( new   URL [ urls . size (  )  ]  )  ,    Enhancer . class . getClassLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["toClassLoader"], "fileName": "org.hibernate.orm.tooling.gradle.HibernatePlugin"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( file . delete (  )  )     {", "if    (  !  ( file . createNewFile (  )  )  )     {", "logger . error (  (  (  \" Unable   to   recreate   class   file    [  \"     +     ( file . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "} else    {", "logger . error (  (  (  \" Unable   to   delete   class   file    [  \"     +     ( file . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "}    catch    ( IOException   e )     {", "logger . warn (  (  (  \" Problem   preparing   class   file   for   writing   out   enhancements    [  \"     +     ( file . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "try    {", "FileOutputStream   outputStream    =    new   FileOutputStream ( file ,    false )  ;", "try    {", "outputStream . write ( enhancedBytecode )  ;", "outputStream . flush (  )  ;", "}    catch    ( IOException   e )     {", "throw   new   GException (  (  (  (  (  \" Error   writing   to   enhanced   class    [  \"     +     ( file . getName (  )  )  )     +     \"  ]    to   file    [  \"  )     +     ( file . getAbsolutePath (  )  )  )     +     \"  ]  \"  )  ,    e )  ;", "}    finally    {", "try    {", "outputStream . close (  )  ;", "}    catch    ( IOException   ignore )     {", "}", "}", "}    catch    ( FileNotFoundException   e )     {", "throw   new   GException (  (  \" Error   opening   class   file   for   writing    :     \"     +     ( file . getAbsolutePath (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["writeOutEnhancedClass"], "fileName": "org.hibernate.orm.tooling.gradle.HibernatePlugin"}, {"methodBody": ["METHOD_START", "{", "try    {", "String   className    =    getAbsolutePath (  )  . substring (  (  ( base . length (  )  )     +     1  )  ,     (  ( getAbsolutePath (  )  . length (  )  )     -     (  \"  . class \"  . length (  )  )  )  )  . replace ( File . separatorChar ,     '  .  '  )  ;", "ByteArrayOutputStream   originalBytes    =    new   ByteArrayOutputStream (  )  ;", "FileInputStream   fileInputStream    =    new   FileInputStream ( javaClassFile )  ;", "try    {", "byte [  ]    buffer    =    new   byte [  1  0  2  4  ]  ;", "int   length ;", "while    (  ( length    =    fileInputStream . read ( buffer )  )     !  =     (  -  1  )  )     {", "originalBytes . write ( buffer ,     0  ,    length )  ;", "}", "}    finally    {", "fileInputStream . close (  )  ;", "}", "return   er . e ( className ,    originalBytes . toByteArray (  )  )  ;", "}    catch    ( Exception   e )     {", "String   msg    =     \" Unable   to   e   class :     \"     +     ( getName (  )  )  ;", "if    ( failOnError )     {", "throw   new   MojoExecutionException ( msg ,    e )  ;", "}", "buildContext . addMessage ( javaClassFile ,     0  ,     0  ,    msg ,    SEVERITY _ WARNING ,    e )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["doEnhancement"], "fileName": "org.hibernate.orm.tooling.maven.MavenEnhancePlugin"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( shouldApply (  )  )  )     {", "getLog (  )  . warn (  \" Skipping   H   bytecode   enhancement   plugin   execution   since   no   feature   is   enabled \"  )  ;", "return ;", "}", "if    (  !  ( dir . startsWith ( base )  )  )     {", "throw   new   MojoExecutionException (  (  (  (  (  \" The   enhancement   directory    ' dir '     (  \"     +     ( dir )  )     +     \"  )    is   no   subdirectory   of    ' base '     (  \"  )     +     ( base )  )     +     \"  )  \"  )  )  ;", "}", "File   root    =    new   File ( this . dir )  ;", "if    (  !  ( root . exists (  )  )  )     {", "getLog (  )  . info (  (  \" Skipping   H   enhancement   plugin   execution   since   there   is   no   classes   dir    \"     +     ( dir )  )  )  ;", "return ;", "}", "walkDir ( root )  ;", "if    ( sourceSet . isEmpty (  )  )     {", "getLog (  )  . info (  (  \" Skipping   H   enhancement   plugin   execution   since   there   are   no   classes   to   enhance   on    \"     +     ( dir )  )  )  ;", "return ;", "}", "getLog (  )  . info (  (  \" Starting   H   enhancement   for   classes   on    \"     +     ( dir )  )  )  ;", "final   ClassLoader   classLoader    =    toClassLoader ( Collections . singletonList ( new   File ( base )  )  )  ;", "EnhancementContext   enhancementContext    =    new   DefaultEnhancementContext (  )     {", "@ Override", "public   ClassLoader   getLoadingClassLoader (  )     {", "return   classLoader ;", "}", "@ Override", "public   boolean   doBiDirectionalAssociationManagement ( UnloadedField   field )     {", "return   enableAssociationManagement ;", "}", "@ Override", "public   boolean   doDirtyCheckingInline ( UnloadedClass   classDescriptor )     {", "return   enableDirtyTracking ;", "}", "@ Override", "public   boolean   hasLazyLoadableAttributes ( UnloadedClass   classDescriptor )     {", "return   enableLazyInitialization ;", "}", "@ Override", "public   boolean   isLazyLoadable ( UnloadedField   field )     {", "return   enableLazyInitialization ;", "}", "@ Override", "public   boolean   doExtendedEnhancement ( UnloadedClass   classDescriptor )     {", "return   enableExtendedEnhancement ;", "}", "}  ;", "if    ( enableExtendedEnhancement )     {", "getLog (  )  . warn (  \" Extended   enhancement   is   enabled .    Classes   other   than   entities   may   be   modified .    You   should   consider   access   the   entities   using   getter / setter   methods   and   disable   this   property .    Use   at   your   own   risk .  \"  )  ;", "}", "final   Enhancer   enhancer    =    Environment . getBytecodeProvider (  )  . getEnhancer ( enhancementContext )  ;", "for    ( File   file    :    sourceSet )     {", "final   byte [  ]    enhancedBytecode    =    doEnhancement ( file ,    enhancer )  ;", "if    ( enhancedBytecode    =  =    null )     {", "continue ;", "}", "writeOutEnhancedClass ( enhancedBytecode ,    file )  ;", "getLog (  )  . info (  (  (  \" Successfully   enhanced   class    [  \"     +    file )     +     \"  ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.hibernate.orm.tooling.maven.MavenEnhancePlugin"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( enableLazyInitialization )     |  |     ( enableDirtyTracking )  )     |  |     ( enableAssociationManagement )  )     |  |     ( enableExtendedEnhancement )  ;", "}", "METHOD_END"], "methodName": ["shouldApply"], "fileName": "org.hibernate.orm.tooling.maven.MavenEnhancePlugin"}, {"methodBody": ["METHOD_START", "{", "List < URL >    urls    =    new   ArrayList < URL >  (  )  ;", "for    ( File   file    :    runtimeClasspath )     {", "try    {", "urls . add ( file . toURI (  )  . toURL (  )  )  ;", "getLog (  )  . debug (  (  \" Adding   classpath   entry   for   classes   root    \"     +     ( file . getAbsolutePath (  )  )  )  )  ;", "}    catch    ( MalformedURLException   e )     {", "String   msg    =     \" Unable   to   resolve   classpath   entry   to   URL :     \"     +     ( file . getAbsolutePath (  )  )  ;", "if    ( failOnError )     {", "throw   new   MojoExecutionException ( msg ,    e )  ;", "}", "getLog (  )  . warn ( msg )  ;", "}", "}", "MavenProject   project    =     (  ( MavenProject )     ( getPluginContext (  )  . get (  \" project \"  )  )  )  ;", "Set < Artifact >    artifacts    =    project . getArtifacts (  )  ;", "if    ( artifacts    !  =    null )     {", "for    ( Artifact   a    :    artifacts )     {", "if    (  !  ( SCOPE _ TEST . equals ( a . getScope (  )  )  )  )     {", "try    {", "urls . add ( a . getFile (  )  . toURI (  )  . toURL (  )  )  ;", "getLog (  )  . debug (  (  \" Adding   classpath   entry   for   dependency    \"     +     ( a . getId (  )  )  )  )  ;", "}    catch    ( MalformedURLException   e )     {", "String   msg    =     (  (  \" Unable   to   resolve   URL   for   dependency    \"     +     ( a . getId (  )  )  )     +     \"    at    \"  )     +     ( a . getFile (  )  . getAbsolutePath (  )  )  ;", "if    ( failOnError )     {", "throw   new   MojoExecutionException ( msg ,    e )  ;", "}", "getLog (  )  . warn ( msg )  ;", "}", "}", "}", "}", "return   new   URLClassLoader ( urls . toArray ( new   URL [ urls . size (  )  ]  )  ,    r . class . getClassLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["toClassLoader"], "fileName": "org.hibernate.orm.tooling.maven.MavenEnhancePlugin"}, {"methodBody": ["METHOD_START", "{", "walkDir ( dir ,    new   FileFilter (  )     {", "@ Override", "public   bean   accept ( File   pathname )     {", "return    ( pathname . isFile (  )  )     &  &     ( pathname . getName (  )  . endsWith (  \"  . class \"  )  )  ;", "}", "}  ,    new   FileFilter (  )     {", "@ Override", "public   bean   accept ( File   pathname )     {", "return   pathname . isDirectory (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["walkDir"], "fileName": "org.hibernate.orm.tooling.maven.MavenEnhancePlugin"}, {"methodBody": ["METHOD_START", "{", "File [  ]    dirs    =    dir . listFiles ( dirFilter )  ;", "for    ( File   dir 1     :    dirs )     {", "walkDir ( dir 1  ,    classesFilter ,    dirFilter )  ;", "}", "File [  ]    files    =    dir . listFiles ( classesFilter )  ;", "Collections . addAll ( this . sourceSet ,    files )  ;", "}", "METHOD_END"], "methodName": ["walkDir"], "fileName": "org.hibernate.orm.tooling.maven.MavenEnhancePlugin"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( file . delete (  )  )     {", "if    (  !  ( file . createNewFile (  )  )  )     {", "buildContext . addMessage ( file ,     0  ,     0  ,     \" Unable   to   recreate   class   file \"  ,    SEVERITY _ ERROR ,    null )  ;", "}", "} else    {", "buildContext . addMessage ( file ,     0  ,     0  ,     \" Unable   to   delete   class   file \"  ,    SEVERITY _ ERROR ,    null )  ;", "}", "}    catch    ( IOException   e )     {", "buildContext . addMessage ( file ,     0  ,     0  ,     \" Problem   preparing   class   file   for   writing   out   ements \"  ,    SEVERITY _ WARNING ,    e )  ;", "}", "OutputStream   outputStream    =    null ;", "try    {", "outputStream    =    buildContext . newFileOutputStream ( file )  ;", "outputStream . write ( edBytecode )  ;", "outputStream . flush (  )  ;", "}    catch    ( IOException   e )     {", "String   msg    =    String . format (  \" Error   writing   to   ed   class    [  % s ]    to   file    [  % s ]  \"  ,    file . getName (  )  ,    file . getAbsolutePath (  )  )  ;", "if    ( failOnError )     {", "throw   new   MojoExecutionException ( msg ,    e )  ;", "}", "buildContext . addMessage ( file ,     0  ,     0  ,    msg ,    SEVERITY _ WARNING ,    e )  ;", "}    finally    {", "try    {", "if    ( outputStream    !  =    null )     {", "outputStream . close (  )  ;", "}", "}    catch    ( IOException   ignore )     {", "}", "}", "}", "METHOD_END"], "methodName": ["writeOutEnhancedClass"], "fileName": "org.hibernate.orm.tooling.maven.MavenEnhancePlugin"}, {"methodBody": ["METHOD_START", "{", "for    ( Class <  ?  >    interfaceClazz    :    clazz . getInterfaces (  )  )     {", "if    ( Managed . class . isAssignableFrom ( interfaceClazz )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["declaresManaged"], "fileName": "org.hibernate.orm.tooling.maven.MavenEnhancePluginTest"}, {"methodBody": ["METHOD_START", "{", "Field   field    =    ReflectionUtils . getFieldByNameIncludingSuperclasses ( variable ,    object . getClass (  )  )  ;", "field . setAccessible ( true )  ;", "field . set ( object ,    value )  ;", "}", "METHOD_END"], "methodName": ["setVariableValueToObject"], "fileName": "org.hibernate.orm.tooling.maven.MavenEnhancePluginTest"}, {"methodBody": ["METHOD_START", "{", "File   baseDir    =    new   File (  \" target / classes / java / test \"  )  ;", "URL [  ]    baseURLs    =    new   URL [  ]  {    baseDir . toURI (  )  . toURL (  )     }  ;", "MavenEnhancePlugin   plugin    =    new   MavenEnhancePlugin (  )  ;", "Map < String ,    Object >    pluginContext    =    new   HashMap <  >  (  )  ;", "pluginContext . put (  \" project \"  ,    new   MavenProject (  )  )  ;", "setVariableValueToObject ( plugin ,     \" pluginContext \"  ,    pluginContext )  ;", "setVariableValueToObject ( plugin ,     \" buildContext \"  ,    new   DefaultBuildContext (  )  )  ;", "setVariableValueToObject ( plugin ,     \" base \"  ,    baseDir . getAbsolutePath (  )  )  ;", "setVariableValueToObject ( plugin ,     \" dir \"  ,    baseDir . getAbsolutePath (  )  )  ;", "setVariableValueToObject ( plugin ,     \" failOnError \"  ,    true )  ;", "setVariableValueToObject ( plugin ,     \" enableLazyInitialization \"  ,    true )  ;", "setVariableValueToObject ( plugin ,     \" enableDirtyTracking \"  ,    true )  ;", "setVariableValueToObject ( plugin ,     \" enableAssociationManagement \"  ,    true )  ;", "setVariableValueToObject ( plugin ,     \" enableExtendedEnhancement \"  ,    false )  ;", "plugin . execute (  )  ;", "try    ( URLClassLoader   classLoader    =    new   URLClassLoader ( baseURLs ,    getClass (  )  . getClassLoader (  )  )  )     {", "Assert . assertTrue ( declaresManaged ( classLoader . loadClass (  . ParentEntity . class . getName (  )  )  )  )  ;", "Assert . assertTrue ( declaresManaged ( classLoader . loadClass (  . ChildEntity . class . getName (  )  )  )  )  ;", "Assert . assertTrue ( declaresManaged ( classLoader . loadClass (  . TestEntity . class . getName (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testEnhancePlugin"], "fileName": "org.hibernate.orm.tooling.maven.MavenEnhancePluginTest"}]