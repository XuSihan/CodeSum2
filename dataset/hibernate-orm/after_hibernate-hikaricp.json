[{"methodBody": ["METHOD_START", "{", "final   Integer   isolation    =    ConnectionProviderInitiator . extractIsolation ( props )  ;", "if    ( isolation    !  =    null )     {", "Props . put (  \" transactionIsolation \"  ,    ConnectionProviderInitiator . toIsolationConnectionConstantName ( isolation )  )  ;", "}", "}", "METHOD_END"], "methodName": ["copyIsolationSetting"], "fileName": "org.hibernate.hikaricp.internal.HikariConfigurationUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( src . containsKey ( srcKey )  )     {", "dst . setProperty ( dstKey ,     (  ( String )     ( src . get ( srcKey )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["copyProperty"], "fileName": "org.hibernate.hikaricp.internal.HikariConfigurationUtil"}, {"methodBody": ["METHOD_START", "{", "Properties   hikariProps    =    new   Properties (  )  ;", ". copyProperty ( AUTOCOMMIT ,    props ,     \" autoCommit \"  ,    hikariProps )  ;", ". copyProperty ( DRIVER ,    props ,     \" driverClassName \"  ,    hikariProps )  ;", ". copyProperty ( URL ,    props ,     \" jdbcUrl \"  ,    hikariProps )  ;", ". copyProperty ( USER ,    props ,     \" username \"  ,    hikariProps )  ;", ". copyProperty ( PASS ,    props ,     \" password \"  ,    hikariProps )  ;", ". copyIsolationSetting ( props ,    hikariProps )  ;", "for    ( Object   keyo    :    props . keySet (  )  )     {", "if    (  !  ( keyo   instanceof   String )  )     {", "continue ;", "}", "String   key    =     (  ( String )     ( keyo )  )  ;", "if    ( key . startsWith (  . CONFIG _ PREFIX )  )     {", "hikariProps . setProperty ( key . substring (  . CONFIG _ PREFIX . length (  )  )  ,     (  ( String )     ( props . get ( key )  )  )  )  ;", "}", "}", "return   new   HikariConfig ( hikariProps )  ;", "}", "METHOD_END"], "methodName": ["loadConfiguration"], "fileName": "org.hibernate.hikaricp.internal.HikariConfigurationUtil"}, {"methodBody": ["METHOD_START", "{", "JdbcServices   jdbcServices    =    serviceRegistry (  )  . getService ( JdbcServices . class )  ;", "ConnectionProviderJdbcConnectionAccess   connectionAccess    =    assertTyping ( ConnectionProviderJdbcConnectionAccess . class ,    jdbcServices . getBootstrapJdbcConnectionAccess (  )  )  ;", "assertTyping (  . class ,    connectionAccess . getConnectionProvider (  )  )  ;", "hikariCP    =     (  (  )     ( connectionAccess . getConnectionProvider (  )  )  )  ;", "final   List < Connection >    conns    =    new   ArrayList < Connection >  (  )  ;", "for    ( int   i    =     0  ;    i    <     2  ;    i +  +  )     {", "Connection   conn    =    hikariCP . getConnection (  )  ;", "assertNotNull ( conn )  ;", "assertFalse ( conn . isClosed (  )  )  ;", "conns . add ( conn )  ;", "}", "try    {", "hikariCP . getConnection (  )  ;", "fail (  \" SQLException   expected    -  -    no   more   connections   should   have   been   available   in   the   pool .  \"  )  ;", "}    catch    ( SQLException   e )     {", "assertTrue ( e . getMessage (  )  . contains (  \" Connection   is   not   available ,    request   timed   out   after \"  )  )  ;", "}", "for    ( Connection   conn    :    conns )     {", "hikariCP . closeConnection ( conn )  ;", "assertTrue ( conn . isClosed (  )  )  ;", "}", "releaseSessionFactory (  )  ;", "try    {", "hikariCP . getConnection (  )  ;", "fail (  \" Exception   expected    -  -    the   pool   should   have   been   shutdown .  \"  )  ;", "}    catch    ( Exception   e )     {", "assertTrue ( e . getMessage (  )  . contains (  \" has   been   closed \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testHikariCPConnectionProvider"], "fileName": "org.hibernate.test.hikaricp.HikariCPConnectionProviderTest"}, {"methodBody": ["METHOD_START", "{", "connectionProvider . clear (  )  ;", "doInH ( this :  : sessionFactory ,     (    session )     -  >     {", "City   city    =    new   City (  )  ;", "city . setId (  1 L )  ;", "city . setName (  \" Cluj - Napoca \"  )  ;", "session . persist ( city )  ;", "assertTrue ( connectionProvider . getAcquiredConnections (  )  . isEmpty (  )  )  ;", "assertTrue ( connectionProvider . getReleasedConnections (  )  . isEmpty (  )  )  ;", "}  )  ;", "verifyConnections (  )  ;", "connectionProvider . clear (  )  ;", "doInH ( this :  : sessionFactory ,     (    session )     -  >     {", "City   city    =    session . find (  . class ,     1 L )  ;", "assertEquals (  \" Cluj - Napoca \"  ,    city . getName (  )  )  ;", "}  )  ;", "verifyConnections (  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.hibernate.test.hikaricp.HikariCPSkipAutoCommitTest"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( connectionProvider . getAcquiredConnections (  )  . isEmpty (  )  )  ;", "List < Connection >    connections    =    connectionProvider . getReleasedConnections (  )  ;", "assertEquals (  1  ,    connections . size (  )  )  ;", "Connection   connection    =    connections . get (  0  )  ;", "try    {", "verify ( connection ,    never (  )  )  . set ( false )  ;", "}    catch    ( SQLException   e )     {", "fail ( e . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["verifyConnections"], "fileName": "org.hibernate.test.hikaricp.HikariCPSkipAutoCommitTest"}, {"methodBody": ["METHOD_START", "{", "return   super . getConnection (  )  ;", "}", "METHOD_END"], "methodName": ["actualConnection"], "fileName": "org.hibernate.test.util.PreparedStatementSpyConnectionProvider"}, {"methodBody": ["METHOD_START", "{", "acquiredConnections . clear (  )  ;", "releasedConnections . clear (  )  ;", "pMap . keySet (  )  . forEach ( Mockito :  : reset )  ;", "pMap . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.hibernate.test.util.PreparedStatementSpyConnectionProvider"}, {"methodBody": ["METHOD_START", "{", "return   acquiredConnections ;", "}", "METHOD_END"], "methodName": ["getAcquiredConnections"], "fileName": "org.hibernate.test.util.PreparedStatementSpyConnectionProvider"}, {"methodBody": ["METHOD_START", "{", "return   releasedConnections ;", "}", "METHOD_END"], "methodName": ["getReleasedConnections"], "fileName": "org.hibernate.test.util.PreparedStatementSpyConnectionProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( MockUtil . isMock ( connection )  )     {", "return   connection ;", "}", "Connection   connectionSpy    =    Mockito . spy ( connection )  ;", "try    {", "Mockito . doAnswer (  (    invocation )     -  >     {", "statement    =     (  (  )     ( invocation . callRealMethod (  )  )  )  ;", "statementSpy    =    Mockito . spy ( statement )  ;", "String   sql    =     (  ( String )     ( invocation . getArguments (  )  [  0  ]  )  )  ;", "preparedStatementMap . put ( statementSpy ,    sql )  ;", "return   statementSpy ;", "}  )  . when ( connectionSpy )  . prepareStatement ( ArgumentMatchers . anyString (  )  )  ;", "Mockito . doAnswer (  (    invocation )     -  >     {", "Statement   statement    =     (  ( Statement )     ( invocation . callRealMethod (  )  )  )  ;", "Statement   statementSpy    =    Mockito . spy ( statement )  ;", "return   statementSpy ;", "}  )  . when ( connectionSpy )  . createStatement (  )  ;", "}    catch    ( SQLException   e )     {", "throw   new   IllegalArgumentException ( e )  ;", "}", "return   connectionSpy ;", "}", "METHOD_END"], "methodName": ["spy"], "fileName": "org.hibernate.test.util.PreparedStatementSpyConnectionProvider"}]